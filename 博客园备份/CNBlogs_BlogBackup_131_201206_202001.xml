<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-欢迎来到YYC的世界</title><link>https://www.cnblogs.com/chaogex/</link><description>分享经验，共同进步</description><language>zh-cn</language><lastBuildDate>Sat, 11 Jan 2020 23:43:39 GMT</lastBuildDate><pubDate>Sat, 11 Jan 2020 23:43:39 GMT</pubDate><ttl>60</ttl><item><title>Web 3D是否需要WebAssembly?</title><link>http://www.cnblogs.com/chaogex/archive/2020/01/10/12177333.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Fri, 10 Jan 2020 09:36:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2020/01/10/12177333.html</guid><description><![CDATA[大家好，本文讨论了Web 3D是否需要WebAssembly，结论是：
对于使用原生3D技术的程序员，需要；
对于使用Javascript语言的前端程序员，不需要，有其它方法可以达到接近WebAssdembly的性能。

# WebAssembly是什么？

WebAssembly简称wasm，是一种数据格式，对应的文件后缀名为.wasm，文件由字节码组成；
而Javascript对应的文件后缀名为.js，文件由字符串组成。

两者都可以在浏览器上直接运行。

一份典型的.wasm 文件如下所示（引用自[恕我直言，90% 的应用场景都不需要用WebAssembly！](https://zhuanlan.zhihu.com/p/79792515)）：
```js
00000000: 0061 736d 0100 0000 0108 0260 017f 0060  .asm.......`...`
00000010: 0000 0215 0203 656e 7603 6d65 6d02 0001  ......env.mem...
00000020: 026a 7303 6c6f 6700 0003 0201 0107 0b01  .js.log.........
00000030: 0765 7861 6d70 6c65 0001 0a23 0121 0041  .example...#.!.A
00000040: 0042 c8ca b1e3 f68d c8ab ef00 3703 0041  .B..........7..A
00000050: 0841 f2d8 918b 0236 0200 4100 1000 0b    .A.....6..A....
```
可以通过Emscripten等编译器，将原生语言（如C++等）编译为wasm程序。

# 比较wasm与js

## 优点
对于使用Javascript语言的前端程序员，wasm的优点为：

- 体积更小

白鹭引擎团队测试过：
> 将大约300k左右（压缩后）JavaScript逻辑改用WebAssembly重写后，体积仅有90k左右。虽然使用WebAssembly需要引入一个50-100k的JavaScript类库作为基础设施，但是总体来看资源尺寸的优势还是很大的。

- 执行性能高（但是通过JIT优化，js程序的执行性能接近wasm）

wasm属于AOT: Ahead-of-Time compilation，即在执行前，通过编译生成浏览器能够直接执行的、优化过的字节码，这样浏览器在执行它时不需要进行编译，性能高。


但是，因为浏览器支持JIT: Just-in-Time compilation，所以**js程序的执行性能接近wasm**。
浏览器在首次执行时，对性能热点的js代码进行编译，优化为字节码；然后从下次执行开始，直接执行字节码。

对于Web 3D程序，性能热点的逻辑会在主循环中多次被执行。所以只会在首次执行时花费一些时间进行编译，以后执行时性能就与wasm差不多了。

要提高js代码在JIT中的性能，需要保证类型的健壮性，如不要轻易改变变量的类型

因为js是弱类型和动态语言，直接写js代码很容易造成类型混乱，降低JIT的性能，所以我们应该使用编译为js的强类型语言（如[Reason语言](https://reasonml.github.io/)），通过编译检查来保证类型的健壮性。


- 更加安全

因为wasm文件是字节码，无法直接阅读，所以增加了安全性。


## 缺点
对于使用Javascript语言的前端程序员，wasm的缺点为：

- 需要熟悉C++等原生语言
 
因为wasm是由原生语言编译而来，所以需要程序员学习原生语言，增加了学习成本

- 不能直接操作原生图形API（如OpenGL），只能通过js调用WebGL

所以与其在wasm中调用webgl，还不如直接用js来调用webgl，这样更方便，性能应该也差不多
**参考资料**
[How to use WebGL shaders in WebAssembly](https://www.freecodecamp.org/news/how-to-use-webgl-shaders-in-webassembly-1e6c5effc813/)：
> When compiling, emscripten will map our code to the WebGL API.

[WebAssembly 的出现是否会取代 JavaScript？ - doodlewind的回答 - 知乎](https://www.zhihu.com/question/322007706/answer/741764049)：
> 调 OpenGL 都要走回 JS 到 WebGL



- 增加了维护成本

我们通常用这种方案来应用wasm：一部分逻辑用wasm实现，负责需要高性能的密集计算；另一部分逻辑用js实现，负责dom操作和webgl调用。
这样就需要同时维护wasm和js代码，增加了成本。


# 对于使用原生3D技术（如基于C++语言和DirectX、OpenGL等原生图形API）的程序员

可以用wasm技术，将3D程序编译为wasm文件，从而原生3D应用搬到浏览器上运行

# 对于使用Javascript语言的前端程序员

不需要用wasm技术，而是通过下面的方法来获得接近wasm的性能： 
1、使用强类型语言（如Reason）编译为js。这样可提高js代码在JIT中的性能
2、把需要高性能的计算逻辑，放到worker线程中进行计算；或者使用WebGPU的compute shader，将其从CPU端移到GPU端进行计算，大幅提升性能。
关于WebGPU，可以参考 [WebGPU学习](https://www.cnblogs.com/chaogex/p/12005108.html)



# 参考资料
[恕我直言，90% 的应用场景都不需要用WebAssembly！](https://zhuanlan.zhihu.com/p/79792515)
[如何评论浏览器最新的 WebAssembly 字节码技术？ - 罗志宇的回答 - 知乎](https://www.zhihu.com/question/31415286/answer/58022648)
[WebAssembly在白鹭引擎5.0中的实践](https://blog.csdn.net/chenqiuge1984/article/details/80131055)]]></description></item><item><title>从0开发3D引擎（六）：函数式反应式编程及其在引擎中的应用</title><link>http://www.cnblogs.com/chaogex/archive/2020/01/10/12175075.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Fri, 10 Jan 2020 02:56:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2020/01/10/12175075.html</guid><description><![CDATA[[TOC]

大家好，本文介绍我们为什么使用函数式反应式编程来开发引擎，以及它在引擎中的相关的知识点。

# 上一篇博文
[从0开发3D引擎（五）：函数式编程及其在引擎中的应用](https://www.cnblogs.com/chaogex/p/12172930.html)

# 介绍函数式反应式编程

函数式反应式编程又称为“函数式响应型编程”，英文缩写为“FRP”。
它的总体思想是一切都是流：可以把事件封装为流，也可以把Promise封装为流，还可以把集合（如数组、list等）封装为流。可以用 merge、concat、map等operater对流进行函数式操作。
本质上，FRP是把时间线上的数据建模为流，即：
```js
流 = 时间 + 数据
```
我们在对流进行一系列操作后，最后会subscribe该流，处理流的三个事件：next、error、complete。
举例来说：
我们把数组[|1,2,3|]（在Reason中，数组的语法是“[||]”，list的语法是“[]”）封装为流并subscribe，则该流会依次触发3次next事件，值分别为：1、2、3；在最后一次next事件触发后，会触发complete事件，完成该流；该流不会触发error事件，因为没有错误发生。


# 函数式反应式编程学习资料

- [你一直都错过的反应型编程](https://my.oschina.net/u/2288602/blog/359270)

该文通俗易懂，建议读者通过该文来入门FRP。

- [函数式反应型编程 (FRP) —— 实时互动应用开发的新思路](https://www.infoq.cn/article/functional-reactive-programming)

该文举了一个FRP的例子，并比较了“FRP”和“回调函数callback”这两种处理异步的方式。该文适合读者进一步学习FRP。

- [函数式响应型编程(Functional Reactive Programming)会在什么问题上有优势?](https://www.zhihu.com/question/26079335)

读者可以通过该问题的讨论，了解为什么要用FRP。



# 函数式反应式编程的优点与缺点


## 优点

- 抽象层面更高

FRP以流为单位，封装了时间序列和具体的数据，隐藏了“状态的同步”、“异步逻辑的具体实现”等底层细节。

- 和函数式编程配合使用

能够使用组合，像管道处理一样处理各种流，符合函数式编程的思维。


## 缺点

- 学习成本高，需要用户转换思维，用流来思考

我当时用了1个月学习FRP，并模仿Rxjs，使用Typescript写了一个FRP库：[Wonder-FRP](https://github.com/Wonder-Technology/Wonder-FRP)。
掌握FRP确实不容易，但一旦掌握，异步处理就会变得非常容易和健壮，值得我们学习它！


# 异步处理的其它方法
除了用“FRP”处理异步，还可以用：
1)回调函数
过多的回调会导致嵌套层次太深，容易陷入回调地狱，不易维护。
2)await,aync
通过这两个关键字，把所有异步操作变为同步操作。
这样虽然简化了逻辑，但是损失了异步带来的性能优势（如把两个并行操作变为两个串性操作，增加了时间开销）



# 为什么使用Most库

要在Javascript中使用FRP，有两个库可以选择：

- [RxJS](https://rxjs-dev.firebaseapp.com/)
该库用的人很多，功能齐全。
- [most](https://github.com/cujojs/most)
该库性能更好，而且更轻量。虽然功能要少点，不过够用，

为了更高的性能，本系列使用most库来开发引擎，并封装了它的[FFI](https://github.com/Wonder-Technology/Wonder-bs-most)。


# 引擎中相关的函数式反应式编程知识点


引擎使用函数反应式编程来处理**异步**。

FRP的流来自于：

- Promise
如将“加载图片”封装为Promise，再用most.fromPromise将其转换为流。

- Dom事件
如对于“鼠标click”事件，使用most.fromEvent将其转换为流。

- 集合
使用most.from将集合（如数组或者list）转换为流。

FRP的应用场景包括：
1）处理事件
2）处理多个线程的执行顺序
3）读写资源



# 参考资料

[用函数式编程，从0开发3D引擎和编辑器（二）：函数式编程准备](https://www.cnblogs.com/chaogex/p/10807469.html)]]></description></item><item><title>从0开发3D引擎（五）：函数式编程及其在引擎中的应用</title><link>http://www.cnblogs.com/chaogex/archive/2020/01/09/12172930.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Thu, 09 Jan 2020 10:20:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2020/01/09/12172930.html</guid><description><![CDATA[[TOC]

大家好，本文介绍我们为什么使用函数式编程来开发引擎，以及它在引擎中的相关的知识点。


# 上一篇博文
[从0开发3D引擎（四）：搭建测试环境](https://www.cnblogs.com/chaogex/p/12169434.html)

# 下一篇博文
[从0开发3D引擎（六）：函数式反应式编程及其在引擎中的应用](https://www.cnblogs.com/chaogex/p/12175075.html)

# 函数式编程的优点与缺点


## 优点
（1）粒度小
面向对象编程以类为单位，而函数式编程以函数为单位，粒度更小。
> 我只想要一个香蕉，而面向对象却给了我整个森林

（2）擅长处理数据，适合3D领域的编程
通过高阶函数、柯西化、函数组合等工具，函数式编程可以像流水线一样对**数据**进行管道操作，非常方便。

而3D程序正好要处理大量的数据，从函数式编程的角度来看：
**3D程序=数据+逻辑**

因此，我们可以这样使用函数式编程范式来进行3D编程：

- 使用Immutable/Mutable数据结构、Data Oriented思想来表达数据
- 使用函数来表达逻辑
- 使用组合、柯西化等操作作为工具，把数据和逻辑关联起来，进行管道操作

现代的3D引擎越来越倾向于**面向数据**进行设计，从而获得更佳的性能，如Unity新版本有很多Data Oriented的思想；
也越来越倾向于使用函数式编程范式，如Frostbite使用Frame Graph来封装现代图形API（DX12），而Frame Graph是面向数据的，有函数式风格的编码框架。




## 缺点
（1）存在性能问题

- Reduce、Map、Filter等操作需要遍历多次，会增加时间开销
我们可以通过下面的方法来优化：
a)减少不必要的Map、Reduce等操作；
b)使用transducer来合并这些操作。具体可以参考[Understanding transducer in Javascript](https://www.zoubingwu.com/2018-08-06/Understanding-transducer-in-Javascript/)

- 柯西化、组合等操作会增加时间开销

- 每次操作Immutable数据，都需要复制它为新的数据，增加了时间和内存开销




# 为什么使用Reason语言

本系列使用Reason语言来实现函数式编程。

Reason语言可以解决前面提到的性能问题：

- Bucklescript编译器在编译时进行了很多优化，使柯西化、组合等操作和Immutable数据被编译成了优化过的js代码，大幅减小了时间开销和内存开销
更多编译器的优化以及与Typescript的比较可参考：
[架构最快最好的To JS编译器](https://zhuanlan.zhihu.com/p/22216448)

- Reason支持Mutable变量、for/while进行迭代遍历、非纯函数
在性能热点处可以使用它们来提高性能，而在其它地方则尽量使用Immutable数据、递归遍历和纯函数来提高代码的可读性和健壮性。


另外，Reason属于“非纯函数式编程语言”，为什么不使用Haskell这种“纯函数式编程语言”呢？
因为以下几点原因：
（1）获得更高的性能
在性能热点处使用非纯操作（如使用Mutable变量），提高性能。
（2）更简单易用
Reason允许非纯函数，不需要像Haskell一样使用各种Monad来隔离副作用，保持“纯函数”；
Reason使用严格求值，相对于Haskell的惰性求值更简单。


# 函数式编程学习资料

- [JS 函数式编程指南](https://legacy.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details)
这本书作为我学习函数式编程的第一本书，讲得很简单易懂，非常容易上手，推荐～


- [Awesome FP JS](https://github.com/stoeffel/awesome-fp-js)
收集了函数式编程相关的资料。


- [F# for fun and profit](https://fsharpforfunandprofit.com/site-contents/)
这个博客讲了很多F#相关的函数式编程的知识点，介绍了怎样基于类型来设计、怎样处理错误等，非常全面和通俗易懂，强力推荐～
Reason语言基于Ocaml语言，而Ocaml语言与F#语言都属于ML语言类别的，很多概念和语法都类似，所以读者在该博客学到的内容，也可以直接应用到Reason。


# 引擎中相关的函数式编程知识点

本文从以下几个方面进行介绍：

## 数据

因为我们不使用全局变量，而是通过形参传入函数需要的变量，所以所有的变量都是函数的局部变量。

我们把与引擎相关的需要持久化的数据，聚合在一起成为一个Record类型的数据，命名为“State”。该Record的一些成员是可变的（用来存放性能优先的数据），另外的成员是不可变的。

关于Record数据结构，可以参考[Record](https://reasonml.github.io/docs/zh-CN/record)。


### 不可变数据

**介绍**
不能直接修改不可变数据的值。
创建不可变数据之后，对其任何的操作，都会返回一个复制后的新数据。

**示例**
变量默认为不可变的（Immutable）：
```re
//a为immutable变量
let a = 1;
//导致编译错误
a = 2;
```

Reason也有专门的不可变数据结构，如Tuple、List、Record。
其中，Record类似于Javascript中的Object，我们以它为例，来看下如何使用不可变数据结构：
首先定义Record的类型：
```re
type person = {
  age: int,
  name: string
};
```
然后定义Record的值，它被编译器推导为person类型：
```re
let me = {
  age: 5,
  name: "Big Reason"
};
```
最后操作这个Record，如修改“age”的值：
```re
let newMe = {
    ...me,
    age: 10
};

Js.log(newMe === me); /* false */
```
newMe是从me复制而来的。任何对newMe的修改，都不会影响me。
（这里Reason进行了优化，只复制了修改的age字段，没有复制name字段 ）

**在引擎中的应用**

大部分数据都是不可变的（是不可变变量，或者是Tuple,Record等数据结构），这样的好处是：
1)不用关心数据之间的关联关系，因为每个数据都是独立的
2)不可变数据不能被修改


**相关资料**
[Reason->Let Binding](https://reasonml.github.io/docs/zh-CN/let-binding)
[Reason->Record](https://reasonml.github.io/docs/zh-CN/record)
[facebook immutable.js 意义何在，使用场景？](https://www.zhihu.com/question/28016223)
[Introduction to Immutable.js and Functional Programming Concepts](https://auth0.com/blog/intro-to-immutable-js/)




### 可变数据

**介绍**
对可变数据的任何操作，都会直接修改原数据。

**示例**
Reason使用"ref"关键字定义Mutable变量：
 
```re
let foo = ref(5);

//将foo的值取出来，设置到five这个Immutable变量中
let five = foo^; 

//修改foo的值为6，five的值仍然为5
foo := 6;
```



Reason也可以通过"mutable"关键字，定义Record的字段为Mutable字段: 
```re
type person = {
  name: string,
  mutable age: int
};
let baby = {name: "Baby Reason", age: 5};
//修改原数据baby->age的值为6
baby.age = baby.age + 1; 
```

**在引擎中的应用**
因为操作可变数据不需要拷贝，没有垃圾回收的开销，所以在性能热点处常常使用可变数据。
    

**相关资料**
[Reason->Mutable](https://reasonml.github.io/docs/zh-CN/mutation)


## 函数


函数是第一等公民，函数即是数据。

相关资料：
[如何理解在 JavaScript 中 "函数是第一等公民" 这句话?](https://www.zhihu.com/question/67652709)
[Reason->Function](https://reasonml.github.io/docs/zh-CN/function)


### 纯函数


**介绍**

> 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。


**示例**


```re
let a = 1;

/* func2是纯函数 */
let func2 = value => value;

/* func1是非纯函数，因为引用了外部变量"a" */
let func1 = () => a;
```



**在引擎中的应用**

脚本组件的钩子函数(如init,update,dispose等函数，这些函数会在主循环的特定时间点被调用，从而执行函数中用户的逻辑)属于纯函数，这样是为了：
1)在导入/导出为Scene Graph文件时，能够正确序列化
当导出为Scene Graph文件时，序列化钩子函数为字符串，保存在文件中；
当导入Scene Graph文件时，反序列化字符串为函数。如果钩子函数不是纯函数(如调用了外部变量)，则在此时会报错（因为外部变量并没有定义在字符串中，所以会找不到该变量）。
2)支持多线程
可以通过序列化的方式将钩子函数传到独立于主线程的脚本线程，从而在该线程中被执行，实现多线程执行脚本，提高性能。


虽然纯函数好处很多，但引擎中大多数的函数都是非纯函数，这是因为：
1)为了提高性能
2)为了简单，允许副作用，从而避免使用Monad


    

**相关资料**
[第 3 章：纯函数的好处](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#%E8%BF%BD%E6%B1%82%E2%80%9C%E7%BA%AF%E2%80%9D%E7%9A%84%E7%90%86%E7%94%B1)



### 高阶函数

**介绍**
高阶函数的输入或者输出为函数。

**示例**

```re
//func1是高阶函数，因为它的参数是函数
let func1 = func => func(1);

let func2 = value => value * 2;

//a=2
let a = func1(func2);   
```


**在引擎中的应用**

函数之间常常有一些重复或者类似的逻辑，可以通过提出一个私有的高阶函数来消除重复。具体示例如下：
重构前：
```re
let add1 = value => value + 2;

let add2 = value => value + 10;

let minus1 = value => value - 10;

let minus2 = value => value - 200;

let compute1 = value => value |> add1 |> minus1;

let compute2 = value => value |> add2 |> minus2;

//compute1,compute2有重复逻辑

```

重构后：

```re
...

let _compute = (value, (addFunc, minusFunc)) =>
  value |> addFunc |> minusFunc;

let compute1 = value => _compute(value, (add1, minus1));

let compute2 = value => _compute(value, (add2, minus2));
```

    


**相关资料**
[理解 JavaScript 中的高阶函数](https://zhuanlan.zhihu.com/p/49579052)




### 柯西化


**介绍**
> 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。
你可以一次性地调用curry 函数，也可以每次只传一个参数分多次调用。


**示例**

```re
let func1 = (value1, value2) => value1 + value2;

//传入第一个参数，func2只有一个参数value2
let func2 = func1(1);

//a=3
let a = func2(2);
```


**在引擎中的应用**

应用的地方太多了，此处省略。


    


**相关资料**
[第 4 章: 柯里化（curry）](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8F%8C%E5%85%B3%E8%AF%AD%E5%92%96%E5%96%B1)
[Currying](https://fsharpforfunandprofit.com/posts/currying/)








## 类型

Reason是强类型语言，编译时会检查类型是否正确。

本系列希望通过尽可能强的类型约束，来达到“编译通过即程序正确，减少大量的测试工作”的目的。

关于Reason类型带来的好处，参考[架构最快最好的To JS编译器](https://zhuanlan.zhihu.com/p/22216448)：
> 更好的类型安全: typescript是一个JS的超集，它存在很多历史包袱。而微软引入typescript更多的是作为一个工具来使用的比如IDE的代码补全，相对安全的代码重构。而这个类型的准确从第一天开始就不是它的设计初衷，以至于Facebook自己设计了一个相对更准确地类型系统Flow. 而OCaml的类型系统是已经被形式化的证明过正确的。也就是说从理论上BuckleScript 能够保证一旦编译通过是不会有运行时候类型错误的，而typescript远远做不到这点。
更多的类型推断，更好的语言特性：用过typescript的人都知道，typescript的类型推断很弱，基本上所有参数都需要显示的标注类型。不光是这点，像对函数式编程的支持，高阶类型系统GADT的支持几乎是没有。而OCaml本身是一个比Elm,PureScript还要强大的多的语言，它自身有一个非常高阶的module system，是为数不多的对dependent type提供支持的语言，polymorphic variant。而且pattern match的编译器也是优化过的。

**相关资料**
[The "Understanding F# types" series](https://fsharpforfunandprofit.com/series/understanding-fsharp-types.html)

### 基本类型

**介绍**
Reason包含int、float、string等基本类型。



**示例**

```reason
//定义a为string类型
type a = string;
//定义str变量的类型为a
let str:a = "zzz";
```


**在引擎中的应用**

应用广泛，包括以下的使用场景：
1)类型驱动设计
2)领域建模
3)枚举


    
    


**相关资料**

[Reason->Type](https://reasonml.github.io/docs/zh-CN/type)
[Algebraic type sizes and domain modelling](https://fsharpforfunandprofit.com/posts/type-size-and-design/)








### Discriminated Union类型


**介绍**
Discriminated Union类型可以接受参数，还可以组合其它的类型。


**示例**

```re
//result为Discriminated Union Type
type result('a, 'b) =
  | Ok('a)
  | Error('b);

type myPayload = {data: string};

let payloadResults: list(result(myPayload, string)) = [
  Ok({data: "hi"}),
  Ok({data: "bye"}),
  Error("Something wrong happened!")
];
```


**在引擎中的应用**

作为本文后面讲到的“容器”的实现，用于领域建模
    
    


**相关资料**
[Reason->Type Argument](https://reasonml.github.io/docs/zh-CN/more-on-type#type-argument)
[Reason->Null, Undefined & Option](https://reasonml.github.io/docs/zh-CN/null-undefined-option)
[Discriminated Unions](https://fsharpforfunandprofit.com/posts/discriminated-unions/)


### 抽象类型


**介绍**
抽象类型只给出类型名字，没有具体的定义。


**示例**

```re
//value为抽象类型
type value;
```


**在引擎中的应用**

包括以下的使用场景：
1)如果不需要类型的具体定义，则将该类型定义为抽象类型

如在封装WebGL API的FFI中([什么是FFI?](https://reasonml.github.io/docs/zh-CN/external))，因为不需要知道“WebGL的上下文”包含哪些方法和属性，所以将其定义为抽象类型。

示例代码如下：
```re
//抽象类型
type webgl1Context;

[@bs.send]
external getWebgl1Context : ('canvas, [@bs.as "webgl"] _) => webgl1Context = "getContext";

[@bs.send.pipe: webgl1Context]
external viewport : (int, int, int, int) => unit = "";




//client code

//gl是webgl1Context类型
//编译后的js代码为：var gl = canvasDom.getContext("webgl");
let gl = getWebgl1Context(canvasDom);   

//编译后的js代码为：gl.viewport(0,0,100,100);
gl |> viewport(0,0,100,100);

```


2)如果一个数据可能为多个类型,则定义一个抽象类型和它与这“多个类型”之间相互转换的FFI，然后把该数据设为该抽象类型

如脚本->属性->value字段可以为int或者float类型，因此将value设为抽象类型，并且定义抽象类型和int、float类型之间的转换FFI。

示例代码如下：
```re

type scriptAttributeType =
  | Int
  | Float;


//抽象类型
type scriptAttributeValue;

type scriptAttributeField = {
  type_: scriptAttributeType,
  //定义value字段为该抽象类型
  value: scriptAttributeValue
};

//定义抽象类型scriptAttributeValue和int,float类型相互转换的FFI

external intToScriptAttributeValue: int => scriptAttributeValue = "%identity";

external floatToScriptAttributeValue: float => scriptAttributeValue =
  "%identity";

external scriptAttributeValueToInt: scriptAttributeValue => int = "%identity";

external scriptAttributeValueToFloat: scriptAttributeValue => float =
  "%identity";
  
  
//client code

//创建scriptAttributeField，设置value的数据

let scriptAttributeField = {
    type_: Int,
    value:intToScriptAttributeValue(10) 
};



//修改scriptAttributeField->value

let newScriptAttributeField = {
    ...scriptAttributeField,
    value: (scriptAttributeValueToInt(scriptAttributeField.value) + 1) |> intToScriptAttributeValue
};
```


    

**相关资料**
[抽象类型(Abstract Types)](https://ocaml.org/learn/tutorials/modules.zh.html#Abstract-Types)








## 过程


### 组合

**介绍**
多个函数可以组合起来，使前一个函数的返回值作为后一个函数的输入，从而对数据进行管道处理。


**示例**

```re
let func1 = value => value1 + 1;

let func2 = value => value1 + 2;

//13
10 |> func1 |> func2;
```





**在引擎中的应用**

把多个函数组合成job，再把多个job组合成一个管道操作，处理每帧的逻辑。

我们从组合的角度来分析下引擎的结构：

```re
job = 多个函数的组合

引擎＝初始化+主循环

//而初始化和主循环的每一帧，都是由多个job组合而成的管道操作：
初始化 = create_canvas |> create_gl |> ...

每一次循环 = tick |> dispose |> reallocate_cpu_memory |> update_transform |> ...
```
    


**相关资料**

[第 5 章: 代码组合（compose）](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html)










### 迭代和递归

**介绍**

遍历操作可以分成两类：
迭代
递归

例如广度优先遍历是迭代操作，而深度优先遍历是递归操作

Reason支持用for、while循环实现迭代操作，用“rec”关键字定义递归函数。
Reason支持尾递归优化，可将其编译成迭代操作。所以我们应该在需要遍历很多次的地方，用尾递归进行遍历。

**示例**


```re
//func1为尾递归函数
let rec func1 = (value, result) => {
    value > 3 ? result : func1(value + 1, result + value);
};

//0+1+2+3=6
func1(1, 0);
```


**在引擎中的应用**

几乎所有的遍历都是尾递归遍历（因为相对于迭代，代码更可读），只有在少数使用Mutable和少数性能热点的地方，使用迭代遍历
    


**相关资料**
[什么是尾递归？](https://www.zhihu.com/question/20761771)
[Reason->Recursive Functions](https://reasonml.github.io/docs/zh-CN/function#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0)
[Reason->Imperative Loops](https://reasonml.github.io/docs/zh-CN/imperative-loops)




### 模式匹配

**介绍**
使用switch代替if/else来处理程序分支。


**示例**

```re
let func1 = value => {
    switch(value){
        | 0 => 10 
        | _ => 100
    }
};

//10
func1(0);
//100
func1(2);
```


**在引擎中的应用**

主要用在下面三种场景：

1)取出容器的值

```re
type a = 
    | A(int)
    | B(string);
    
let aValue = switch(a){
    | A(value) => value
    | B(value) => value
};
```

    
2)处理[Option](https://reasonml.github.io/docs/zh-CN/null-undefined-option)


```re
let a = Some(1);

switch(a){
    | None => ...
    | Some(value) => ...
}
```

3)处理枚举类型

```re
type a = 
    | A
    | B;
    
switch(a){
    | A => ...
    | B => ...
}
```


**相关资料**
[Reason->Pattern Matching!](https://reasonml.github.io/docs/zh-CN/pattern-matching)
[模式匹配](https://www.kancloud.cn/kancloud/functional-programm-for-rest/56937)







## 容器

**介绍**

为了领域建模，或者为了隔离副作用来保证纯函数，需要把值封装到容器中，使外界只能操作容器，不能直接操作值。


**示例**

1)领域建模示例

比如我们要开发一个图书管理系统，需要对“书”进行建模。
书有书号、页数这两个数据，有小说书、技术书两种类型。
建模为：

```re
type bookId = int;

type pageNum = int;

//book为Discriminated Union Type
//book作为容器，定义了两个Union Type：Novel、Technology
type book = 
    | Novel(bookId, pageNum)
    | Technology(bookId, pageNum);
    
```

现在我们创建一本小说，一本技术书，以及它们的集合list：

```re
let novel = Novel(0, 100);

let technology = Technology(1, 200);

let bookList = [
    novel,
    technology
];
```

对“书”这个容器进行操作：

```re
let getPage = (book) => 
switch(book){
    | Novel(_, page) => page
    | Technology(_, page) => page
};


let setPage = (page, book) => 
switch(book){
    | Novel(bookId, _) => Novel(bookId, page)
    | Technology(bookId, _) => Technology(bookId, page)
};

//client code

//得到新的技术书，它的页数为集合中所有书的总页数
let newTechnology =
bookList
|> List.fold_left((totalPage, book) => totalPage + getPage(book), 0)
|> setPage(_, technology);

```




**在引擎中的应用**

包含以下使用场景：
1)领域建模
2)错误处理
3)处理空值
使用[Option](https://reasonml.github.io/docs/en/null-undefined-option)这个容器包装空值。

    

**相关资料**

[Railway Oriented Programming](https://fsharpforfunandprofit.com/rop/)
[The "Map and Bind and Apply, Oh my!" series](https://fsharpforfunandprofit.com/series/map-and-bind-and-apply-oh-my.html)
[强大的容器](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html#%E2%80%9C%E7%BA%AF%E2%80%9D%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86)
[Monad](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html)
[Applicative Functor](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#%E5%8D%8F%E8%B0%83%E4%BA%8E%E6%BF%80%E5%8A%B1)




## 多态


### GADT


**介绍**
全称为Generalized algebraic data type，可以用来实现函数参数多态。


**示例**
重构前，需要定义多个isXXXEqual函数来处理每种类型：
```re
let isIntEqual = (source: int, target: int) => source == target;

let isStringEqual = (source: string, target: string) => source == target;
  
//true
isIntEqual(1, 1);

//true
isStringEqual("aaa", "aaa");
```

使用GADT重构后，只需要一个isEqual函数来处理所有的类型：

```re
type isEqual(_) =
  | Int: isEqual(int)
  | Float: isEqual(float)
  | String: isEqual(string);

let isEqual = (type g, kind: isEqual(g), source: g, target: g) =>
  switch (kind) {
  | _ => source == target
  };

//true
isEqual(Int, 1, 1);

//true
isEqual(String, "aaa", "aaa");
```


**在引擎中的应用**

包含以下使用场景：
1)契约检查
使用GADT定义一个assertEqual方法来判断两个任意类型的变量是否相等，从而不需要assertStringEqual,assertIntEqual等方法。

    
    

**相关资料**
[Why GADTs matter for performance（需要翻墙）](https://blog.janestreet.com/why-gadts-matter-for-performance/)
[维基百科->Generalized algebraic data type](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type)






### Module Functor

**介绍**

[module](https://reasonml.github.io/docs/zh-CN/module)作为参数，传递给functor，得到一个新的module。

它类似于面向对象的“继承”，可以通过函子functor，在基module上扩展出新的module。


**示例**
```re
module type Comparable = {
  type t;

  let equal: (t, t) => bool;
};

//module functor
module MakeAdd = (Item: Comparable) => {
  let add = (x: Item.t, newItem: Item.t, list: list(Item.t)) =>
    Item.equal(x, newItem) ? list : [newItem, ...list];
};


module A = {
  type t = int;
  let equal = (x1, x2) => x1 == x2;
};

//module B增加了add函数，该方法调用了A.equal函数
module B = MakeAdd(A);

//list == [2]
let list = B.add(1, 2, []);    
//list == [2]
let list = list |> B.add(1, 1);
```


**在引擎中的应用**

    
包含以下使用场景：
1)错误处理
错误信息被包装到容器Result中。
由于错误的类型不一样，所以需要不同数据结构的容器（RelationResult、SameDataResult）来包装。
这两类容器有共同的模式，可以通过“Module Functor”来消除重复：
提出基module：Result;
增加MakeRelationResult、MakeSameDataResult这两个module functor，它们将Result作为参数，返回新的module：RelationResult、SameDataResult。

    


**相关资料**
[Reason->Module Functions](https://reasonml.github.io/docs/zh-CN/module#module-functions-functors)



# 参考资料
[用函数式编程，从0开发3D引擎和编辑器（二）：函数式编程准备](https://www.cnblogs.com/chaogex/p/10807469.html)]]></description></item><item><title>从0开发3D引擎（四）：搭建测试环境</title><link>http://www.cnblogs.com/chaogex/archive/2020/01/09/12169434.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Wed, 08 Jan 2020 23:11:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2020/01/09/12169434.html</guid><description><![CDATA[[TOC]

大家好，本文介绍了3D引擎的测试方法，搭建了本地的测试环境。


# 上一篇博文
[从0开发3D引擎（三）：搭建开发环境](https://www.cnblogs.com/chaogex/p/12164689.html)

# 下一篇博文
[从0开发3D引擎（五）：函数式编程及其在引擎中的应用](https://www.cnblogs.com/chaogex/p/12172930.html)


# 了解自动化测试

对于引擎开发这种复杂、长期的项目，为了减少bug，提升长期的开发效率，自动化测试必不可少。在我们的[Wonder.js](https://github.com/Wonder-Technology/Wonder.js)引擎中，包括了本节介绍的3种自动化测试，测试覆盖率达到了95%。


本系列为了节省篇幅，不进行自动化测试。因此本节只进行简单的介绍，不给出实际的案例，读者可以到[Wonder.js->test/](https://github.com/Wonder-Technology/Wonder.js/tree/master/test)目录下查看自动化测试实例。





## 单元测试

我们需要写测试用例对单个函数进行单元测试。

**搭建环境**
使用[jest](https://jestjs.io/)作为测试框架，[sinon](https://sinonjs.org/)进行stub。
如果读者想了解stub的概念，可以参考[我对Stub和Mock的理解](https://www.cnblogs.com/chaogex/p/3388386.html)

因为不能直接使用js库，需要写对应的[FFI](https://reasonml.github.io/docs/en/external)（类似于typescript的d.ts文件）才能在Reason中被调用，所以我们可以使用[bs-jest](https://github.com/glennsl/bs-jest)和Wonder的[Wonder-bs-sinon](https://github.com/Wonder-Technology/Wonder-bs-sinon)作为FFI





## 集成测试

相对于单元测试，集成测试的测试目标变为某个特性，该特性跨越多个函数或多个模块。


**搭建环境**
与单元测试的环境一样。

**目录结构**
可以在test/unit/目录下写单元测试用例，而在test/integration/目录下写集成测试用例。


## 端对端测试

也称为e2e测试，包括了“渲染测试”和“性能测试”。它们都需要安装[puppeteer](https://github.com/puppeteer/puppeteer)，通过chrome内核渲染3D场景来进行测试。


- 渲染测试

渲染测试是针对特定的场景（如只有一个模型的场景，或者只有一个光源的场景）进行测试，从而保证**渲染**的正确性。

测试步骤为：
1、预先渲染一张正确图片
2、使用引擎渲染一张当前图片
3、逐个像素地比较两者，如果95%以上的像素都相同，则测试通过；否则测试失败



- 性能测试

性能测试是针对极端场景（如5000个box）进行测试，从而保证**花费的时间**和**占用的内存大小**符合要求。


测试步骤为：
1、预先准备基准数据
使用引擎运行场景多次，取平均值，记录到json文件中
2、使用引擎运行场景多次（少于“准备基准数据”的运行次数），取平均值，得到当前数据
3、比较两者的**花费的时间**和**占用的内存大小**，如果在误差范围内，则测试通过；否则测试失败


注意事项：
只有在本地测试时，保持基准数据不变。如果在云端（如在push到Github仓库时使用CI工具-travis进行测试）或者其它环境（如换一台电脑进行测试）进行性能测试，需要在每次测试时更新基准数据（因为不同的环境，性能不一样，所以对应的基准数据也不一样）。

## 通过打印日志来调试

有以下的原因使得可以在单元测试和集成测试中通过打印日志来进行调试：

- 因为在自动化测试中打开watch，代码修改后能够立即刷新，所以能够即时看到打印的结果，测试很方便
- 因为在函数式编程中，函数为纯函数（Reason也允许非纯），没有状态，所以我们可以通过打印函数的输入和输出，来验证该函数是否正确



# 了解运行测试


本系列通过在Chrome浏览器中进行运行测试来验证程序的正确性。

通过以下的方式进行运行测试：

## 断点调试

因为浏览器运行的是Reason编译后的js代码，所以我们可以在浏览器的控制台->Sources中通过断点来调试js代码




具体可以参考：
[使用断点暂停代码](https://developers.google.com/web/tools/chrome-devtools/javascript/breakpoints)




## 通过Spector.js测试WebGL

Spector.js调试预览：
![68747470733a2f2f73706563746f72646f632e626162796c6f6e6a732e636f6d2f70696374757265732f7469746c652e706e67.png-258.5kB][1]

Spector.js能查看一帧中WebGL的调用情况、shader代码和WebGL的状态，它支持WebGL 1.0或WebGL 2.0，也支持WebGL 1.0的VAO等扩展。

另外，Spector.js支持多个canvas，能查看指定的canvas对应的WebGL信息。这对于调试编辑器（如我们的[Wonder-Editor](https://editor.wonder-3d.com/)在线编辑器）很有用。因为编辑器有多个canvas（如一个canvas进行主场景绘制，另一个canvas以材质球的方式显示单个material资产的效果），而我们希望分别调试从每个canvas中取得上下文的WebGL。

Spector.js可以在Chrome的[扩展](https://chrome.google.com/webstore/detail/spectorjs/denbgaamihkadbghdceggmchnflmhpmk)中安装，详情请见[官方Github](https://github.com/BabylonJS/Spector.js)


## 通过log调试Shader

本系列通过在fragment shader中，将变量作为输出的颜色，来调试Shader的变量值。

更多可以参考：

[调试OpenGL](https://learnopengl-cn.readthedocs.io/zh/latest/06%20In%20Practice/01%20Debugging/) -> 调试着色器输出

[OpenGL shader如何调试？](https://www.zhihu.com/question/30735616)

[OpenGL ES 2.0 Shader 调试新思路(一): 改变提问方式](https://www.cnblogs.com/freeblues/p/5724774.html)


## 移动端测试

我们通过下面两种方法进行测试：

- 模拟测试

我们可以在Chrome浏览器上，点击控制台->Toggle Device Toolbar，打开用于模拟移动设备视口的界面。

本系列主要用该方法测试引擎对于移动端touch事件的支持。

详细的介绍参考：
[使用 Chrome DevTools 中的 Device Mode 模拟移动设备](https://developers.google.cn/web/tools/chrome-devtools/device-mode)


- 真机测试

具体步骤如下：
1、在测试html页面中引入vConsole库
从而可以通过打印日志的方式，在手机上查看错误和日志信息
vConsole介绍参考：
[前端开发 - 在手机上调试利器vConsole](https://www.jianshu.com/p/3df8862481c8)
2、把测试页面push到测试环境的服务器上（如使用Github Pages搭建的服务器）
3、把测试页面的访问地址转换为二维码
如使用[草料二维码](https://cli.im/)在线转换
4、用测试手机的微信扫该二维码，运行测试页面，验证渲染结果，查看错误和日志信息




# 了解性能测试

因为本系列开发的引擎重视性能，所以会通过手动的性能测试，来指导引擎优化。

性能测试的指标包括时间开销和内存开销，下面分别分析：
## 测试时间开销

- 使用Chrome DevTools的Javascript Profiler

通过在测试页面记录profile，查看每个函数的时间开销，从而定位到热点函数进行优化。

相关资料可参考：
[加速执行 JavaScript](https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution)
[Chrome DevTools 之 Profiles，深度性能优化必备](https://www.jianshu.com/p/504bde348956)

- 使用Chrome DevTools的Performance

通过时间线Timeline，可以查看CPU端各个线程和GPU的执行顺序和热点函数的时间开销。

本系列主要用该方法测试在**多线程**中，每个线程的执行顺序和性能开销


相关资料可参考：
[如何使用 Timeline 工具](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool?utm_campaign=2016q3&utm_medium=redirect&utm_source=dcc)
[Chrome DevTools 之 Timeline，快捷性能优化工具](https://www.jianshu.com/p/b8cdcd9bfad8)

- 使用Chrome DevTools的NetWork

查看各个资源的加载时间和顺序。

本系列用该方法测试在“使用函数式反应式编程的流来异步加载 js、二进制文件等资源”时，各个资源的加载顺序是否正确。 


- 使用Performance.now

使用该方法打印某段逻辑的时间开销，多用于自动化测试->端对端测试—>性能测试。

本系列在使用profile定位到热点函数后，会使用该方法确定具体代码的时间开销。通过比较优化前和优化后的时间开销，来评估优化的效果。

示例代码为：
```js
var n1 = performance.now();

执行某些逻辑


var n2 = performance.now();

//打印逻辑的时间开销（ms为单位）
console.log(n2 - n1);
```



- 使用Console.profile

相对于Chrome DevTools的Javascript Profiler，该方法可以测试某一段逻辑的profile，而不是整个页面的profile，粒度更小，更加可控。

![截屏2020-01-08下午5.31.44.png-311.6kB][2]
（图来自[Chrome 控制台console的用法（学了之后对于调试js可是大大有用的哦）](https://segmentfault.com/a/1190000002511877)）


## 测试内存开销

- 使用Chrome DevTools的Memory


本系列对这个工具的应用：
使用Allocation sampling，定位内存占用的热点函数；
使用Allocation instrumentation on timeline来比较每一帧内存开销的增长情况，从而确定是否有内存泄漏。如果有内存泄漏，则通过Heap snapshot，记录多个内存快照并进行比较，定位到具体是哪些地方增加了内存。


相关资料可参考：
[解决内存问题](https://developers.google.com/web/tools/chrome-devtools/memory-problems/?hl=zh-cn#allocation-profile)



# 搭建本地测试环境

运行测试和性能测试不仅需要使用Chrome浏览器的控制台功能，还需要：
1、安装Spector.js
Spector.js可以在Chrome的[扩展](https://chrome.google.com/webstore/detail/spectorjs/denbgaamihkadbghdceggmchnflmhpmk)中安装
2、进行移动端测试时，需要在测试页面中引入vConsole库，并使用Github Pages搭建测试服务器




  [1]: http://static.zybuluo.com/yangyc/b4g322wpdjvxu8cqzyrztqtp/68747470733a2f2f73706563746f72646f632e626162796c6f6e6a732e636f6d2f70696374757265732f7469746c652e706e67.png
  [2]: http://static.zybuluo.com/yangyc/i2x7a5q8q0zzs4r70wcanw2c/%E6%88%AA%E5%B1%8F2020-01-08%E4%B8%8B%E5%8D%885.31.44.png]]></description></item><item><title>从0开发3D引擎（三）：搭建开发环境</title><link>http://www.cnblogs.com/chaogex/archive/2020/01/08/12164689.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Tue, 07 Jan 2020 23:47:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2020/01/08/12164689.html</guid><description><![CDATA[本系列使用Reason语言，因此需要搭建它的开发环境。

# 上一篇博文
[从0开发3D引擎（二）：准备预备知识](https://www.cnblogs.com/chaogex/p/12156965.html)

# 下一篇博文
[从0开发3D引擎（四）：搭建测试环境](https://www.cnblogs.com/chaogex/p/12169434.html)

# 搭建开发环境



建议使用VSCode编辑器来开发Reason，因为它的插件支持得最好。

具体搭建Reason开发环境的步骤如下：

1.安装Chrome浏览器
我们使用Chrome浏览器作为测试和运行环境。

2.执行“yarn global add bs-platform”

这一步是为了安装Reason的相关工具，如格式化工具bsrefmt等

3.安装VSCode

4.安装VSCode->Extensions->reason-vscode插件

5.设置reason-vscode，显示函数的类型签名

在VSCode->“设置”中，搜索到reason的设置，选中 “Show the type for each top-level value in a codelens”。
或者在setting.json中，加上：
```json
  "reason_language_server.per_value_codelens": true
```


6.克隆Reason-Example项目： 

```js
git clone https://github.com/Wonder-Technology/Reason-Example.git
```

在src/目录下的Reason文件First.re，定义了一个用于测试的函数getFirst，该函数返回1:
```re
let getFirst = () => 1;
```


1)执行"yarn watch"

开个watch，这样在写Reason的时候，会自动编译为js。


我们看到，First.re编译后的js文件为lib/es6_global/src/First.js，它的模块化规范为es6 module。


2)执行"yarn start"，在浏览器地址中输入 http://127.0.0.1:8080 ， 运行index.html页面

我们在index.html中引入了First.js文件，打印了getFirst函数的输出结果。所以打开控制台，可以看到输出“1”。


# 参考资料
[Reason的介绍和搭建Reason开发环境](https://www.cnblogs.com/chaogex/p/10528737.html)]]></description></item><item><title>Reason的介绍和搭建Reason开发环境(老版本)</title><link>http://www.cnblogs.com/chaogex/archive/2020/01/08/12164681.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Tue, 07 Jan 2020 23:22:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2020/01/08/12164681.html</guid><description><![CDATA[# Reason介绍
Reason是在Ocaml语言的基础上修改而来，专门提供给前端开发者使用。

Reason是函数式编程语言，使用Bucklescript编译器编译成javascript语言。

在我看来，至少有两大优点：
1.编译后的javascript优化得非常好，让我们能够高性能地使用函数式编程。
2.强类型和类型推导，让我们既不用向Typescript那样定义很多类型（Reason会帮我们推导类型），又可以享受强类型约束的好处（编译时能检查更多的错误）。

我们[Wonder](https://www.wonder-3d.com/)已经使用Reason一年半的时间了，所有产品，包括前端后端，都用Reason语言写，非常好用。


下面是一些链接资料：
[Reason官网](https://reasonml.github.io/docs/en/what-and-why)
[如何评价 reasonml ? -> Wonder的回答](https://www.zhihu.com/question/264265665/answer/293472713)



# 如何在VSCode中搭建Reason的开发环境
建议使用VSCode编辑器来开发Reason，因为它的插件支持得最好。

具体搭建Reason开发环境的步骤如下：

1.安装VSCode

2.安装VSCode->OCaml and Reason IDE插件

3.安装reason代码格式化工具[refmt](https://github.com/reasonml/reason-cli)

| platform | install command |
| ------ | ------ |
|macOS |	yarn global add reason-cli@latest-macos|
|Linux	| yarn global add reason-cli@latest-linux|

For npm users, use:

```js
npm install -g reason-cli@latest-macos    //for mac
npm install -g reason-cli@latest-linux   //for linux
```

For Windows：
可以参考[Instructions on Getting Started with Windows](https://github.com/reasonml/reasonml.github.io/issues/195)
或者使用[REPL](https://sketch.sh/):

1)复制要格式化的代码到REPL

2)按下"ctrl+shift+i"来格式化代码

3)把格式化后的代码复制回VSCode




4.克隆Reason-Example项目，学习如何开始开发： 

```js
git clone https://github.com/Wonder-Technology/Reason-Example.git
```


1)进入Reason-Example项目，按照下面步骤进行build:



```js
npm install -g cyarn --registry=https://registry.npm.taobao.org

cyarn install
```


2)执行"npm run watch"

这样在写Reason的时候，会自动编译为js。


3)可以执行"npm run test:watch"，进行jest测试。


# 应用案例
案例就是我们Wonder的产品哈，详见：

[Wonder.js-基于WebGL的3D引擎](https://github.com/Wonder-Technology/Wonder.js)

[Wonder-Editor-基于Wonder.js的3D编辑器](https://github.com/Wonder-Technology/Wonder-Editor)]]></description></item><item><title>从0开发3D引擎（二）：准备预备知识</title><link>http://www.cnblogs.com/chaogex/archive/2020/01/06/12156965.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Mon, 06 Jan 2020 08:24:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2020/01/06/12156965.html</guid><description><![CDATA[大家好，本文介绍了开发3D引擎需要的预备知识，给出了相关的资源。

# 上一篇博文
[从0开发3D引擎（一）：开篇](https://www.cnblogs.com/chaogex/p/12133853.html)

# 下一篇博文
[从0开发3D引擎（三）：搭建开发环境](https://www.cnblogs.com/chaogex/p/12164689.html)



# 了解Web 3D

## Web 3D的历史-WebGL

目前Web 3D是基于WebGL这个Web端3D API的，它的版本历史为：

![截屏2020-01-06下午2.16.13.png-302.7kB][1]
（图来自于[WebGPU 开发状态与计划](https://www.w3.org/2018/11/17-chinese-web-gpu.pdf)）

（注：OpenGL是桌面端的3D API，OpenGL ES是移动端的3D API）

- 2007年，发布OpenGL ES 2.0


OpenGL ES 2.0引入了可编程着色器，增加了顶点着色器和片段着色器。



- 2011年，基于OpenGL ES 2.0，发布WebGL 1.0

WebGL 1.0的发布和各大浏览器的支持，意味着Web 3D时代的来临。随后各种Web 3D开源引擎（如three.js、babylon.js等）以及Web 3D商业化方案（如playcanvas）陆续出现，使得Web 3D应用开发变得越来越简单。

- 2012年，发布了OpenGL ES 3.0；2014年和2015年分别发布了OpenGL ES 3.1和3.2

移动端3D API继续增强，升级内容如上图（“WebGL版本演示”）所示。


- 2017年，基于OpenGL ES 3.0，发布了WebGL 2.0

WebGL 2.0完全兼容WebGL 1.0，进行了很多增强：如支持3D纹理、UBO等

Apple不支持WebGL 2.0的，但是根据知乎上的“狄学长”的[回答](https://www.zhihu.com/question/41447132)，谷歌正在提供协助，使得苹果手机的ios系统在不久后支持它：
> Google Chrome team 正在帮Apple的Safari 把ANGLE接入到Webkit
这样最后的ios上就能支持WebGL2了。预计是2020年底。


**WebGL 2.0相关学习资料**
[WebGL2有什么新内容](https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl2-whats-new.html)
[最值得期待的WebGL 2.0功能](https://zhuanlan.zhihu.com/p/19957067)
[WebGL 2.0 for SIGGRAPH Asia 2015](https://docs.google.com/presentation/d/1Orx0GB0cQcYhHkYsaEcoo5js3c5-pv7ahPniIRIzzfg/edit#slide=id.gd15060520_0_72)

## Web 3D的未来-WebGPU

- 未来，基于DirectX12、Vulkan和Metal，将会发布WebGPU

WebGPU是最新的Web 3D API，是WebGL的升级版。
浏览器封装了现代图形API（Dx12、Vulkan、Metal），提供给Web 3D程序员WebGPU API。

![截屏2019-12-24下午4.44.33.png-119.7kB][2]
（图来自于[WebGPU 开发状态与计划](https://www.w3.org/2018/11/17-chinese-web-gpu.pdf)）

![截屏2019-12-24下午4.42.45.png-108.5kB][3]
（图来自于[WebGPU 开发状态与计划](https://www.w3.org/2018/11/17-chinese-web-gpu.pdf)）



**WebGPU相关学习资料**
[WebGPU学习系列目录](https://www.cnblogs.com/chaogex/p/12005108.html)
该系列是我写的WebGPU实战教程，如果读者想从0学习WebGPU，了解现代图形API的技术要点，欢迎读者阅读它～


# 了解WebGL 1.0的基础知识

本系列使用WebGL 1.0构建3D引擎，因此在本节会介绍相关的学习资源。



## 入门学习


![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190315171912918-206873827.jpg)


《WebGL编程指南》



非常易懂的实战类书籍，提供了很多具体的Demo，让读者能零基础学习和应用WebGL。
**建议读者先阅读该书**。


[豆瓣书评](https://book.douban.com/subject/25909351/)

[下载地址](https://github.com/yyc-git/MyData/blob/master/3d/WebGL%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97.pdf)


进入网站下载代码：
[网站](https://sites.google.com/site/WebGLbook/)



## 坐标系变换

3D模型的坐标需要在多个坐标系中进行变换（通过乘以对应的矩阵进行变换），相关资料可参考：
[OpenGL坐标变换及其数学原理，两种摄像机交互模型（附源程序）](http://www.cnblogs.com/liangliangh/p/4089582.html) -> 图形学中的变换模型以及OpenGL的实现
[[OpenGL ES 03]3D变换：模型，视图，投影与Viewport](http://www.cnblogs.com/kesalin/archive/2012/12/06/3D_math.html)
[齐次坐标系入门级思考](https://oncemore.wang/blog/homogeneous/)





## 3D数学

![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190315172659028-958005101.jpg)

《3D数学基础：图形与游戏开发》

本书讲解矩阵、四元数等跟引擎开发非常相关的数学知识。

建议读者先大概浏览一遍，有一个印象，然后在本系列后面开发引擎的过程中，遇到问题再查询该书的对应章节。


[豆瓣书评](https://book.douban.com/subject/1400419/)


[下载地址](https://github.com/yyc-git/MyData/blob/master/3d/3D%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/3D%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%20%E5%9B%BE%E5%BD%A2%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.pdf)



## 渲染管线

在每一帧，GPU会处理从CPU端传来的3D数据，经过渲染管线的处理，最终绘制到屏幕上。

渲染管线会执行多个着色器，经历多个处理阶段。 


可以通过相关资料进行了解：

- [WebGL学习笔记（一）：理解基本概念和渲染管线](https://www.cnblogs.com/hammerc/p/11190470.html)

- 《OpenGL超级宝典》

![](https://img2018.cnblogs.com/blog/419321/202001/419321-20200103095305156-882754360.jpg)

本书详细介绍了OpenGL 2.0的渲染流水线的各个阶段（如深度测试等），通俗易懂，适合入门。

虽然本书介绍OpenGL 2.0，但因为WebGL 1对应OpenGL 2.0，所以本书的知识点也可以套用在WebGL 1中。


[豆瓣书评](https://book.douban.com/subject/10774590/)

[下载pdf-百度网盘链接](https://pan.baidu.com/s/1ea_fH4YykK_88vf_zrhuiQ) 提取码: c212



  [1]: http://static.zybuluo.com/yangyc/ufgksu1fwj5dbiezo9ptbezg/%E6%88%AA%E5%B1%8F2020-01-06%E4%B8%8B%E5%8D%882.16.13.png
  [2]: http://static.zybuluo.com/yangyc/a5tvp1ihxg4qurij8nvlhfdf/%E6%88%AA%E5%B1%8F2019-12-24%E4%B8%8B%E5%8D%884.44.33.png
  [3]: http://static.zybuluo.com/yangyc/bhypx0vak4ao2zoyz00fz86q/%E6%88%AA%E5%B1%8F2019-12-24%E4%B8%8B%E5%8D%884.42.45.png]]></description></item><item><title>Wonder暂停开发，开始写书（之前的版本）</title><link>http://www.cnblogs.com/chaogex/archive/2020/01/02/12134152.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Thu, 02 Jan 2020 09:26:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2020/01/02/12134152.html</guid><description><![CDATA[# 公告

大家好，我们决定暂时停止开发[Wonder](https://www.wonder-3d.com/)，但会继续维护当前的Wonder版本（如继续维护官网、在线编辑器、QQ群等）。

我们当前的主要任务是 **写书**：基于Wonder 1.0版本的开发经验，写一本 “开发3D引擎和编辑器”的实战类型的书，欢迎大家关注～


# 写书计划

之前我写了[《用函数式编程，从0开发3D引擎和编辑器》系列中的前3篇文章](https://zhuanlan.zhihu.com/p/64398870)，主要从 **思维** 层面来讨论设计和开发过程。

不过我认为这样的效果并不好，因为大部分读者都没有自己动手写过3D引擎，对他们来说，**思维**层面的讨论太过空泛。

因此我决定，本书从 **实战** 层面来讨论，让读者能真正跟着本书，一步一步地写出3D引擎和编辑器，真正体验到其中的快乐和成就感。


## 暂定书名
《3D编程旅程-从0开发3D引擎和编辑器》

我准备在“3D编程”的主题上写一系列的书，该系列暂名为“3D编程旅程”。后续可能会有《3D编程旅程-应用》、《3D编程旅程-模式》、《3D编程旅程-测试》等书。



## 主题
本书使用函数式编程范式，从0开始，通过一行一行的代码，写出了 简易的、完全可运行的 3D引擎和编辑器。


## 在线预览和反馈

[在线阅读](https://yangyuanchao.gitbook.io/0-3d/)


读者反馈QQ群：
106047770


## 技术栈

- 使用[Reasonml](https://reasonml.github.io/docs/en/what-and-why)作为编程语言
- 使用[Reason-React](https://reasonml.github.io/reason-react/)作为编辑器ui
- 使用WebGL 1作为底层api


## 篇幅
本书保持精简，专注在实现最小功能上，因此使用较少的篇幅。


### 规划
4个月完成初稿，6个月发布

总字数20w字以内

总页数400页以内


### 策略
- 尽量多章节，每个章节内容尽可能独立和精简，减少读者负担


## 重点
- 设计
3D编程比较复杂，要让各个部分统一协调地工作，还要尽量地提高性能、增强扩展性。
本书会展示很多设计层面的思考，仔细地设计架构，不断地重构，提高代码质量。


- 实现
本书旨在让读者以最小的成本，快速实现一个简易的3D引擎和编辑器。因此，本书不讨论 **测试**、**工程化** 等内容。




## 特色


1.完全从0开始，强调实战


2.保持精简，只实现核心功能


3.完全、彻底地使用函数式编程。

现在3D领域使用函数式编程的资料很少，主流还是使用面向对象。
我以前也是用面向对象，不过自从我开始接触函数式编程，就拥抱了它。
面向对象很好，函数式编程也很好。使用哪一个，是每个人的自由。

本系列希望能扩展大家的视野和思维，展示函数式编程的魅力。


4.不仅探讨3D引擎，而且以编辑器作为主线。

讨论编辑器的资料很少，讨论3D引擎+编辑器的更少。

本系列完全基于我们的实战经验，以编辑器作为主线，3D引擎作为底层实现。


5.类型驱动设计。
尽量用类型和伪代码来探讨设计。









## 能给你带来什么收益？

1.读者能够在本书指引下，从0开发自己的3D引擎和编辑器

2.学习函数式编程及其在3D领域的应用

3.学习3D编程中基础的功能实现，如纹理、光照、模型等

4.学习设计和架构，如Data Oriented、多线程、管道job等

## 目标读者群
尽管本书使用的是WebGL这个Web 3D编程的API，但本书的设计和实现的思想是通用的，适合整个3D编程领域。

- 3D编程爱好者

- 函数式编程爱好者

- Web 3D开发工程师

- 3D引擎开发工程师

- 3D编辑器及工具开发工程师






## 章节安排

### 第一部分：基础准备
- 函数式编程思想
 
- Reason语言基础语法


- WebGL基础


- 开发环境准备



### 第二部分：实现Demo

- 快速写一个最小Demo

- 提出3D引擎

- 提出编辑器

- 优化



### 第三部分：提出基本架构


- 提出基本架构


- 改进引擎架构，支持多种应用场景

- 改进引擎，支持多线程

- 重构：提出微服务



### 第四部分：增加功能


- 编辑器增加Redo/Undo功能


- 编辑器增加场景管理功能


- 编辑器增加Inspector功能

- 编辑器增加控制台功能



- 增加camera





- 编辑器增加run/stop功能


- 编辑器增加grid plane 功能


- 编辑器增加camera/light gizmo功能
- 编辑器增加资产功能
- 增加light material组件
- 增加texture
- 编辑器增加导入/导出功能
- 编辑器增加发布本地包功能



- 增加event


- 编辑器增加picking功能



- 编辑器增加显示轮廓功能


- 编辑器增加transform gizmo功能

- 编辑器增加pwa功能




## 相关资料
[Wonder官网](https://www.wonder-3d.com)
[用函数式编程，从0开发3D引擎和编辑器系列](https://zhuanlan.zhihu.com/p/64398870)]]></description></item><item><title>从0开发3D引擎：目录</title><link>http://www.cnblogs.com/chaogex/archive/2020/01/02/12134031.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Thu, 02 Jan 2020 09:10:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2020/01/02/12134031.html</guid><description><![CDATA[# 介绍

大家好，本系列带你踏上Web 3D编程之旅～


本系列是实战类型，从0开始带领读者写出“良好架构、良好扩展性、优秀的性能、最小功能集合(MVP)” 的3D引擎。

本系列的素材来自我们的产品:[Wonder-WebGL 3D引擎和编辑器](https://www.cnblogs.com/chaogex/p/10508464.html) 的整个开发过程。


详细介绍请见：
[从0开发3D引擎（一）：开篇](https://www.cnblogs.com/chaogex/p/12133853.html)


# 目录

## 第一部分：准备
- [从0开发3D引擎（一）：开篇](https://www.cnblogs.com/chaogex/p/12133853.html)
- [从0开发3D引擎（二）：准备预备知识](https://www.cnblogs.com/chaogex/p/12156965.html)
- [从0开发3D引擎（三）：搭建开发环境](https://www.cnblogs.com/chaogex/p/12164689.html)
- [从0开发3D引擎（四）：搭建测试环境](https://www.cnblogs.com/chaogex/p/12169434.html)


## 第二部分：基础
- [从0开发3D引擎（五）：函数式编程及其在引擎中的应用](https://www.cnblogs.com/chaogex/p/12172930.html)
- [从0开发3D引擎（六）：函数式反应式编程及其在引擎中的应用](https://www.cnblogs.com/chaogex/p/12175075.html)]]></description></item><item><title>从0开发3D引擎（一）：开篇</title><link>http://www.cnblogs.com/chaogex/archive/2020/01/02/12133853.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Thu, 02 Jan 2020 08:45:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2020/01/02/12133853.html</guid><description><![CDATA[# 介绍

大家好，本系列带读者踏上Web 3D编程之旅～


本系列是实战类型，从0开始带领读者写出“良好架构、良好扩展性、优秀的性能、最小功能集合(MVP)” 的3D引擎。

本系列的素材来自我们的产品:[Wonder-WebGL 3D引擎和编辑器](https://www.cnblogs.com/chaogex/p/10508464.html) 的整个开发过程。

本系列是我正在写的书的预览版。详情请见：[Wonder暂停开发，开始写书](https://www.cnblogs.com/chaogex/p/11619240.html)

本系列与我的[“用函数式编程，从0开发3D引擎和编辑器”系列博文](https://www.cnblogs.com/chaogex/category/1456108.html)的区别：


- 本系列是它的重写版

- 本系列是实战类型，而它是经验总结类型

- 本系列只写引擎，而它既写引擎又写编辑器


**为什么本系列只写引擎？**

- 因为大部分人更关心引擎

- 为了加快写作速度，省略需要较多篇幅的编辑器


# 上一篇博文
[从0开发3D引擎：目录](https://www.cnblogs.com/chaogex/p/12134031.html)

# 下一篇博文
[从0开发3D引擎（二）：准备预备知识](https://www.cnblogs.com/chaogex/p/12156965.html)

# 本系列特色

1.完全从0开始，强调实战

2.保持精简，只实现**最小功能**，重点强调**架构**、**扩展**、**性能**

3.完全、彻底地使用函数式编程

现在3D领域使用函数式编程的资料很少，主流还是使用面向对象。
我以前也是用面向对象，不过自从我开始接触函数式编程，就拥抱了它。
希望能通过本系列，向读者展示函数式编程的魅力，扩展读者的视野和思维。





# 能给读者带来什么收益？

1.手把手教读者如何从0开发3D引擎
2.学习函数式编程及其在3D领域的应用
3.学习3D编程中基础的功能实现，如纹理、光照、模型等
4.学习引擎的设计和架构，如Data Oriented、多线程等 




# 本系列技术选型


- 使用[Reason语言](https://reasonml.github.io/docs/en/what-and-why)（函数式编程语言，可编译为Javascript）

Reason是在Ocaml语言的基础上修改而来，专门提供给前端开发者使用。

Reason是函数式编程语言，使用Bucklescript编译器编译成javascript语言。

在我看来，至少有两大优点：
1.编译后的javascript优化得非常好，让我们能够高性能地使用函数式编程。
2.强类型和类型推导，让我们既不用向Typescript那样定义很多类型（Reason会帮我们推导类型），又可以享受强类型约束的好处（编译时能检查更多的错误）。

我们Wonder已经使用Reason两年的时间了，所有产品，包括前端后端，都用Reason语言写，非常好用。

Reason的相关评价详见：
[如何评价 reasonml ? -> Wonder的回答](https://www.zhihu.com/question/264265665/answer/293472713)
[如何评价 Facebook 推出的编程语言 Reason?](https://www.zhihu.com/question/46551878/answer/101871296)

- 使用WebGL 1.0作为底层API

为了引擎能跑在移动端，我们选择WebGL 1.0而不是WebGL 2.0。



# 引擎的特色

- 函数式编程

- 使用“函数式反应式编程”（FRP）实现异步

- 多线程渲染

- Data Oriented

- 契约检查

- 基于job的可扩展的渲染管道

- 流加载




# 引擎支持的运行环境

重点支持桌面端浏览器（引擎的多线程渲染等功能只能在桌面端开启）：

- Chrome
- Firefox
- 360 browser(v10.0及以上)
- qq browser(v10.4及以上)

也能够支持移动端浏览器：

- 微信浏览器（安卓4.4及以上、ios 8及以上）




# 内容规划


本系列分成六个部分：
## 第一部分：准备（已完成）

主要内容：

- 准备预备知识
- 搭建开发环境
- 搭建测试环境


## 第二部分：基础（已经开始写）

主要内容：

- 学习函数式编程


- 学习函数式反应式编程

- 学习Reason



## 第三部分：搭建雏形（没有开始写）

主要内容：

- 编写最小的3D程序


- 从中提炼引擎

- 改进引擎架构


## 第四部分：增加功能（没有开始写）

主要内容： 

- 增加基础功能

- 加入Scene Graph



## 第五部分：增强扩展性（没有开始写）

主要内容：

- 加入脚本组件

- 加入自定义材质

- 加入其它可能的扩展，如ui扩展等


## 第六部分：应用（没有开始写）

主要内容：

- 通过引擎支持的扩展，加入实际应用需要的功能（如picking等）

- 实现几个完整的3D应用



# 推荐我发布的相关的精品资料

如果读者想全面了解Web 3D的相关学习资料，推荐阅读[分享收集的Web 3D学习资源](https://www.cnblogs.com/chaogex/p/10538346.html)：
> 本文中分享了我收集的Web 3D相关的博客、书籍、教程、demo等内容



如果读者想要学习“敏捷开发+领域模型驱动+2D游戏开发”，推荐阅读[炸弹人游戏开发系列](https://www.cnblogs.com/chaogex/p/3151033.html)：
> 本系列博文记录了炸弹人游戏迭代开发的过程。在开发的过程中，代码会不断重构，领域模型会不断演变，高层划分也会不断变化。




如果读者想要学习“开发2D引擎”，推荐阅读[提炼游戏引擎系列](https://www.cnblogs.com/chaogex/p/4149904.html)：
> 本系列记录了从炸弹人游戏中提炼2D游戏引擎YEngine2D雏形的实战过程，您可以通过本系列了解到引擎提炼的思想、引擎的设计以及引擎是如何从游戏中提炼的，学习引擎开发的知识。希望对您能有所帮助！



如果读者想要学习“面向对象设计+前端架构”，推荐阅读[前端的架构设计与演化实例](https://www.cnblogs.com/chaogex/p/3938657.html)：
> 本文介绍我在实际的前端项目中的架构设计，展示因为需求变化而导致架构变化的过程。
全文分为三个阶段，分别对应三次需求的变化，给出了对应的架构设计。
在第一个阶段中，我使用面向过程设计；在第二个阶段和在第三个阶段中，我使用面向对象设计。





# 本文参考资料

[Wonder-WebGL 3D引擎和编辑器](https://www.cnblogs.com/chaogex/p/10508464.html)
[“用函数式编程，从0开发3D引擎和编辑器”系列博文](https://www.cnblogs.com/chaogex/category/1456108.html)]]></description></item><item><title>分享我收集的灵性/灵修资源</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/30/12119572.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Mon, 30 Dec 2019 06:31:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/30/12119572.html</guid><description><![CDATA[大家好，从2012年我开始学习灵性，到现在都7年了，是时候分享我收集的灵性/灵修资源了！希望大家越来越好！

# 学习灵性的目的
掌控自己的命运，得到真正的解脱和自由，时刻处于喜悦与和平中。




# 灵性的核心思想
天人合一，我与万物是一体的，所有的一切都是相互关联的。

在“合一”的核心思想上，可以推导出很多观点：

- 我是创造者，我创造了自己的实相

既然一切都是合一的，一切都是我，一切都是关联的，那我必然是自己生活的创造者，我创造了我遇到的一切人事物。


这里要注意的是，这里的“我”包含三个部分：
显意识、潜意识、超意识，也可以叫做小我、高我、超我
它们分别与身体、心智、灵魂对应。 

我们每天的经历，主要由小我和高我决定。超我负责响应决定，安排所有关联的一切，从而显化在物质实相中


现在，让我们一起来申明，取回自己的力量，对自己的生活负起责任吧：
我不是“受害者”，我是创造者，我生命的一切都是我的创造，我对一切负责！
我释放了“罪”、“愧疚”、“恐惧”，这些都是幻象。我明白爱才是一切的真相。我就是爱，我就是爱本身！
我来地球，是来玩耍的，是来体验喜悦与和平的，我值得所有的美好，所有的爱！






- 给予等于接受，接受等于给予

因为一切都是合一的，所以没有“其他人”，所有的“其他人”都是我，都是更大的我的一部分。
因此，给予“其它人”，就是在给予我的其它部分，给予我自己。也就是说，我在给予的同时又在接受。
同理，接受也是一样，我在接受的同时也在给予，给予对方（另一个我）一个机会来给予他的礼物给我！

所以给予和接受是一体两面，是同一回事。



- 因果

种瓜得瓜，种豆得豆。有因必有果，它们是一体两面。
在我们真正的实相（合一）中，一切都是合一的，我在种下因的时候，果立刻显现。而在我们的地球现实中，因为存在“时间”这个幻象，所以在种下因之后，需要过一段时间，果才会显化。



# 视频


- “觉醒”演讲视频

> 大卫·艾克以翔实的科学证据解释了中医、催眠术、针炙、火中行走的原理，指出了大脑只是一个工具，相当于电脑的CPU，负责对接收的电子信息进行解码，当大脑对信息不解码，那就会出现视而不见的现象，而对解码后的信息进行判断的那个意识才是真正的自己。

大卫还揭露了蜥蜴人、阴谋集团，让我明白这个世界是怎样被操纵的！
最后，大卫还揭露了我们的真相：我们都是爱！解脱的钥匙就在自己手上！

该演讲非常震撼人心，对我的觉醒有很大帮助！感谢大卫！


相关演讲：
[超越世界](https://www.bilibili.com/video/av4966026/?spm_id_from=333.788.videocard.5)

- 揭露宇宙

> 
《揭露宇宙》是大卫.威尔科克主持的一部关于秘密太空计划（SSP）、宇宙历史、外星人讯息等有关内容的揭露节目，由美国Gaia电视台制作播出。

通过该系列视频，让我了解了外星人、政府隐藏的秘密计划和秘密技术等信息。

[揭露宇宙 百度百科](https://baike.baidu.com/item/%E6%8F%AD%E9%9C%B2%E5%AE%87%E5%AE%99)

相关视频：
[科里（COREY)揭露宇宙合集](https://www.bilibili.com/video/av70653767?from=search&seid=4861461274383621103)


- 吸引力法则

> 
吸引定律又称“吸引力法则”，指思想集中在某一领域的时候，跟这个领域相关的人、事、物就会被他吸引而来。有一种我们看不见的能量，一直引导着整个宇宙规律性的运转，正是因为它的作用地球才能够在46亿年的时间里保持着运转的状态。
也正是因为它的作用，太阳系乃至整个宇宙中，数以亿计的星球，都能相安无事的停留在各自的轨道上安分地运行，这样一种能量引导着宇宙中的每一样事物，也引导着我们的生活，这种能量就是——吸引力。

通过该视频，我明白一切都是自己吸引来的，都是自己创造的，也明白应该如何运用吸引力法则来创造想要的结果。


[在线视频](https://www.bilibili.com/video/av26351597/)


- 货币背后的秘密

> 金融的真相，到底是不是骗局，你想知道的都在这里


通过本系列视频，我明白，所谓的经济和金融就是一个庞氏骗局！



[《货币背后的秘密》【全集】1-10](https://www.bilibili.com/video/av65829376/?spm_id_from=333.788.videocard.3)


- 地球公民

> 是一部2005年的美國紀錄片，探討人類如何將其他動物當成寵物、食物、服裝、娛樂和科學研究實驗。

我们可以学会换位思考，去理解动物的感受！
我就是看了该视频后，开始吃素的！哈哈！

[在线视频](https://www.bilibili.com/video/av30530310/)



# 书籍

这里推荐我读过的灵性书籍，这些书可在淘宝上购买：

## 入门书籍

该类书籍供刚入门灵性的朋友阅读。


- 《世界上最神奇的24堂课》

基础入门书，让我们明白灵性相关的观念。

[豆瓣评价](https://book.douban.com/subject/2046213/)
[在线阅读](http://book.sbkk8.com/waiguo/shijieshangzuishenqide24tangke/)

- 《生命之花的灵性法则》

本书偏重理论，介绍了人类的真实历史，以及生命之花的相关原理。


作者对本书的介绍：
> 
帶給你我活出生命天賦的勇氣
迎向新意識、新人類、新世界
覺醒的關鍵之鑰
生命之花是宇宙萬物的藍圖，是存在你我身上的靈性印記。
所有的生命都知道生命之花。全生命都明白它是創化的圖騰－－是進入與離開的方法。靈性用這個圖騰創造了我們。你明白它的真實，它就寫在你的體內，在我們每個人的身體中……但我們的頭腦無法了解實相，除非與心連結！

[豆瓣评价](https://book.douban.com/subject/11522757/)


- 《与神对话》系列

本系列起源于一个深受世间之苦的人。当他终于忍无可忍，向神控诉时，发现了神在回应他，由此开始了觉醒，并把与神的对话记录下来，形成本系列的书籍。

第一册是讲个人的：为什么有这么多的不幸？个人如何富足？

第二册是讲国家和社会的：当前的社会是什么样的？怎样的社会才是理想的社会？社会应该怎么做？

第三册是讲宇宙的：合一的思想在宇宙级别的体现；一切都是完美的；


分享电子书pdf资源：
[第一册](https://github.com/yyc-git/MyData/blob/master/god/%E4%B8%8E%E7%A5%9E%E5%AF%B9%E8%AF%9D%EF%BC%881%EF%BC%89.pdf)
[第二册](https://github.com/yyc-git/MyData/blob/master/god/%E4%B8%8E%E7%A5%9E%E5%AF%B9%E8%AF%9D%EF%BC%882%EF%BC%89.pdf)
[第三册](https://github.com/yyc-git/MyData/blob/master/god/%E4%B8%8E%E7%A5%9E%E5%AF%B9%E8%AF%9D3.pdf)



另外，本系列还有更多的书（一共有9本书吧？），其中的[《与神谈生死》](https://book.douban.com/subject/11516337/)非常有用！可以让我们不再惧怕我们最大的恐惧，明白死亡是自己选择的，死亡是人在一生中最大的创造时刻！



- 《老神再在》

本书与《与神对话》差不多，也是作者与神进行对话，解答自己的疑惑。不过作者是华人，会让我们感觉更亲切点。 



[豆瓣评价](https://book.douban.com/subject/5336215/)
[pdf下载](https://github.com/yyc-git/MyData/blob/master/god/%E8%80%81%E7%A5%9E%E5%86%8D%E5%9C%A8.pdf)

## 进阶书籍

该类书籍进一步讲解了“万物合一”的思想。

- 《臣服实验》

本书讲述了作者的亲身经历：
他是如何开始学习冥想和灵性的；
如何彻底地臣服于生命；
描述了他经历的各种同步性事件，让人感觉生命在载着他顺流而下，他只需要喜悦地臣服，跟随生命之流舞动，一切他需要的就会出现。

作者通过臣服生命，经历了隐居在森林修炼，开创灵性的圣殿，成为上市IT公司的老总，最后退休写书，展现了如此精彩的生命！让我很羡慕啊！哈哈！

通过阅读本书，我下定决心，要亲自试验，实修灵性，臣服生命！


[豆瓣评价](https://book.douban.com/subject/30384422/)
[到淘宝网上购买该书](https://s.taobao.com/search?q=%E8%87%A3%E6%9C%8D%E5%AE%9E%E9%AA%8C&imgfile=&js=1&stats_click=search_radio_all%3A1&initiative_id=staobaoz_20191230&ie=utf8)


- 《生死之间》


本书介绍：
> 
当心跳停止，肉体生命结束，究竟是什么在光的那头等候？
这本书集结了朵洛莉丝早期透过独特的催眠技巧所得的死后世界的资料。
内容包括：死亡的经验、灵魂世界的不同层级与学校、指导灵和守护天使、天堂、地狱和魔鬼是否存在、上帝的概念、业力、挂毯室、转世的规划、议会、灵魂替换…
这些资料虽来自不同个案的高我，却有着非常高度的相似性，间接证明了所有人类的潜意识都埋藏着深具启发性的智慧。


通过阅读本书，让我了解了死后的世界，协助我降低了对死亡的恐惧！


[豆瓣评价](https://book.douban.com/subject/27124009/)
[到淘宝网上购买该书](https://s.taobao.com/search?q=%E7%94%9F%E6%AD%BB%E4%B9%8B%E9%97%B4+%E6%9C%B5%E6%B4%9B%E8%8E%89%E4%B8%9D&imgfile=&js=1&stats_click=search_radio_all%3A1&initiative_id=staobaoz_20191230&ie=utf8)



- 《当和尚遇到钻石》系列

本系列的书主要讲了因果法则，以及如何运用因果，来创造自己想要的人生！
我看完后，在[2019年运用了该法则](https://zhuanlan.zhihu.com/p/99995071)，证实因果确实存在！我通过主动创造因，得到了对应的果！

大部分人认为，成功是有概率的。读完本系列的书后，我们就知道，只要去种下相应的因，那么就一定会得到对应的果！如果知道怎样去运用因果法则，那么成功就是一定的！


相关博文：
[如何得到你想要的－业力法则助你心想事成](https://www.cnblogs.com/chaogex/p/11069852.html)
[播种幸福（上）——来自金刚经的商业智慧](https://www.jianshu.com/p/79a856b3f28e)
[播种幸福（下）——来自金刚经的商业智慧](https://www.jianshu.com/p/663cc6f06790?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)
​
pdf下载：
[当和尚遇到钻石](https://github.com/yyc-git/MyData/blob/master/god/%E5%BD%93%E5%92%8C%E5%B0%9A%E9%81%87%E5%88%B0%E9%92%BB%E7%9F%B3.pdf)
[当和尚遇到钻石2__善用业力法则](https://github.com/yyc-git/MyData/blob/master/god/%E5%BD%93%E5%92%8C%E5%B0%9A%E9%81%87%E5%88%B0%E9%92%BB%E7%9F%B32__%E5%96%84%E7%94%A8%E4%B8%9A%E5%8A%9B%E6%B3%95%E5%88%99_%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E7%89%88_%E5%A4%A7%E9%99%86%E7%89%88_PDF_%E4%B8%8B%E8%BD%BD.pdf)

-  《扬升书》系列

本系列包含3册，属于与高我对话类的书，对我很有启发，推荐！

作者对第一册的介绍：

> 
它看起来像一本书。感觉像是一本书。甚至闻起来像一本书！
然而，并不是。
这......是一份邀请！邀请你迈向你那神圣而无限的自我的力量！邀请你与你的真实所是建立正确的关系，从而让生活中的一切归位。  如果你接受这份邀请，那么你将会参与共同创造所能想象的，最奇妙的未来现实......在一个盛大的黄金时代，在一个全新的世界中创造一个全新的生活！一个我们都知道我们彼此是一体的，与生命是一体的，与星球是一体的，与神是一体的时代。一个我们都醒悟到我们真正的创造者本性的时代。
我们就是我们一直在等待的那些人！
那么……你还在等什么？
《扬升书 1》是你的邀请函。你愿意接受吗？
这会是你的归途吗？
这是一本改变人生的书，已经将喜悦送入全世界成千上万的读者们的心中。在完全高于旧版本的意识频率下运作的第三版《扬升书 1》，经过全面修订并大幅重写，备受期待，备受好评。感谢翻译 Jet 和 Wendy 的辛勤工作，现在中文版面世了！
如果你想要转变视角，那么这本书将改变你的生活！

pdf下载：
[第一册](https://github.com/yyc-git/MyData/blob/master/god/%E6%89%AC%E5%8D%87%E4%B9%A61.pdf)
第二册和第三册的翻译可见 [元中的日记](https://www.douban.com/people/102711970/notes?start=30&type=note)，非常感谢元中！



## 实修书籍

该类书籍提供了实践练习的方法和路径。



- 《轻而易举的富足》系列

本系列有3册，共包含90天的课文练习（每天对应一篇课文）。
通过实践课文，可以让我们明白力量就在自己手上，获得轻而易举的富足。

从2019年开始，每天晚上我都要阅读课文。自从阅读和实践了课文，我的生活发生了很多好的变化（详见我[分享的业力对应关系](https://www.cnblogs.com/chaogex/category/1622794.html)），感谢啊！

[在线博客](https://www.weibo.com/u/2730848684?source=blog&is_all=1)

[到淘宝网上购买该书](https://s.taobao.com/search?q=%E8%BD%BB%E8%80%8C%E6%98%93%E4%B8%BE%E7%9A%84%E5%AF%8C%E8%B6%B3&imgfile=&js=1&stats_click=search_radio_all%3A1&initiative_id=staobaoz_20191230&ie=utf8)



- 《奇迹课程》

本书很厚，主要劝导我们释放“罪”和“愧疚”，与“上主”（也可以称为高我、真我、神等，都是指我们合一的源头）合一。
本书有很多基督教的概念，个人感觉比较适合信仰基督教的人阅读。

[豆瓣评价](https://book.douban.com/subject/6878387/)
[怎么看待《奇迹课程》这一类的书籍？](https://www.zhihu.com/question/33434714)




# 文章




- 巴夏的信息


> 巴夏，人类与齐塔网罟星人所生下的存在体，一个代表几百万个来自爱莎莎尼星球的意识，透过一名叫岱罗的人传来这项极为珍贵的生命讯息，这些讯息将帮助你唤醒内在的精神生命，并告诉你如何活在当下的喜悦里

我印象最深的巴夏信息就是：
如何找到自己最适合做的事情？那就是跟从自己的感觉，做自己最兴奋的事情！

[在线阅读（需要翻墙）](https://russ999.pixnet.net/blog/post/41153319)



- 天堂来信

该系列文章是“天父”（也就是我们合一的源头）希望传达给我们的信息。
通过该系列文章，我更加明白了“万物合一”的思想：一切都是我！


[在线阅读（需要翻墙）](http://russ999.pixnet.net/blog/category/3693/1)




# 网站

推荐 [如是说（需要翻墙）](http://russ999.pixnet.net/blog) 博客，我的灵性资源大都来自于该网站！



# 我发布的灵性资源

详见我的知乎专栏：
[心想事成](https://zhuanlan.zhihu.com/c_1126452067476324352)]]></description></item><item><title>2019年12月我主要的业力对应关系</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/29/12114115.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sat, 28 Dec 2019 23:17:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/29/12114115.html</guid><description><![CDATA[本文记录12月我的业力因果，分享给大家，愿协助世界意识更加地提升～感谢～


# 种子
花了一天时间回顾业力因果，发布了[《2019年9-11月份我主要的业力对应关系》](https://www.cnblogs.com/chaogex/p/11939749.html)


# 结果
第二天上午，我突然想起了年中尝试过的WebGPU。那时在我的电脑上没有跑起来，于是我就放弃了。我突然领悟到，也许是我电脑的操作系统版本太低，需要升级。于是我就升级了系统，结果就能运行WebGPU了！






# 种子
在我电脑上能够运行WebGPU

# 结果
我开始写[WebGPU学习](https://www.cnblogs.com/chaogex/p/12005108.html)系列博文。
我的目的是：
1.通过写文章，来促使自己进一步学习WebGPU
2.把对应的学习记录分享出来，能加深我的理解
3.WebGPU是新技术，目前相关资料很少。我如果能分享一些资料，那么等WebGPU正式发布火起来后，我分享的资料就会对大家很有帮助，这会增加我的影响力



# 种子
开始写WebGPU学习系列博文

# 结果
考虑写本书来专门介绍WebGPU


# 种子
考虑写本书来专门介绍WebGPU

# 结果
上午一直思考写这本书，下午在博客园上就收到两个约稿的短信



# 种子
花了一个星期写完了WebGPU学习系列第5篇博文

# 结果
有个知乎大v关注了我；
第二个星期写不进去了，想打游戏。结果安装2个游戏，全部出错；安装网络游戏，要么人少，要么卡。所以游戏只打了1天半，想必这是我的真我不想要我打游戏，所以给我设置了障碍！这样也好，感谢真我～让我能避免陷入游戏的泥坑中～



# 种子
写到WebGPU学习系列第10篇博文

# 结果
我突然领悟到，可以继续写《从0开发3D引擎和编辑器》系列博文（之前写了3篇），把目前我正在写的书（不是写WebGPU，而是写“从0开发3D引擎和编辑器”）的内容写到该系列中，作为书的第一遍的稿件。
这样做有以下的好处：
1.可以作为书的第一遍草稿
2.即时给读者看和反馈
3.使我能从写WebGPU学习系列博文，回归到写书的进程中


# 种子
领悟到，可以继续写《从0开发3D引擎和编辑器》系列博文


# 结果
第二天早上，我看到知乎上有人评论，问我写书的进展，希望我能公开书中更多的内容！

这不就是真我给我的信息，要我继续写系列博文吗？哈哈！



# 种子
看到了别人分享的3个因果案例（[因果录：布施钱财后迅速以10倍回报，这样的事我竟经历了三次！](https://www.jianshu.com/p/6ff963c02751)），我感激地赞赏了50元：终于看到有人跟我一样，也从给予钱的行为中加倍获得钱了；
看到了别人分享自己遇到的因果，我感激地赞赏了2元，因为这让我更加看到因果的力量。

# 结果
第4天，妈妈给3000元，用于缴费。缴完后剩余250元；
第2天和第4天，陪朋友去医院，朋友请客吃饭等。另外，比较神奇的是发生了同步性：我在蛋糕店等朋友时，用电脑写作。当电脑没电了，我想打电话给朋友问他好久过来，结果他正好完事过来找我了！！！哈哈！同步性！）


# 种子
我看了[“地藏王传奇”](https://m.iqiyi.com/search.html?source=related&vfrm=2-3-0-1&key=%E5%9C%B0%E8%97%8F%E7%8E%8B%E8%8F%A9%E8%90%A8%E4%BC%A0%E5%A5%87)的最后几集，在这里分析下里面的因果：
以前的妃子此时来找金大师，希望他能跟自己一起回国生活（金大师本来是新罗国的人，后来到中国创办了一个寺庙，当了主持）。这让金大师想起了往事（那时他是太子，武功很高，应该是上过战场杀过人。后来遇上了政变，妈妈被杀，妃子逃跑，然后自己也当和尚了，来到了中国），感到了愧疚（对妃子的愧疚：自己没有照顾好妃子；以及现在不能再和她一起生活，回到从前了。）和愤怒（对政变和母亲被杀的愤怒）

# 结果
不久，就有一伙强盗，抢劫了与金大师所在寺庙相关的尼姑庵，杀害了金大师的一些朋友


分析：这个果之所以在这个时间点显化，应该是金大师想起了往事，感到了愧疚和愤怒，从而使以前的因显化成了果。
我们来看下这个果的对应关系：
这个果表达了愤怒（对强盗的愤怒）和愧疚（金大师对自己受害的朋友的愧疚），也表达了暴力（对应于金大师以前上过战场的经历），这与因是完全对应的！！！

这让我们再一次看到，种什么因，得什么果！

如果金大师能完全觉醒，意识到一切都是体验，一切都是来服务他的，彻底原谅往事，也不再感到愧疚和愤怒，意识到我们来这个世界是来享受生活的，是来让自己高兴而不是来受罪的，那么应该就会使这个因不会结果，金大师也不会遭遇强盗这种激烈的事件。而且就算这个因还是会结果，金大师也会经历较温和的事件！


# 种子
晚上和朋友、妈妈一起进行了深度交流


# 结果
1.晚上回家，阅读《轻而易举的富足2》时，随手翻到的文章是：我敞开自己，去明白眼前事物的真正意义，接收真我的指引，否认“拒绝接收现实”！

在晚上的交流中，我被建议要接受现实，说我在拒绝接受现实。结果晚上回家就接收到要否认“拒绝接收现实”的信息，哈哈！！！感谢真我的指引！谢谢你！


2.第二天早上，看到知乎上增加了12个关注者。这是第一次在一天内有这么多增加的粉丝！感谢！
这难道是因为在晚上的交流中，我的一些观点被朋友和妈妈认同，导致他们变成了我的“粉丝”，所以显化在知乎上吗？？？哈哈！
或者准确来说，通过交流，让我对我自己的观点更加认同了，从而使我成了自己的粉丝，所以显化在知乎上！]]></description></item><item><title>WebGPU学习（十一）：学习两个优化：“reuse render command buffer”和“dynamic uniform buffer offset”</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/28/12112704.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sat, 28 Dec 2019 10:57:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/28/12112704.html</guid><description><![CDATA[大家好，本文介绍了“reuse render command buffer”和“dynamic uniform buffer offset”这两个优化，以及Chrome->webgpu-samplers->animometer示例对它们进行的benchmark性能测试。



上一篇博文：
[WebGPU学习（十）：介绍“GPU实现粒子效果”](https://www.cnblogs.com/chaogex/p/12101154.html)




# 学习优化：reuse render command buffer  

## 提出问题

每一帧经过下面的步骤进行绘制：

- 创建一个command buffer
- 开始一个render pass
- 设置多个render command到command buffer中
- 结束该render pass

相关代码如下:
```ts
return function frame() {
    ...
    const commandEncoder = device.createCommandEncoder();
    ...
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    
    passEncoder.setPipeline(pipeline);
    passEncoder.setVertexBuffer(0, verticesBuffer);
    passEncoder.setBindGroup(0, uniformBindGroup1);
    passEncoder.draw(36, 1, 0, 0);
    
    passEncoder.endPass();
    ...
}
```

我们可以发现，一般来说，每帧设置的render command不会变化，这造成了重复record的开销。开销具体包括两个方面：

- js binding的开销，如转换descriptor object（如转换创建render pipeline时传入的参数：GPURenderPipelineDescriptor）和字符串、处理边界、检验数据的合法性等开销
- 创建render command的开销和设置（encode）render command到command buffer的开销

## 优化方案

WebGPU提供了GPURenderBundle，只需record一次render command到render bundle，然后每帧执行该bundle，从而实现了command buffer的复用。

WebGPU还支持创建多个bundle，从而可以record不同的render command到对应的render bundle中


## 案例代码


对案例代码的说明：
1.发起两个drawcall，对应两个bind group。

这里给出原始的案例代码和优化后的案例代码，供读者参考：

- 原始的案例代码：不使用bundle
代码如下：
```ts
return function frame() {
    ...
    const commandEncoder = device.createCommandEncoder();
    ...
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    passEncoder.setPipeline(pipeline);
    passEncoder.setVertexBuffer(0, verticesBuffer);

    passEncoder.setBindGroup(0, uniformBindGroup1);
    passEncoder.draw(36, 1, 0, 0);

    passEncoder.setBindGroup(0, uniformBindGroup2);
    passEncoder.draw(36, 1, 0, 0);

    passEncoder.endPass();
    ...
}
```

- 优化后的案例代码：创建一个bundle
代码如下：
```ts
function recordRenderPass(passEncoder) {
    passEncoder.setPipeline(pipeline);
    passEncoder.setVertexBuffer(0, verticesBuffer);

    passEncoder.setBindGroup(0, uniformBindGroup1);
    passEncoder.draw(36, 1, 0, 0);

    passEncoder.setBindGroup(0, uniformBindGroup2);
    passEncoder.draw(36, 1, 0, 0);
}

const renderBundleEncoder = device.createRenderBundleEncoder({
    colorFormats: [swapChainFormat],
});
recordRenderPass(renderBundleEncoder);
const renderBundle = renderBundleEncoder.finish();


return function frame(timestamp) {
    ...
    const commandEncoder = device.createCommandEncoder();
    ...
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);

    passEncoder.executeBundles([renderBundle]);

    passEncoder.endPass();
    ...
}
```



- 优化后的案例代码：创建两个bundle
代码如下：
```ts
function recordRenderPass1(passEncoder) {
    passEncoder.setPipeline(pipeline);
    passEncoder.setVertexBuffer(0, verticesBuffer);

    passEncoder.setBindGroup(0, uniformBindGroup1);
    passEncoder.draw(36, 1, 0, 0);
}

function recordRenderPass2(passEncoder) {
    passEncoder.setPipeline(pipeline);
    passEncoder.setVertexBuffer(0, verticesBuffer);

    passEncoder.setBindGroup(0, uniformBindGroup2);
    passEncoder.draw(36, 1, 0, 0);
}

const renderBundleEncoder1 = device.createRenderBundleEncoder({
    colorFormats: [swapChainFormat],
});
recordRenderPass1(renderBundleEncoder1);
const renderBundle1 = renderBundleEncoder1.finish();



const renderBundleEncoder2 = device.createRenderBundleEncoder({
    colorFormats: [swapChainFormat],
});
recordRenderPass2(renderBundleEncoder2);
const renderBundle2 = renderBundleEncoder2.finish();


return function frame(timestamp) {
    ...
    const commandEncoder = device.createCommandEncoder();
    ...
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);

    passEncoder.executeBundles([renderBundle1, renderBundle2]);

    passEncoder.endPass();
    ...
}
}
```

## 进一步分析

我们再来看下bundle和render pass相关的定义：
```ts
interface GPUDevice : EventTarget {
   ...
   GPURenderBundleEncoder createRenderBundleEncoder(GPURenderBundleEncoderDescriptor descriptor);
   ...
}

dictionary GPURenderBundleEncoderDescriptor : GPUObjectDescriptorBase {
    required sequence<GPUTextureFormat> colorFormats;
    GPUTextureFormat depthStencilFormat;
    //与MSAA有关，这里不分析
    unsigned long sampleCount = 1;
};

...

interface GPUCommandEncoder {
    ...
    GPURenderPassEncoder beginRenderPass(GPURenderPassDescriptor descriptor);
    ...
}

...

dictionary GPURenderPassDescriptor : GPUObjectDescriptorBase {
    required sequence<GPURenderPassColorAttachmentDescriptor> colorAttachments;
    GPURenderPassDepthStencilAttachmentDescriptor depthStencilAttachment;
};
```

创建bundle时，需要指定与所属render pass相同的color attachments和depthAndStencil attachment的format。

## 参考资料
[Encoder results reuse](https://github.com/gpuweb/gpuweb/issues/286)
[Add GPURenderBundle](https://github.com/gpuweb/gpuweb/pull/301)
[How do people reuse command buffers?（要翻墙）](https://www.reddit.com/r/vulkan/comments/8orhcp/how_do_people_reuse_command_buffers/)



# 学习优化：dynamic uniform buffer offset

## 提出问题

在大多数应用中，每个drawcall需要不同的uniform变量，对应不同的uniform buffer。而uniform buffer被设置在bind group中，这意味着需要在每一帧中为每个drawcall创建并设置一个bind group（或者只创建一次所有的bind group作为cache，然后在每一帧中复用它）。

创建bind group比drawcall的开销更大。通过[在“Proposal: Dynamic uniform and storage buffer offsets”中进行的性能测试](https://github.com/gpuweb/gpuweb/issues/116#issuecomment-449245367)，我们知道现代图形API创建bind group的个数是有限的（而WebGPU是基于现代图形API而实现的，因此它在WebGPU中也是有限的）：
> This means, in a single frame, the Metal devices can create 285 bind groups, the D3D12 devices can create 7270 bind groups, and the Vulkan devices can create 18561 bind groups.


## 优化方案

WebGPU支持“dynamic uniform buffer offset”，也就是说：
可以只创建一个bind group，但是它只能设置一个或多个uniform buffer（不能设置storage buffer等数据）；
每个drawcall用对应的offset来设置同一个bind group。

这样就去掉了创建多个bind group的开销。


根据[Proposal: Dynamic uniform and storage buffer offsets](https://github.com/gpuweb/gpuweb/issues/116#issuecomment-444948727)：
> I believe we said:
We need at least one of the two for the MVP
Having both causes more complication because they will fight for root table space so we might have to introduce a combined limit for pushConstantSize + N * DynamicBufferCount.

WebGPU的MVP版本应该不会支持dynamic storage buffer offset，也就是说bind group不能设置storage buffer。



## 案例代码

对案例代码的说明：
1.bind group只设置一个uniform buffer，它包含的uniform变量为：
```ts
float scale;
float offsetX;
float offsetY;
float scalar;
float scalarOffset;
```
2.一共有100个gameObject，对应100个draw call和uniform变量的100份数据（设置在uniformBufferData中）
3.不同drawcall对应的bind group->uniform buffer的offset需要为256的倍数


这里给出原始的案例代码和优化后的案例代码，供读者参考：

- 原始的案例代码：创建bind group cache
代码如下：
```ts
const bindGroupLayout = device.createBindGroupLayout({
    bindings: [
        { binding: 0, visibility: GPUShaderStage.VERTEX, type: "uniform-buffer" },
    ],
});


const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });


const pipeline = device.createRenderPipeline({
    layout: pipelineLayout,
    ...
});



const gameObjects = 100;
const uniformBytes = 5 * Float32Array.BYTES_PER_ELEMENT;
const alignedUniformBytes = Math.ceil(uniformBytes / 256) * 256;
const alignedUniformFloats = alignedUniformBytes / Float32Array.BYTES_PER_ELEMENT;

const uniformBuffer = device.createBuffer({
    size: gameObjects * alignedUniformBytes + Float32Array.BYTES_PER_ELEMENT,
    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM
});


const uniformBufferData = new Float32Array(gameObjects * alignedUniformFloats);

//bind group的cache数组
const bindGroups = new Array(gameObjects);

function setUniformBufferData(i) {
    uniformBufferData[alignedUniformFloats * i + 0] = Math.random() * 0.2 + 0.2;        // scale
    uniformBufferData[alignedUniformFloats * i + 1] = 0.9 * 2 * (Math.random() - 0.5);  // offsetX
    uniformBufferData[alignedUniformFloats * i + 2] = 0.9 * 2 * (Math.random() - 0.5);  // offsetY
    uniformBufferData[alignedUniformFloats * i + 3] = Math.random() * 1.5 + 0.5;       // scalar
    uniformBufferData[alignedUniformFloats * i + 4] = Math.random() * 10;               // scalarOffset
}

for (let i = 0; i < gameObjects; ++i) {
    setUniformBufferData(i);

    bindGroups[i] = device.createBindGroup({
        layout: bindGroupLayout,
        bindings: [{
            binding: 0,
            resource: {
                buffer: uniformBuffer,
                offset: i * alignedUniformBytes,
                size: 5 * Float32Array.BYTES_PER_ELEMENT,
            }
        }]
    });
}

uniformBuffer.setSubData(0, uniformBufferData);


return function frame() {
    ...
    const commandEncoder = device.createCommandEncoder();
    ...
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    passEncoder.setPipeline(pipeline);
    passEncoder.setVertexBuffer(0, verticesBuffer);

    for (let i = 0; i < gameObjects; ++i) {
        passEncoder.setBindGroup(0, bindGroups[i]);
        passEncoder.draw(3, 1, 0, 0);
    }

    passEncoder.endPass();
    ...
}
```

- 优化后的案例代码：使用offset
代码如下：
```ts
//设置hasDynamicOffset为true
const dynamicBindGroupLayout = device.createBindGroupLayout({
    bindings: [
        { binding: 0, visibility: GPUShaderStage.VERTEX, type: "uniform-buffer", hasDynamicOffset: true },
    ],
});

const dynamicBindGroup = device.createBindGroup({
    layout: dynamicBindGroupLayout,
    bindings: [{
        binding: 0,
        resource: {
            buffer: uniformBuffer,
            offset: 0,
            size: 5 * Float32Array.BYTES_PER_ELEMENT,
        },
    }],
});


const dynamicPipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [dynamicBindGroupLayout] });

const dynamicPipeline = device.createRenderPipeline({
    layout: dynamicPipelineLayout,
    ...
});

//定义gameObjects等代码与原始的案例代码相同，故省略
...

for (let i = 0; i < gameObjects; ++i) {
    //setUniformBufferData函数与原始的案例代码相同
    setUniformBufferData(i);
}

const dynamicBindGroup = device.createBindGroup({
    layout: dynamicBindGroupLayout,
    bindings: [{
        binding: 0,
        resource: {
            buffer: uniformBuffer,
            offset: 0,
            size: 5 * Float32Array.BYTES_PER_ELEMENT,
        },
    }],
});

uniformBuffer.setSubData(0, uniformBufferData);

const dynamicOffsets = [0];

return function frame() {
    ...
    const commandEncoder = device.createCommandEncoder();
    ...
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    passEncoder.setPipeline(pipeline);
    passEncoder.setVertexBuffer(0, verticesBuffer);


    for (let i = 0; i < gameObjects; ++i) {
        //之所以要预先创建dynamicOffsets数组，然后在这里设置它的元素，而不直接用“passEncoder.setBindGroup(0, dynamicBindGroup, [i * alignedUniformBytes]);”，是因为这样会增加“创建数组”的开销
        dynamicOffsets[0] = i * alignedUniformBytes;
        passEncoder.setBindGroup(0, dynamicBindGroup, dynamicOffsets);
        passEncoder.draw(3, 1, 0, 0);
    }

    passEncoder.endPass();
    ...
}
```




## 参考资料
[Proposal: Dynamic uniform and storage buffer offsets](https://github.com/gpuweb/gpuweb/issues/116)


# 性能测试

[animometer示例](https://github.com/yyc-git/webgpu-samples/blob/master/src/examples/animometer.ts)对这两个优化进行了benchmark测试。

（需要说明的是，该示例的“size: 6 * Float32Array.BYTES_PER_ELEMENT”应该被改为“size: 5 * Float32Array.BYTES_PER_ELEMENT”）

该示例的运行截图如下所示：
![截屏2019-12-28下午5.36.41.png-801.2kB][1]

在右侧的红圈内选中按钮可启用对应的优化；
右上角的紫圈可设置绘制的三角形个数；
在左上角的蓝圈内，第一行显示每一帧在CPU端所用时间，主要包括render pass的js binding所用的时间；第二行显示每一帧总时间，它等于CPU端+GPU端的所用时间。

## 测试数据

在我的电脑（Mac Pro 2014，MacOS Catalina10.15.1，Chrome Canary 80.0.3977.4）上绘制4万个三角形的测试结果：

- 只使用bundle与没用任何优化相比

大幅降低了js binding所用时间，由14ms变为0.2ms；
每一帧总时间只降低了20%。



- 同时使用bundle与offset与只使用bundle相比

js binding所用时间和每一帧总时间几乎没有变化


- 只使用offset与没用任何优化相比


js binding所用时间大幅增加了60%；
每一帧总时间只稍微增加了10%。



## 结论
使用offset优化，虽然增加了CPU端开销，但也降低了GPU端开销，从而使每一帧总时间增加得很少。而且它使代码更为简洁（只创建一个bind group），可能也减少了内存占用（我没有进行测试，仅为推测），所以推荐使用。


使用bundle优化，虽然大幅降低了CPU端开销，但也增加了GPU端开销。不过考虑到每一帧总时间还是降低了20%，而且有被浏览器进一步优化的空间（参考[Encoder results reuse](https://github.com/gpuweb/gpuweb/issues/286#issuecomment-492481518)），所以推荐使用。



## 参考资料
[animometer示例](https://github.com/yyc-git/webgpu-samples/blob/master/src/examples/animometer.ts)


  [1]: http://static.zybuluo.com/yangyc/v10eadt6dya6m8dacf10tohh/%E6%88%AA%E5%B1%8F2019-12-28%E4%B8%8B%E5%8D%885.36.41.png]]></description></item><item><title>WebGPU学习（十）：介绍“GPU实现粒子效果”</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/26/12101154.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Thu, 26 Dec 2019 03:32:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/26/12101154.html</guid><description><![CDATA[大家好，本文介绍了“GPU实现粒子效果”的基本思想，并推荐了相应的学习资料。

本文学习webgpu-samplers->[computeBoids示例](https://github.com/yyc-git/webgpu-samples/blob/master/src/examples/computeBoids.ts)，它展示了如何用compute shader实现粒子效果，模拟鸟群的行为。



上一篇博文：
[WebGPU学习（九）：学习“fractalCube”示例](https://www.cnblogs.com/chaogex/p/12097129.html)

下一篇博文：
[WebGPU学习（十一）：学习两个优化：“reuse render command buffer”和“dynamic uniform buffer offset”](https://www.cnblogs.com/chaogex/p/12112704.html)

最终渲染结果：
![截屏2019-12-26上午9.38.33.png-26.9kB][1]




# 为什么不在CPU端实现粒子效果？
虽然在CPU端实现会更灵活和可控，但如果粒子数量很大（如上百万），且与场景有交互，则最好在GPU端实现。


# 示例的实现思想

## 首先执行compute pass

代码如下：
```ts
  return function frame() {
    ...

    const commandEncoder = device.createCommandEncoder({});
    {
      const passEncoder = commandEncoder.beginComputePass();
      passEncoder.setPipeline(computePipeline);
      passEncoder.setBindGroup(0, particleBindGroups[t % 2]);
      passEncoder.dispatch(numParticles);
      passEncoder.endPass();
    }
    ...
  }
```

我们对这个pass进行分析：

### bind group包含两个storage buffer：ParticlesA和ParticlesB


ParticlesA存储了上一帧所有粒子的数据。compute shader读取它，并计算出下一帧所有粒子的数据，写到ParticlesB中，打了一个ping-pong操作；

注：storage buffer在shader中可被读和写，而uniform buffer、vertex buffer等在shader中只能被读

### dispatch到1500个instance，每个instance执行一次compute shader

compute shader计算每个粒子的数据时，需要遍历其它的所有粒子，从而实现相互的交互作用，模拟鸟群行为。
一共有1500个粒子，共需要计算1500*1500次。如果在CPU端执行，太花时间；而在GPU端执行，则每个instance只需要计算1500次，大大提高了效率。 

## 然后执行render pass


代码如下：
```ts
  const renderPipeline = device.createRenderPipeline({
    ...
    vertexState: {
      vertexBuffers: [{
        // instanced particles buffer
        arrayStride: 4 * 4,
        stepMode: "instance",
        attributes: [{
          // instance position
          shaderLocation: 0,
          offset: 0,
          format: "float2"
        }, {
          // instance velocity
          shaderLocation: 1,
          offset: 2 * 4,
          format: "float2"
        }],
      }, {
        // vertex buffer
        arrayStride: 2 * 4,
        stepMode: "vertex",
        attributes: [{
          // vertex positions
          shaderLocation: 2,
          offset: 0,
          format: "float2"
        }],
      }],
    },
    ...
  });
  
  ...

  const vertexBufferData = new Float32Array([-0.01, -0.02, 0.01, -0.02, 0.00, 0.02]);
  const verticesBuffer = device.createBuffer({
    size: vertexBufferData.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });
  verticesBuffer.setSubData(0, vertexBufferData);
  
  ...

  return function frame() {
    ...

    const commandEncoder = device.createCommandEncoder({});
    ...
    {
      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setPipeline(renderPipeline);
      passEncoder.setVertexBuffer(0, particleBuffers[(t + 1) % 2]);
      passEncoder.setVertexBuffer(1, verticesBuffer);
      passEncoder.draw(3, numParticles, 0, 0);
      passEncoder.endPass();
    }
    ...
  }
```


有两个vertex buffer：
ParticlesB使用“instance”的stepMode，被设置到第一个vertex buffer中；
vertices buffer（包含3个顶点数据，每个顶点数据包含x坐标和y坐标）使用“vertex”的stepMode，被设置到第二个vertex buffer中。


draw一次，绘制1500个实例（使用ParticlesB的数据），3个顶点（使用vertices buffer的数据）。


注：每个粒子作为一个实例，由包含3个顶点的三角形组成。



# 推荐学习资料

大家可以参考[WebGPU-8](https://blog.csdn.net/caxieyou/article/details/96451952)，来学习示例的具体的代码。

虽然该文对应的示例代码的版本比较老（如它的示例中是1000个粒子，而不是1500个粒子），但与本文对应的最新版本基本上相同，而且它对示例代码分析得比较详细，所以推荐大家学习。


另外，大家可以通过[Get started with GPU Compute on the Web](https://developers.google.com/web/updates/2019/08/get-started-with-gpu-compute-on-the-web)，学习如何使用compute shader计算矩阵运算。






# 参考资料
[WebGPU-8](https://blog.csdn.net/caxieyou/article/details/96451952)
[webgpu-samplers Github Repo](https://github.com/yyc-git/webgpu-samples)


  [1]: http://static.zybuluo.com/yangyc/5i6wd1wv63sxlvepr1be14j5/%E6%88%AA%E5%B1%8F2019-12-26%E4%B8%8A%E5%8D%889.38.33.png]]></description></item><item><title>WebGPU学习（九）：学习“fractalCube”示例</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/25/12097129.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Wed, 25 Dec 2019 07:52:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/25/12097129.html</guid><description><![CDATA[大家好，本文学习Chrome->webgpu-samplers->fractalCube示例。



上一篇博文：
[WebGPU学习（八）：学习“texturedCube”示例](https://www.cnblogs.com/chaogex/p/12091529.html)

下一篇博文：
[WebGPU学习（十）：介绍“GPU实现粒子效果”](https://www.cnblogs.com/chaogex/p/12101154.html)


# 学习fractalCube.ts

最终渲染结果：
![截屏2019-12-25上午8.14.22.png-107.3kB][1]


该示例展示了如何用上一帧渲染的结果作为下一帧的纹理。



与[“texturedCube”示例](https://www.cnblogs.com/chaogex/p/12091529.html)相比，该示例的纹理并不是来自图片，而是来自上一帧渲染的结果


下面，我们打开[fractalCube.ts](https://github.com/yyc-git/webgpu-samples/blob/master/src/examples/fractalCube.ts)文件，分析相关代码：





## 传输顶点的color


它与“texturedCube”示例->“传递顶点的uv数据”类似，这里不再分析




## 上一帧渲染的结果作为下一帧的纹理

- 配置swapChain

因为swapChain保存了上一帧渲染的结果，所以将其作为下一帧纹理的source，它的usage需要增加GPUTextureUsage.COPY_SRC：
```ts
  const swapChain = context.configureSwapChain({
    device,
    format: "bgra8unorm",
    usage: GPUTextureUsage.OUTPUT_ATTACHMENT | GPUTextureUsage.COPY_SRC,
  });
```


- 创建空纹理和sampler，设置到uniform bind group中

代码如下：
```ts
  const cubeTexture = device.createTexture({
    size: { width: canvas.width, height: canvas.height, depth: 1 },
    format: "bgra8unorm",
    usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.SAMPLED,
  });

  const sampler = device.createSampler({
    magFilter: "linear",
    minFilter: "linear",
  });

  const uniformBindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    bindings: [
    ...
    {
      binding: 1,
      resource: sampler,
    }, {
      binding: 2,
      resource: cubeTexture.createView(),
    }],
  });
```

- 绘制和拷贝

在每一帧中：
绘制带纹理的立方体；
将渲染结果拷贝到纹理中。

相关代码如下：
```ts
  return function frame() {
    const swapChainTexture = swapChain.getCurrentTexture();
                   
    renderPassDescriptor.colorAttachments[0].attachment = swapChainTexture.createView();
    
    const commandEncoder = device.createCommandEncoder({});
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    ...
    passEncoder.setBindGroup(0, uniformBindGroup); 
    ...
    passEncoder.draw(36, 1, 0, 0);
    passEncoder.endPass();

    commandEncoder.copyTextureToTexture({
      texture: swapChainTexture,
    }, {
      texture: cubeTexture,
    }, {
      width: canvas.width,
      height: canvas.height,
      depth: 1,
    });
    
    device.defaultQueue.submit([commandEncoder.finish()]); 
   
    ...

  }
```

## 分析shader代码

vertex shader与“texturedCube”示例相比，增加了color attribute：
```ts
  const vertexShaderGLSL = `#version 450
  ...
  layout(location = 1) in vec4 color;
  ...

  layout(location = 0) out vec4 fragColor;
  ...

  void main() {
    ...
    fragColor = color;
    ...
  }`;
```


fragment shader的代码如下：
```ts
  const fragmentShaderGLSL = `#version 450
  layout(set = 0, binding = 1) uniform sampler mySampler;
  layout(set = 0, binding = 2) uniform texture2D myTexture;

  layout(location = 0) in vec4 fragColor;
  layout(location = 1) in vec2 fragUV;
  layout(location = 0) out vec4 outColor;

  void main() {
    vec4 texColor = texture(sampler2D(myTexture, mySampler), fragUV * 0.8 + 0.1);

    // 1.0 if we're sampling the background
    float f = float(length(texColor.rgb - vec3(0.5, 0.5, 0.5)) < 0.01);

    outColor = mix(texColor, fragColor, f);
  }`;
```

第10行对fragUV进行了处理，我们会在[分析渲染时间线](#分析渲染时间线)中分析它。

第13行和第15行相当于做了if判断：
```ts
if(纹理颜色 === 背景色){
    outColor = fragColor
}
else{
    outColor = 纹理颜色
}
```

这里之所以不用if判断而使用计算的方式，是为了减少条件判断，提高gpu的并行性

## 分析渲染时间线

下面分析下渲染的时间线：




### 第一帧
因为纹理为空纹理，它的颜色为背景色，所以fragment shader的outColor始终为fragColor，因此立方体的所有片段的颜色均为fragColor。


第一帧的渲染结果如下：
![截屏2019-12-25下午12.23.39.png-116.5kB][2]

第一帧绘制结束后，渲染结果会被拷贝到纹理中。


### 第二帧


分析执行的fragment shader代码：
```ts
  const fragmentShaderGLSL = `#version 450
  layout(set = 0, binding = 1) uniform sampler mySampler;
  layout(set = 0, binding = 2) uniform texture2D myTexture;

  layout(location = 0) in vec4 fragColor;
  layout(location = 1) in vec2 fragUV;
  layout(location = 0) out vec4 outColor;

  void main() {
    vec4 texColor = texture(sampler2D(myTexture, mySampler), fragUV * 0.8 + 0.1);

    // 1.0 if we're sampling the background
    float f = float(length(texColor.rgb - vec3(0.5, 0.5, 0.5)) < 0.01);

    outColor = mix(texColor, fragColor, f);
  }`;
```


- 第10行的“fragUV * 0.8 + 0.1”是为了取纹理坐标u、v方向的[0.1-0.9]部分，从而使纹理中立方体所占比例更大。

得到的纹理区域如下图的红色区域所示：
![截屏2019-12-25下午12.23.39.png-117kB][4]


- 第13行和第15行代码，将纹理中的背景色替换为了fragColor，使纹理中立方体区域的颜色保持不变


第二帧的渲染结果如下：
![截屏2019-12-25下午12.24.49.png-141.1kB][3]






- 第三帧

依次类推，第三帧的渲染结果如下：
![截屏2019-12-25下午12.47.45.png-157.2kB][5]





# 参考资料
[WebGPU规范](https://gpuweb.github.io/gpuweb/)
[webgpu-samplers Github Repo](https://github.com/yyc-git/webgpu-samples)
[WebGPU-7](https://blog.csdn.net/caxieyou/article/details/94995831)


  [1]: http://static.zybuluo.com/yangyc/u3ps3lqscb3dv4i3s5k3oqgv/%E6%88%AA%E5%B1%8F2019-12-25%E4%B8%8A%E5%8D%888.14.22.png
  [2]: http://static.zybuluo.com/yangyc/o9ytllxowsluxjwbslch3d1q/%E6%88%AA%E5%B1%8F2019-12-25%E4%B8%8B%E5%8D%8812.23.39.png
  [3]: http://static.zybuluo.com/yangyc/xtlfidfpp56465zkplz2l9im/%E6%88%AA%E5%B1%8F2019-12-25%E4%B8%8B%E5%8D%8812.24.49.png
  [4]: http://static.zybuluo.com/yangyc/5oonhn95jflaogybxlq5cp2e/%E6%88%AA%E5%B1%8F2019-12-25%E4%B8%8B%E5%8D%8812.23.39.png
  [5]: http://static.zybuluo.com/yangyc/9b4debqj5142n6ci31ztjxld/%E6%88%AA%E5%B1%8F2019-12-25%E4%B8%8B%E5%8D%8812.47.45.png]]></description></item><item><title>WebGPU学习（八）：学习“texturedCube”示例</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/24/12091529.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Tue, 24 Dec 2019 06:57:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/24/12091529.html</guid><description><![CDATA[大家好，本文学习Chrome->webgpu-samplers->texturedCube示例。


上一篇博文：
[WebGPU学习（七）：学习“twoCubes”和“instancedCube”示例](https://www.cnblogs.com/chaogex/p/12081022.html)

下一篇博文：
[WebGPU学习（九）：学习“fractalCube”示例](https://www.cnblogs.com/chaogex/p/12097129.html)

# 学习texturedCube.ts

最终渲染结果：
![截屏2019-12-23上午8.11.40.png-117.2kB][1]


该示例绘制了有一个纹理的立方体。



与“rotatingCube”示例相比，该示例增加了下面的步骤：

- 传输顶点的uv数据
- 增加了sampler和sampled-texture类型的uniform数据


下面，我们打开[texturedCube.ts](https://github.com/yyc-git/webgpu-samples/blob/master/src/examples/texturedCube.ts)文件，依次分析增加的步骤：


## 传递顶点的uv数据

- shader加入uv attribute

代码如下：
```ts
  const vertexShaderGLSL = `#version 450
  ...
  layout(location = 0) in vec4 position;
  layout(location = 1) in vec2 uv;

  layout(location = 0) out vec2 fragUV;
  layout(location = 1) out vec4 fragPosition;

  void main() {
    fragPosition = 0.5 * (position + vec4(1.0));
    ...
    fragUV = uv;
  }
  `;
  
  const fragmentShaderGLSL = `#version 450
  layout(set = 0, binding = 1) uniform sampler mySampler;
  layout(set = 0, binding = 2) uniform texture2D myTexture;

  layout(location = 0) in vec2 fragUV;
  layout(location = 1) in vec4 fragPosition;
  layout(location = 0) out vec4 outColor;

  void main() {
    outColor =  texture(sampler2D(myTexture, mySampler), fragUV) * fragPosition;
  }
  `;
```

vertex shader传入了uv attribute数据，并将其传递给fragUV，从而传到fragment shader，作为纹理采样坐标

另外，这里可以顺便说明下：fragPosition用来实现与position相关的颜色渐变效果




- uv数据包含在verticesBuffer的cubeVertexArray中

cubeVertexArray的代码如下：

```ts
cube.ts:
export const cubeUVOffset = 4 * 8;
export const cubeVertexArray = new Float32Array([
    // float4 position, float4 color, float2 uv,
    1, -1, 1, 1,   1, 0, 1, 1,  1, 1,
    -1, -1, 1, 1,  0, 0, 1, 1,  0, 1,
    -1, -1, -1, 1, 0, 0, 0, 1,  0, 0,
    1, -1, -1, 1,  1, 0, 0, 1,  1, 0,
    1, -1, 1, 1,   1, 0, 1, 1,  1, 1,
    -1, -1, -1, 1, 0, 0, 0, 1,  0, 0,

    ...
]);
```

创建和设置verticesBuffer的相关代码如下：

```ts
texturedCube.ts:
  const verticesBuffer = device.createBuffer({
    size: cubeVertexArray.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
  });
  verticesBuffer.setSubData(0, cubeVertexArray);
  
  ...
  
  return function frame() {
    ...
    passEncoder.setVertexBuffer(0, verticesBuffer);
    ...
  } 
```



- 创建render pipeline时指定uv attribute的相关数据

代码如下：

```ts
  const pipeline = device.createRenderPipeline({
    ...
    vertexState: {
      vertexBuffers: [{
        ...
        attributes: [
        ...
        {
          // uv
          shaderLocation: 1,
          offset: cubeUVOffset,
          format: "float2"
        }]
      }],
    },
    ...
  });    
```


## 增加了sampler和sampled-texture类型的uniform数据

WebGPU相对于WebGL1，提出了sampler，可以对它设置filter、wrap等参数，从而实现了texture和sampler自由组合，同一个texture能够以不同filter、wrap来采样


- fragment shader传入这两个uniform数据，用于纹理采样

代码如下：

```ts
  const fragmentShaderGLSL = `#version 450
  layout(set = 0, binding = 1) uniform sampler mySampler;
  layout(set = 0, binding = 2) uniform texture2D myTexture;

  layout(location = 0) in vec2 fragUV;
  layout(location = 1) in vec4 fragPosition;
  layout(location = 0) out vec4 outColor;

  void main() {
    outColor =  texture(sampler2D(myTexture, mySampler), fragUV) * fragPosition;
  }
  `;
```


- 创建bind group layout时指定它们在shader中的binding位置等参数

代码如下：

```ts
  const bindGroupLayout = device.createBindGroupLayout({
    bindings: [
    ...
    {
      // Sampler
      binding: 1,
      visibility: GPUShaderStage.FRAGMENT,
      type: "sampler"
    }, {
      // Texture view
      binding: 2,
      visibility: GPUShaderStage.FRAGMENT,
      type: "sampled-texture"
    }]
  });
```



- 拷贝图片到texture，返回texture
 
代码如下，后面会进一步研究：

```ts
  const cubeTexture = await createTextureFromImage(device, 'assets/img/Di-3d.png', GPUTextureUsage.SAMPLED);
```

- 创建sampler，指定filter

代码如下：
```ts
  const sampler = device.createSampler({
    magFilter: "linear",
    minFilter: "linear",
  });
  
```

我们看一下相关定义：

```ts
GPUSampler createSampler(optional GPUSamplerDescriptor descriptor = {});

...

dictionary GPUSamplerDescriptor : GPUObjectDescriptorBase {
    GPUAddressMode addressModeU = "clamp-to-edge";
    GPUAddressMode addressModeV = "clamp-to-edge";
    GPUAddressMode addressModeW = "clamp-to-edge";
    GPUFilterMode magFilter = "nearest";
    GPUFilterMode minFilter = "nearest";
    GPUFilterMode mipmapFilter = "nearest";
    float lodMinClamp = 0;
    float lodMaxClamp = 0xffffffff;
    GPUCompareFunction compare = "never";
};
```

GPUSamplerDescriptor的addressMode指定了texture在u、v、w方向的wrap mode（u、v方向的wrap相当于WebGL1的wrapS、wrapT）（w方向是给3d texture用的）

mipmapFilter与mipmap有关，lodXXX与texture lod有关，compare与软阴影的Percentage Closer Filtering技术有关，我们不讨论它们



 - 创建uniform bind group时传入sampler和texture的view

```ts
  const uniformBindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    bindings: [
    ...
    {
      binding: 1,
      resource: sampler,
    }, {
      binding: 2,
      resource: cubeTexture.createView(),
    }],
  });
```

### 参考资料
[Sampler Object](https://www.khronos.org/opengl/wiki/Sampler_Object)




## 详细分析“拷贝图片到texture”步骤


相关代码如下：
```ts
  const cubeTexture = await createTextureFromImage(device, 'assets/img/Di-3d.png', GPUTextureUsage.SAMPLED);
```

该步骤可以分解为两步：
1.解码图片
2.拷贝解码后的类型为HTMLImageElement的图片到GPU的texture中

下面依次分析：

### 解码图片

打开[helper.ts](https://github.com/yyc-git/webgpu-samples/blob/master/src/helpers.ts)文件，查看createTextureFromImage对应代码：
```ts
  const img = document.createElement('img');
  img.src = src;
  await img.decode();
```

这里使用decode api来解码图片，也可以使用img.onload来实现：
```ts
  const img = document.createElement('img');
  img.src = src;
  img.onload = (img) => {
    ...
  };
```

根据[Pre-Loading and Pre-Decoding Images with Javascript for Better Performance](https://usefulangle.com/post/123/javascript-pre-load-decode-image)的说法，图片的加载过程有两个步骤：
1.从服务器加载图片
2.解码图片

第1步都是在其它线程上并行执行；
如果用onload，则浏览器会在主线程上同步执行第2步，会阻塞主线程；
如果用decode api，则浏览器会在其它线程上并行执行第2步，不会阻塞主线程。

chrome和firefox浏览器都支持decode api，因此加载图片应该优先使用该API：
![截屏2019-12-24下午2.31.34.png-85.3kB][2]

#### 参考资料
[Pre-Loading and Pre-Decoding Images with Javascript for Better Performance](https://usefulangle.com/post/123/javascript-pre-load-decode-image)
[Chrome 图片解码与 Image.decode API](https://zhuanlan.zhihu.com/p/43991630)



### 拷贝图片

WebGL1直接使用texImage2D将图片上传到GPU texture中，而WebGPU能让我们更加灵活地控制上传过程。

WebGPU有两种方法上传：

- 创建图片对应的imageBitmap，将其拷贝到GPU texture中

该方法要用到copyImageBitmapToTexture函数。虽然WebGPU规范已经定义了该函数，但目前Chrome Canary不支持它，所以暂时不能用该方法上传。

**参考资料**
[Proposal for copyImageBitmapToTexture](https://github.com/gpuweb/gpuweb/pull/266)
[ImageBitmapToTexture design](https://github.com/gpuweb/gpuweb/blob/master/design/ImageBitmapToTexture.md)

- 将图片绘制到canvas中，通过getImageData获得数据->将其设置到buffer中->把buffer数据拷贝到GPU texture中

我们来看下createTextureFromImage对应代码：
```ts
  const imageCanvas = document.createElement('canvas');
  imageCanvas.width = img.width;
  imageCanvas.height = img.height;

  const imageCanvasContext = imageCanvas.getContext('2d');
  
  //flipY
  imageCanvasContext.translate(0, img.height);
  imageCanvasContext.scale(1, -1);
  
  imageCanvasContext.drawImage(img, 0, 0, img.width, img.height);
  const imageData = imageCanvasContext.getImageData(0, 0, img.width, img.height);
```

这里创建canvas->绘制图片->获得图片数据。
（注：在绘制图片时将图片在Y方向反转了）

接着看代码：
```ts
  let data = null;

  const rowPitch = Math.ceil(img.width * 4 / 256) * 256;
  if (rowPitch == img.width * 4) {
    data = imageData.data;
  } else {
    data = new Uint8Array(rowPitch * img.height);
    for (let y = 0; y < img.height; ++y) {
      for (let x = 0; x < img.width; ++x) {
        let i = x * 4 + y * rowPitch;
        data[i] = imageData.data[i];
        data[i + 1] = imageData.data[i + 1];
        data[i + 2] = imageData.data[i + 2];
        data[i + 3] = imageData.data[i + 3];
      }
    }
  }

  const texture = device.createTexture({
    size: {
      width: img.width,
      height: img.height,
      depth: 1,
    },
    format: "rgba8unorm",
    usage: GPUTextureUsage.COPY_DST | usage,
  });

  const textureDataBuffer = device.createBuffer({
    size: data.byteLength,
    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
  });

  textureDataBuffer.setSubData(0, data);
``` 

rowPitch需要为256的倍数（也就是说，图片的宽度需要为64px的倍数），这是因为Dx12对此做了限制（参考[Copies investigation](https://github.com/gpuweb/gpuweb/issues/69)）：
> RowPitch must be aligned to D3D12_TEXTURE_DATA_PITCH_ALIGNMENT.
Offset must be aligned to D3D12_TEXTURE_DATA_PLACEMENT_ALIGNMENT, which is 512.

另外，关于纹理尺寸，可以参考[WebGPU-6](https://blog.csdn.net/caxieyou/article/details/94987754)：
> 第一个问题是关于纹理尺寸的，回答是WebGPU没有对尺寸有特别明确的要求。sample code中最多不能比4kor8k大就行。这个也不是太难理解，OpenGL对纹理和FBO的尺寸总是有上限的。


根据我的测试，buffer（代码中的textureDataBuffer）中的图片数据需要为未压缩的图片数据（它的类型为Uint8Array，length=img.width * img.height * 4（因为每个像素有r、g、b、a这4个值）），否则会报错（在我的测试中，“通过canvas->toDataURL得到图片的base64->将其转为Uint8Array，得到压缩后的图片数据->将其设置到buffer中”会报错）


继续看代码：
```ts
  const commandEncoder = device.createCommandEncoder({});
  commandEncoder.copyBufferToTexture({
    buffer: textureDataBuffer,
    rowPitch: rowPitch,
    imageHeight: 0,
  }, {
    texture: texture,
  }, {
    width: img.width,
    height: img.height,
    depth: 1,
  });

  device.defaultQueue.submit([commandEncoder.finish()]);

  return texture;
```
这里提交了copyBufferToTexture这个command到GPU，并返回texture
（注：这个command此时并没有执行，会由GPU决定什么时候执行）

WebGPU支持buffer与buffer、buffer与texture、texture与texture之间互相拷贝。


**参考资料**
[3 channel formats](https://github.com/gpuweb/gpuweb/issues/66)
[Copies investigation (+ proposals)](https://github.com/gpuweb/gpuweb/issues/69)


# 参考资料
[WebGPU规范](https://gpuweb.github.io/gpuweb/)
[webgpu-samplers Github Repo](https://github.com/yyc-git/webgpu-samples)
[WebGPU-6](https://blog.csdn.net/caxieyou/article/details/94987754)


  [1]: http://static.zybuluo.com/yangyc/9r24sg9rl3tydj6h2wxbwtso/%E6%88%AA%E5%B1%8F2019-12-23%E4%B8%8A%E5%8D%888.11.40.png
  [2]: http://static.zybuluo.com/yangyc/3r89lnqm2bmcjte6sngr81mo/%E6%88%AA%E5%B1%8F2019-12-24%E4%B8%8B%E5%8D%882.31.34.png]]></description></item><item><title>WebGPU学习（七）：学习“twoCubes”和“instancedCube”示例</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/22/12081022.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sun, 22 Dec 2019 12:52:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/22/12081022.html</guid><description><![CDATA[大家好，本文学习Chrome->webgpu-samplers->twoCubes和instancedCube示例。

这两个示例都与[“rotatingCube”示例](https://www.cnblogs.com/chaogex/p/12079739.html)差不多。建议大家先学习该示例，再学习本文的两个示例

上一篇博文：
[WebGPU学习（六）：学习“rotatingCube”示例](https://www.cnblogs.com/chaogex/p/12079739.html)

下一篇博文：
[WebGPU学习（八）：学习“texturedCube”示例](https://www.cnblogs.com/chaogex/p/12091529.html)

# 学习twoCubes.ts
该示例绘制了两个立方体。

与“rotatingCube”示例相比，该示例增加了以下的内容：

- 一个ubo保存两个立方体的mvp矩阵
- 每帧更新两个mvp矩阵数据
- draw两次，分别设置对应的uniformBindGroup


下面，我们打开[twoCubes.ts](https://github.com/yyc-git/webgpu-samples/blob/master/src/examples/twoCubes.ts)文件，依次来看下新增内容：

## 一个ubo保存两个立方体的mvp矩阵
- vertex shader定义uniform block

因为只有一个ubo，所以只有一个uniform block，代码与rotatingCube示例相同：
```ts
  const vertexShaderGLSL = `#version 450
  layout(set = 0, binding = 0) uniform Uniforms {
    mat4 modelViewProjectionMatrix;
  } uniforms;
  ...
  void main() {
    gl_Position = uniforms.modelViewProjectionMatrix * position;
    ...
  }
  `;
```



- 创建uniform buffer

代码如下：
```ts
  const matrixSize = 4 * 16; // BYTES_PER_ELEMENT(4) * matrix length(4 * 4 = 16)
  const offset = 256; // uniformBindGroup offset must be 256-byte aligned
  const uniformBufferSize = offset + matrixSize;

  const uniformBuffer = device.createBuffer({
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
```

uniform buffer要保存两个mvp矩阵的数据，但是它们不能连续存放，它们的起始位置必须为256的倍数，所以uniform buffer实际的内存布局为：
0-63:第一个mvp矩阵
64-255:0（占位）
256-319:第二个mvp矩阵

uniform buffer的size为256+64=320

- 创建uniform bind group

创建两个uniform bind group，通过指定offset和size，对应到同一个uniform buffer：
```ts
  const uniformBindGroup1 = device.createBindGroup({
    layout: uniformsBindGroupLayout,
    bindings: [{
      binding: 0,
      resource: {
        buffer: uniformBuffer,
        offset: 0,
        size: matrixSize
      }
    }],
  });

  const uniformBindGroup2 = device.createBindGroup({
    layout: uniformsBindGroupLayout,
    bindings: [{
      binding: 0,
      resource: {
        buffer: uniformBuffer,
        offset: offset,
        size: matrixSize
      }
    }]
  });
```

- 创建2个mvp矩阵

代码如下：
```ts
  //因为是固定相机，所以只需要计算一次projection矩阵
  const aspect = Math.abs(canvas.width / canvas.height);
  let projectionMatrix = mat4.create();
  mat4.perspective(projectionMatrix, (2 * Math.PI) / 5, aspect, 1, 100.0);
  ...
  
  let modelMatrix1 = mat4.create();
  mat4.translate(modelMatrix1, modelMatrix1, vec3.fromValues(-2, 0, 0));
  let modelMatrix2 = mat4.create();
  mat4.translate(modelMatrix2, modelMatrix2, vec3.fromValues(2, 0, 0));
  //创建两个mvp矩阵
  let modelViewProjectionMatrix1 = mat4.create();
  let modelViewProjectionMatrix2 = mat4.create();
  //因为是固定相机，所以只需要计算一次view矩阵
  let viewMatrix = mat4.create();
  mat4.translate(viewMatrix, viewMatrix, vec3.fromValues(0, 0, -7));

  let tmpMat41 = mat4.create();
  let tmpMat42 = mat4.create();
```

## 每帧更新两个mvp矩阵数据

相关代码如下所示：
```ts
  function updateTransformationMatrix() {
    let now = Date.now() / 1000;

    mat4.rotate(tmpMat41, modelMatrix1, 1, vec3.fromValues(Math.sin(now), Math.cos(now), 0));
    mat4.rotate(tmpMat42, modelMatrix2, 1, vec3.fromValues(Math.cos(now), Math.sin(now), 0));

    mat4.multiply(modelViewProjectionMatrix1, viewMatrix, tmpMat41);
    mat4.multiply(modelViewProjectionMatrix1, projectionMatrix, modelViewProjectionMatrix1);
    mat4.multiply(modelViewProjectionMatrix2, viewMatrix, tmpMat42);
    mat4.multiply(modelViewProjectionMatrix2, projectionMatrix, modelViewProjectionMatrix2);
  }

  return function frame() {
    updateTransformationMatrix();

    ...

    uniformBuffer.setSubData(0, modelViewProjectionMatrix1);
    uniformBuffer.setSubData(offset, modelViewProjectionMatrix2);
    ...
  }
```

updateTransformationMatrix函数更新两个mvp矩阵；
调用两次setSubData，分别将更新后的mvp矩阵数据更新到同一个uniform buffer中。


## draw两次，分别设置对应的uniformBindGroup

代码如下：
```ts
  return function frame() {
    ...
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    ...

    passEncoder.setBindGroup(0, uniformBindGroup1);
    passEncoder.draw(36, 1, 0, 0);

    passEncoder.setBindGroup(0, uniformBindGroup2);
    passEncoder.draw(36, 1, 0, 0);

    passEncoder.endPass();

    ...
  }
```
第一次draw，绘制第一个cube，设置对应的uniformBindGroup1；
第二次draw，绘制第二个cube，设置对应的uniformBindGroup2。

## 最终渲染结果
![截屏2019-12-22下午4.18.16.png-55kB][1]

# 学习instancedCube.ts
该示例使用instance技术，通过一次draw，绘制了多个立方体实例。


与“rotatingCube”示例相比，该示例增加了以下的内容：

- 一个ubo保存所有立方体实例的mvp矩阵
- 每帧更新所有立方体实例的mvp矩阵数据
- 指定实例个数，draw一次


下面，我们打开[instancedCube.ts](https://github.com/yyc-git/webgpu-samples/blob/master/src/examples/instancedCube.ts)文件，依次来看下新增内容：

## 一个ubo保存所有立方体实例的mvp矩阵
- vertex shader定义uniform block

代码如下：
```ts
  const vertexShaderGLSL = `#version 450
  //总共16个实例
  #define MAX_NUM_INSTANCES 16
  layout(set = 0, binding = 0) uniform Uniforms {
    //ubo包含mvp矩阵数组，数组长度为16
    mat4 modelViewProjectionMatrix[MAX_NUM_INSTANCES];
  } uniforms;
  layout(location = 0) in vec4 position;
  layout(location = 1) in vec4 color;
  ...
  void main() {
    //使用gl_InstanceIndex取到当前实例的序号（0-15），通过它获取对应的mvp矩阵
    gl_Position = uniforms.modelViewProjectionMatrix[gl_InstanceIndex] * position;
    ...
  }`;
```

- 创建uniform buffer

代码如下：
```ts
  //16个立方体的排列顺序是x方向4个、y方向4个
  const xCount = 4;
  const yCount = 4;
  const numInstances = xCount * yCount;
  const matrixFloatCount = 16;
  // BYTES_PER_ELEMENT(4) * matrix length(4 * 4 = 16)
  const matrixSize = 4 * matrixFloatCount;
  const uniformBufferSize = numInstances * matrixSize;

  const uniformBuffer = device.createBuffer({
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
```

这里与twoCubes不同的是，不同实例的mvp矩阵的数据是连续存放的，所以uniform buffer的size为numInstances（16个）* matrixSize。


- 创建uniform bind group

只创建一个：
```ts
  const uniformBindGroup = device.createBindGroup({
    layout: uniformsBindGroupLayout,
    bindings: [{
      binding: 0,
      resource: {
        buffer: uniformBuffer,
      }
    }],
  });
```


- 准备mvp矩阵数据

代码如下：
```ts
  //因为是固定相机，所以只需要计算一次projection矩阵
  const aspect = Math.abs(canvas.width / canvas.height);
  let projectionMatrix = mat4.create();
  mat4.perspective(projectionMatrix, (2 * Math.PI) / 5, aspect, 1, 100.0);
  ...
  
  
  
  let modelMatrices = new Array(numInstances);
  //mvpMatricesData用来依次存放所有立方体实例的mvp矩阵数据
  let mvpMatricesData = new Float32Array(matrixFloatCount * numInstances);

  let step = 4.0;

  let m = 0;
  //准备modelMatrices数据
  for (let x = 0; x < xCount; x++) {
    for (let y = 0; y < yCount; y++) {
      modelMatrices[m] = mat4.create();
      mat4.translate(modelMatrices[m], modelMatrices[m], vec3.fromValues(
        step * (x - xCount / 2 + 0.5),
        step * (y - yCount / 2 + 0.5),
        0
      ));
      m++;
    }
  }

  //因为是固定相机，所以只需要计算一次view矩阵
  let viewMatrix = mat4.create();
  mat4.translate(viewMatrix, viewMatrix, vec3.fromValues(0, 0, -12));

  let tmpMat4 = mat4.create();
```


## 每帧更新所有立方体实例的mvp矩阵数据 

相关代码如下所示：
```ts
  function updateTransformationMatrix() {

    let now = Date.now() / 1000;

    let m = 0, i = 0;
    for (let x = 0; x < xCount; x++) {
      for (let y = 0; y < yCount; y++) {
        mat4.rotate(tmpMat4, modelMatrices[i], 1, vec3.fromValues(Math.sin((x + 0.5) * now), Math.cos((y + 0.5) * now), 0));

        mat4.multiply(tmpMat4, viewMatrix, tmpMat4);
        mat4.multiply(tmpMat4, projectionMatrix, tmpMat4);

        mvpMatricesData.set(tmpMat4, m);

        i++;
        m += matrixFloatCount;
      }
    }
  }

  return function frame() {
    updateTransformationMatrix();
    ...
    uniformBuffer.setSubData(0, mvpMatricesData);
    ...
  }
```

updateTransformationMatrix函数更新mvpMatricesData；
调用一次setSubData，将更新后的mvpMatricesData设置到uniform buffer中。


## 指定实例个数，draw一次

代码如下：
```ts
  return function frame() {
    ...
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    ...


    //设置对应的uniformBindGroup
    passEncoder.setBindGroup(0, uniformBindGroup);
    //指定实例个数为numInstances
    passEncoder.draw(36, numInstances, 0, 0);
    ...
  }
```

## 最终渲染结果
![截屏2019-12-22下午4.18.23.png-143.2kB][2]

# 参考资料
[WebGPU规范](https://gpuweb.github.io/gpuweb/)
[webgpu-samplers Github Repo](https://github.com/yyc-git/webgpu-samples)


  [1]: http://static.zybuluo.com/yangyc/lyzkr8xe0fzake55x38h9zwq/%E6%88%AA%E5%B1%8F2019-12-22%E4%B8%8B%E5%8D%884.18.16.png
  [2]: http://static.zybuluo.com/yangyc/b6p7r7v675sx6pql56zkg3c8/%E6%88%AA%E5%B1%8F2019-12-22%E4%B8%8B%E5%8D%884.18.23.png]]></description></item><item><title>WebGPU学习（六）：学习“rotatingCube”示例</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/22/12079739.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sun, 22 Dec 2019 06:27:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/22/12079739.html</guid><description><![CDATA[大家好，本文学习Chrome->webgpu-samplers->rotatingCube示例。

上一篇博文：
[WebGPU学习（五）: 现代图形API技术要点和WebGPU支持情况调研](https://www.cnblogs.com/chaogex/p/12041286.html)

下一篇博文：
[WebGPU学习（七）：学习“twoCubes”和“instancedCube”示例](https://www.cnblogs.com/chaogex/p/12081022.html)

# 学习rotatingCube.ts


我们已经学习了[“绘制三角形”](https://www.cnblogs.com/chaogex/p/11993144.html)的示例，与它相比，本示例增加了以下的内容：

- 增加一个uniform buffer object（简称为ubo），用于传输model矩阵*view矩阵*projection矩阵的结果矩阵（简称为mvp矩阵），并在每帧被更新
- 设置顶点
- 开启面剔除
- 开启深度测试

下面，我们打开[rotatingCube.ts](https://github.com/yyc-git/webgpu-samples/blob/master/src/examples/rotatingCube.ts)文件，依次来看下新增内容：

## 增加一个uniform buffer object

### 介绍
在WebGL 1中，我们通过uniform1i,uniform4fv等函数传递每个gameObject对应的uniform变量（如diffuseMap, diffuse color, model matrix等）到shader中。
其中很多相同的值是不需要被传递的，举例如下：
如果gameObject1和gameObject3使用同一个shader1，它们的diffuse color相同，那么只需要传递其中的一个diffuse color，而在WebGL 1中我们一般把这两个diffuse color都传递了，造成了重复的开销。

WebGPU使用uniform buffer object来传递uniform变量。uniform buffer是一个全局的buffer，我们只需要设置一次值，然后在每次draw之前，设置使用的数据范围（通过offset, size来设置），从而复用相同的数据。如果uniform值有变化，则只需要修改uniform buffer对应的数据。

在WebGPU中，我们可以把所有gameObject的model矩阵设为一个ubo，所有相机的view和projection矩阵设为一个ubo，每一种material（如phong material，pbr material等）的数据（如diffuse color，specular color等）设为一个ubo，每一种light（如direction light、point light等）的数据（如light color、light position等）设为一个ubo，这样可以有效减少uniform变量的传输开销。

另外，我们需要注意ubo的内存布局：
默认的布局为std140，我们可以粗略地理解为，它约定了每一列都有4个元素。
我们来举例说明：
下面的ubo对应的uniform block，定义布局为std140：
```js
layout (std140) uniform ExampleBlock
{
    float value;
    vec3  vector;
    mat4  matrix;
    float values[3];
    bool  boolean;
    int   integer;
};
```

它在内存中的实际布局为：
```js
layout (std140) uniform ExampleBlock
{
                     // base alignment  // aligned offset
    float value;     // 4               // 0 
    vec3 vector;     // 16              // 16  (must be multiple of 16 so 4->16)
    mat4 matrix;     // 16              // 32  (column 0)
                     // 16              // 48  (column 1)
                     // 16              // 64  (column 2)
                     // 16              // 80  (column 3)
    float values[3]; // 16              // 96  (values[0])
                     // 16              // 112 (values[1])
                     // 16              // 128 (values[2])
    bool boolean;    // 4               // 144
    int integer;     // 4               // 148
};
```
也就是说，这个ubo的第一个元素为value，第2-4个元素为0（为了对齐）；
第5-7个元素为vector的x、y、z的值，第8个元素为0；
第9-24个元素为matrix的值（列优先）；
第25-27个元素为values数组的值，第28个元素为0；
第29个元素为boolean转为float的值，第30-32个元素为0；
第33个元素为integer转为float的值，第34-36个元素为0。




### 分析本示例对应的代码
- 在vertex shader中定义uniform block

代码如下：
```ts
  const vertexShaderGLSL = `#version 450
  layout(set = 0, binding = 0) uniform Uniforms {
    mat4 modelViewProjectionMatrix;
  } uniforms;
  ...
  void main() {
    gl_Position = uniforms.modelViewProjectionMatrix * position;
    fragColor = color;
  }
  `;
```
布局为默认的std140，指定了set和binding，包含一个mvp矩阵


- 创建uniformsBindGroupLayout

代码如下：
```ts
  const uniformsBindGroupLayout = device.createBindGroupLayout({
    bindings: [{
      binding: 0,
      visibility: 1,
      type: "uniform-buffer"
    }]
  });
```

visibility为GPUShaderStage.VERTEX（等于1），指定type为“uniform-buffer”

- 创建uniform buffer

代码如下：
```ts
  const uniformBufferSize = 4 * 16; // BYTES_PER_ELEMENT(4) * matrix length(4 * 4 = 16)

  const uniformBuffer = device.createBuffer({
    size: uniformBufferSize,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
```

- 创建uniform bind group

代码如下：
```ts
  const uniformBindGroup = device.createBindGroup({
    layout: uniformsBindGroupLayout,
    bindings: [{
      binding: 0,
      resource: {
        buffer: uniformBuffer,
      },
    }],
  });
```



- 每一帧更新uniform buffer的mvp矩阵数据

代码如下：
```ts
  //因为是固定相机，所以只需要计算一次projection矩阵
  const aspect = Math.abs(canvas.width / canvas.height);
  let projectionMatrix = mat4.create();
  mat4.perspective(projectionMatrix, (2 * Math.PI) / 5, aspect, 1, 100.0);
  
  ...
 
  
  //计算mvp矩阵
  function getTransformationMatrix() {
    let viewMatrix = mat4.create();
    mat4.translate(viewMatrix, viewMatrix, vec3.fromValues(0, 0, -5));
    let now = Date.now() / 1000;
    mat4.rotate(viewMatrix, viewMatrix, 1, vec3.fromValues(Math.sin(now), Math.cos(now), 0));

    let modelViewProjectionMatrix = mat4.create();
    mat4.multiply(modelViewProjectionMatrix, projectionMatrix, viewMatrix);

    return modelViewProjectionMatrix;
  }
  
  ...
  return function frame() {
    uniformBuffer.setSubData(0, getTransformationMatrix());
    ...
  }
```

- draw之前设置bind group

代码如下：
```ts
  return function frame() {
    ...
    passEncoder.setBindGroup(0, uniformBindGroup);
    passEncoder.draw(36, 1, 0, 0);
    ...
  }
```


### 详细分析“更新uniform buffer”
本示例使用setSubData来更新uniform buffer：
```ts
  return function frame() {
    uniformBuffer.setSubData(0, getTransformationMatrix());
    ...
  }
```

我们在[WebGPU学习（五）: 现代图形API技术要点和WebGPU支持情况调研](https://zhuanlan.zhihu.com/p/97410952)->Approaching zero driver overhead->persistent map buffer中，提到了WebGPU目前有两种方法实现“CPU把数据传输到GPU“，即更新GPUBuffer的值：
1.调用GPUBuffer->setSubData方法
2.使用persistent map buffer技术

我们看下如何在本示例中使用第2种方法：
```ts
function setBufferDataByPersistentMapBuffer(device, commandEncoder, uniformBufferSize, uniformBuffer, mvpMatricesData) {
    const [srcBuffer, arrayBuffer] = device.createBufferMapped({
        size: uniformBufferSize,
        usage: GPUBufferUsage.COPY_SRC
    });

    new Float32Array(arrayBuffer).set(mvpMatricesData);
    srcBuffer.unmap();

    commandEncoder.copyBufferToBuffer(srcBuffer, 0, uniformBuffer, 0, uniformBufferSize);
    const commandBuffer = commandEncoder.finish();

    const queue = device.defaultQueue;
    queue.submit([commandBuffer]);

    srcBuffer.destroy();
}

return function frame() {
    //uniformBuffer.setSubData(0, getTransformationMatrix());
     ...

    const commandEncoder = device.createCommandEncoder({});

    setBufferDataByPersistentMapBuffer(device, commandEncoder, uniformBufferSize, uniformBuffer, getTransformationMatrix());
     ...
}
```


为了验证性能，我做了[benchmark测试](https://github.com/yyc-git/WebGPU-Sample/blob/master/benchmark/benchmark_persistent_map_buffer.html)，创建一个ubo，包含160000个mat4，进行js profile：

使用setSubData(调用setBufferDataBySetSubData函数):
![截屏2019-12-22上午10.09.43.png-38.6kB][1]

setSubData占91.54%

使用persistent map buffer(调用setBufferDataByPersistentMapBuffer函数):
![截屏2019-12-22上午10.09.50.png-52.9kB][2]

createBufferMapped和setBufferDataByPersistentMapBuffer占72.72+18.06=90.78%

可以看到两个的性能差不多。但考虑到persistent map buffer从实现原理上要更快（cpu和gpu共用一个buffer，不需要copy），因此应该优先使用该方法。

另外，WebGPU社区现在还在讨论如何优化更新buffer数据（如有人提出增加GPUUploadBuffer pass），因此我们还需要继续关注该方面的进展。






### 参考资料
[Advanced-GLSL](https://learnopengl.com/Advanced-OpenGL/Advanced-GLSL)->Uniform buffer objects


## 设置顶点
- 传输顶点的position和color数据到vertex shader的attribute（in）中

代码如下：
```ts
  const vertexShaderGLSL = `#version 450
  ...
  layout(location = 0) in vec4 position;
  layout(location = 1) in vec4 color;
  layout(location = 0) out vec4 fragColor;
  void main() {
    gl_Position = uniforms.modelViewProjectionMatrix * position;
    fragColor = color;
  }
  
  const fragmentShaderGLSL = `#version 450
  layout(location = 0) in vec4 fragColor;
  layout(location = 0) out vec4 outColor;
  void main() {
    outColor = fragColor;
  }
  `;
```
这里设置color为fragColor（out，相当于WebGL 1的varying变量），然后在fragment shader中接收fragColor，将其设置为outColor，从而将fragment的color设置为对应顶点的color


- 创建vertices buffer，设置立方体的顶点数据

代码如下：
```ts
cube.ts:

//每个顶点包含position,color,uv数据
export const cubeVertexArray = new Float32Array([
    // float4 position, float4 color, float2 uv,
    1, -1, 1, 1,   1, 0, 1, 1,  1, 1,
    -1, -1, 1, 1,  0, 0, 1, 1,  0, 1,
    -1, -1, -1, 1, 0, 0, 0, 1,  0, 0,
    1, -1, -1, 1,  1, 0, 0, 1,  1, 0,
    1, -1, 1, 1,   1, 0, 1, 1,  1, 1,
    -1, -1, -1, 1, 0, 0, 0, 1,  0, 0,

    1, 1, 1, 1,    1, 1, 1, 1,  1, 1,
    1, -1, 1, 1,   1, 0, 1, 1,  0, 1,
    1, -1, -1, 1,  1, 0, 0, 1,  0, 0,
    1, 1, -1, 1,   1, 1, 0, 1,  1, 0,
    1, 1, 1, 1,    1, 1, 1, 1,  1, 1,
    1, -1, -1, 1,  1, 0, 0, 1,  0, 0,

    -1, 1, 1, 1,   0, 1, 1, 1,  1, 1,
    1, 1, 1, 1,    1, 1, 1, 1,  0, 1,
    1, 1, -1, 1,   1, 1, 0, 1,  0, 0,
    -1, 1, -1, 1,  0, 1, 0, 1,  1, 0,
    -1, 1, 1, 1,   0, 1, 1, 1,  1, 1,
    1, 1, -1, 1,   1, 1, 0, 1,  0, 0,

    -1, -1, 1, 1,  0, 0, 1, 1,  1, 1,
    -1, 1, 1, 1,   0, 1, 1, 1,  0, 1,
    -1, 1, -1, 1,  0, 1, 0, 1,  0, 0,
    -1, -1, -1, 1, 0, 0, 0, 1,  1, 0,
    -1, -1, 1, 1,  0, 0, 1, 1,  1, 1,
    -1, 1, -1, 1,  0, 1, 0, 1,  0, 0,

    1, 1, 1, 1,    1, 1, 1, 1,  1, 1,
    -1, 1, 1, 1,   0, 1, 1, 1,  0, 1,
    -1, -1, 1, 1,  0, 0, 1, 1,  0, 0,
    -1, -1, 1, 1,  0, 0, 1, 1,  0, 0,
    1, -1, 1, 1,   1, 0, 1, 1,  1, 0,
    1, 1, 1, 1,    1, 1, 1, 1,  1, 1,

    1, -1, -1, 1,  1, 0, 0, 1,  1, 1,
    -1, -1, -1, 1, 0, 0, 0, 1,  0, 1,
    -1, 1, -1, 1,  0, 1, 0, 1,  0, 0,
    1, 1, -1, 1,   1, 1, 0, 1,  1, 0,
    1, -1, -1, 1,  1, 0, 0, 1,  1, 1,
    -1, 1, -1, 1,  0, 1, 0, 1,  0, 0,
]);
```

```ts
rotatingCube.ts:

  const verticesBuffer = device.createBuffer({
    size: cubeVertexArray.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
  });
  verticesBuffer.setSubData(0, cubeVertexArray);
```

因为只需要设置一次顶点数据，所以这里可以使用setSubData来设置，对性能影响不大


- 创建render pipeline时，指定vertex shader的attribute

代码如下：
```ts
cube.ts:

export const cubeVertexSize = 4 * 10; // Byte size of one cube vertex.
export const cubePositionOffset = 0;
export const cubeColorOffset = 4 * 4; // Byte offset of cube vertex color attribute.
```

```ts
rotatingCube.ts:

  const pipeline = device.createRenderPipeline({
    ...
    vertexState: {
      vertexBuffers: [{
        arrayStride: cubeVertexSize,
        attributes: [{
          // position
          shaderLocation: 0,
          offset: cubePositionOffset,
          format: "float4"
        }, {
          // color
          shaderLocation: 1,
          offset: cubeColorOffset,
          format: "float4"
        }]
      }],
    },
    ...
  });
```


- render pass->draw指定顶点个数为36

代码如下：
```ts
  return function frame() {
    ...
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    ...
    passEncoder.draw(36, 1, 0, 0);
    passEncoder.endPass();
    ...
  }
```



## 开启面剔除
相关代码为：
```ts
  const pipeline = device.createRenderPipeline({
    ...
    rasterizationState: {
      cullMode: 'back',
    },
    ...
  });
```


相关的定义为：
```ts
enum GPUFrontFace {
    "ccw",
    "cw"
};
enum GPUCullMode {
    "none",
    "front",
    "back"
};
...

dictionary GPURasterizationStateDescriptor {
    GPUFrontFace frontFace = "ccw";
    GPUCullMode cullMode = "none";
    ...
};
```
其中ccw表示逆时针，cw表示顺时针。

因为本示例设置了cullMode为back，没有设置frontFace（frontFace为默认的ccw），所以WebGPU会把逆时针方向设为外侧，把所有背面的三角形（顶点连接方向为内侧，即顺时针方向的三角形）剔除掉 



### 参考资料
[[WebGL入门]六，顶点和多边形](https://blog.csdn.net/lufy_legend/article/details/38326955)
[Investigation: Rasterization State](https://github.com/gpuweb/gpuweb/issues/137)



## 开启深度测试
现在分析相关代码，并忽略与模版测试相关的代码：

- 创建render pipeline时，设置depthStencilState

代码如下：
```ts
  const pipeline = device.createRenderPipeline({
    ...
    depthStencilState: {
      //开启深度测试
      depthWriteEnabled: true,
      //设置比较函数为less，后面会继续说明 
      depthCompare: "less",
      //设置depth为24bit
      format: "depth24plus-stencil8",
    },
    ...
  });
```


- 创建depth texture（注意它的size->depth为1，格式也为24bit），将它的view设置为render pass->depth和stencil attachment->attachment

代码如下：
```ts
  const depthTexture = device.createTexture({
    size: {
      width: canvas.width,
      height: canvas.height,
      depth: 1
    },
    format: "depth24plus-stencil8",
    usage: GPUTextureUsage.OUTPUT_ATTACHMENT
  });

  const renderPassDescriptor: GPURenderPassDescriptor = {
    ...
    depthStencilAttachment: {
      attachment: depthTexture.createView(),

      depthLoadValue: 1.0,
      depthStoreOp: "store",
      ...
    }
  };
```

其中，depthStencilAttachment的定义为：
```ts
dictionary GPURenderPassDepthStencilAttachmentDescriptor {
    required GPUTextureView attachment;

    required (GPULoadOp or float) depthLoadValue;
    required GPUStoreOp depthStoreOp;
    ...
};
```

depthLoadValue和depthStoreOp与[WebGPU学习（二）: 学习“绘制一个三角形”示例](https://zhuanlan.zhihu.com/p/95650126)->分析render pass->colorAttachment的loadOp和StoreOp类似，我们直接分析本示例的相关代码：
```ts

  const pipeline = device.createRenderPipeline({
    ...
    depthStencilState: {
      ...
      depthCompare: "less",
      ...
    },
    ...
  });
  
  ...

  const renderPassDescriptor: GPURenderPassDescriptor = {
    ...
    depthStencilAttachment: {
      ...
      depthLoadValue: 1.0,
      depthStoreOp: "store",
      ...
    }
  };
```

在深度测试时，gpu会将fragment的z值（范围为[0.0-1.0]）与这里设置的depthLoadValue值（这里为1.0）比较。其中比较的函数使用depthCompare定义的函数（这里为less，意思是所有z值大于等于1.0的fragment会被剔除）



### 参考资料
[Depth testing](https://learnopengl.com/Advanced-OpenGL/Depth-testing)

## 最终渲染结果
![截屏2019-12-22下午12.01.20.png-54.8kB][3]

# 参考资料
[WebGPU规范](https://gpuweb.github.io/gpuweb/)
[webgpu-samplers Github Repo](https://github.com/yyc-git/webgpu-samples)
[WebGPU-5](https://blog.csdn.net/caxieyou/article/details/94644924)


  [1]: http://static.zybuluo.com/yangyc/v3rzu4oev680fltan07jmkqo/%E6%88%AA%E5%B1%8F2019-12-22%E4%B8%8A%E5%8D%8810.09.43.png
  [2]: http://static.zybuluo.com/yangyc/giz6vd39ik0plvwqksgwzb6l/%E6%88%AA%E5%B1%8F2019-12-22%E4%B8%8A%E5%8D%8810.09.50.png
  [3]: http://static.zybuluo.com/yangyc/gdvfrk3fxjfrd4n7to1ywvu2/%E6%88%AA%E5%B1%8F2019-12-22%E4%B8%8B%E5%8D%8812.01.20.png]]></description></item><item><title>WebGPU学习（五）: 现代图形API技术要点和WebGPU支持情况调研</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/14/12041286.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sat, 14 Dec 2019 14:50:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/14/12041286.html</guid><description><![CDATA[大家好，本文整理了现代图形API的技术要点，重点研究了并行和GPU Driven Render Pipeline相关的知识点，调查了WebGPU的相关支持情况。

另外，本文对实时光线追踪也进行了简要的分析。这是我非常感兴趣的技术方向，也是图形学的发展方向之一。本系列后续文章会围绕这个方向进行更多的研究和实现相关的Demo。

上一篇博文：
[WebGPU学习（四）:Alpha To Coverage](https://www.cnblogs.com/chaogex/p/12004546.html)

下一篇博文：
[WebGPU学习（六）：学习“rotatingCube”示例](https://www.cnblogs.com/chaogex/p/12079739.html)




# 本文内容

- [前置知识](#前置知识)
- [技术要点](#技术要点)
- [并行](#并行)
    - [Multiple Queues](#multiple-queues)
    - [同步](#同步)
    - [多线程](#多线程)
- [内存管理](#内存管理)
- [延迟渲染](#延迟渲染)
    - [Defer Shading](#defer-shading)
    - [Textureless Defer Render](#textureless-defer-render)
- [GPU Driven Render Pipeline](#gpu-driven-render-pipeline)
    - [Approaching zero driver overhead](#approaching-zero-driver-overhead)
    - [GPU Cull](#gpu-cull)
    - [GPU Lod](#gpu-lod)
- [Hybrid Render For Real-time Ray Tracing](#hybrid-render-for-real-time-ray-tracing)
    - [混合渲染](#混合渲染)
    - [如何使用WebGPU学习和实现Ray Tracing](#如何使用webgpu学习和实现ray-tracing)
    - [学习资料](#学习资料)
- [其它](#其它)
    - [Bindless Texture](#bindless-texture)
    - [Virtual Texture](#virtual-texture)
    - [Tessellation](#tessellation)
    - [Mesh Shader](#mesh-shader)


# 前置知识

- 现代图形API包括哪些API？
包括DX12、Vulkan、Metal


- MVP是什么？
是WebGPU的最小可用版本。
在1.0版本发布前，先发布MVP版本。

# 技术要点
现代图形API包含下面的技术要点：
![现代图形API技术要点1 (4).png-43.7kB][1]

下面依次进行分析：
# 并行

为了提高多核CPU和GPU的利用率，现代图形API充分支持了并行。

并行包含下面的技术要点：

## Multiple Queues

### 介绍

为了提高GPU利用率，可以将不同种类的任务对应的command buffer提交到3种队列中：
graphics queue
copy queue
compute queue

不同队列的任务能够在GPU中并行执行，从而实现Async Compute，提高利用率。


**参考资料**
[Multi-engine synchronization](https://docs.microsoft.com/en-us/windows/win32/direct3d12/user-mode-heap-synchronization)


### WebGPU支持情况

根据[Multiple Queues skeleton proposal](https://github.com/gpuweb/gpuweb/pull/95)，MVP只支持单队列：
> what single queue is exposed in the MVP



## 同步

### 介绍

有3个技术可以实现CPU与GPU之间以及GPU内部的同步：

- semaphores

我不了解它，它应该是用来同步队列的

- memory barrier

它用来避免GPU因为资源依赖关系造成等待，以及避免CPU和GPU之间发生Race Condition。

现代图形API更加底层，以前GPU做的同步工作也交给了图形程序员，更加灵活的同时也加重了程序员的负担。


**参考资料**
[Breaking Down Barriers](https://zhuanlan.zhihu.com/p/60975148)



- fence

它用来在CPU和GPU之间同步。


这3个技术的关系可以参考[Vulkan Multi-Threading](https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/munich/mschott_vulkan_multi_threading.pdf):
![截屏2019-12-12下午7.50.08.png-158.7kB][2]

    

### WebGPU支持情况

- semaphores

因为目前只支持单队列，所以不需要它

- memory barrier


大家都表示memory barrier不容易实现，所以barriers由WebGPU帮我们做了（参考[Memory barriers investigations](https://github.com/gpuweb/gpuweb/issues/27)、[Memory Barriers portability](https://github.com/gfx-rs/gfx/issues/1498)、[The case for passes](https://github.com/gpuweb/gpuweb/issues/64) -> Synchronization and validation），我们只需要给WebGPU一些提示（如指定buffer的[usage](https://gpuweb.github.io/gpuweb/#buffer-usage)）




- fence

支持以计数的方式实现fence。


**参考资料**
[TimelineFences](https://github.com/gpuweb/gpuweb/blob/master/design/TimelineFences.md)


## 多线程


### 介绍

可以在线程中执行现代图形API相关的渲染任务：

- 在线程中更新资源
如更新buffer

- 并行地编译shader

- 并行地创建pipeline state

- 在线程中创建command buffer

参考[Vulkan Multi-Threading](https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/munich/mschott_vulkan_multi_threading.pdf):
![截屏2019-12-12下午8.15.25.png-121.2kB][3]


### WebGPU支持情况

有两种方法实现多线程：

- 通过OffscreenCanvas API，实现主线程与渲染线程分离

根据[Rendering to OffscreenCanvas on non-yielding workers](https://github.com/gpuweb/gpuweb/issues/403)：
WebGPU支持OffScreenCanvas API，但是目前Chrome不能使用它。

- 创建worker，在worker中执行WebGPU相关的渲染任务

[Create a proposal for multi-worker](https://github.com/gpuweb/gpuweb/issues/354)中提出了WebGPU如何在worker中执行渲染任务：
> 
1.Asynchronous texture & buffer uploads
2.Asynchronous shader compilation
3.Asynchronous pipeline state creation
4.Using MTLParallelRenderEncoder
5.Each thread in a thread pool records into its own command buffer

根据[Minutes for GPU Web meeting 2019-08-05 -> Multi threading](https://docs.google.com/document/d/1_SZqLdSaG1I3Pwe2SJFqrcXtAvH4aIDcXbf5kEple88/edit#heading=h.u4znwge7pulf):
其中的1,2,3正在实现中；
4, 5会最终实现（没有说好久实现）；


根据我目前的调查：
1.shader编译和创建pipeline state目前是同步的，还不是异步的。
2.在[WebGPU 规范](https://gpuweb.github.io/gpuweb/#gpubuffer)中，GPUTexture,GPUBuffer,GPUDevice,GPUComputePipeline,GPURenderPipeline,GPUShaderModule是Serializable的，意味着可以传给worker。
那是不是现在已经可以在worker中使用它们，从而实现1,2,3呢？需要进一步验证！


## 扩展阅读
引擎对于多线程的封装：
[Parallelizing the Naughty Dog Engine using Fibers ](https://zhuanlan.zhihu.com/p/36309461)
[Destiny’s Multi-threaded Renderer Architecture](http://advances.realtimerendering.com/destiny/gdc_2015/Tatarchuk_GDC_2015__Destiny_Renderer_web.pdf)

# 内存管理

## 介绍
与memory barriers类似，现代图形API需要程序员自己管理GPU的资源。

如[Memory Management in Vulkan™ and DX12](http://twvideo01.ubm-us.net/o1/vault/gdc2018/presentations/Sawicki_Adam_Memory%20management%20in%20Vulkan.pdf)所示：
![截屏2019-12-12下午8.47.46.png-64.1kB][4]

**参考资料**
[Memory Management in Vulkan™ and DX12](http://twvideo01.ubm-us.net/o1/vault/gdc2018/presentations/Sawicki_Adam_Memory%20management%20in%20Vulkan.pdf)

## WebGPU支持情况
根据[WebGPU as low level graphics API ](https://github.com/WebAssembly/WASI/issues/53)：
> WebGPU compares closest to Metal (probably since Apple is the one that originally proposed it)--both don't require manual memory management while DX12 and Vulkan do

不需要手动管理memory，WebGPU会帮我们管理





# 延迟渲染

## defer shading


包括两个步骤：
第一个pass遍历gameObjects，创建gbuffer；
第二个pass遍历lights，使用gbuffer计算光照。

相对于前向渲染，它的优点是只在屏幕上出现的像素中计算SHADING，从而使复杂度由O(M * N)将为O(M) + O(N)

### WebGPU支持情况

因为支持MRT（多渲染目标），所以支持延迟渲染。

值得一提的是两个优化的方向：

- 优化内存访问

在[Investigation: Managing on-chip memory](https://github.com/gpuweb/gpuweb/issues/435)中提到：
第一个pass创建gbuffer后，gbuffer的数据会从on-chip内存移到主内存中；
第二个pass读取gbuffer时，将gbuffer的数据从主内存移到on-chip内存。


gbuffer的数据来回移动，造成了性能损失。
因此在[Add render sub-passes](https://github.com/gpuweb/gpuweb/issues/393)中，建议增加render的子pass，在子pass中读取gbuffer，从而实现在创建和读取gbuffer期间，gbuffer的数据一直在on-chip内存中。

[Minutes for GPU Web meeting 2019-10-28](https://docs.google.com/document/d/1vjEeT_CO2zlHZ2K5SiNMdROVDk6ag8skSgN-ZEO4evg/edit#heading=h.vakh3hkqixgj)也讨论了这一点。


WebGPU可能会在extension中支持这个优化。



- 针对tile-based defer shading，使用compute shader，在第二个pass中剔除光源，剩余的光源参与光照计算

正如[DirectX 11 Rendering in Battlefield 3](http://www.dice.se/wp-content/uploads/2014/12/GDC11_DX11inBF3_Public.pdf)所说：
> 
Hybrid Graphics/Compute shading pipeline:
› Graphics pipeline rasterizes gbuffers for opaque surfaces
› Compute pipeline uses gbuffers, culls lights, computes lighting &
combines with shading
› Graphics pipeline renders transparent surfaces on top


### 参考资料

[延迟着色法](https://learnopengl-cn.readthedocs.io/zh/latest/05%20Advanced%20Lighting/08%20Deferred%20Shading/)
[Optimizing tile-based light culling](https://wickedengine.net/2018/01/10/optimizing-tile-based-light-culling/)
[DirectX 11 Rendering in Battlefield 3](http://www.dice.se/wp-content/uploads/2014/12/GDC11_DX11inBF3_Public.pdf)


## textureless defer render


### 介绍

在defer shading的第一个pass中，我们将gameObject的几何数据（如Position, Normal等）和材质贴图数据（如从diffuse map中获得的diffuse）存到gbuffer中。

有了[bindless texture](#bindless-texture)的支持，我们可以对此进行优化：

- gbuffer不再存储材质贴图的数据，而是存储uv和material id。在第二个pass中，shader根据它们去获取对应材质贴图texture的数据

这样做的优点是：
1.减少了gbuffer的大小
2.只在可见的像素中，采样texture的数据，减少了采样次数

这样做也存在一些问题，不过都是可以解决的：
具体可以参考[什么是deferred material shading？是否会在未来流行开来？](https://www.zhihu.com/question/40108592)：
> 1.多材质如何做deferred shading？总不能每个像素做动态分支，一个一个判断吧。有人提出了做tile把像素区块合并，然后一次性dispatch，性能会高很多。至于vgpr，sgpr，lds占用率之类需要通盘考虑，偏向一边都会影响性能。
2.结果SSAO，SSR之类的post effect还是需要用到normal，roughness之类的g-bufffer信息。应用上还是需要权衡利弊。

以及参考[Deferred Texturing](http://www.reedbeta.com/blog/deferred-texturing/)：
> What about mip levels, or derivatives? 


- gbuffer不存储几何数据，而是存储primitive ID。在第二个pass中，接收vertex data，在每个可见像素上执行vertex shader

具体可以参考[Deferred Texturing](http://www.reedbeta.com/blog/deferred-texturing/) -> Defer All The Things：
> It stores only primitive IDs in its G-buffer; then in a later pass, it fetches vertex data, re-runs the vertex shader per pixel (!), finds the barycentric coordinates of each fragment within its triangle, interpolates the vertex attributes, then finally samples all the textures and does the shading work.

### WebGPU支持情况
根据本文后面[bindless texture](#bindless-texture)的分析，目前WebGPU不支持bindless texture
或许可用texture 2d array代替bindless texture，从而使用WebGPU实现textureless defer render




### 参考资料
[Deferred Texturing](http://www.reedbeta.com/blog/deferred-texturing/)
[什么是deferred material shading？是否会在未来流行开来？](https://www.zhihu.com/question/40108592)
[BINDLESS TEXTURING FOR DEFERRED RENDERING AND DECALS](https://mynameismjp.wordpress.com/2016/03/25/bindless-texturing-for-deferred-rendering-and-decals/)
[Modern textureless deferred rendering techniques](https://forum.beyond3d.com/threads/modern-textureless-deferred-rendering-techniques.57611/)



# GPU Driven Render Pipeline


## 介绍

这个技术应该是在[[Siggraph15] GPU-Driven Rendering Pipelines](https://zhuanlan.zhihu.com/p/33881505)中提出来的。它的思想是把渲染任务从CPU端移到GPU端，减少CPU与GPU的同步和数据传输，实现1个draw call就渲染整个场景，从而提高GPU的利用率。


### 优点

- GPU更细粒度的Visibility

- 不需要在CPU和GPU之间来回传递数据

### 应用场景

- 绘制大量的静态物体

- 绘制人群

- 绘制模块化半自动生成内容

### 主要步骤

**离线处理**
1.分解gameObject的mesh为多个cluster

参考[GPU Driven Pipeline — 工具链与进阶渲染](https://zhuanlan.zhihu.com/p/44411827)

**CPU**
1.对gameObject进行粗粒度的frustum cull

2.使用persistent map buffer，准备GPU的数据

可以按照数据的类型，创建多个mapped buffer（如一个buffer存储人群的数据，另一个buffer存储所有静态物体的数据）


3.使用[virtual texture](#virtual-texture)处理texture

所有的texture数据一次性全部准备好，只绑定一次texture

4.用indirect draw发起multi draw call，提交mapped buffer

WebGPU目前不支持multi draw，因此需要发起多个draw call，每个draw call使用indirect draw提交对应的mapped buffer


**GPU**
1.对gameObject进行frustum cull和occlusion cull

2.对gameObject的cluster进行frustum cull和occlusion cull

3.修改index buffer，生成新的indices数据

根据[Proposal: Run all index buffers through a compute shader validator](https://github.com/gpuweb/gpuweb/issues/117)： 
> I'm inclined to propose that WebGPU MVP doesn't support index buffers changed on the GPU, since this is quite a bit of headache, but eventually we can do that.
> ...
> In an actual 1.0 release we'll absolutely need to support GPU-generated indices, there is no question here.

WebGPU MVP不会支持在GPU端修改index buffer，1.0版本会支持。

4.multi draw call

根据[ExecuteIndirect investigation](https://github.com/gpuweb/gpuweb/issues/431)： 
> In order to issue draw calls on the CPU, there must be a synchronization point where the CPU waits for the GPU update to complete. This is particularly devastating for WebGPU, where if the CPU has to wait for the GPU, you miss your implicit present and now you're a frame late. Being able to issue these commands on the GPU directly means the rendering and update steps can be in sync.

在GPU端发起draw call可以去掉“CPU和GPU同步”的开销。

> However, making it an extension seems valuable.

可能会在WebGPU extension中支持该特性。



### 总结
GPU Driven Render Pipeline可以一次性取得所有mesh data，通过virtual texture可以取得所有texture，意味着整个场景只需要一次drawcall

### 参考资料
[[Siggraph15] GPU-Driven Rendering Pipelines](https://zhuanlan.zhihu.com/p/33881505)
[[GDC16] Optimizing the Graphics Pipeline with Compute](https://zhuanlan.zhihu.com/p/33881861)
[知乎大神MaxwellGeng关于GPU Driven Rendering Pipelines的相关文章1](https://www.zhihu.com/people/maxwellgeng/posts?page=2)
[知乎大神MaxwellGeng关于GPU Driven Rendering Pipelines的相关文章2](https://www.zhihu.com/people/maxwellgeng/posts?page=1)



现在我们介绍下GPU Driven Render Pipeline相关的概念和技术要点：

## Approaching zero driver overhead

这个概念（简称为AZDO）出自[approaching-zero-driver-overhead](https://www.slideshare.net/CassEveritt/approaching-zero-driver-overhead)，它分析了OpenGL如何使用GPU实现CPU端0负载，具体包括下面几个方面： 

- persistent map buffer 

**介绍**

该技术是为了在“CPU把数据传输到GPU“时减小数据传输的开销。
它包括下面的步骤：
1.映射GPU的buffer到CPU
2.在CPU端修改这个mapped buffer的数据（因为mapped buffer在shared memory中，CPU和GPU都可以访问它，所以要使用fence同步来确保GPU没操作这个buffer）
3.提交修改buffer数据的command
4.GPU执行该command，更新buffer数据

通过上面的步骤，不再需要“从CPU传输新buffer的数据到GPU”了，减小了开销



参考资料:
[Persistent mapped buffers](https://ferransole.wordpress.com/2014/06/08/persistent-mapped-buffers/)
[Persistent Mapped Buffers in OpenGL](https://www.bfilipek.com/2015/01/persistent-mapped-buffers-in-opengl.html)




**WebGPU支持情况**

有两种方式实现“CPU把数据传输到GPU“：


1.调用GPUBuffer->setSubData方法
该方法性能差，需要从CPU传输数据到GPU（WebGPU规范并没有定义该方法，但是Chrome的WebGPU实现目前有该方法）

2.使用persistent map buffer技术
对于该方法，有以下的要点要说明：
1)不需要fence
WebGPU提供了GPUBuffer->unmap方法，该方法将buffer设置为unmapped state，使该buffer能够被GPU使用。

WebGPU应该在该方法中帮我们做了fence同步的工作。

2)如何创建mapped buffer？
有两种方式创建：
a)调用GPUDevice->createBufferMapped方法，创建mapped buffer
[Make it easier to upload data into buffers correctly](https://github.com/gpuweb/gpuweb/pull/418)指出：
createBufferMapped创建的buffer会使内存增加，因此需要destory它。



b)调用GPUBuffer->mapReadAsync,mapWriteAsync，将buffer设置为mapped buffer
[Make it easier to upload data into buffers correctly](https://github.com/gpuweb/gpuweb/pull/418)指出，使用mapWriteAsync会造成一些问题：
>  in WebGPU, have an implicit present after rAF() returns
> ...
> Using mapWriteAsync() requires you to wait on a promise, so if you do the naive thing and just wait on the promise inside rAF(), you’ll miss your present
> ...
> Could we replace mapWriteAsync returning a Promise with it taking a callback that is guaranteed to execute before any submitted queue bundles are executed? 


其中“rAF”指“requestAnimationFrame”

我们根据示例代码来说明下这个问题：
```js
function frame(time){
    ...

    const vertexBuffer = device.createBuffer({
        ...
        usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,
    });

    vertexBuffer.mapWriteAsync().then((vertexBufferData) => {
        设置vertexBufferData

        vertexBuffer.unmap();

        提交修改buffer数据的command到队列中
        
        ...
    });

    window.requestAnimationFrame(frame);
}
```

因为mapWriteAsync是异步操作，而frame函数是同步操作，所以当执行到unmap时，可能已经执行了好几次frame（过了好几帧）。
在这几帧中，可能提交了其它的command到队列，WebGPU可能会在这几帧之间提交了队列中的command到GPU，GPU可能已经执行了其中的一些command。

执行unmap时，我们预期GPU还没有执行其它的command，但实际上可能已经执行了。这样会造成不同步的错误。



为了解决该问题，或许可以使用await关键字，将mapWriteAsync变成同步操作。
示例代码如下：
```js
async function frame(time){
    ...

    var vertexBufferData = await vertexBuffer.mapWriteAsync();
    
    设置vertexBufferData

    vertexBuffer.unmap();

    提交修改buffer数据的command到队列

    ...
}
```





这里给出使用persistent map buffer技术的参考代码（来自[Buffer operations](https://github.com/gpuweb/gpuweb/blob/master/design/BufferOperations.md#updating-data-to-an-existing-buffer-like-webgls-buffersubdata)）
（参考代码通过“调用GPUDevice->createBufferMapped方法”来创建mapped buffer）：
```js
//Updating data to an existing buffer(destBuffer)
function bufferSubData(device, destBuffer, destOffset, srcArrayBuffer) {
    const byteCount = srcArrayBuffer.byteLength;
    const [srcBuffer, arrayBuffer] = device.createBufferMapped({
        size: byteCount,
        usage: GPUBufferUsage.COPY_SRC
    });
    new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer)); // memcpy
    srcBuffer.unmap();

    const encoder = device.createCommandEncoder();
    encoder.copyBufferToBuffer(srcBuffer, 0, destBuffer, destOffset, byteCount);
    const commandBuffer = encoder.finish();
    const queue = device.getQueue();
    queue.submit([commandBuffer]);

    srcBuffer.destroy();
}


```

**参考资料**
[Make it easier to upload data into buffers correctly](https://github.com/gpuweb/gpuweb/pull/418)
[What is the purpose of WebGPUSwapChain.present()? ](https://github.com/gpuweb/gpuweb/issues/182)
[Buffer operations](https://github.com/gpuweb/gpuweb/blob/master/design/BufferOperations.md#updating-data-to-an-existing-buffer-like-webgls-buffersubdata)
[Minutes for GPU Web meeting 2019-10-21](https://docs.google.com/document/d/1622qfucqJ4BcGh-cmuCDR7pnm1Af3dmRORzibwXn2nU/edit#heading=h.yrgf5cr5ikjy)









- indirect draw


**介绍**

以WebGPU为例，draw方法需要指定顶点个数、实例个数等数据，每次只能绘制一个gameObject（可以批量绘制多个实例instance）：
```js
void draw(unsigned long vertexCount, unsigned long instanceCount, unsigned long firstVertex, unsigned long firstInstance);
```

而indirect draw可以使用buffer进行批量绘制多个gameObject（也可以批量绘制多个实例），这个buffer包含了每个gameObject的顶点个数等数据：
```js
void drawIndirect(GPUBuffer indirectBuffer, GPUBufferSize indirectOffset);
```


**优点**
1.可以在compute shader修改buffer的数据，从而实现[gpu cull](#gpu-cull)
2.减少了绘制gameObject的次数
3.减少了CPU和GPU之间的同步开销




**WebGPU支持情况**
支持Indirect draw/dispatch，相关讨论参考 [Indirect draw/dispatch commands investigation](https://github.com/gpuweb/gpuweb/issues/31)


**参考资料**
[What are the advantage of using indirect rendering in OpenGL?](https://stackoverflow.com/questions/19534284/what-are-the-advantage-of-using-indirect-rendering-in-opengl)
[vulkan Indirect drawing](https://github.com/SaschaWillems/Vulkan/tree/master/examples/indirectdraw)
[INDIRECT RENDERING : “A WAY TO A MILLION DRAW CALLS”](http://cpp-rendering.io/indirect-rendering/)
[Surviving without gl_DrawID](https://www.g-truc.net/post-0518.html)



- bindless texture and virtual texture 

bindless texture和virtual texture可以结合使用，实现“只绑定一次texture”。

具体参见本文后面的说明：
其它->[Bindless Texture](#bindless-texture)
其它->[Virtual Texture](#virtual-texture)




## GPU Cull

在GPU端实现剔除。

### 实现思路

1.创建persistent map buffer，indirect draw该buffer
2.在compute shader进行cull操作，将剩余的gameObject对应的draw call数据（如顶点个数）写到该buffer中


### 相关技术要点

- 剔除的目标可以是gameObject的整个mesh，也可以是部分mesh（以cluster为单位）

具体可参考[GPU Driven Pipeline — 工具链与进阶渲染](https://zhuanlan.zhihu.com/p/44411827)


- frustum cull

通过判断目标是否在主相机的视锥体中，来实现剔除


具体可参考[（程序向）Unity3D GPU绘制管线(1)](https://zhuanlan.zhihu.com/p/41910737)


- occlusion cull

通过判断目标是否被遮挡，来实现剔除

具体可参考[Hi-Z GPU Occlusion Culling](https://zhuanlan.zhihu.com/p/47615677)





## GPU Lod

在GPU端实现lod。

这个我没有仔细研究，读者可以参考相关资料：
[谷歌搜索结果](https://www.google.com.hk/search?q=gpu+lod&oq=gpu+lod&aqs=chrome..69i57j69i60l4j69i65.1071j0j7&sourceid=chrome&ie=UTF-8)
[GPU based dynamic geometry LOD](http://rastergrid.com/blog/2010/10/gpu-based-dynamic-geometry-lod/)







# Hybrid Render For Real-time Ray Tracing

## 介绍

以前Ray Tracing只在离线渲染中使用（如制作CG电影，一般会使用path tracing来加快收敛速度），现在随着DXR（DirectX Raytracing）的发布，新增了Ray Tracing管线，提出了专为Ray Tracing设计的shader，再配合上新的降噪方法（如使用[SVGF降噪算法](https://zhuanlan.zhihu.com/p/28288053)或者[NVDIA提供的基于AI的降噪SDK](https://developer.nvidia.com/optix-denoiser)），能够实现实时的Ray Tracing！

## 混合渲染

完全用Ray Tracing来渲染太耗性能，所以目前业界使用混合方案来实现实时Ray Tracing：
如果支持DXR，可以使用“光栅化管线 + Ray Tracing管线”来实现；
如果不支持DXR，可以使用“光栅化管线 + Compute管线（即使用compute shader）”来实现。

我们可以把渲染分解为：
![截屏2019-12-14下午3.31.15.png-563.9kB][5]

## WebGPU支持情况

根据[Is there some plan for Ray Tracing?](https://github.com/gpuweb/gpuweb/issues/477)：
> There are not plan for ray-tracing for the forseeable future because WebGPU is meant to be extremely portable and ray-tracing isn't mature yet and is implemented only by a single hardware vendor for now.

WebGPU目前不支持Ray Tracing管线，因此只能使用“光栅化管线 + Compute管线（即使用compute shader）”来实现混合渲染。


## 如何使用WebGPU学习和实现Ray Tracing
可以按照下面的步骤：
1.广泛收集相关资料，对整个技术体系有初步的了解（读者可以看下面的“学习资料”）
2.参考[Ray Tracing in One Weekend](http://www.realtimerendering.com/raytracing/Ray%20Tracing_%20The%20Next%20Week.pdf)、[Ray Tracing: The Next Week](http://www.realtimerendering.com/raytracing/Ray%20Tracing_%20The%20Next%20Week.pdf)、[对应的详解](https://www.cnblogs.com/lv-anchoret/category/1368696.html)，使用fragment shader，从0实现Ray Tracing。
目前只需要渲染球体或者立方体就好了，不用渲染模型。
3.使用compute shader实现Ray Tracing
4.使用混合渲染（如使用光栅化实现GBuffer和直接光照，使用Ray Tracing实现阴影和反射）
5.实现降噪算法
直接实现SVGF很有难度，可以先实现其中的子环节（如temporal anti aliasing、tone map、[Edge-Avoiding À-Trous](https://www.google.com.hk/search?q=Edge-Avoiding+%C3%80-Trous&oq=Edge-Avoiding+%C3%80-Trous&aqs=chrome..69i57j0.1309j0j7&sourceid=chrome&ie=UTF-8)等），然后再把它们组装起来，实现SVGF
6.渲染模型
需要实现BVH
7.进一步研究和实现，探索path tracing、优化采样、优化光线排序和连贯性、支持更多的材质等方向


## 学习资料
[一篇光线追踪的入门](https://zhuanlan.zhihu.com/p/41269520)
[光线追踪与实时渲染的未来](https://zhuanlan.zhihu.com/p/34851503)
[Introduction to NVIDIA RTX and DirectX Ray Tracing](https://devblogs.nvidia.com/introduction-nvidia-rtx-directx-ray-tracing/)
[如何评价微软的 DXR（DirectX Raytracing）？](https://www.zhihu.com/question/269149582)
[Daily Pathtracer！安利下不错的Pathtracer学习资料](https://zhuanlan.zhihu.com/p/37462611)
[Ray Tracing in One Weekend](http://www.realtimerendering.com/raytracing/Ray%20Tracing_%20The%20Next%20Week.pdf)
[Ray Tracing: The Next Week](http://www.realtimerendering.com/raytracing/Ray%20Tracing_%20The%20Next%20Week.pdf)
[Ray Tracing in One Weekend和Ray Tracing: The Next Week的详解](https://www.cnblogs.com/lv-anchoret/category/1368696.html)
[基于OpenGL的GPU光线追踪](https://zhuanlan.zhihu.com/p/51387524)
[Webgl中采用PBR的实时光线追踪](https://zhuanlan.zhihu.com/p/58692781)
[Spatiotemporal Variance-Guided Filter, 向实时光线追踪迈进](https://zhuanlan.zhihu.com/p/28288053)
系统学习Ray Tracing的资料：[Ray Tracing Gems](http://www.realtimerendering.com/raytracinggems/unofficial_RayTracingGems_v1.6.pdf)






# 其它

## Bindless Texture


### 在WebGPU中，什么是bind texture？

[Investigation: Bindless resources](https://github.com/gpuweb/gpuweb/issues/380)提到：
> 
Currently, in WebGPU, if a draw/dispatch call wants to use a resource, that resource must be part of a pre-baked "bind group" and then associated with the draw call inside the current render/compute pass. This means that all the resources that the draw/dispatch call could possibly access are explicitly listed by the programmer at the draw/dispatch site.

也就是说，我们需要定义每个texture在shader的binding，然后在每次提交command时，绑定该texture。

我们来看具体的[textureCube](https://github.com/yyc-git/webgpu-samples/blob/master/src/examples/texturedCube.ts) sample：
绑定的texture需要在shader中指定binding：
```js
  //在fragment shader中指定binding为2
  const fragmentShaderGLSL = `#version 450
  ...
  layout(set = 0, binding = 2) uniform texture2D myTexture;
```

在BindGroup中，设置binding为2的相关数据：
```js
  const bindGroupLayout = device.createBindGroupLayout({
    bindings: [
    ...
    {
      // Texture view
      binding: 2,
      visibility: GPUShaderStage.FRAGMENT,
      type: "sampled-texture"
    }]
  });
  
  ...
  
  const uniformBindGroup = device.createBindGroup({
    layout: bindGroupLayout,
    bindings: [
    ...
    {
      binding: 2,
      resource: cubeTexture.createView(),
    }],
  });
```

把BindGroup设置到Pipeline中：
```js
  const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
  const pipeline = device.createRenderPipeline({
    layout: pipelineLayout,
    ...
  });
```


提交command时，设置该bind group和pipeline：
```js
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(0, uniformBindGroup);
    ...
    passEncoder.endPass();
```



### 在WebGPU中，什么是bindless texture？

[Investigation: Bindless resources](https://github.com/gpuweb/gpuweb/issues/380)提到：
> 
"Bindless" is a model where the programmer doesn't explicitly list all of the available resources at the draw/dispatch site. Instead, a large swath of resources are made available to the GPU ahead of time (e.g. during application launch) and then shaders can access any/all of them at runtime.

可以将所有的texture设置到一个buffer中，将其传给GPU，然后shader可以在运行时操作任意的texture。

这样的好处是我们不需要在每次提交command时绑定特定的texture，只需要绑定一次。


### 如果不支持bindless texture，可以使用texture 2d array替代

参考[approaching-zero-driver-overhead](https://www.slideshare.net/CassEveritt/approaching-zero-driver-overhead)->36页，我们可以使用texture 2d array代替bindless texture，只需要绑定一次texture 2d array，不需要在每次提交command时绑定特定的texture。

texture 2d array的优点参考：
[为什么要强调Texture2DArray在地形上的应用？](https://www.zhihu.com/question/56015505)

缺点是texture array中的每个texture的大小、格式要相同，而bindless texture没有该要求。

为了解决该缺点，我们可以按照大小和格式，把texture划分为多组，对应多个texture 2d array。


### WebGPU支持情况

从[Minutes for GPU Web meeting 2019-08-12](https://docs.google.com/document/d/18Ze0h9InJN5QWXe0iN9UzEebfiEIg8HYo-aX9rKvhuk/edit#heading=h.d3fou7jjp88m)中得知，目前还未决定何时实现bindless texture，可能实现为extension，可能在1.0版本后实现。

所以目前可考虑用texture 2d array作为替代品


### 参考资料
[OPENGL AZDO : BINDLESS TEXTURES : BATCHING PROBLEM SOLVED](http://cpp-rendering.io/opengl-azdo-bindless-textures/)




## Virtual Texture


### 思想

把所有要用到的texture拼到一起，组成physic texture；
通过索引，只把当前要用到的texture加载到内存中。

### 优点
1.只绑定一次texture
2.组成physic texture的子纹理的格式和mipmap等可以不一样；
3.减小了内存占用（内存中只有当前使用的texture）

### 缺点
因为要不断地在内存中加载/卸载texture，所以增加了IO开销

### 应用场景
- 地形纹理

### WebGPU支持情况
有人提出了[Investigation: Sparse Resources](https://github.com/gpuweb/gpuweb/issues/455)， 希望WebGPU增加操作堆heap的API。不过目前没有回应。

我目前不清楚WebGPU是否能实现virtual texture

### 参考资料
[approaching-zero-driver-overhead](https://www.slideshare.net/CassEveritt/approaching-zero-driver-overhead) -> Sparse Texture
[知乎->Virtual Texture Tools & Practices](https://zhuanlan.zhihu.com/p/83831633)
[关于对virtual texture的浅显认识](https://zhuanlan.zhihu.com/p/66567332)




## Tessellation

根据[Investigation: Tessellation](https://github.com/gpuweb/gpuweb/issues?utf8=%E2%9C%93&q=tess)：
> Let's wait until after the release of a MVP

WebGPU应该会在MVP后考虑加入Tessellation shader



## Mesh Shader

### 介绍
NVDIA在Turing架构中推出了新的管线，用来替代光栅化管线。新管线只保留了Pixel Shader（即fragment shader），新增了Task Shader和Mesh Shader，如下图所示：
![截屏2019-12-14下午4.04.43.png-79.7kB][6]

新管线更适合于GPU Driven Render Pipeline的理念，包括以下的特性：
类似于Compute管线（compute shader），具有强大的计算能力；
把Mesh分解为Meshlet（类似于GPU Driven Render Pipeline中提到的Cluster），更好地支持cluster cull。


### WebGPU支持情况

根据[Investigation: Tessellation](https://github.com/gpuweb/gpuweb/issues?utf8=%E2%9C%93&q=tess)中的讨论，因为Vulkan和Metal还没支持Mesh Shader，所以WebGPU至少要等它们支持后才会考虑支持。




### 参考资料


[DX12支持了Mesh Shader](https://devblogs.microsoft.com/directx/dev-preview-of-new-directx-12-features/)
[Introduction to Turing Mesh Shaders](https://devblogs.nvidia.com/introduction-turing-mesh-shaders/#toc4)
[怎么评价nvidia 推出mesh shader管线？](https://www.zhihu.com/question/296664537/answer/501329775)


  [1]: http://static.zybuluo.com/yangyc/djiofp9ahz6gsk8hi2ue6lmw/%E7%8E%B0%E4%BB%A3%E5%9B%BE%E5%BD%A2API%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B91%20%284%29.png
  [2]: http://static.zybuluo.com/yangyc/bxilez1nulia6lxpu8qjihgs/%E6%88%AA%E5%B1%8F2019-12-12%E4%B8%8B%E5%8D%887.50.08.png
  [3]: http://static.zybuluo.com/yangyc/r8voicjst50bbzgcjmf2wt0g/%E6%88%AA%E5%B1%8F2019-12-12%E4%B8%8B%E5%8D%888.15.25.png
  [4]: http://static.zybuluo.com/yangyc/i1hkkbd4b3czv82molng6ngb/%E6%88%AA%E5%B1%8F2019-12-12%E4%B8%8B%E5%8D%888.47.46.png
  [5]: http://static.zybuluo.com/yangyc/h2x31jx0yaags83gm5hwy1m8/%E6%88%AA%E5%B1%8F2019-12-14%E4%B8%8B%E5%8D%883.31.15.png
  [6]: http://static.zybuluo.com/yangyc/500ch687a0o3cvsatxk627xz/%E6%88%AA%E5%B1%8F2019-12-14%E4%B8%8B%E5%8D%884.04.43.png]]></description></item><item><title>WebGPU学习系列目录</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/08/12005108.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sun, 08 Dec 2019 03:30:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/08/12005108.html</guid><description><![CDATA[# 介绍

大家好，本系列从0开始学习WebGPU API，并给出相关的demo。

## WebGPU介绍
WebGPU是最新的Web 3D图形API，是WebGL的升级版。
浏览器封装了现代图形API（Dx12、Vulkan、Metal），提供给Web 3D程序员WebGPU API。

![截屏2019-12-24下午4.44.33.png-119.7kB][1]
（图来自于[WebGPU 开发状态与计划](https://www.w3.org/2018/11/17-chinese-web-gpu.pdf)）


## 为什么要学习WebGPU

- WebGPU更好地支持多线程

- WebGPU支持compute shader，从而让程序员能利用GPU实现很多优化


- WebGPU与WebGL2的区别很大，两者不容易兼容。如果要从WebGL1升级，最好直接升级到WebGPU，一劳永逸
- WebGPU是标准，各大浏览器都会支持。不像WebGL2，苹果直接不支持。

- 目前WebGPU虽然还未正式发布，但已经比较成熟了，也有相关的Demo可供学习




# 目录
## 第一部分：
- [WebGPU学习（一）: 开篇](https://www.cnblogs.com/chaogex/p/11986568.html)
- [WebGPU学习（二）: 学习“绘制一个三角形”示例](https://www.cnblogs.com/chaogex/p/11993144.html)
- [WebGPU学习（三）:MSAA](https://www.cnblogs.com/chaogex/p/12003722.html)
- [WebGPU学习（四）:Alpha To Coverage](https://www.cnblogs.com/chaogex/p/12004546.html)
- [WebGPU学习（五）: 现代图形API技术要点和WebGPU支持情况调研](https://www.cnblogs.com/chaogex/p/12041286.html)
- [WebGPU学习（六）：学习“rotatingCube”示例](https://www.cnblogs.com/chaogex/p/12079739.html)
- [WebGPU学习（七）：学习“twoCubes”和“instancedCube”示例](https://www.cnblogs.com/chaogex/p/12081022.html)
- [WebGPU学习（八）：学习“texturedCube”示例](https://www.cnblogs.com/chaogex/p/12091529.html)
- [WebGPU学习（九）：学习“fractalCube”示例](https://www.cnblogs.com/chaogex/p/12097129.html)
- [WebGPU学习（十）：介绍“GPU实现粒子效果”](https://www.cnblogs.com/chaogex/p/12101154.html)
- [WebGPU学习（十一）：学习两个优化：“reuse render command buffer”和“dynamic uniform buffer offset”](https://www.cnblogs.com/chaogex/p/12112704.html)


  [1]: http://static.zybuluo.com/yangyc/fjolhub41h697j3c87k6x8lk/%E6%88%AA%E5%B1%8F2019-12-24%E4%B8%8B%E5%8D%884.44.33.png]]></description></item><item><title>WebGPU学习（四）:Alpha To Coverage</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/08/12004546.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sun, 08 Dec 2019 00:11:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/08/12004546.html</guid><description><![CDATA[大家好，本文学习与MSAA相关的Alpha To Coverage以及在WebGPU中的实现。


上一篇博文
[WebGPU学习（三）:MSAA](https://www.cnblogs.com/chaogex/p/12003722.html)

下一篇博文
[WebGPU学习（五）: 现代图形API技术要点和WebGPU支持情况调研](https://www.cnblogs.com/chaogex/p/12041286.html)

# 学习Alpha To Coverage

## 前置知识

- [WebGPU学习（三）:MSAA](https://zhuanlan.zhihu.com/p/95930763)
- 一个fragment对应一个像素


## 介绍

开启了MSAA和Alpha To Coverage后，fragment的alpha值（fragment shader输出的颜色的alpha值）会影响该fragment对应像素的采样点是否被覆盖。





## 动机


参考[乱弹纪录II:Alpha To Coverage](http://www.zwqxin.com/archives/opengl/talk-about-alpha-to-coverage.html)：
![截屏2019-12-07下午3.48.09.png-220.6kB][1]
![截屏2019-12-07下午3.48.17.png-844.8kB][2]
![截屏2019-12-07下午3.48.23.png-203.1kB][3]
![截屏2019-12-07下午3.48.29.png-774.9kB][4]
![截屏2019-12-07下午9.25.41.png-380.3kB][5]



## 原理

### 覆盖检测

通过[WebGPU学习（三）:MSAA](https://zhuanlan.zhihu.com/p/95930763)对MSAA原理的介绍，我们知道gpu要经过覆盖检测的步骤，来决定哪些采样点被覆盖。没有被覆盖的采样点不会进入“解析”步骤。


覆盖检测的结果是计算出每个fragment的coverage（覆盖率）。

根据[乱弹纪录II:Alpha To Coverage](http://www.zwqxin.com/archives/opengl/talk-about-alpha-to-coverage.html) 的说法，开启MSAA后，每个fragment带了一个新属性coverage（覆盖率），它是一个二进制的bit掩码mask。

以4X MSAA为例，每个fragment的coverage为xxxx，其中x为0或1。它的每一位对应像素的一个采样点sample，0表示该sample没被覆盖，1表示被覆盖。



所以coverage这个掩码对应了采样点的覆盖情况。


### 如何计算coverage

1.用户可以设置一个固定的coverage掩码，这里命名为FixedSampleMask

2.gpu检测每个像素有哪些采样点被primitive覆盖，得到该采样点的coverage掩码，这里命名为RasterizerCoverageMask

3.如果开启了Alpha To Coverage，则会将fragment的alpha值转换为coverage掩码，这里命名为AlphaCoverageMask


转换的算法可以参考[乱弹纪录II:Alpha To Coverage](http://www.zwqxin.com/archives/opengl/talk-about-alpha-to-coverage.html) ：
> 一个fragment的Alpha值在0~1间，它对应着一个dither mask。还是以4XMSAA为例，这个dither mask也是xxxx的形式，Alpha为0对应了0000，alpha为1对应了1111，至于中间的值的对应关系，OpenGL是交由显卡制造商决定的——其实一般就是类似[0~0.249 -> 0000, 0.25~0.499 -> 0001, 0.5~0.749 -> 0011, 0.75~0.99-> 0111]这样。



4.fragment shader可以输出该fragment的coverage掩码，这里称为FragShaderSampleMaskOutput



像素最终的coverage = FixedSampleMask & RasterizerCoverageMask & AlphaCoverageMask & FragShaderSampleMaskOutput
（“&”是逻辑与运算，如0011 & 0010 = 0010）







## 参考资料
[乱弹纪录II:Alpha To Coverage](http://www.zwqxin.com/archives/opengl/talk-about-alpha-to-coverage.html)


# WebGPU实现Alpha To Coverage

暂时没有实现的sample，我们根据WebGPU规范和相关资料，分析下WebGPU如何实现Alpha To Coverage。

- 在render pipeline descriptor中设置固定的coverage掩码FixedSampleMask和是否开启Alpha To Coverage：
```js
dictionary GPURenderPipelineDescriptor : GPUPipelineDescriptorBase {
...
    unsigned long sampleMask = 0xFFFFFFFF;
    boolean alphaToCoverageEnabled = false;
...    
};
```

我们注意到sampleMask是unsigned long类型，它是32位的，而coverage应该是二进制的（如4X MSAA的coverage是4位的二进制），所以这里是进行了进制转换。

举例来说：
对于4X MSAA，如果设置sampleMask为0x1（十六进制），则它转换为二进制是0001；
如果设置sampleMask为0x3，则它转换为二进制是0010

- 可以在fragment shader中设置输出的coverage掩码FragShaderSampleMaskOutput

根据[Investigation: Multisample Coverage](https://github.com/gpuweb/gpuweb/issues/267)，我们知道Vulkan->SPIR-V的fragment shader支持内置的SampleMask变量。

因为Chrome实现的WebGPU也使用SPIR-V作为shader编译后的字节码，所以WebGPU在这点上应该与Vulkan类似。

我没有搜索到SPIR-V中关于SampleMask的详细资料，但是考虑到Chrome实现的WebGPU使用GLSL 4.5，所以我们可以看下它关于gl_SampleMask的[说明](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/gl_SampleMask.xhtml)：
> Name
gl_SampleMask — specifies the sample coverage mask for the current fragment
Declaration
out int gl_SampleMask[] ;

我们看到gl_SampleMask的每个元素的类型是32位的，所以也进行了进制转换。

又因为它是数组，所以它支持coverage为超过32位的二进制（如支持64X MSAA）

用代码来说明：
```js
//in fragment shader

gl_SampleMask[0] = 1;   //对于4X MSAA来说，相当于设置该fragment的coverage为0001

```


```js
//in fragment shader

gl_SampleMask[0] = 2;

gl_SampleMask[1] = 1;   //对于64X MSAA来说，可能相当于设置该fragment的coverage为000...1000...10 （前面的000...1有32位，后面的000...10有32位） (我不能确定这是否正确！)

```



- 如果开启了Alpha To Coverage，则不能在fragment shader中输出coverage掩码



- 如果开启了Alpha To Coverage，将alpha转换为掩码的算法在不同的浏览器中不一样



## 参考资料
[Investigation: Multisample Coverage](https://github.com/gpuweb/gpuweb/issues/267)
[Minutes for GPU Web meeting 2019-04-29](https://docs.google.com/document/d/1RxZx6K2eytCCNI593YtEDgyxP84iuG0xvcS-Fr2EZsk/edit#heading=h.o7nziwf8wb1n)
[OpenGL->gl_SampleMask](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/gl_SampleMask.xhtml)


  [1]: http://static.zybuluo.com/yangyc/lmv12ihkuodtb2i78xl3wd9y/%E6%88%AA%E5%B1%8F2019-12-07%E4%B8%8B%E5%8D%883.48.09.png
  [2]: http://static.zybuluo.com/yangyc/mkusa81g92wg3tqpxtmc042h/%E6%88%AA%E5%B1%8F2019-12-07%E4%B8%8B%E5%8D%883.48.17.png
  [3]: http://static.zybuluo.com/yangyc/mdnlj97g7wofgjojbndboko7/%E6%88%AA%E5%B1%8F2019-12-07%E4%B8%8B%E5%8D%883.48.23.png
  [4]: http://static.zybuluo.com/yangyc/wp14rb2jpm7ijbfqhzkf5vpm/%E6%88%AA%E5%B1%8F2019-12-07%E4%B8%8B%E5%8D%883.48.29.png
  [5]: http://static.zybuluo.com/yangyc/io5jm4efldzjo9mlkrnv6ftc/%E6%88%AA%E5%B1%8F2019-12-07%E4%B8%8B%E5%8D%889.25.41.png]]></description></item><item><title>WebGPU学习（三）:MSAA</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/07/12003722.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sat, 07 Dec 2019 14:24:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/07/12003722.html</guid><description><![CDATA[大家好，本文学习MSAA以及在WebGPU中的实现。


上一篇博文
[WebGPU学习（二）: 学习“绘制一个三角形”示例](https://www.cnblogs.com/chaogex/p/11993144.html)

下一篇博文
[WebGPU学习（四）:Alpha To Coverage](https://www.cnblogs.com/chaogex/p/12004546.html)


# 学习MSAA

## 介绍

MSAA（多重采样抗锯齿），是硬件实现的抗锯齿技术


## 动机

参考[深入剖析MSAA](https://www.cnblogs.com/ghl_carmack/p/8245032.html) ：
> 
具体到实时渲染领域中，走样有以下三种：
1.几何体走样（几何物体的边缘有锯齿），几何走样由于对几何边缘采样不足导致。
2.着色走样，由于对着色器中着色公式（渲染方程）采样不足导致。比较明显的现象就是高光闪烁。
3.时间走样，主要是对高速运动的物体采样不足导致。比如游戏中播放的动画发生跳变等。


这里讨论几何体走样。
![anti_aliasing_rasterization.png-27.2kB][1]

如上图所示，我们要绘制一个三角形。它由三个顶点组成，红线范围内的三角形是片元primitive覆盖的区域。
primitive会被光栅化为fragment，而一个fragment最终对应屏幕上的一个像素，如图中的小方块所示。

gpu会根据像素中心的采样点是否被pritimive覆盖来判断是否生成该fragment和执行对应的fragment shader。

图中红色的点是被覆盖的采样点，它所在的像素会被渲染。


下图是最终渲染的结果，我们看到三角形边缘产生了锯齿：
![anti_aliasing_rasterization_filled.png-14.2kB][2]












## 原理

MSAA通过增加采样点来减轻几何体走样。
它包括4个步骤：
1.针对采样点进行覆盖检测
2.每个被覆盖的fragment执行一次fragment shader
3.针对采样点进行深度检测和模版检测
4.解析（resolve）



下面以4X MSAA为例（每个像素有4个采样点），说明每个步骤：

1.针对采样点进行覆盖检测

gpu会计算每个fragment的coverage（覆盖率），从而得知对应像素的每个采样点是否被覆盖的信息。

 
coverage相关知识可以参考[WebGPU学习（四）:Alpha To Coverage](https://zhuanlan.zhihu.com/p/95931422) -> 学习Alpha To Coverage -> 原理

这里为了简化，我们只考虑通过“检测每个像素有哪些采样点被primitive覆盖”来计算coverager：

![anti_aliasing_rasterization_samples.png-38.9kB][4]

如上图所示，蓝色的采样点是在三角形中，是被覆盖的采样点。


2.每个被覆盖的fragment执行一次fragment shader

如果一个像素至少有一个采样点被覆盖，那么会执行一次它对应的fragment（注意，只执行一次哈，不是执行4次）（它所有的输入varying变量都是针对其像素中心点而言的，所以计算的输出的颜色始终是针对该栅格化出的像素中心点而言的），输出的颜色保存在color buffer中（覆盖的采样点都要保存同一个输出的颜色）



3.针对采样点进行深度检测和模版检测

所有采样点的深度值和模版值都要存到depth buffer和stencil buffer中（无论是否被覆盖）。

被覆盖的采样点会进行深度检测和模版检测，通过了的采样点会进入“解析”步骤。

那为什么要保存所有采样点的深度和模版值了（包括没有被覆盖的）？因为它们在深度检测和模版检测阶段决定所在的fragment是否被丢弃：

> 那是因为之后需要每个sample（采样点）都执行一下depth-test，以确定整个fragment是否要流向（通往缓冲区输出的）流水线下一阶段——只有当全部fragment-sample的Depth-Test都Fail掉的时候，才决定抛弃掉这个fragment（蒙版值stencil也是这样的，每个sample都得进行Stencil-Test）。



4.解析

什么是解析？

根据[深入剖析MSAA](https://www.cnblogs.com/ghl_carmack/p/8245032.html) 的说法：
> 像超采样一样，过采样的信号必须重新采样到指定的分辨率，这样我们才可以显示它。
这个过程叫解析（resolving）。

根据[乱弹纪录II:Alpha To Coverage](http://www.zwqxin.com/archives/opengl/talk-about-alpha-to-coverage.html) 的说法：
> 在把所有像素输出到渲染缓冲区前执行Resolve以生成单一像素值。
> 。。。。。。
> 也该是时候谈到一直说的“计算输出的颜色”是怎么一回事了。MultiSample的Resolve阶段，如果是屏幕输出的话这个阶段会发生在设备的屏幕输出直前；如果是FBO输出，则是发生在把这个Multisample-FBO映射到非multisample的FBO（或屏幕）的时候（见[多重采样(MultiSample)下的FBO反锯齿] ）。Resolve，说白了就是把MultiSample的存储区域的数据，根据一定法则映射到可以用于显示的Buffer上了（这里的输出缓冲区包括了Color、Depth或还有Stencil这几个）。Depth和Stencil前面已经提及了法则了，Color方面其实也简单，一般的显卡的默认处理就是把sample的color取平均了。注意，因为depth-test等Test以及Coverage mask的影响下，有些sample是不参与计算的（被摒弃），例如4XMSAA下上面的0101，就只有两个sample，又已知各sample都对应的只是同一个颜色值，所以输出的颜色 = 2 * fragment color / 4 = 0.5 * fragment color。也就是是说该fragemnt最终显示到屏幕（或Non-MS-FBO）上是fragment shader计算出的color值的一半——这不仅是颜色亮度减半还包括真·透明度值的减半。

我的理解：
“解析”是把每个像素经过上述步骤得到的采样点的颜色值，取平均值，得到这个像素的颜色值。


![anti_aliasing_sample_points.png-6.7kB][5]
如上图右边所示，像素的2个采样点进入了“解析”，最终该像素的颜色值为 0.5（2/4） * 原始颜色值


经过上述所有步骤后，最终的渲染结果如下：
![anti_aliasing_rasterization_samples_filled.png-50.4kB][3]





## 总结
MSAA能减轻几何体走样，但会增加color buffer、depth buffer、stencil buffer开销。




## 参考资料

[深入剖析MSAA](https://www.cnblogs.com/ghl_carmack/p/8245032.html) 
[乱弹纪录II:Alpha To Coverage](http://www.zwqxin.com/archives/opengl/talk-about-alpha-to-coverage.html) 
[Anti Aliasing](https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing) 


# WebGPU实现MSAA

有下面几个要点：

- 能够查询最大的采样个数sample count

目前我没找到查询的方法，但至少支持4个采样点

参考 [Investigation: Multisampled Render Targets and Resolve Operations](https://github.com/gpuweb/gpuweb/issues/108)：
> We can say that 4xMSAA is guaranteed on all WebGPU implementations, and we need to provide APIs for queries on whether we can create a multisampled texture with given format and sample count.

- 设置sample count

```js
dictionary GPURenderPipelineDescriptor : GPUPipelineDescriptorBase {
...
    unsigned long sampleCount = 1;
...
};
```

```js
dictionary GPUTextureDescriptor : GPUObjectDescriptorBase {
...
    unsigned long sampleCount = 1;
...
};
```

我们在WebGPU 规范中看到render pipeline descriptor和texture descriptor可以设置sampleCount。



- 设置resolveTarget

在“解析”步骤中，需要重新采样到指定的分辨率：
> 过采样的信号必须重新采样到指定的分辨率，这样我们才可以显示它

所以我们应该设置color的resolveTarget（depth、stencil不支持resolveTarget），它包含“分辨率”的信息。

我们来看下WebGPU 规范：
```js
dictionary GPURenderPassColorAttachmentDescriptor {
    required GPUTextureView attachment;
    GPUTextureView resolveTarget;

    required (GPULoadOp or GPUColor) loadValue;
    GPUStoreOp storeOp = "store";
};
```


resolveTarget在render pass colorAttachment descriptor中设置，它的类型是GPUTextureView。

而GPUTextureView是从GPUTexture得来的，我们来看下GPUTexture的descriptor的定义：
```js
dictionary GPUExtent3DDict {
    required unsigned long width;
    required unsigned long height;
    required unsigned long depth;
};
typedef (sequence<unsigned long> or GPUExtent3DDict) GPUExtent3D;

dictionary GPUTextureDescriptor : GPUObjectDescriptorBase {
...
  required GPUExtent3D size;
...
};
```

GPUTextureDescriptor的size属性有width和height属性，只要texture对应了屏幕大小，我们就能获得屏幕“分辨率”的信息（depth设为1，因为分辨率只有宽、高，没有深度）。




## 实现sample

我们对应到sample来看下。

打开webgpu-samplers->[helloTriangleMSAA.ts](https://github.com/yyc-git/webgpu-samples/blob/master/src/examples/helloTriangleMSAA.ts)文件。

代码基本上与我们上篇文章学习的webgpu-samplers->[helloTriangle.ts](https://github.com/yyc-git/webgpu-samples/blob/master/src/examples/helloTriangle.ts)差不多，

### 我们看下创建render pipeline代码
```js
    const sampleCount = 4;

    const pipeline = device.createRenderPipeline({
    ...
      sampleCount,
    });
```

这里设置了sample count为4

### 我们看下frame函数->render pass descrptor代码

```js
      const renderPassDescriptor: GPURenderPassDescriptor = {
        colorAttachments: [{
          attachment: attachment,
          resolveTarget: swapChain.getCurrentTexture().createView(),
          ...
        }],
      };
```

- 设置attachment为多重采样的texture的view

该texture的创建代码为：
```js
    const texture = device.createTexture({
      size: {
        width: canvas.width,
        height: canvas.height,
        depth: 1,
      },
      sampleCount,
      format: swapChainFormat,
      usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
    });
    const attachment = texture.createView();
```

注意：texture的sampleCount应该与render pipeline的sampleCount一样，都是4

- 设置resolveTarget为swapChain对应的view

swapChain.getCurrentTexture()获得的texture的大小是与屏幕相同，所以它包含了屏幕分辨率的信息。









## 参考资料
[helloTriangleMSAA.ts](https://github.com/yyc-git/webgpu-samples/blob/master/src/examples/helloTriangleMSAA.ts)
[Investigation: Multisampled Render Targets and Resolve Operations](https://github.com/gpuweb/gpuweb/issues/108)












  [1]: http://static.zybuluo.com/yangyc/om4z7x4lusftwt7642y3xrrh/anti_aliasing_rasterization.png
  [2]: http://static.zybuluo.com/yangyc/8er2iz8w2t8b1mlgs7glo1ih/anti_aliasing_rasterization_filled.png
  [3]: http://static.zybuluo.com/yangyc/wn4yhw09z3t176l0tdbv5ba1/anti_aliasing_rasterization_samples_filled.png
  [4]: http://static.zybuluo.com/yangyc/p1m2rlkcpv0djl80fzqqo2lc/anti_aliasing_rasterization_samples.png
  [5]: http://static.zybuluo.com/yangyc/sgbvsm5mglxgw2ngdys0ox29/anti_aliasing_sample_points.png]]></description></item><item><title>WebGPU学习（二）: 学习“绘制一个三角形”示例</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/06/11993144.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Fri, 06 Dec 2019 00:34:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/06/11993144.html</guid><description><![CDATA[大家好，本文学习Chrome->webgpu-samplers->helloTriangle示例。

上一篇博文：
[WebGPU学习（一）: 开篇](https://www.cnblogs.com/chaogex/p/11986568.html)

下一篇博文：
[WebGPU学习（三）:MSAA](https://www.cnblogs.com/chaogex/p/12003722.html)

# 准备Sample代码

克隆[webgpu-samplers Github Repo](https://github.com/yyc-git/webgpu-samples)到本地。
（备注：当前的version为0.0.2）

实际的sample代码在src/examples/文件夹中，是typescript代码写的：
![截屏2019-12-04下午3.53.16.png-64.7kB][1]







# 学习helloTriangle.ts

打开helloTriangle.ts文件，我们来看下init函数的内容。

## 首先是shader代码
```ts
    const vertexShaderGLSL = `#version 450
      const vec2 pos[3] = vec2[3](vec2(0.0f, 0.5f), vec2(-0.5f, -0.5f), vec2(0.5f, -0.5f));

      void main() {
          gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);
      }
    `;

    const fragmentShaderGLSL = `#version 450
      layout(location = 0) out vec4 outColor;

      void main() {
          outColor = vec4(1.0, 0.0, 0.0, 1.0);
      }
    `;
```

这里是vertex shader和fragment shader的glsl代码。

（webgpu支持vertex shader、fragment shader、compute shader，这里只使用了前面两个）

“#version 450”声明了glsl版本为4.5（它要放在glsl的第一行）

第2行定义了三角形的三个顶点坐标，使用2维数组保存（每个元素为vec2类型）。因为都在一个平面，所以顶点只定义了x、y坐标（顶点的z为0.0）

第5行的gl_VertexIndex为顶点序号，每次执行时值依次为0、1、2（vertex shader被执行了3次，因为只有3个顶点）（具体见本文末尾对draw的分析）

第9行是fragment shader，因为三角形为一个颜色，所以所有片段的颜色为同一个固定值


## 然后我们继续看下面的代码
```ts
    const adapter = await navigator.gpu.requestAdapter();
    const device = await adapter.requestDevice();
    // 准备编译glsl的库
    const glslang = await glslangModule();
    // 获得webgpu上下文
    const context = canvas.getContext('gpupresent');
```

第4行的glslangModule是import的第三方库：
```ts
import glslangModule from '../glslang';
```


## 继续往下看
```ts
    // 定义swapbuffer的格式为RGBA8位的无符号归一化格式
    const swapChainFormat = "bgra8unorm";

    // @ts-ignore:
    const swapChain: GPUSwapChain = context.configureSwapChain({
      device,
      format: swapChainFormat,
    });
```

@ts-ignore是typescript用来忽略错误的。因为context的类型是RenderingContext，它没有定义configureSwapChain函数，如果编译该行typescript会报错，所以需要忽略错误。

第5行配置了swap chain。[vulkan tutorial](https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain)对此进行了说明：
swap chain是一个缓冲结构，webgpu会先将内容渲染到swap chain的buffer中，然后再将其显示到屏幕上；
swap chain本质上是等待呈现在屏幕上的一个图片队列。


## 接下来就是创建render pipeline
```ts
    const pipeline = device.createRenderPipeline({
      layout: device.createPipelineLayout({ bindGroupLayouts: [] }),

      vertexStage: {
        module: device.createShaderModule({
          code: glslang.compileGLSL(vertexShaderGLSL, "vertex"),

          // @ts-ignore
          source: vertexShaderGLSL,
          transform: source => glslang.compileGLSL(source, "vertex"),
        }),
        entryPoint: "main"
      },
      fragmentStage: {
        module: device.createShaderModule({
          code: glslang.compileGLSL(fragmentShaderGLSL, "fragment"),

          // @ts-ignore
          source: fragmentShaderGLSL,
          transform: source => glslang.compileGLSL(source, "fragment"),
        }),
        entryPoint: "main"
      },

      primitiveTopology: "triangle-list",

      colorStates: [{
        format: swapChainFormat,
      }],
    });
```

### 了解pipeline

WebGPU有两种pipeline:render pipeline和compute pipeline，这里只用了render pipeline

这里使用render pipeline descriptor来创建render pipeline，它的定义如下：
```ts
dictionary GPUPipelineDescriptorBase : GPUObjectDescriptorBase {
    required GPUPipelineLayout layout;
};

...

dictionary GPURenderPipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUProgrammableStageDescriptor vertexStage;
    GPUProgrammableStageDescriptor fragmentStage;

    required GPUPrimitiveTopology primitiveTopology;
    GPURasterizationStateDescriptor rasterizationState = {};
    required sequence<GPUColorStateDescriptor> colorStates;
    GPUDepthStencilStateDescriptor depthStencilState;
    GPUVertexStateDescriptor vertexState = {};

    unsigned long sampleCount = 1;
    unsigned long sampleMask = 0xFFFFFFFF;
    boolean alphaToCoverageEnabled = false;
    // TODO: other properties
};
```

render pipeline可以设置绑定的资源布局、编译的shader、fixed functions（如混合、深度、模版、cullMode等各种状态和顶点数据的格式vertexState），相对于WebGL（WebGL的一个API只能设置一个，如使用gl.cullFace设置cull mode），提升了性能（静态设置了各种状态，不需要在运行时设置），便于管理（把各个状态集中到了一起设置）。


### 分析render pipeline descriptor
vertexStage和fragmentStage分别设置vertex shader和fragment shader：
使用第三方库，将glsl编译为字节码（格式为SPIR-V）；
source和transform字段是多余的，可以删除。


因为shader没有绑定资源（如uniform buffer, texture等），所以第2行的bindGroupLayouts为空数组，不需要bind group和bind group layout




第25行的primitiveTopology指定片元的拓扑结构，此处为三角形。
它可以为以下值：
```ts
enum GPUPrimitiveTopology {
    "point-list",
    "line-list",
    "line-strip",
    "triangle-list",
    "triangle-strip"
};
```



现在先忽略colorStates



## 我们继续分析后面的代码，接下来定义了frame函数

frame函数定义了每帧执行的逻辑：
```ts
    function frame() {
      const commandEncoder = device.createCommandEncoder({});
      const textureView = swapChain.getCurrentTexture().createView();

      const renderPassDescriptor: GPURenderPassDescriptor = {
        colorAttachments: [{
          attachment: textureView,
          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
        }],
      };

      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setPipeline(pipeline);
      passEncoder.draw(3, 1, 0, 0);
      passEncoder.endPass();

      device.defaultQueue.submit([commandEncoder.finish()]);
    }

    return frame;
```

### 学习command buffer

我们不能直接操作command buffer，需要创建command encoder，使用它将多个commands（如render pass的draw）设置到一个command buffer中，然后执行submit，把command buffer提交到gpu driver的队列中。

根据 webgpu设计文档->[Command Submission](https://github.com/gpuweb/gpuweb/blob/master/design/CommandSubmission.md):
> Command buffers carry sequences of user commands on the CPU side. They can be recorded independently of the work done on GPU, or each other. They go through the following stages:
creation -> "recording" -> "ready" -> "executing" -> done

我们知道，command buffer有
creation, recording,ready,executing,done五种状态。

根据该文档，结合代码来分析command buffer的操作流程：
第2行创建command encoder时，应该是创建了command buffer，它的状态为creation；
第12行开始render pass（webgpu还支持compute pass，不过这里没用到），command buffer的状态变为recording；
13-14行将“设置pipeline”、“绘制”的commands设置到command buffer中；
第15行结束render pass，(可以设置下一个pass，如compute pass，不过这里只用了一个pass）；
第17行“commandEncoder.finish()”将command buffer的状态变为ready；
然后执行subimit，command buffer状态变为executing，被提交到gpu driver的队列中，不能再在cpu端被操作；
如果提交成功，gpu会决定在某个时间处理它。



### 分析render pass

第5行的renderPassDescriptor描述了render pass，它的定义为：
```ts
dictionary GPURenderPassDescriptor : GPUObjectDescriptorBase {
    required sequence<GPURenderPassColorAttachmentDescriptor> colorAttachments;
    GPURenderPassDepthStencilAttachmentDescriptor depthStencilAttachment;
};
```

这里只用到了colorAttachments。它类似于WebGL->framebuffer的colorAttachments。这里只用到了一个color buffer attachment。


我们来看下colorAttachment的定义：
```ts
dictionary GPURenderPassColorAttachmentDescriptor {
    required GPUTextureView attachment;
    GPUTextureView resolveTarget;

    required (GPULoadOp or GPUColor) loadValue;
    GPUStoreOp storeOp = "store";
};
```


这里设置attachment，将其与swap chain关联：
```ts
          attachment: textureView,
```

我们现在忽略resolveTarget。

loadValue和storeOp决定渲染前和渲染后怎样处理attachment中的数据。
我们看下它的类型：
```ts
enum GPULoadOp {
    "load"
};
enum GPUStoreOp {
    "store",
    "clear"
};

...
dictionary GPUColorDict {
    required double r;
    required double g;
    required double b;
    required double a;
};
typedef (sequence<double> or GPUColorDict) GPUColor;
```

loadValue如果为GPULoadOp类型，则只有一个值：“load”，它的意思是渲染前保留attachment中的数据；
如果为GPUColor类型（如这里的{ r: 0.0, g: 0.0, b: 0.0, a: 1.0 }），则不仅为"load"，而且设置了渲染前的初始值，类似于WebGL的clearColor。

storeOp如果为“store”，意思是渲染后保存被渲染的内容到内存中，后面可以被读取；
如果为“clear”，意思是渲染后清空内容。


现在我们回头看下render pipeline中的colorStates：
```ts
      colorStates: [{
        format: swapChainFormat,
      }],
```

colorStates与colorAttachments对应，也只有一个，它的format应该与swap chain的format相同


我们继续看render pass代码:
```ts
      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setPipeline(pipeline);
      passEncoder.draw(3, 1, 0, 0);
      passEncoder.endPass();
```
draw的定义为：
```ts
void draw(unsigned long vertexCount, unsigned long instanceCount,
              unsigned long firstVertex, unsigned long firstInstance);
```

三角形有3个顶点，这里只绘制1个实例，两者都从0开始（所以vertex shader中的gl_VertexIndex依次为0、1、2），所以第3行为“draw(3, 1, 0, 0)”


## 最终渲染结果
![截屏2019-12-04下午9.53.50.png-8kB][6]


# 参考资料
[webgpu-samplers Github Repo](https://github.com/yyc-git/webgpu-samples)
[vulkan tutorial](https://vulkan-tutorial.com/Introduction)
[webgpu设计文档->Command Submission](https://github.com/gpuweb/gpuweb/blob/master/design/CommandSubmission.md)
[WebGPU-4](https://blog.csdn.net/caxieyou/article/details/94631287)



  [1]: http://static.zybuluo.com/yangyc/78dc1oxrsvstvcaa36pmgv3c/%E6%88%AA%E5%B1%8F2019-12-04%E4%B8%8B%E5%8D%883.53.16.png
  [6]: http://static.zybuluo.com/yangyc/27ponnq38o0e1fzifo3k75hd/%E6%88%AA%E5%B1%8F2019-12-04%E4%B8%8B%E5%8D%889.53.50.png]]></description></item><item><title>WebGPU学习（一）: 开篇</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/05/11986568.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Thu, 05 Dec 2019 00:39:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/05/11986568.html</guid><description><![CDATA[# 介绍

大家好，本系列从0开始学习WebGPU API，并给出相关的demo。


上一篇博文
[WebGPU学习系列目录](https://www.cnblogs.com/chaogex/p/12005108.html)
下一篇博文
[WebGPU学习（二）: 学习“绘制一个三角形”示例](https://www.cnblogs.com/chaogex/p/11993144.html)

## WebGPU介绍

参考[WebGPU 开发状态与计划](https://www.w3.org/2018/11/17-chinese-web-gpu.pdf)：

WebGL是老的Web 3D图形API，它的版本演进如下图所示：
![截屏2019-12-24下午4.32.02.png-140.5kB][1]

WebGPU是最新的Web 3D图形API，与WebGL的对比为：
![截屏2019-12-24下午4.42.45.png-108.5kB][2]

浏览器封装了现代图形API（Dx12、Vulkan、Metal），提供给Web 3D程序员WebGPU API。

WebGPU概要：
![截屏2019-12-24下午4.44.33.png-119.7kB][3]



## 为什么要学习WebGPU

- WebGPU更好地支持多线程

- WebGPU支持compute shader，从而让程序员能利用GPU实现很多优化


- WebGPU与WebGL2的区别很大，两者不容易兼容。如果要从WebGL1升级，最好直接升级到WebGPU，一劳永逸
- WebGPU是标准，各大浏览器都会支持。不像WebGL2，苹果直接不支持。

- 目前WebGPU虽然还未正式发布，但已经比较成熟了，也有相关的Demo可供学习


## WebGPU完善程度

自从2017年提出WebGPU后，已经经过两年的发展。
目前Chrome和Safari支持得比较好，基本功能都有了（比如能够绘制pbr材质的模型，支持compute shader等），而且已经可以在MacOS中运行。


Babylonjs已经支持了WebGPU，详见[WebGPU 文档](https://doc.babylonjs.com/extensions/webgpu)。

不过WebGPU对于shader使用哪种方案还没有确定：
在Chrome中，使用4.5版本的glsl ，需要通过官方提供的第三方库将其转成二进制码（SPIR-V）；
在Safari中，直接使用新的语言[WSL](https://webkit.org/blog/8482/web-high-level-shading-language/)，不需要转换。

前者的好处是我们熟悉glsl，学习成本低；
后者的好处是新语言功能更强大，性能更好。




- 参考资料
 
[WebGPU 开发状态与计划-2018.11.17](https://www.w3.org/2018/11/17-chinese-web-gpu.pdf)
[Implementation Status](https://github.com/gpuweb/gpuweb/wiki/Implementation-Status)
[WebGPU and WSL in Safari](https://webkit.org/blog/9528/webgpu-and-wsl-in-safari/)
[WebGPU and WSL in Web Inspector](https://webkit.org/blog/9624/webgpu-and-wsl-in-web-inspector/)
[Babylonjs->WebGPU 文档](https://doc.babylonjs.com/extensions/webgpu)
[webgpu-samples for Chrome (uses GLSL via SPIR-V)](https://github.com/yyc-git/webgpu-samples)
[WebKit/Safari Demos (uses WSL)](https://webkit.org/demos/webgpu/)
[gpuweb->issues](https://github.com/gpuweb/gpuweb/issues)


## 准备开发环境

MacOS只有高版本支持WebGPU（我之前是MacOS 10.10版本，运行不了WebGPU！升级为MacOS Catalina就可以运行了！！！）。

对于Chrome：
下载最新的Chrome Canary，并且打开 chrome://flags/#enable-unsafe-webgpu

大家可以使用我下载的[Chrome Canary](https://github.com/yyc-git/MyData/blob/master/3d/googlechrome(canary).dmg)。


对于Safari：
下载最新的Safari Technology Preview，选中 Safari → Preferences → Advanced → Develop menu→ Experimental Features → WebGPU


## WebGPU学习资料

目前学习资料非常少，属于早期探索阶段～

[WebGPU学习中文资料](https://blog.csdn.net/caxieyou/article/details/92142390)
[WebGPU: An Explicit Graphics API for the Web](https://docs.google.com/presentation/d/1URnqb1Vuf2jPieHnt_eqXsPV_Es9Oog00_8LKZUdo6g/edit#slide=id.g482a63b4f5_0_1191)
[Get started with GPU Compute on the Web](https://developers.google.com/web/updates/2019/08/get-started-with-gpu-compute-on-the-web)
[WebGPU API规范](https://gpuweb.github.io/gpuweb/)



# 本系列技术选型

- 开发环境

    - Chrome Canary
因为Chrome市场占用率更高，而且shader使用glsl更简单，所以我使用Chrome Canary。

- 技术栈

    - Javascript语言

    - 使用原生WebGPU API


# 能给你带来什么收益？

- 从0学习WebGPU，熟悉原生API
- 缩小与PC端最新的3D技术的差距（学了WebGPU，就只与目前最新的DX12 RTX差半代了！而WebGL2只相当于DX10）
- 更新思维模式，学习最新的设计理念（WebGPU相比WebGL相当灵活和模块化，如果要被封装成引擎的话需要一些新的设计思路）


# 内容规划

本系列分成三个部分：
## 第一部分（已经完成）
一个一个地学习官方的[sample](https://github.com/yyc-git/webgpu-samples)（我fork到本地了），掌握基础的API调用，讲解相关的概念


## 第二部分（没有开始写）
学习进阶内容（如indirect draw、ray tracing等），并实现对应的sample

## 第三部分（没有开始写）
综合运用所学内容，实现一些demo（如gpu driven render pipeline）


  [1]: http://static.zybuluo.com/yangyc/ufgksu1fwj5dbiezo9ptbezg/%E6%88%AA%E5%B1%8F2020-01-06%E4%B8%8B%E5%8D%882.16.13.png
  [2]: http://static.zybuluo.com/yangyc/p3dfxuliofylp2rcqfw7tgju/%E6%88%AA%E5%B1%8F2019-12-24%E4%B8%8B%E5%8D%884.42.45.png
  [3]: http://static.zybuluo.com/yangyc/fjolhub41h697j3c87k6x8lk/%E6%88%AA%E5%B1%8F2019-12-24%E4%B8%8B%E5%8D%884.44.33.png]]></description></item><item><title>我在知识星球上创建了免费的Web3D学习的星球～</title><link>http://www.cnblogs.com/chaogex/archive/2019/12/03/11977879.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Tue, 03 Dec 2019 08:47:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/12/03/11977879.html</guid><description><![CDATA[大家好，我是YYC。
我在知识星球创建了一个**免费**的星球-“YYC的Web 3D旅程”，欢迎大家加入～

本星球完全免费，致力于打造专业的Web 3D技术学习区，分享各种3D技术和信息，纪录YYC学习Web 3D的足迹。 

同学，你加入星球可以免费获得：
1、YYC每周都会分享Web 3D相关的技术干货；
2、你可以问Web 3D、引擎开发、编辑器开发、前端开发、架构设计、函数式编程、领域驱动设计、测试等相关问题，YYC会尽快回复；
3、大家可以一起交流讨论；

点击链接地址加入：
https://t.zsxq.com/aMNJyZf


或者微信扫一扫加入：
![知识星球二维码.png-1.5kB][1]

  [1]: http://static.zybuluo.com/yangyc/g4brnst5i6c6qdo06g7qggoc/%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83%E4%BA%8C%E7%BB%B4%E7%A0%81.png]]></description></item><item><title>2019年9-11月我主要的业力对应关系</title><link>http://www.cnblogs.com/chaogex/archive/2019/11/27/11939749.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Wed, 27 Nov 2019 01:08:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/11/27/11939749.html</guid><description><![CDATA[这几个月也发生了很多事情。仔细想想，有很多业力的对应。而且我发现，我现在的因果显化非常快，一般几天果就显化回馈我，有时候甚至当天就显化！哈哈！


# 种子

花了一天时间，反思我这两年的业力对应关系，发布了[《2019年1-8月份我主要的业力对应关系》](https://www.cnblogs.com/chaogex/p/11372425.html)文章


# 结果

一个星期內，发生了几件事情：
当天晚上，一个网友看了该文，给我推荐了两个朋友，试图帮助我融资和创业；
我联系了那两个朋友，其中一个朋友是做媒体的，并邀请我去他公司交流。我第三天去了一上午，很有收获；
第二天，一个网友想使用wonder的编辑器；
第三天，我的一个朋友A建议我去另一个朋友的公司，与他交流。我去了，很有收获；
第四天，A办一个酒局，喊我和那个朋友一起去，我也去了；
第四天，网友想回成都工作，我与他约好改天一起交流下，看有无合作机会；



本来一般情况下，一个星期都没几个人联系我。结果这几件事情集中发生在一个星期內，而且恰好在我发布了文章之后！！！



# 种子

8月底，我与小浩沟通，我们协商同意暂停合作，他2个月內搬出，找工作。



# 结果

第三天，我去打篮球，遇到了罕见的情况：
首先有个队伍明明少个人，但是不加我。稍微等了一会，另外一个队伍加我了；
我队伍的中锋多次指责我防守不力；
（虽然后面那个中锋走了，换了个高手，然后我们就很顺利，一直不下）

第一种情况，让我体验到了被拒绝，没有人需要的感觉（虽然马上就有另一个队伍加我了，所以这种感觉没持续好久）；
第二种情况，让我体验到了被指责的感觉（虽然不久后就顺利了）；


而我这个体验，应该就是我与小浩沟通时，他的体验！

幸好我处理得比较恰当，所以让小浩体验这些负面感觉的时间比较少
（
我先说我们沟通一下，小浩就明显情绪低落，感觉被抛弃；
然后具体沟通时，我说2个月再搬出，所以他感觉时间足够，而且找工作赚钱也是他希望的。所以他明显情绪好转；

看看，我的体验不就是等同于他的体验吗！！！哈哈

感谢我现在的高频率，让我在第三天就收到果（越早显化，果的效力越低！）
）





# 种子

9月份，我给了小浩900块；
10月份，给了小浩2700块；

我主要的动机：
我知道业力，给出的会加倍回来。因为我没有钱（我在借钱），那要获得钱该怎么办？给出钱！所以我尽量把所有剩余的钱都给小浩！而且他也需要！这样的业力种子是很强大的，哈哈；
我也有弥补的心理。毕竟是我主动要求小浩离开的；


# 结果

妈妈表示小浩离开后，会帮我偿还债务。



# 种子

我与小浩沟通，解除了一个误会。让我也更加清楚地认识到：小浩如果找到好工作，对我来说是最好的事情。我是真的希望他一切顺利，这样也能证明我们这两年的创业是有价值的，能够被社会认可；
10月下旬，我协助小浩找工作；


# 结果

小浩收到了阿里的面试邀请；
小浩在成都找到了工作，工资翻了150%

这证明了我们这两年的创业是有价值的



# 种子

8月底，我们确定暂时停止合作，停止开发wonder；
国庆节，我参加了内观修行；

# 结果

内观结束后，我开始正式写书；
我顺利地与编辑签了约稿合同；






# 种子

我在路上看到有垃圾，一般会顺手收拾；
如果我在路上看到有东西挡住了道路，会立马清理；

# 结果

家里的清洁总有人做；
我出行总是很顺利，没有什么东西阻碍我；






# 种子

打篮球时，我不小心伤害了朋友的手

# 结果

没过多久，我自己在抢篮板时，手也受伤了




# 种子

生活中，我从来不责怪他人


# 结果

生活中，也没人责怪我




# 种子

网友来找我，咨询创业的技术可行性。
我与他交流了半天，帮助他分析；
并在他离开后，写了分析报告给他



# 结果

当天晚上，阿里给我打了面试邀请电话（已经一年没接到阿里的面试电话了！）；
第4天，妈妈给了我12000，帮助我还清了债务；


# 参考资料
如果你也想像我一样，明智地应用业力法则，让自己的生活更好；
如果你需要任何东西（钱、人际关系、伴侣等）；

可以看下这篇文章：
[如何得到你想要的－业力法则助你心想事成](https://zhuanlan.zhihu.com/p/70478532)]]></description></item><item><title>提前预览系列：我已经写完第一本书了！</title><link>http://www.cnblogs.com/chaogex/archive/2019/11/21/11904165.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Thu, 21 Nov 2019 02:51:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/11/21/11904165.html</guid><description><![CDATA[我的书在书店销售了！哈哈

我和妈妈去逛书店，走到我的书面前！

我拿起了我的书，哇塞！《开发引擎》的书啊～这真是太梦幻了！

里面有妈妈的序。


我认识女朋友，带她去逛书店，看我的书～哈哈

我也正在写第二本书了！！！

大家好～这就是我的书～一本已经写完的书～

闪亮登场～

真是太好了～已经写完了～哈哈～我感觉非常充实～非常满足～这是多大的成就啊～化成了一本实体书～

捧在手里的感觉真是太棒了～感谢啊～

感谢出版社～

感谢妈妈～

感谢我自己～

感谢小浩～

感谢wonder～

感谢所有关心我的人事物～

谢谢你们～～～～我爱你们～

写书就是这么爽～哈哈～]]></description></item><item><title>Wonder暂停开发，开始写书</title><link>http://www.cnblogs.com/chaogex/archive/2019/10/03/11619240.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Thu, 03 Oct 2019 02:18:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/10/03/11619240.html</guid><description><![CDATA[# 公告

大家好，我们决定暂时停止开发[Wonder](https://www.wonder-3d.com/)，但会继续维护当前的Wonder版本（如继续维护官网、在线编辑器、QQ群等）。

我们当前的主要任务是 **写书**：基于Wonder 1.0版本的开发经验，写一本 “开发3D引擎”的实战类型的书，欢迎大家关注～


# 写书计划

之前我写了[《用函数式编程，从0开发3D引擎和编辑器》系列中的前3篇文章](https://zhuanlan.zhihu.com/p/64398870)，主要从 **思维** 层面来讨论设计和开发过程。

不过我认为这样的效果并不好，因为大部分读者都没有自己动手写过3D引擎，对他们来说，**思维**层面的讨论太过空泛。

因此我决定，本书从 **实战** 层面来讨论，让读者能真正跟着本书，一步一步地写出3D引擎，真正体验到其中的快乐和成就感。


此外，我决定把书的预览稿作为一个系列文章，发到网上，供读者先行预览，欢迎给我反馈意见！
系列文章：
[从0开发3D引擎](https://www.cnblogs.com/chaogex/p/12134031.html)





# 暂定书名
《3D编程旅程-从0开发3D引擎》

我准备在“3D编程”的主题上写一系列的书，该系列暂名为“3D编程旅程”。后续可能会有《3D编程旅程-应用》、《3D编程旅程-模式》、《3D编程旅程-测试》等书。



# 主题
本书使用函数式编程范式，从0开始，通过一行一行的代码，写出了 简易的、完全可运行的 3D引擎。


# 在线预览和反馈

[从0开发3D引擎](https://www.cnblogs.com/chaogex/p/12134031.html)


读者反馈QQ群：
106047770


# 技术栈

- 使用[Reasonml](https://reasonml.github.io/docs/en/what-and-why)作为编程语言
- 使用WebGL 1作为底层api


# 篇幅
本书保持精简，专注在实现最小功能上，因此使用较少的篇幅。



## 策略
- 尽量多章节，每个章节内容尽可能独立和精简，减少读者负担


# 重点
- 设计
3D编程比较复杂，要让各个部分统一协调地工作，还要尽量地提高性能、增强扩展性。
本书会展示很多设计层面的思考，仔细地设计架构，不断地重构，提高代码质量。


- 实现
本书旨在让读者以最小的成本，快速实现一个简易的3D引擎。因此，本书不讨论 **测试**、**工程化** 等内容。




# 特色


1.完全从0开始，强调实战

2.保持精简，只实现**最小功能**，重点强调**架构**、**扩展**

3.完全、彻底地使用函数式编程

现在3D领域使用函数式编程的资料很少，主流还是使用面向对象。
我以前也是用面向对象，不过自从我开始接触函数式编程，就拥抱了它。
希望能通过本系列，向读者展示函数式编程的魅力，扩展读者的视野和思维。



# 能给你带来什么收益？

1.手把手教你如何从0开发3D引擎
2.学习函数式编程及其在3D领域的应用
3.学习3D编程中基础的功能实现，如纹理、光照、模型等
4.学习引擎的设计和架构，如Data Oriented、多线程等 


# 目标读者群
尽管本书使用的是WebGL 1这个Web 3D编程的API，但本书的设计和实现的思想是通用的，适合整个3D编程领域。

- 3D编程爱好者

- 函数式编程爱好者

- Web 3D开发工程师

- 3D引擎开发工程师







# 章节安排

## 第一部分：准备

主要内容：

- 准备预备知识
- 搭建开发环境
- 搭建测试环境


## 第二部分：基础

主要内容：

- 学习函数式编程


- 学习函数式反应式编程

- 学习Reason



## 第三部分：搭建雏形

主要内容：

- 编写最小的3D程序


- 从中提炼引擎

- 改进引擎架构


## 第四部分：增加功能

主要内容： 

- 增加基础功能

- 加入Scene Graph



## 第五部分：增强扩展性

主要内容：

- 加入脚本组件

- 加入自定义材质

- 加入其它可能的扩展，如ui扩展等


## 第六部分：应用

主要内容：

- 通过引擎支持的扩展，加入实际应用需要的功能（如picking等）

- 实现几个完整的3D应用



## 相关资料
[Wonder官网](https://www.wonder-3d.com)
[“用函数式编程，从0开发3D引擎和编辑器”系列博文](https://zhuanlan.zhihu.com/p/64398870)
[“从0开发3D引擎”系列博文](https://www.cnblogs.com/chaogex/p/12134031.html)]]></description></item><item><title>Web 3D引擎和编辑器(Wonder)天使轮融资300-500万元</title><link>http://www.cnblogs.com/chaogex/archive/2019/08/19/11375362.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Mon, 19 Aug 2019 01:37:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/08/19/11375362.html</guid><description><![CDATA[# 融资计划

融资金额：300-500万元

所在地区：成都

融资主体：企业(暂时还没有注册公司)

所属行业：IT互联网

融资用途：
1.扩建团队
预计从2人增加到8人

2.更换办公场地
搬到软件园的写字楼

3.运作
用于团队工资、项目运作等开销



融资方式：股权融资


项目所处阶段：种子期

资金方占股比例：10%-15%


最短退出年限：5年


# 项目介绍
我们做的是web端3D开发的通用解决方案，包括3D引擎和编辑器等，致力于打造开放、分享、互助的web 3d生态。

Wonder定位上可以看成是Web端的Unity。

我们专注于做好工具和生态。用户使用我们的工具，加入到我们的生态，从而用户可以做出各种Web 3D应用。


![editor.jpg-98.9kB][1]


![Wonder上下游 (1).png-123.5kB][2]

# 痛点分析
1.Web端还没有一个类似于Unity3D这样成熟的通用解决方案，导致每次开发Web 3D应用，都要自己开发或者使用开源引擎（如three.js）开发，效率很低。

2.Web端缺少3D生态

3.国内都是2D的，如cocos creator等，3D还不成熟。

4.要开发一个大型的Web 3D应用（或游戏），还没有现成的工具，开源的引擎（如three.js）也支持得不好

5.微信小游戏等还是2D为主。

6.国内的Web 3D引擎和编辑器，基本都是基于开源引擎开发，大都是在模仿别人。

# 解决方案
1.Wonder提供Web 3D整套通用工具，并且建设生态。

2.Wonder从基础架构上就支持大型Web 3D应用（如支持多线程）

3.Wonder在2.0版本会支持发布到微信小游戏，这个市场非常大。

4.Wonder完全自主开发，并且创造性地使用了函数式编程范式。



# 应用场景

## 我们的应用场景包括但不限于
1.做各种Web 3D游戏，如微信小游戏等
2.Web 3D场景、模型展示
3.各种Web 3D应用
4.vr、ar应用
5.影视、动画
6.通过扩展，开发自定义编辑器





## 适合这几类用户使用

1.美术、策划同学
2.完全没有编程基础，想快速开发Web 3D应用和游戏的同学(可以从Wonder的商城中下载资源；可以上传资源和3D项目到托管平台)
3.程序员同学（可以写脚本、自定义shader、扩展编辑器和引擎之类的）

不过目前1.0版本还没有脚本、商城、托管平台、扩展，2.0版本就会支持。



# 市场分析
1.同类产品少
现在国内没有商业的Web 3D通用解决方案，世界上也很少（目前我们只看到有一家公司：playcanvas跟我们做的类似）

2.市场潜力大
Web 3D是发展趋势。
目前Html5应用多是2D的，但就像手机上的游戏从2D过渡到3D一样，未来必是3D的。


3.符合技术发展趋势
随着5G的应用，互联网上传下载速度大幅增加，从而会出现更多的Web 3D应用。










# 商业模式

1.编辑器分免费版和收费版。
基础功能免费，增强版收费（如要使用托管平台等）

2.收取交易费。
2.0版本会上商城，用户在商城可以开店，但需要交一定的交易费。

3.提供增值服务
提供“数据统计”、“支付”等增值服务，按月收费。

4.如果用户使用Wonder开发出来的产品，月流水超过一定数额，需交一定比例的收入给Wonder




# 目前的情况

## 已发布的产品
[Wonder 1.0正式版发布-----WebGL 3D引擎和编辑器](https://www.cnblogs.com/chaogex/p/10508464.html)

[官网](https://www.wonder-3d.com/)

[博客](https://www.wonder-3d.com/docs/blog/)

[FAQ](https://www.wonder-3d.com/docs/docs/doc1-8/)


目前已经发布了1.0版本并上线，向用户提供引擎、编辑器，实现了核心流程（如导入、导出、发布等流程）。

已上线官网、论坛、文档等配套设施。


目前能应用到 3D展示->静态场景，可以用来做静态的模型和场景，做些demo演示之类的，后面版本会支持更多的应用场景。


## 股权结构
杨元超：65%
杨浩：25%
李蓉：10%

杨元超：投入4万
杨浩：投入1.5万
李蓉：投入10万



## 运营数据
目前产品免费、不用注册，可能会在1.2版本开始收费。


2000+人访问了官网/编辑器
7000+人阅读了发布的博文

发布三周后，每天访客数：25人左右




# 项目优势

1.技术雄厚
3D引擎、编辑器等产品都是我们自主开发的，并且进行了大胆的创新，我们掌握所有的技术。

2.开源
我们是开源的商业项目，能让大家都参与到Wonder的生态建设中

3.创始团队投入大
我们全职开发Wonder，已经投入了4年、7000小时开发1.0版本，资金都是自己投入的，并会继续长期投入和维护Wonder的发展

4.技术门槛高
3D引擎技术难度大，研发时间长，不容易被复制。

5.同类产品少
现在国内没有商业的Web 3D通用解决方案，世界上也很少（目前我们只看到有一家公司：playcanvas跟我们做的类似）

6.市场潜力大
Web 3D是发展趋势，而且我们在2.0版本会支持移动端，支持发布到微信小游戏等各种Html5平台。
目前Html5应用多是2D的，但就像手机上的游戏从2D过渡到3D一样，未来必是3D的。












# 团队介绍

## 创始人
- 杨元超

电子科技大学研究生，已从业8年。

之前在腾讯实习过
阿里资深前端工程师：
作为第一批早期开发者，参与了PC端钉钉项目；
加入天猫，负责开发Hilo3D引擎；

负责Wonder整个产品线，主要负责:
- Wonder引擎
- Wonder编辑器
a)编辑器中与引擎相关的部分开发
b)编辑器的技术审核
c)解决编辑器的技术难点


## 合伙人
- 杨浩

西南科技大学本科毕业生，已从业6年。
从毕业一直在创业公司学习创始人成功和失败的管理经验。

主要负责Wonder编辑器开发和官网等网站建设。


## 种子投资人
- 李蓉
创始人的母亲，投入种子资金


# 未来发展计划
## 2.0版本
2.0版本会增加基础功能，做出一些可用的demo，使用户能够真正使用并获利。

主要任务：

加入脚本
加入AssetBundle
支持pbr材质
支持动画
支持picking
支持碰撞
支持声音
加强ui
增加更多案例，如3D管理系统、游戏等
加入托管平台
支持移动端，支持发布到微信小游戏

## 3.0版本
3.0版本会继续加强基础设施，加强扩展，完善生态。

主要任务：

支持WebGL2.0
加强引擎和编辑器扩展
优化
加入资源商店

## 4.0版本
4.0版本会增加更多的功能，如地形、粒子等。


## 5.0版本
5.0版本可能会增加vr、ar的支持；还可能会加强渲染，加入全局光照之类的特性，支持应用到动画、电影的制作中。


# 联系方式
创始人（杨元超）：
电话：13668214304
QQ：395976266
微信：chaogex


  [1]: http://static.zybuluo.com/yangyc/upyxn2839371qy5u6yp04laj/editor.jpg
  [2]: http://static.zybuluo.com/yangyc/zetrnk0bqnm23umdubvtvla5/Wonder%E4%B8%8A%E4%B8%8B%E6%B8%B8%20%281%29.png]]></description></item><item><title>2019年1-8月份我主要的业力对应关系</title><link>http://www.cnblogs.com/chaogex/archive/2019/08/18/11372425.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sun, 18 Aug 2019 06:50:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/08/18/11372425.html</guid><description><![CDATA[与大家分享我今年的业力对应关系～

# 种子
整理我的物品，把玩具、废书等都送人了

# 结果
妈妈过来做了清洁

# 种子
每天早晚朗诵《轻而易举的富足》

# 结果
春节期间，与妈妈到川大湖边聊天，第一次感受到了深深的和平，这种感觉正是我在《轻而易举的富足》学习的和平！

开始学习业力法则

心想事成的速度明显加快

开始亲自体验奇迹！

开始关注清明梦

开始在我身边遇到灵性伙伴！（如李姐）

# 种子
捐赠李姐550元，用于救助她父亲

# 结果
释放了在爸爸去世这件事上的情绪：
释放了我对自己的愧疚
释放了我对老家的不满

一个星期后，妈妈获得爷爷婆婆的20万（以帮助我创业的名义）

# 种子
6月下旬，毕棚沟闭关期间: 
给小浩1.2万，用于偿还贷款 
捐赠50元，用于治病 
给10元，用于众筹

# 结果
这段时间，妈妈的股票涨10万元

我银行账户多出5000元！！！（真是奇迹啊啊啊啊啊！感谢！）

# 种子
关注清明梦

# 结果
参加清明梦同好组织的催眠： 
第一次体验了被催眠 
第一次参加灵性活动，与灵性伙伴进行了交流 
体验了天使牌

# 种子
6月份：

给小浩压力，减他股份，并跟具体任务挂钩

把对我自己工作状态的不满，转移为对小浩工作不满

# 结果
6－8月份，自己的状态一直不好，6月上旬完全没产出

8月份，妈妈（作为投资人）直接给我们压力，并要撤资

# 补救
明白这是我自己创造的，感谢妈妈和小浩，把妈妈的这次压力看作是一次对我的激励，激励我们提高效率，是件好事！

感谢妈妈，感谢小浩

提高工资标准，给小浩钱

定出作息计划表，提高自己的效率]]></description></item><item><title>前端学习路线建议</title><link>http://www.cnblogs.com/chaogex/archive/2019/07/30/11268184.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Tue, 30 Jul 2019 01:55:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/07/30/11268184.html</guid><description><![CDATA[本文写给刚入门前端，或者对前端感兴趣的朋友，希望能对你的学习之路有所帮助，谢谢～


# 应用方向

(介绍前端有哪些方向)

- 网页开发
用css+html+javascript开发静态/动态网页。
这个是初级阶段。



- 游戏
开发Html5 2d,3d 游戏

- 3D可视化展示
基于WebGL技术，在线展示互动的3D场景。
如在线粮仓管理系统，物联网在线展示等。
可参考[hightop](https://hightopo.com/demos/index.html), [wonder](https://www.wonder-3d.com/)等。


- 单页面富应用
与android,ios上的app一样，使用web技术也可以开发本地app



- 网站，管理系统
使用web前端技术+服务器技术（node.js,jsp...)+数据库(mysql, ...), 搭建整个网站、管理系统等。

- 移动端(手机)开发
主要是开发移动端的网页，也可以开发html5 小游戏、小程序等。


- 设计师
偏设计方向，设计网页，主要应用html+css+photoshop


    
# 阶段学习

(介绍如何分阶段学习前端)

1.学习html+css+javascript基本知识，
完成网页开发，并加上一些javascript特效。

2.学习node.js等服务器技术和mysql等数据库技术。 然后开发一个个人网站，或者简单的管理系统。

3.根据你个人情况，再看学习上面哪个应用方面的知识（如游戏、富应用等）







# 学习建议

(给出我个人的学习建议)

1.建议先不要用前端框架，使用原生javascript开发一个网页和一个简单的网站。自己可以进行一些封装，如封装dom操作等，从而为以后开发框架打下基础。

2.完成第一个网站项目后，建议看一些增加内功的书籍，关注代码质量。如：
<<重构：改善既有代码的设计>>
<<冒号课堂>>
<<测试驱动的javascript开发>>
...
详见[<<分享我收集的计算机内功修炼的经典资源>>](https://www.cnblogs.com/chaogex/p/11262509.html)


3.学习进阶的学习资料，如[<<深入理解JavaScript系列>>](http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html)







4.学习前端框架源码。
如prototype.js, jquery.js的源码等。

我重点看了prototype.js的源码(网上也有很多源码学习的笔记和资料)，它写得很精妙，对学习如何写一个前端框架很有帮助，建议花一个月的时间，把它看3遍，然后就可以开始写框架了。


5.学习和使用react或者vue框架，模块化开发网页]]></description></item><item><title>我的学习资源汇总</title><link>http://www.cnblogs.com/chaogex/archive/2019/07/30/11268059.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Tue, 30 Jul 2019 01:35:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/07/30/11268059.html</guid><description><![CDATA[本文汇总我所有的学习资源的文章，让你的学习轻而易举～


# 我的实战纪录

[“打造3D引擎”的一万小时实践打卡](https://www.douban.com/group/topic/78459659/)


# 学习经验

[<<前端学习路线建议>>](https://zhuanlan.zhihu.com/p/75626808)


[<<8年，从2D到3D，我的学习之路>>](https://www.cnblogs.com/chaogex/p/10533026.html)




# 资源分享

[<<分享我收集的计算机内功修炼的经典资源>>](https://zhuanlan.zhihu.com/p/75619709)


[<<分享收集的WebGL 3D学习资源>>](https://www.cnblogs.com/chaogex/p/10538346.html)

[<<分享我收集的引擎、图形学、WebGL方面的电子资料>>](https://www.cnblogs.com/chaogex/p/5579365.html)

[2011-2014年收集的经典书和心得](https://github.com/yyc-git/MyData/blob/master/2011-2014%E5%B9%B4%E6%94%B6%E9%9B%86%E7%9A%84%E7%BB%8F%E5%85%B8%E4%B9%A6%E5%92%8C%E5%BF%83%E5%BE%97.doc)]]></description></item><item><title>分享我收集的计算机内功修炼的经典资源</title><link>http://www.cnblogs.com/chaogex/archive/2019/07/29/11262509.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Mon, 29 Jul 2019 02:33:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/07/29/11262509.html</guid><description><![CDATA[大家好，我在本文中分享了我收集的计算机内功修炼的经典资源，希望对大家提升内功有所帮助，谢谢～

# 算法
## leetcode
一个在线刷题的算法题库，题目分了简单、中等、困难，每道题几乎都有很多人的答案和多种解法。

总题数在不断增加中，我以前刷的时候有500+的题。

我只是把简单的题刷了，感觉对我的算法能力的提高有很大的帮助。

另外需要面试的同学也可以刷下题。

[在线链接](https://leetcode-cn.com/problemset/all/?utm_source=LCUS&utm_medium=banner_click&utm_campaign=transfer2china&utm_content=title_main)


# 设计


##《计算机程序的构造和解释》	

本书就是大名鼎鼎的SICP，使用Lisp语言，从程序设计思想的角度介绍了构造过程抽象、构造数据抽象、面向对象设计和并发和流等内容，给出了若干设计实例。

本书是一本介绍设计思想的书，重点介绍了抽象的思维，是一本好书啊！能大幅提高抽象能力！

第1章：构造过程抽象。
本章讲解了面向过程设计的思想。
第2章：构造数据抽象。
本章介绍了模块化、层次化思想。
第3章：模块化、对象和状态
本章介绍了对象的结构实现、并发、流等内容。

我只看了本书前3章，并参考网上资料做了1遍前3章的习题（3.5流的习题没做。“流”这部分我只学习了下思想，没有掌握）。
第1章很简单，第二章有难度，第三章简单（流的习题没做，有一定难度）。

本书让我加深了对程序设计的理解，并学习了递归的使用。
建议大家把前3章的习题做了，网上有详细的答案。



##《冒号课堂：编程范式与OOP思想》

通过老师与学生对话的方式，非常生动地讲解了面向对象的思想。

作为新手第一本学习面向对象思想的书，是很合适的。


##《设计模式之禅》

讲了5大设计原则和23个设计模式，并给出了多种设计模式的组合使用。

全书非常通俗易懂，书中的案例也非常生动，适合大家上手学习设计模式。


##《领域驱动设计》	

本书提出了模型驱动设计，围绕领域建模来展开论述。
本书是一本经典书，对提高设计能力很有帮助！

第1-3章提出了领域建模的注意事项。
第5章介绍了模型的组成部分：Entity、Value Object、Service、Module。
第6章介绍了聚合体AGGREGATE、存储库REPOSITORY、工厂。
第7章介绍了对初步的领域模型进行重构细化的过程，展示了将领域模型细化为详细架构的过程。
第8章展示了初步的领域模型的演化直到获得突破的过程。
第9章讲解了如何实现深层建模，以及将业务规则提出来的思想（提出了SPECIFICATION规格模式）。
第10章提出了一些原则、启发，参考这些模式能获得柔性设计。
第四部分从较高的范围来展开论述。
第14章提出了上下文BOUNDED CONTEXT、持续集成、上下文之间如何联系起来CONTEXT MAP、BOUNDED CONTEXT之间的关系（共享内核、客户/供应商等关系）、选择上下文的策略以及如何转换BOUNDED CONTEXT之间关系。
第15章讲解了如何提炼出核心模型CORE DOMAIN。
第16章讲解了大比例结构。包括进化迭代的思想来重构大比例结构、系统隐喻、分层、KNOWLEDGE LEVEL、可插入式组件框架PLUGGABLE COMPONRNY FRAMEWORK。

通过阅读该书，我了解了领域模型的重要性。领域模型不只是用来转化为数据库表，也与实际的架构模型应该对应。也获得了设计的相关启示（风格与《敏捷》有点像）。



##《软件架构设计（第二版）》	(作者：温昱 )

本书系统梳理了架构设计的知识，让我对架构设计有了更深入的理解，是一本很好的架构设计的参考资料。

书中一共有三个部分，分别讲解了软件架构的概念，架构设计的方法、过程及步骤，模块划分等专题。

书中的第2部分，介绍了整个架构从需求到设计的流程，并对每个流程展开说明，并给出了实例。

书中的第3部分，介绍了架构师的关键技能：模块划分。包括水平划分（分层）、垂直划分（子系统）、用例驱动设计（自底向上）等内容。这部分可以结合《敏捷软件开发原则、模式与实践》中的包设计部分来理解消化。


##《一线架构师实践指南》 (作者：温昱 )

本书重实践，《软件架构设计》重理论。
本书给出了一些实践经验，以及具体的实例，可以作为《软件架构设计》在实践方面的补充！

建议设计架构时，参考《软件架构设计》和本书！






# 工程
##《重构：改善既有代码的设计》 
重构领域的经典书籍。每一小节讲了一个重构手法，基本覆盖了重构的各个方面。

如果你想要你的代码更加可读、易于维护，建议阅读本书。

##《代码整洁之道》

有些内容与《重构》的思想相似，也是讲解如何改进代码的书。


##《修改代码的艺术》
本书讲解了处理遗留代码的技术，其中包含了测试的相关讨论（如测试私有方法）。

如果你正在接手或重构别人的代码，或者正在你之前的项目上继续开发，本书就是你需要看的。


##《测试驱动的Javascript开发》 

如果你要开发大型软件，自动化测试非常重要。虽然前期编写测试时会花双倍的开发时间，但是越到后期，越能保证代码质量，减少修改bug的时间。


本书讲解了如何在开发产品代码之前，就先写测试，用测试来驱动开发。

这样做的好处之一是可以从用户的角度，来审视代码。通过明确代码的输入输出，来提高代码的设计。


当然，并不是所有地方都适合测试驱动，我觉得像 实现算法、代码相对稳定明确（如不是在实现demo的时候） 的地方可以使用测试驱动。



##《敏捷软件开发原则、模式与实践（C#版）》
本书讲解了敏捷设计、类设计原则和包设计原则、UML、设计模式、薪水项目的设计与实现以及打包等内容，对我学习迭代开发和设计很有帮助，不愧是经典书籍。

以下章节对我帮助很大：
第6章（采用TDD开发保龄球比赛程序（C#））、第20章（咖啡机的面向对象设计与实现）、第26章（薪水项目的面向对象设计的过程与思路）、第28章（包和组件的设计原则）、第30章（薪水项目的包分析）、第37章（测试数据层）


##《xUnit测试模式：测试码重构》	

本书是一本关于如何解决测试中遇到的问题的实战经验书籍，给出了测试相关的概念、术语、经验、味道以及模式和实例。

第1部分总体介绍了测试的模式和相关知识，包括测试的味道、目标、基本观点、原则、策略，以及提出夹具的管理、结果验证、测试替身、组织测试、数据库测试等内容。

第2部分介绍了三大类测试味道：代码味道、行为味道、项目味道，对每种味道进行了详细分析，并介绍了解决方案模式。

第3部分介绍了测试的模式。对应第1部分，给出了具体实例，是对第1部分的补充。


本书内容组织的方式类似于《重构》一书，同样也应用于实战，来源于实战。

阅读本书后，在实际应用中如果遇到测试相关的问题，可以迅速地知道该问题在该书中对应的术语、模式以及解决方案。

因为我有一些测试的实战经验，所以看本书时就比较顺利，同时也深入了我对平时遇到的测试问题的理解。

所以建议先积累一些实战经验，然后再看该书，然后再应用于实战中。






# 开发经验

##《人月神话》
本书讲了一些实际开发软件的经验，如 :
增加更多的人来开发，并不能提高开发速度，反而有可能会下降。因为人越多，沟通成本就越高；
没有银弹，没有能通吃一切应用场景的解决方案；
避免陷入焦油坑；



##《软件随想录》
本书适合要做项目管理的同学，讲解了发布软件的经济学分析等内容，其中项目管理的知识（如“循证式日程规划”）很有启发。

##《创业必经的那些事 1》
讲解了为什么创业失败，企业发展的三个阶段，如何经营企业等内容，对学习创业的思想很有帮助。

##《创业必经的那些事 2》

本书是该系列的第2本书，与第1本书有些相同的观念，如三种角色（国王、管理者、技师），创新、量化、统一等。

本书的核心观念就是：作为管理者，要像企业家那样，把公司当成自己的公司，强调要有自我意识，注重换位思考。

本书强调要管理系统，而不是管理人，因为人是不可管理的，因此需要创建一个愿景，一套流程，每个人都能在流程中快速上手，认同企业文化。

“创业”系列书籍的观点与众不同，耐人寻味，在创业之前需要认真品读。


##《程序员修炼之道》

本书讲解了如何成为更好的程序员，涉及到了成为优秀程序员的方方面面，注重实践经验。

本书让我更加了解了如何成为优秀的程序员，学习了一些最佳实践。


##《高效程序员的45个习惯：敏捷开发修炼之道》
本书讲解了敏捷开发的最佳实践，从态度、学无止境、交互用户想要的软件、敏捷反馈、敏捷编码、敏捷调试、敏捷协作、走向敏捷 这些方面来展开论述，展示了敏捷开发的过程、实现、方法，使我对“如何成为高校的敏捷人员”有了更深入的认识。

下面是对我启发较大的内容：
1.	第4章-15 提早实现自动化部署。
提出了一开始就自动化部署应用，如：使用户可以在线看到我们的演示系统。
2.	第5章-21 不同环境，就有不同的问题。
提到了“持续集成”。可以用一个持续集成工具，周期性地从源代码控制系统中取得代码，并运行代码。如果有任何测试失败了，它会通知相关的开发者。
3.	第5章-22 自动验收测试。
提到了FIT，即集成测试框架。它可以更容易地使用HTML表格定义测试用例，并比较测试结果数据。
使用FIT，客户可以定义带有新功能的使用样本。客户、测试人员和开发人员（根据样本）都可以创建表格，为代码描述可能的输入和输出值。开发人员会参照样本编写测试代码。测试结果成功或者失败，都会显示在HTML页面中，用户可以很方便地查阅。




# 底层原理


##《HTTP权威指南》

本书是HTTP及其相关核心Web技术方面的权威著作，适合所有想了解HTTP和Web底层结构的人阅读。
本书包含21章，分为5个逻辑部分（每部分都是一个技术专题），以及8个很有用的附录，这些附录包含了参考资料，以及对相关技术的介绍。
第一部分　HTTP：Web的基础
第二部分　HTTP结构
第三部分　识别、认证与安全
第四部分　实体、编码和国际化
第五部分　内容发布与分发
第六部分　附录
第一部分用4章的篇幅描述了Web的基础构件与HTTP的核心技术。
第1章简要介绍了HTTP。
第2章详细阐述了统一资源定位符（Uniform Resource Locator，URL）的格式， 以及URL在因特网上命名的各种类型的资源，还介绍了统一资源名（Uniform Resource Name，URN）的演变过程。
第3章详细介绍了HTTP报文是如何传送Web内容的。
第4章解释了HTTP连接管理过程中一些经常会引起误解且少有文档说明的规则和行为。
第二部分重点介绍了Web系统的结构构造块：HTTP服务器、代理、缓存、网关以及机器人应用程序。（当然，Web浏览器也是一种构造块，但在本书的第一部分已经对其进行过很详细的介绍了。）第二部分包含以下6章。
第5章简要介绍了Web服务器结构。
第6章深入研究了HTTP代理服务器，HTTP代理服务器是作为HTTP服务与控制平台使用的中间服务器。
第7章深入研究了Web缓存的问题。缓存是通过保存常用文档的本地副本来提高性能、减少流量的设备。
第8章探讨了网关和应用服务器的概念，通过它们，HTTP就可以与使用不同协议（包括SSL加密协议）的软件进行通信了。
第9章介绍了Web上的各种客户端类型，包括无处不在的浏览器、机器人和网络蜘蛛以及搜索引擎。
第10章讲述了仍在研究之中的HTTP协议：HTTP-NG协议。
第三部分提供了一套用于追踪身份、增强安全性以及控制内容访问的技术和技巧。包含下列4章。
第11章讨论了一些识别用户的技术，以便向用户提供私人化的内容服务。
第12章重点介绍了一些验证用户身份的基本方式。这一章还对HTTP认证机制与数据库的接口问题进行了研究。
第13章详述了摘要认证，它是对HTTP的建议性综合增强措施，可以大幅度提高其安全性。
第14章说明了因特网的密码体系、数字证书以及SSL。
第四部分涵盖HTTP报文主体和Web标准，前者包含实际内容，后者描述并处理主体内容。第四部分包含以下3章。
第15章介绍了HTTP内容的结构。
第16章探讨了一些Web标准，通过这些标准，全球范围内的用户都可以交换以不同语言和字符集表示的内容。
第17章解释了一些用于协商可接受内容的机制。
第五部分介绍了发布和传播Web内容的技巧。包括以下4章。
第18章讨论了在现代的网站托管环境中布署服务器的方式以及HTTP对虚拟网站托管的支持。
第19章探讨了一些创建Web内容，并将其装载到Web服务器中去的技术。
第20章介绍了能够将输入Web流量分散到一组服务器上去的一些工具和技术。
第21章介绍了一些日志格式和常见问题。
第六部分是一些很有用的参考附录，以及相关技术的教程。
	
本书知识点较多，内容广而浅，没有难度，可以帮助读者全面了解Web底层结构。


##《深入理解计算机系统》

本书从程序员的角度介绍了计算机系统，概述了计算机整个系统的实现，帮助读者建立一个层次性的计算机系统模型。

第1章：计算机系统漫游
大概介绍了整个计算机系统
第2章：信息的表示和处理
介绍了存储单位、整数和浮点数的表示及运算
第3章：程序的机器级表示
介绍了汇编语言
第4章：处理器体系结构
介绍了处理器硬件的设计，介绍了指令集、逻辑电路、指令处理的5个阶段（取指、译码、执行、访存、写回），介绍了指令流水线原理，以及使用暂停、转发等技术处理流水线的数据相关和控制相关。
第5章：优化程序性能
介绍了程序优化策略，优化循环的关键路径，包括：
消除连续的函数调用
将计算移到循环外
消除不必要的存储器引用（引入临时变量保存中间结果）
展开循环（增大循环步长）
通过使用如多格累积变量利用并行执行
重新结合
用功能的风格重写条件操作，使得编译采用条件数据传送
第6章：存储器层次结构
介绍了高速缓存SRAM、主存DRAM、磁盘的实现原理，介绍了存储器层次结构。
第7章：链接
介绍了
链接器的主要任务（符号解析和重定位）
静态链接
静态库
动态链接
第8章：异常控制流
介绍了4种类型的中断，用户模式与内核模式的切换，进程控制和进程间信号通信，非本地跳转。
第9章：虚拟存储器
介绍了虚拟存储器，地址翻译，CPU、MMU和缓存、磁盘之间的页命中、缺页的执行过程，动态存储器分配（堆）等内容。
第10章：系统级I/O
介绍了文件的操作，描述符表->打开文件表->v-node表。
第11章：网络编程
介绍了集线器、网关、路由等，介绍了套接字操作，实现了简单的web服务器
第12章：并发编程
介绍了进程、I/O多路复用、线程这三种不同的构建并发程序的机制，并扩展了一个并发网络服务器。
介绍了互斥，介绍了生产者-消费者和读者-写者模型，介绍了线程不安全函数和竞争、死锁。

该书介绍了系统底层实现，为我整体理解计算机很有帮助。]]></description></item><item><title>Wonder第一期3D引擎和编辑器线下培训班报名开始啦（免费学习）</title><link>http://www.cnblogs.com/chaogex/archive/2019/07/06/11142287.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sat, 06 Jul 2019 03:59:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/07/06/11142287.html</guid><description><![CDATA[[Wonder](https://www.wonder-3d.com/)第一次举办 针对3D底层技术的 线下培训班，免费学习，请大家多多支持～感谢～


# 培训地点
成都


# 开课时间
报名满5人开课。


# 报名方式
加QQ群：732861508


备注请写：报名培训



# 老师介绍
[Wonder-WebGL 3D引擎和编辑器](https://zhuanlan.zhihu.com/p/58873078) 开发者，前阿里巴巴资深工程师，多年3D开发经验，认真负责。


# 课程介绍
## 教学的技术栈
WebGL
React
Javascript语言(使用Reason语言，可编译为Javascript)


## 培训方式
小班(5-10人)面对面线下培训。

根据学员情况，每周安排1、2天进行学习； 也可以集中连续学习一段时间。



## 能给你带来什么收益？
- 老师是一线的开发人员，有丰富的实战经验
- 完整学习3D底层开发的各种技术、思想
- 从0学习3D引擎和编辑器
- 能够实践理论，完成各种实战应用






# 可选课程


- 基础课程
    - 课程介绍&&学员意见收集
    - 函数式编程与Reason语言学习
    - 函数反应式编程FRP


- 3D引擎
    - 准备工作（开发环境准备、前期学习准备资料、3D引擎学习范围介绍）
    - 引擎设计(架构、引擎相关的设计模式)
    - 基础
        - 纹理、光照、模型、Shader、材质等
    - 高级
        - 多线程、UI、脚本等
    - 扩展
        - 地形、体素、全局光照等




- 编辑器
    - 准备工作（开发环境准备、前期学习准备资料、编辑器学习范围介绍）
    - 编辑器设计(架构等)
    - 基础
        - PWA、场景树、Inspector等
    - 高级
        - 运行/停止、Redo/Undo、Gizmo等
    - 扩展
        - 编辑器扩展等






- 算法
    - 基础算法（如排序等）
    - 3D引擎相关的算法
    - 编辑器相关的算法



- 内功修炼
    - 设计原则、设计模式
    - 敏捷开发、领域建模
    - 测试驱动开发
    - 类型驱动设计
    - ...

- 工程化
    - 保证代码质量(运行测试、静态测试、编译检查。。。）
    - 持续集成、持续部署、持续交付
    - 代码审核
    - ...





- 网站开发
    - 准备工作（开发环境准备、前期学习准备资料、学习范围介绍）
    - 前端
        - 网站页面开发
    - 后端
        - 服务器开发
        - 数据库开发



- 实战应用
    - 全景展示（基于skybox的360度全景展示）
    - 3D可视化（如物联网的各种可视化等）
    - 微信小游戏开发
    - ...]]></description></item><item><title>如何得到你想要的－业力法则助你心想事成</title><link>http://www.cnblogs.com/chaogex/archive/2019/06/22/11069852.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sat, 22 Jun 2019 10:13:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/06/22/11069852.html</guid><description><![CDATA[你是否在为金钱而困扰？
你需要钱，需要更多的钱？
一般人的解决方法是：紧紧地抓住自己的金钱，想法设法从别人／别处获得金钱。
其结果就是：越是追逐金钱，越是没有金钱。就算得到了金钱，也不快乐，不圆满。

为什么会这样呢？大部分人不都是这样吗？一边抱怨，一边也“不得不”做不喜欢的事。
什么时候才能真正解脱？真正自由？


仔细想想，原来我们一直在向外求，以为自己没有力量，外面的某人／某物才有力量。这就像对着镜中的自己，希望看到笑脸，不断地抱怨，要求镜中的自己先笑，自己才笑。结果发现为什么一直看到的都是苦涩的脸？

聪明的做法是：自己先笑，镜中的自己（外在的投射）才会笑。

你笑了，整个世界都笑了。


回到金钱这块，你想要更多的钱，而你现在没有钱，怎么办？让别人有钱。把你的钱/时间/精力给出去，让别人成功，让别人有钱，自然你就有钱了。

为什么阿里、腾讯这么成功？是创始团队绝妙的点子、执行，还是绝妙的机会？这些都不是本质，那什么是本质？让别人成功，让别人有钱。
阿里的淘宝店，让多少人致富了？让多少人不用工作，自己当老板了？
腾讯的QQ、微信，让多少人致富了？让多少人的沟通简单了？让多少人的生活丰富了？

这就是核心的要素：你要有钱，首先要给出钱，或者通过给出自己的时间，帮助别人有钱！！！

种瓜得瓜，种豆得豆。

不要害怕给出钱，自己就没有了钱，因为整个宇宙、整个世界都是你的，都是你！你给别人钱，就是在给自己钱！给的人越多，回馈给自己的就越多！
因为我们都是一体的！你与别人都是一个！

推荐大家阅读：
[播种幸福（上）——来自金刚经的商业智慧](https://www.jianshu.com/p/79a856b3f28e)
​

[播种幸福（下）——来自金刚经的商业智慧](https://www.jianshu.com/p/663cc6f06790?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)
​
[当和尚遇到钻石2__善用业力法则](https://github.com/yyc-git/MyData/blob/master/god/%E5%BD%93%E5%92%8C%E5%B0%9A%E9%81%87%E5%88%B0%E9%92%BB%E7%9F%B32__%E5%96%84%E7%94%A8%E4%B8%9A%E5%8A%9B%E6%B3%95%E5%88%99_%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E7%89%88_%E5%A4%A7%E9%99%86%E7%89%88_PDF_%E4%B8%8B%E8%BD%BD.pdf)
​

[当和尚遇到钻石](https://github.com/yyc-git/MyData/blob/master/god/%E5%BD%93%E5%92%8C%E5%B0%9A%E9%81%87%E5%88%B0%E9%92%BB%E7%9F%B3.pdf)
​]]></description></item><item><title>用函数式编程，从0开发3D引擎和编辑器（三）：初步需求分析</title><link>http://www.cnblogs.com/chaogex/archive/2019/06/05/10978934.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Wed, 05 Jun 2019 04:41:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/06/05/10978934.html</guid><description><![CDATA[大家好，本文介绍了[Wonder](https://www.wonder-3d.com/)的高层需求和本系列对应的具体功能点。






# 确定Wonder高层需求


## 业务目标
Wonder是web端3D开发的解决方案，包括引擎、编辑器，致力于打造开放、分享、互助的生态。



## 范围

![](https://img2018.cnblogs.com/blog/419321/201906/419321-20190605124953296-176205822.png)




- 引擎
[Wonder.js WebGL 3D引擎](https://github.com/Wonder-Technology/Wonder.js)



- 编辑器
[Wonder-Editor](https://github.com/Wonder-Technology/Wonder-Editor)


- 工具
提供给用户使用的各种工具，如gltf转wdb数据在线转换器等。



- 增值服务
增强用户在Wonder中发布的3D应用的能力，如提供数据统计、支付等。



- 平台
构建3D生态，提供如托管平台、开发资源商城等，用户可上传/下载相关资源。





## 上下文

![](https://img2018.cnblogs.com/blog/419321/201906/419321-20190605125006480-1322242856.png)




- 开发者
开发者是Wonder的直接用户，可以划分为这几类：
1)美术、策划同学
2)完全没有编程基础，想快速开发Web 3D应用和游戏的同学(可以从Wonder的商城中下载资源；可以上传资源和3D项目到托管平台)
3)程序员同学（可以写脚本、自定义shader、扩展编辑器和引擎之类的）


- Wonder


- 分发服务商
开发者可在Wonder中发布Web 3D应用/游戏到各个分发平台，如微信小游戏等。


- 终端用户
终端用户直接在浏览器上消费开发者在Wonder中发布的Web 3D应用/游戏。




# 确定本系列对应的Wonder v1.0版本的功能点


## 引擎v1.0版本功能点
![](https://img2018.cnblogs.com/blog/419321/201906/419321-20190605125022818-512943150.png)




- GameObject和Component
引擎是ECS架构，场景是由多个GameObject组成，而每个GameObject又由各种Component组成。
组件包括Transform、Geometry、Material等。


- 纹理
基本的纹理。


- 光照
支持方向光、点光源。
- 多线程渲染
通过浏览器的Shared ArrayBuffer和OffscreenCanvas，引擎支持开两个线程：主线程＋渲染线程。
- Scene Graph
使用自定义的.wdb格式保存场景数据
支持导入/导出.wdb
- 流加载
支持使用流加载来加载.wdb，让用户首次加载更顺滑。
具体是指：
用户会看到边加载边显示场景的效果。


- IMGUI
可以用代码调用API，来绘制UI。
- 事件
绑定和封装了事件，统一了pc端和移动端的事件。

## 编辑器v1.0版本功能点

![](https://img2018.cnblogs.com/blog/419321/201906/419321-20190605125036256-2101372018.png)




- GameObject和Component
可直接操作GameObject和Component，如添加、删除、修改等。


- 场景管理
可通过场景树的形式看到该场景的所有GameObject
可进行添加、删除、修改等操作



- 撤销/重做


- 输出
可在控制台输出日志、错误等信息


- 运行/停止
可直接运行/停止场景


- 快捷键
可使用快捷键


- 资产Asset
可操作Material、纹理、模型等资产

- Gizmo
可通过Transform Gizmo，设置GameObject->Transform组件的位移、旋转、缩放等属性
在编辑视图scene view中显示相机、光等小图标





- 导入/导出
可导入/导出场景、模型


- 发布本地包
可将做好的场景，发布为本地压缩包，然后自己部署到服务器上，供终端用户使用


- PWA
使用了Chrome的PWA技术，支持离线访问编辑器等


欢迎浏览上一篇博文：[用函数式编程，从0开发3D引擎和编辑器（二）：函数式编程准备](https://www.cnblogs.com/chaogex/p/10807469.html)]]></description></item><item><title>Wonder发布v1.1正式版本，新增资产预览、脚本、AssetBundle等</title><link>http://www.cnblogs.com/chaogex/archive/2019/06/02/10962063.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sun, 02 Jun 2019 02:03:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/06/02/10962063.html</guid><description><![CDATA[# 更新说明
本次版本重点增加了脚本组件，并且实现了类似于unity的AssetBundle，支持动态加载场景和资源。


# 相关链接


- [官网](https://www.wonder-3d.com/)
- Wonder官方QQ群： 106047770


# 相关资料

- [Wonder v1.1版本 新特性 视频演示](https://www.bilibili.com/video/av54326698/)

- [Wonder v1.1版本 视频演示相关的 测试资源](https://github.com/Wonder-Technology/Wonder-Demo/tree/master/testResources/1.1/package)




# 新特性

## 增加了Inspector Canvas，可以预览Material和WDB资产

## 增加了脚本组件(实验性功能，请暂不使用)，可加入用户逻辑


## 增加了AssetBundle，以及生成AssetBundle的整个流程(实验性功能，请暂不使用)

AssetBundle用来支持动态加载场景和资源，这在大型游戏和应用中很有用。
比如：
一开始只需要加载第一关的数据，然后在第一关运行中，异步加载第二关数据，并且在第一关结束时无缝切换第二关。
这样就不需要一开始加载所有关卡的数据了，减少了用户等待的时间。

相对于Unity，我们有三个优势：
1)AssetBundle包体更小，生成速度更快
2)AssetBundle支持脚本
3)支持将多个场景AssetBundle中的重复的资源，提出到资源AssetBundle中，这样场景AssetBundle中就没有该资源了


## 增加了进度条



# 注意事项
## 脚本组件和AssetBundle功能目前属于测试阶段，仅供用户测试，请不要用到生产环境
没有相应的文档
目前提供给用户的API也很少，后面会陆续增加



# 详细改动列表

## 引擎
### Bug Fixes

* **api:** fix CoordinateAPI->convertWorldToScreen: change result to option ([9dd6c50](https://github.com/Wonder-Technology/Wonder.js/commit/9dd6c50))
* **asset-bundle:** fix "add manifest data" logic ([357df6b](https://github.com/Wonder-Technology/Wonder.js/commit/357df6b))
* **asset-bundle:** fix "add manifest data" logic ([9cdd2e0](https://github.com/Wonder-Technology/Wonder.js/commit/9cdd2e0))
* **asset-bundle:** fix "generate whole asset bundle" logic ([a90c52e](https://github.com/Wonder-Technology/Wonder.js/commit/a90c52e))
* **clone:** fix "clone transform": not mark dirty in CloneTransformMainService.re ([000bde0](https://github.com/Wonder-Technology/Wonder.js/commit/000bde0))
* **event:** bind mobile event use {"passive": false} ([5464e01](https://github.com/Wonder-Technology/Wonder.js/commit/5464e01))
* **event:** change point dom->target from canvas to body ([688310b](https://github.com/Wonder-Technology/Wonder.js/commit/688310b))
* **event:** fix "unbind arcballCameraController event" bug: unbind should unbind cameraController's all binded functions ([24f861f](https://github.com/Wonder-Technology/Wonder.js/commit/24f861f))
* **event:** fix init event job->chrome bug for getMovementDeltaWhenPointerLocked ([4f3e45b](https://github.com/Wonder-Technology/Wonder.js/commit/4f3e45b))
* **event:** fix init event job->chrome bug for getMovementDeltaWhenPointerLocked: use skip(2) instead of skip(1) ([2e7add8](https://github.com/Wonder-Technology/Wonder.js/commit/2e7add8))
* **event:** fix touch event: not prevent default ([05422f1](https://github.com/Wonder-Technology/Wonder.js/commit/05422f1))
* **event:** fix unbind arcball camera controller->keydown event ([2290309](https://github.com/Wonder-Technology/Wonder.js/commit/2290309))
* **event:** fix unbind arcball event->dispose point drag start/drop event ([8567055](https://github.com/Wonder-Technology/Wonder.js/commit/8567055))
* **event:** touchmove event prevent default ([ee51005](https://github.com/Wonder-Technology/Wonder.js/commit/ee51005))
* **geometry:** now "get points" use slice instead of subarray(for ios);optimize RenderJobUtils->_getOrCreateBuffer->Index: defer get indices data; ([6a45c0a](https://github.com/Wonder-Technology/Wonder.js/commit/6a45c0a))
* **glsl:** fix webgl1_frontLight_fragment.glsl->calcTotalLight ([40574ed](https://github.com/Wonder-Technology/Wonder.js/commit/40574ed))
* **job:** fix worker->add custom job->"if action is BEFORE, the custom job is executed after the source job(in pipeline)" bug ([4db344d](https://github.com/Wonder-Technology/Wonder.js/commit/4db344d))
* **memory:** fix QueryCPUMemoryService->isGeometryBufferNearlyFull:add judge indices16 and indices32 ([27485bc](https://github.com/Wonder-Technology/Wonder.js/commit/27485bc))
* **redo-undo:** fix deep copy gameObject record->disposedArcballCameraControllerArray ([895b2e0](https://github.com/Wonder-Technology/Wonder.js/commit/895b2e0))


### Features

* **api:** add APIAPI.re ([606b8b1](https://github.com/Wonder-Technology/Wonder.js/commit/606b8b1))
* **api:** change scriptAPI to uncurry ([a66f6ef](https://github.com/Wonder-Technology/Wonder.js/commit/a66f6ef))
* **api:** reallocateCPUMemoryJobAPI add reallocateGeometry api ([58f6e1c](https://github.com/Wonder-Technology/Wonder.js/commit/58f6e1c))
* **api:** sceneAPI,script api add findGameObjectsByName ([72382d0](https://github.com/Wonder-Technology/Wonder.js/commit/72382d0))
* **api:** scriptAPI add more apis ([0be975d](https://github.com/Wonder-Technology/Wonder.js/commit/0be975d))
* **asset:** convert->script: support script component not has event function data/attribute ([6def268](https://github.com/Wonder-Technology/Wonder.js/commit/6def268))
* **asset:** convert,assemble,generate add "gameObject->isActive, script->isActive, meshRenderer->isRender" ([83603b8](https://github.com/Wonder-Technology/Wonder.js/commit/83603b8))
* **asset:** wdb add script component data ([5ea3908](https://github.com/Wonder-Technology/Wonder.js/commit/5ea3908))
* **asset-bundle:** add "add manifest data" logic ([bcf6dd4](https://github.com/Wonder-Technology/Wonder.js/commit/bcf6dd4))
* **asset-bundle:** add "assemble rab", "isAssembled" logic ([a92371d](https://github.com/Wonder-Technology/Wonder.js/commit/a92371d))
* **asset-bundle:** add "assemble sab" logic ([001a1d8](https://github.com/Wonder-Technology/Wonder.js/commit/001a1d8))
* **asset-bundle:** add "checkCircleDependency","removeDupliceData" logic ([259919d](https://github.com/Wonder-Technology/Wonder.js/commit/259919d))
* **asset-bundle:** add "generate rab" logic ([8e5c3c7](https://github.com/Wonder-Technology/Wonder.js/commit/8e5c3c7))
* **asset-bundle:** add "generate sab" logic ([124e9bd](https://github.com/Wonder-Technology/Wonder.js/commit/124e9bd))
* **asset-bundle:** add "get ab progress info" logic ([353c8a1](https://github.com/Wonder-Technology/Wonder.js/commit/353c8a1))
* **asset-bundle:** add "load and use asset bundle"->client logic ([3fc4ecb](https://github.com/Wonder-Technology/Wonder.js/commit/3fc4ecb))
* **asset-bundle:** add "release asset bundle data" logic ([9067e17](https://github.com/Wonder-Technology/Wonder.js/commit/9067e17))
* **asset-bundle:** add GenerateAllABSystem and finish its logic ([e7a860d](https://github.com/Wonder-Technology/Wonder.js/commit/e7a860d))
* **asset-bundle:** add more script apis ([39167d7](https://github.com/Wonder-Technology/Wonder.js/commit/39167d7))
* **asset-bundle:** FindDependencyDataSystem add findAllDependencyRAbRelativePathByBreadthSearch and fix ImportABSystem->loadAndAssembleAllDependencyRAB to use mergeArray and concat array; ([37aa67f](https://github.com/Wonder-Technology/Wonder.js/commit/37aa67f))
* **asset-bundle:** fix "assembled sab->gameObject->texture->flipY not equal (generated single sab)sab->gameObject->texture->flipY" bug ([4df279d](https://github.com/Wonder-Technology/Wonder.js/commit/4df279d))
* **asset-bundle:** fix "generate single sab": now can get imageUint8Array data ([b035e61](https://github.com/Wonder-Technology/Wonder.js/commit/b035e61))
* **asset-bundle:** fix "loadAndAssembleAllDependencyRAB and loadSABAndSetToState->load order" bug: now concat and merge loadAndAssembleAllDependencyRAB and then concat loadSABAndSetToState. ([2ac5441](https://github.com/Wonder-Technology/Wonder.js/commit/2ac5441))
* **asset-bundle:** fix "removeDupliceData" logic ([01d4a57](https://github.com/Wonder-Technology/Wonder.js/commit/01d4a57))
* **asset-bundle:** fix api->generateSingleRAB, generateSingleSAB: not return state ([2a4affd](https://github.com/Wonder-Technology/Wonder.js/commit/2a4affd))
* **asset-bundle:** fix BatchOperateWholeGeometrySystem->setGeometryData->set texCoord data ([84b837a](https://github.com/Wonder-Technology/Wonder.js/commit/84b837a))
* **asset-bundle:** fix cache api: change return value from stream to promise ([efa904b](https://github.com/Wonder-Technology/Wonder.js/commit/efa904b))
* **asset-bundle:** fix cache: ImportABSystem->loadAllDependencyRABAndSetToState,loadSABAndSetToState now not handle "initAssetBundleArrayBufferCache" logic ([9434c6e](https://github.com/Wonder-Technology/Wonder.js/commit/9434c6e))
* **asset-bundle:** fix GenerateAllABAPI->generateAllABs: not check circle dependency ([596703a](https://github.com/Wonder-Technology/Wonder.js/commit/596703a))
* **asset-bundle:** fix ImportABSystem->RAB->_loadAndAssembleRAB: use stream to wrap rabRelativePath for mergeArray ([2843138](https://github.com/Wonder-Technology/Wonder.js/commit/2843138))
* **asset-bundle:** optimize load rabs and sab: 1.merge load all; 2.concat assemble dependency rabs ([8394da3](https://github.com/Wonder-Technology/Wonder.js/commit/8394da3))
* **asset-bundle:** run test->use.html use indexDB for cache asset bundle ([7a643fc](https://github.com/Wonder-Technology/Wonder.js/commit/7a643fc))
* **asset-bundle:** script api add getAllDependencyRABCount,getLoadedDependencyRABCount ([010c408](https://github.com/Wonder-Technology/Wonder.js/commit/010c408))
* **asset-bundle:** script api add initAllSABGameObjects,addSABSceneGameObjectChildrenToScene ([1939aca](https://github.com/Wonder-Technology/Wonder.js/commit/1939aca))
* **asset-bundle:** script api add releaseLoadedSAB,releaseLoadedRAB,releaseAssembleRABData ([a874898](https://github.com/Wonder-Technology/Wonder.js/commit/a874898))
* **asset-bundle:** script api: add isSABAssembled ([7303a19](https://github.com/Wonder-Technology/Wonder.js/commit/7303a19))
* **camera:** unbind camera controller event: add unbindArcballCameraControllerPointScaleEvent api ([7346f4c](https://github.com/Wonder-Technology/Wonder.js/commit/7346f4c))
* **clone:** fix clone script component ([4c0ed54](https://github.com/Wonder-Technology/Wonder.js/commit/4c0ed54))
* **data-json:** decrease setting.json->buffer->textureCountPerMaterial to 8 ([58dc883](https://github.com/Wonder-Technology/Wonder.js/commit/58dc883))
* **dispose:** add "dispose array buffer view source texture" ([d5c6e77](https://github.com/Wonder-Technology/Wonder.js/commit/d5c6e77))
* **dispose:** add "dispose texture" logic(draft) ([dce7094](https://github.com/Wonder-Technology/Wonder.js/commit/dce7094))
* **dispose:** fix "dispose basic source texture/array buffer view source texture->bindTextureUnitCacheMap" ([c56411f](https://github.com/Wonder-Technology/Wonder.js/commit/c56411f))
* **dispose:** fix "dispose script component": now clear script component disposed data ([ecae5e7](https://github.com/Wonder-Technology/Wonder.js/commit/ecae5e7))
* **dispose:** GameObjectAPI add disposeGameObjectLightMaterialComponentRemoveTexture; LightMaterialAPI add batchDisposeLightMaterialRemoveTexture; ([8b2ea84](https://github.com/Wonder-Technology/Wonder.js/commit/8b2ea84))
* **dispose:** pass "render worker->dispose basic source texture" ([4692a5e](https://github.com/Wonder-Technology/Wonder.js/commit/4692a5e))
* **gameObject:** gameObjectAPI add disposeGameObjectRemoveTexture api ([8818438](https://github.com/Wonder-Technology/Wonder.js/commit/8818438))
* **gameObject): add "is active" logic; (feat(script:** add "is active" logic); ([d772512](https://github.com/Wonder-Technology/Wonder.js/commit/d772512))
* **imgui:** add sliderFloat api ([6252277](https://github.com/Wonder-Technology/Wonder.js/commit/6252277))
* **imgui:** manageIMGUIAPI add clearIMGUIFunc api ([11e51e6](https://github.com/Wonder-Technology/Wonder.js/commit/11e51e6))
* **jiehuo:** add "draw line->solid line, dash line, alpha" feature ([ffb862a](https://github.com/Wonder-Technology/Wonder.js/commit/ffb862a))
* **jiehuo:** add jiehuo html and api ([0e03ac9](https://github.com/Wonder-Technology/Wonder.js/commit/0e03ac9))
* **jiehuo:** JieHuoAPI add loadImageDataArr api ([c7ec5b9](https://github.com/Wonder-Technology/Wonder.js/commit/c7ec5b9))
* **redo-undo:** fix deep copy gameObject: add copy disposedScriptArray ([d06d0f7](https://github.com/Wonder-Technology/Wonder.js/commit/d06d0f7))
* **script:** fix scriptp api->loadAllDependencyRABAndSetToState ([8ec0299](https://github.com/Wonder-Technology/Wonder.js/commit/8ec0299))
* **shader:** fix "no material shader"->HandleNoMaterialShaderUniformConfigDataService: useSendUniformService.getSendCachableDataByType(type_) ([e2644e6](https://github.com/Wonder-Technology/Wonder.js/commit/e2644e6))
* **skybox:** add skybox(by add job); ([b1bd64f](https://github.com/Wonder-Technology/Wonder.js/commit/b1bd64f))
* **skybox:** fix "left and right reverse" bug ([59ab763](https://github.com/Wonder-Technology/Wonder.js/commit/59ab763))
* **skybox:** fix draw cube texture->gl format ([2e14fd1](https://github.com/Wonder-Technology/Wonder.js/commit/2e14fd1))
* **texture:** basicSourceTextureAPI add disposeBasicSourceTexture; ([3217b6c](https://github.com/Wonder-Technology/Wonder.js/commit/3217b6c))
* **texture:** fix "assemble wdb"->BatchSetTextureAllDataSystem->batchSetNewDiffueMaps ([e5f1cd7](https://github.com/Wonder-Technology/Wonder.js/commit/e5f1cd7))
* update wonder-bs-jest, jest version ([f423264](https://github.com/Wonder-Technology/Wonder.js/commit/f423264))
* **script:** add "enable/disable script event function" api ([75a400b](https://github.com/Wonder-Technology/Wonder.js/commit/75a400b))
* **script:** add draft; pass script example run test; ([52c76db](https://github.com/Wonder-Technology/Wonder.js/commit/52c76db))
* **script:** event function can be undefined ([b8ae68f](https://github.com/Wonder-Technology/Wonder.js/commit/b8ae68f))
* **script:** handle clone script component ([f3a761d](https://github.com/Wonder-Technology/Wonder.js/commit/f3a761d))
* **script:** handle dispose script component ([2c53649](https://github.com/Wonder-Technology/Wonder.js/commit/2c53649))
* **script:** run test: change transform->local position when update ([1cbd100](https://github.com/Wonder-Technology/Wonder.js/commit/1cbd100))
* **script:** ScriptAPI and ScriptAttributeAPI add more api ([745cbd6](https://github.com/Wonder-Technology/Wonder.js/commit/745cbd6))
* **texture:** fix dispose texture: not delete glTexture ([be455eb](https://github.com/Wonder-Technology/Wonder.js/commit/be455eb))
* **worker:** script: exec script in main worker ([7638acb](https://github.com/Wonder-Technology/Wonder.js/commit/7638acb))





## 编辑器

### Bug Fixes

* **asset:** fix "remove folder asset": should remove folder's all children ([79e3d37](https://github.com/Wonder-Technology/Wonder-Editor/commit/79e3d37))
* **asset:** fix "remove material asset":1.remove instead of dispose material->maps; 2.if material has no gameObjects, dispose material; ([d81994f](https://github.com/Wonder-Technology/Wonder-Editor/commit/d81994f))
* **asset:** fix remove texture asset: if texture has no materials, should dispose texture's engine data ([c711c20](https://github.com/Wonder-Technology/Wonder-Editor/commit/c711c20))
* **asset:** fix rename asset in inspector: if value not change, shouldn't warn ([22eeb02](https://github.com/Wonder-Technology/Wonder-Editor/commit/22eeb02))
* **asset:** script attribute: sort entries show order; add check script event function/attribute jsObj str; ([5185889](https://github.com/Wonder-Technology/Wonder-Editor/commit/5185889))
* **console:** fix "str.split error" bug: fix ConsoleBaseComponent->buildMultiLineStringComponent ([272a8ba](https://github.com/Wonder-Technology/Wonder-Editor/commit/272a8ba))
* **event:** fix FloatInput,IntInput->drag over in pointer lock->movement ([a085859](https://github.com/Wonder-Technology/Wonder-Editor/commit/a085859))
* **event:** fix init event job->chrome bug for getMovementDeltaWhenPointerLocked ([d60b64f](https://github.com/Wonder-Technology/Wonder-Editor/commit/d60b64f))
* **event:** fix init event job->chrome bug for getMovementDeltaWhenPointerLocked: use skip(2) instead of skip(1) ([6eb7a9d](https://github.com/Wonder-Technology/Wonder-Editor/commit/6eb7a9d))
* **imgCanvas:** fix bug: remove texture should redraw material snapshot and remove container gameObj ([a51373c](https://github.com/Wonder-Technology/Wonder-Editor/commit/a51373c))
* **imgCanvas:** use drawImage func instead of Js.object.type ([4c94f56](https://github.com/Wonder-Technology/Wonder-Editor/commit/4c94f56))
* **inspectorCanvas:** fix texture cache: if change texture asset,clear its cache ([c93df9f](https://github.com/Wonder-Technology/Wonder-Editor/commit/c93df9f))
* **inspectorEngine:** fix bug caused by 192843c39172cd9983ac1ed2f524f10b3015209f ([db62c89](https://github.com/Wonder-Technology/Wonder-Editor/commit/db62c89))
* **inspectorEngine:** fix bug: stateData no state ([8ea3542](https://github.com/Wonder-Technology/Wonder-Editor/commit/8ea3542))
* **inspectorEngine:** need fix bug ([192843c](https://github.com/Wonder-Technology/Wonder-Editor/commit/192843c))
* **publish:** index.html: use contentLength instead of totalByteLength ([201e5da](https://github.com/Wonder-Technology/Wonder-Editor/commit/201e5da))
* **resize:** fix bug: enter editor; show material inspector; resize to big window; show blank area; ([9995f8b](https://github.com/Wonder-Technology/Wonder-Editor/commit/9995f8b))
* **ui:** mouse over FloatInput/IntInput->drag zone should show move cursor ([b0c4b57](https://github.com/Wonder-Technology/Wonder-Editor/commit/b0c4b57))
* **wdb:** need jack fix bug ([974710e](https://github.com/Wonder-Technology/Wonder-Editor/commit/974710e))


### Features

* **abUI:** finish all asset bundle ui ([2c24176](https://github.com/Wonder-Technology/Wonder-Editor/commit/2c24176))
* **ambientLight:** add ambient light in inspector canvas ([3c00512](https://github.com/Wonder-Technology/Wonder-Editor/commit/3c00512))
* **asset:** add "remove script event function, script attribute asset" ([119af1d](https://github.com/Wonder-Technology/Wonder-Editor/commit/119af1d))
* **asset:** add script event function asset; add script attribute asset; ([2e0facb](https://github.com/Wonder-Technology/Wonder-Editor/commit/2e0facb))
* **asset:** fix rename script attribute asset->attribute name: now update in all script components ([fee5180](https://github.com/Wonder-Technology/Wonder-Editor/commit/fee5180))
* **asset:** script attribute asset: add "update script attribute in all script components" logic ([32d3785](https://github.com/Wonder-Technology/Wonder-Editor/commit/32d3785))
* **asset:** script event function asset: add "update script event function in all script components" logic ([fe76e2e](https://github.com/Wonder-Technology/Wonder-Editor/commit/fe76e2e))
* **asset-bundle:** add "asset->load assetBundle" logic ([51fba9d](https://github.com/Wonder-Technology/Wonder-Editor/commit/51fba9d))
* **asset-bundle:** add "generate all ab" draft logic(pass compile) ([e3876ab](https://github.com/Wonder-Technology/Wonder-Editor/commit/e3876ab))
* **asset-bundle:** add "generate single sab" ([5d6a4cf](https://github.com/Wonder-Technology/Wonder-Editor/commit/5d6a4cf))
* **asset-bundle:** add geo.png ([ec60c07](https://github.com/Wonder-Technology/Wonder-Editor/commit/ec60c07))
* **asset-bundle:** add HeaderAssetBundle->"generate single rab" related ui ([150ca0c](https://github.com/Wonder-Technology/Wonder-Editor/commit/150ca0c))
* **asset-bundle:** add SelectTree ui draft ([63fb0b1](https://github.com/Wonder-Technology/Wonder-Editor/commit/63fb0b1))
* **asset-bundle:** asset tree->add assetBundle node ([f0f289c](https://github.com/Wonder-Technology/Wonder-Editor/commit/f0f289c))
* **asset-bundle:** begin "import ab at runtime when run": rewrite script api for asset bundle ([594684b](https://github.com/Wonder-Technology/Wonder-Editor/commit/594684b))
* **asset-bundle:** export/import wpk add asset bundle ([6310e5f](https://github.com/Wonder-Technology/Wonder-Editor/commit/6310e5f))
* **asset-bundle:** finish "build select tree from asset tree for generate single rab" ([75c226b](https://github.com/Wonder-Technology/Wonder-Editor/commit/75c226b))
* **asset-bundle:** finish "generateAndDownloadSingleRAB" logic ([c973ebf](https://github.com/Wonder-Technology/Wonder-Editor/commit/c973ebf))
* **asset-bundle:** fix generate single rab: added light material shouldn't add to basic material resource data ([b149ac7](https://github.com/Wonder-Technology/Wonder-Editor/commit/b149ac7))
* **asset-bundle:** fix HeaderAssetBundleGenerateAllAB: change generate-single-sab to generate-all-ab ([cf32db3](https://github.com/Wonder-Technology/Wonder-Editor/commit/cf32db3))
* **asset-bundle:** fix modal: click close button shouldn't generate single ab ([a179227](https://github.com/Wonder-Technology/Wonder-Editor/commit/a179227))
* **asset-bundle:** header->"generate single rab" add "name" input ([2c34074](https://github.com/Wonder-Technology/Wonder-Editor/commit/2c34074))
* **asset-bundle:** publish local: write asset bundle to zip ([5e45104](https://github.com/Wonder-Technology/Wonder-Editor/commit/5e45104))
* **asset-bundle:** support load "asset bundle zip" to asset ([72b90e6](https://github.com/Wonder-Technology/Wonder-Editor/commit/72b90e6))
* **assetCanvas:** finish asset canvas demo ([7cf4536](https://github.com/Wonder-Technology/Wonder-Editor/commit/7cf4536))
* **camera:** fix scene view->edit camera: fix point scale ([bcf22bc](https://github.com/Wonder-Technology/Wonder-Editor/commit/bcf22bc))
* **controller:** add "exec script event functions when run" logic ([a676fef](https://github.com/Wonder-Technology/Wonder-Editor/commit/a676fef))
* **engine:** update wonder.js to 1.0.2 ([15da515](https://github.com/Wonder-Technology/Wonder-Editor/commit/15da515))
* **engine:** update wonder.js to 1.1.0 ([dda7c6b](https://github.com/Wonder-Technology/Wonder-Editor/commit/dda7c6b))
* **engine:** update wonder.js version ([50402dd](https://github.com/Wonder-Technology/Wonder-Editor/commit/50402dd))
* **engine:** update wonder.js version ([bcf12f1](https://github.com/Wonder-Technology/Wonder-Editor/commit/bcf12f1))
* **engine:** update wonder.js version ([238649c](https://github.com/Wonder-Technology/Wonder-Editor/commit/238649c))
* **engine:** update wonder.js version ([f7e1eab](https://github.com/Wonder-Technology/Wonder-Editor/commit/f7e1eab))
* **engine:** update wonder.js version ([b429bce](https://github.com/Wonder-Technology/Wonder-Editor/commit/b429bce))
* **engine:** update wonder.js, wonder-webgl version ([9d41c84](https://github.com/Wonder-Technology/Wonder-Editor/commit/9d41c84))
* **export:** export mateial snapshot ([10fda6d](https://github.com/Wonder-Technology/Wonder-Editor/commit/10fda6d))
* **header:** add "New Scene" ([eb5d73a](https://github.com/Wonder-Technology/Wonder-Editor/commit/eb5d73a))
* **header:** fix "New Scene": should operate in stop ([5792121](https://github.com/Wonder-Technology/Wonder-Editor/commit/5792121))
* **header:** fix "NewScene": should clear current scene tree node before exec update_transform_gizmos job ([b65da2f](https://github.com/Wonder-Technology/Wonder-Editor/commit/b65da2f))
* **imgCanvas:** create import wdb/gltf file material snapshot ([1c75f35](https://github.com/Wonder-Technology/Wonder-Editor/commit/1c75f35))
* **imgCanvas:** finish remove material should remove it's imageData from imageDataMap ([76c648a](https://github.com/Wonder-Technology/Wonder-Editor/commit/76c648a))
* **imgCanvas:** finish TODOs ([98e2bb6](https://github.com/Wonder-Technology/Wonder-Editor/commit/98e2bb6))
* **imgCanvas:** fix "create material/wdb snapshot": now clear img canvas before draw ([245be64](https://github.com/Wonder-Technology/Wonder-Editor/commit/245be64))
* **imgCanvas:** fix AssetTreeInspectorUtils->disposeContainerGameObjectAllChildrenAndReallocateCPUMemory->_reallocateCPUMemory: add condition judge ([90e4a49](https://github.com/Wonder-Technology/Wonder-Editor/commit/90e4a49))
* **imgCanvas:** store img-canvas context in editorState ([2b71dfc](https://github.com/Wonder-Technology/Wonder-Editor/commit/2b71dfc))
* **imgui:** fix scene view imgui: if SceneViewIMGUIUtils->convertWorldToScreen return None, return (-100, -100) ([a6a1fdd](https://github.com/Wonder-Technology/Wonder-Editor/commit/a6a1fdd))
* **inspector:** finish create material sphere into inspector canvas ([8573a77](https://github.com/Wonder-Technology/Wonder-Editor/commit/8573a77))
* **inspectorCanvas:** arcball camera controller->event work ([bb505cb](https://github.com/Wonder-Technology/Wonder-Editor/commit/bb505cb))
* **inspectorCanvas:** fix "cache texture": load wdb->extract material assets shouldn't dispose texture ([48b4db8](https://github.com/Wonder-Technology/Wonder-Editor/commit/48b4db8))
* **inspectorCanvas:** fix arcball camera controller: left mouse button can still drag ([f236513](https://github.com/Wonder-Technology/Wonder-Editor/commit/f236513))
* **inspectorCanvas:** fix generate material snapshot: generate snapshot in MaterialInspector->willUnmount ([5c166e9](https://github.com/Wonder-Technology/Wonder-Editor/commit/5c166e9))
* **inspectorCanvas:** fix MaterialInspector->update snapshot bug ([b6d3a64](https://github.com/Wonder-Technology/Wonder-Editor/commit/b6d3a64))
* **inspectorCanvas:** fix remove material asset: if material is removed, not create material sphere ([7fe0f3f](https://github.com/Wonder-Technology/Wonder-Editor/commit/7fe0f3f))
* **inspectorCanvas:** fix:restore arcball camera controller->angle  before update snapshot ([62c8c40](https://github.com/Wonder-Technology/Wonder-Editor/commit/62c8c40))
* **inspectorCanvas:** improve light ([b084951](https://github.com/Wonder-Technology/Wonder-Editor/commit/b084951))
* **inspectorCanvas:** update default material snapshot base64 ([c801917](https://github.com/Wonder-Technology/Wonder-Editor/commit/c801917))
* **inspectorCanvas:** wdb inspector: generate snapshot in WDBInspector->didMount ([952ff4c](https://github.com/Wonder-Technology/Wonder-Editor/commit/952ff4c))
* **inspectorCanvas:** wDBInspector, MaterialInspector->didMount add tryCatch ([6ab8559](https://github.com/Wonder-Technology/Wonder-Editor/commit/6ab8559))
* **inspectorEngine:** show sphere and camera ([938daed](https://github.com/Wonder-Technology/Wonder-Editor/commit/938daed))
* **job:** init_pipelines remove init_script job ([e9ac408](https://github.com/Wonder-Technology/Wonder-Editor/commit/e9ac408))
* **language:** add arcball camera and light language ([30126b9](https://github.com/Wonder-Technology/Wonder-Editor/commit/30126b9))
* **language:** add asset and inspector language ([14215de](https://github.com/Wonder-Technology/Wonder-Editor/commit/14215de))
* **language:** add camera group language ([ef33b41](https://github.com/Wonder-Technology/Wonder-Editor/commit/ef33b41))
* **language:** add message language ([7c08bc0](https://github.com/Wonder-Technology/Wonder-Editor/commit/7c08bc0))
* **language:** change header-edit->zh ([6b8efc8](https://github.com/Wonder-Technology/Wonder-Editor/commit/6b8efc8))
* **language:** finish header and controller language ([6053827](https://github.com/Wonder-Technology/Wonder-Editor/commit/6053827))
* **language:** fix language data ([b7fae29](https://github.com/Wonder-Technology/Wonder-Editor/commit/b7fae29))
* **language:** restore DomHelper->locationReload to use reload ([ce4b198](https://github.com/Wonder-Technology/Wonder-Editor/commit/ce4b198))
* **left-header:** fix clone gameObject has script component ([814aca0](https://github.com/Wonder-Technology/Wonder-Editor/commit/814aca0))
* **mainEditorMaterial:** split MainEditorBasic/lightMaterial to MainEditorBasic/LightMaterialForGam ([6577143](https://github.com/Wonder-Technology/Wonder-Editor/commit/6577143))
* **message:** change message -> isActive to be immutable ([e1860e7](https://github.com/Wonder-Technology/Wonder-Editor/commit/e1860e7))
* **message:** finish message demo ([58f197c](https://github.com/Wonder-Technology/Wonder-Editor/commit/58f197c))
* **message:** finish message demo ([0710f75](https://github.com/Wonder-Technology/Wonder-Editor/commit/0710f75))
* **message:** finish message feature ([46ce318](https://github.com/Wonder-Technology/Wonder-Editor/commit/46ce318))
* **message:** finish message feature ([51aeea2](https://github.com/Wonder-Technology/Wonder-Editor/commit/51aeea2))
* **progress:** add progress willUnmount off event ([90ee1d8](https://github.com/Wonder-Technology/Wonder-Editor/commit/90ee1d8))
* **progress:** finish offCustomGlobalEventByEventName in progress->willUnmount ([8a12a22](https://github.com/Wonder-Technology/Wonder-Editor/commit/8a12a22))
* **progress:** finish progress feat and style ([548fa0c](https://github.com/Wonder-Technology/Wonder-Editor/commit/548fa0c))
* **progress:** load wdb, import package add progress ([36b9f75](https://github.com/Wonder-Technology/Wonder-Editor/commit/36b9f75))
* **progress:** use send local ui state instead of operate dom ([7912f99](https://github.com/Wonder-Technology/Wonder-Editor/commit/7912f99))
* **publish:** fix publish local->no worker: fix for asset bundle ([78af837](https://github.com/Wonder-Technology/Wonder-Editor/commit/78af837))
* **publish:** fix publish local->worker: fix for asset bundle ([fe1eb33](https://github.com/Wonder-Technology/Wonder-Editor/commit/fe1eb33))
* **publish:** update engine files ([80ab8fe](https://github.com/Wonder-Technology/Wonder-Editor/commit/80ab8fe))
* **pwa:** finish pwa update data ([2825e30](https://github.com/Wonder-Technology/Wonder-Editor/commit/2825e30))
* **pwa:** finish pwa update data ([c322bcc](https://github.com/Wonder-Technology/Wonder-Editor/commit/c322bcc))
* **redo-undo:** fix redo/undo remove script component ([5e8e4fc](https://github.com/Wonder-Technology/Wonder-Editor/commit/5e8e4fc))
* **redo-undo:** script component->attribute add redo/undo ([cdb392a](https://github.com/Wonder-Technology/Wonder-Editor/commit/cdb392a))
* **redo-undo:** script component->event function add redo/undo ([6e58c7c](https://github.com/Wonder-Technology/Wonder-Editor/commit/6e58c7c))
* **redo-undo:** script event function,script attribute asset add redo-undo ([dd482af](https://github.com/Wonder-Technology/Wonder-Editor/commit/dd482af))
* **script:** add "store script assets in asb", "relate script assets when import package", "extract script assets when load asset" logic(draft) ([5300181](https://github.com/Wonder-Technology/Wonder-Editor/commit/5300181))
* **script:** fix event function->body str: replace "return engineState" to return engineState;" ([d1fc979](https://github.com/Wonder-Technology/Wonder-Editor/commit/d1fc979))
* **script:** fix script component: support Int type ([560e7fb](https://github.com/Wonder-Technology/Wonder-Editor/commit/560e7fb))
* **script:** rewrite script api->asset bundle api->addSABSceneGameObjectChildrenToScene, setSABSceneGameObjectToBeScene, disposeSceneAllChildren ([e2fa8cc](https://github.com/Wonder-Technology/Wonder-Editor/commit/e2fa8cc))
* **script:** script api now update editor ([5fb6843](https://github.com/Wonder-Technology/Wonder-Editor/commit/5fb6843))
* **script-component:** "add script event function": if no scriptEventFunction asset, warn ([bc26270](https://github.com/Wonder-Technology/Wonder-Editor/commit/bc26270))
* **script-component:** add "remove script component" logic ([3d06aab](https://github.com/Wonder-Technology/Wonder-Editor/commit/3d06aab))
* **script-component:** add "remove script event function" ([0cbcaa0](https://github.com/Wonder-Technology/Wonder-Editor/commit/0cbcaa0))
* **script-component:** add "script attribute" logic ([afaba0c](https://github.com/Wonder-Technology/Wonder-Editor/commit/afaba0c))
* **script-component:** add "script attribute"->fields logic ([ad54248](https://github.com/Wonder-Technology/Wonder-Editor/commit/ad54248))
* **script-component:** add script component logic(draft); add "add script event function" logic(draft); ([af77d66](https://github.com/Wonder-Technology/Wonder-Editor/commit/af77d66))
* **script-component:** fix "add script event function" bugs ([4dbcf39](https://github.com/Wonder-Technology/Wonder-Editor/commit/4dbcf39))
* **script-component:** HideScriptEventFunctionGroupForAdd,HideScriptEventFunctionGroupForChange now not dispatch ([f21fa91](https://github.com/Wonder-Technology/Wonder-Editor/commit/f21fa91))
* **snapshot:** add basicMaterial and lightMaterial closeColorPick and blurShininess event handler ([d520210](https://github.com/Wonder-Technology/Wonder-Editor/commit/d520210))
* **wdb:** add imageDataIndex in wdbData ([bacfd2a](https://github.com/Wonder-Technology/Wonder-Editor/commit/bacfd2a))
* **wdb:** add WDBInspector.re and refactor didMount and willunMount ([29ddbef](https://github.com/Wonder-Technology/Wonder-Editor/commit/29ddbef))
* **wdb:** finish clone wdb gameObject to other engine state ([58c609f](https://github.com/Wonder-Technology/Wonder-Editor/commit/58c609f))
* **wdb:** finish export package store wdb snapshot to asb, import package should use it ([a7c265b](https://github.com/Wonder-Technology/Wonder-Editor/commit/a7c265b))
* **wdb:** import wdb create snapshot ([abdb9a8](https://github.com/Wonder-Technology/Wonder-Editor/commit/abdb9a8))
* **wdb:** import wdb should dispose inspector canvas gameObject ([07e54bf](https://github.com/Wonder-Technology/Wonder-Editor/commit/07e54bf))
* remove ImmutableSparseMapService.re ([291b8e4](https://github.com/Wonder-Technology/Wonder-Editor/commit/291b8e4))
* update files ([91c58e4](https://github.com/Wonder-Technology/Wonder-Editor/commit/91c58e4))
* update files ([e3a5e09](https://github.com/Wonder-Technology/Wonder-Editor/commit/e3a5e09))
* update wonder.js,wonder-bs-jest,wonder-commonlib,jest version ([3891511](https://github.com/Wonder-Technology/Wonder-Editor/commit/3891511))


### Performance Improvements

* **img:** change img size ([a50b2d3](https://github.com/Wonder-Technology/Wonder-Editor/commit/a50b2d3))
* **inspectorCanvas:** optimize render inspector canvas: cache texture ([51a9e19](https://github.com/Wonder-Technology/Wonder-Editor/commit/51a9e19))]]></description></item><item><title>用函数式编程，从0开发3D引擎和编辑器（二）：函数式编程准备</title><link>http://www.cnblogs.com/chaogex/archive/2019/05/04/10807469.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sat, 04 May 2019 00:09:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/05/04/10807469.html</guid><description><![CDATA[大家好，本文介绍了本系列涉及到的函数式编程的主要知识点，为正式开发做好了准备。

# 函数式编程的优点

1.粒度小

相比面向对象编程以类为单位，函数式编程以函数为单位，粒度更小。

正所谓：
> 我只想要一个香蕉，而面向对象却给了我整个森林


2.性能好

大部分人认为函数式编程差，主要基于下面的理由(参考 [JavaScript 函数式编程存在性能问题么？](https://www.zhihu.com/question/54637225))：
1)柯西化、函数组合等操作增加时间开销
2)map、reduce等操作，会进行多次遍历，增加时间开销
3)Immutable数据每次操作都会被拷贝为新的数据，增加时间和内存开销


而我说性能好，是指通过“Reason的编译优化+Immutable/Mutable结合使用+递归/迭代结合使用”，可以解决这些问题：
1)由于Bucklescript编译器在编译时的优化，柯西化等操作和Immutable数据被编译成了优化过的js代码，大幅减小了时间开销
2)由于Reason支持Mutable和for,while迭代操作，所以可以在性能热点使用它们，提高性能。



3.擅长处理数据，适合3D领域编程

通过高阶函数、柯西化、组合等工具，函数式编程可以像流水线一样对数据进行管道操作，非常方便。

3D程序有大量的数据要操作，从函数式编程的角度来看：

3D程序=数据+逻辑

因此，我们可以：
使用Immutable/Mutable、Data Oriented等思想和数据结构表达数据；
使用函数表达逻辑；
使用组合、柯西化等工具，把数据和逻辑关联起来。


## 更多讨论

[FP之优点](https://www.kancloud.cn/kancloud/functional-programm-for-rest/56930)
[函数式编程（Functional Programming）相比面向对象编程（Object-oriented Programming）有哪些优缺点？](https://www.zhihu.com/question/19732025/answer/530161703)




# 本系列使用的函数式编程语言

我们使用Reason语言，它是从Ocaml而来的，属于非纯函数式编程语言。

而我们熟知的Haskell，属于纯函数式编程语言。

[Reason学习文档](https://reasonml.github.io/docs/en/what-and-why)

## 为什么不用纯函数式编程语言

1.更高的性能
Reason支持Mutable、迭代操作，提高了性能

2.更简单易用
1)允许非纯操作，所以不需要使用Haskell中的各种Monad
2)严格求值相对于惰性求值更简单。




## 搭建Reason开发环境

详见[Reason的介绍和搭建Reason开发环境](https://zhuanlan.zhihu.com/p/59220417)
    





# 本系列涉及的函数式编程知识点


## 数据


- Immutable  

**介绍**
创建不可变数据之后，对其任何的操作，都会返回一个拷贝后的新数据。


**示例**
Reason的变量默认为immutable：

```js
let a = 1;

/* a为immutable */
```


Reason也有专门的不可变数据结构，如Tuple,List,Record。

这里以Record为例，它类似于Javascript中的Object：
首先定义Record的类型:

```js
type person = {
  age: int,
  name: string
};
```

然后定义Record的值：
    
```js
let me = {
  age: 5,
  name: "Big Reason"
};
```

使用这个Record，如修改"age"的值：

```js
let newMe = {
    ...me,
    age: 10
};

Js.log(newMe === me); /* false */

```
newMe是从me拷贝而来，任何对newMe的修改，都不会影响me。




**在Wonder中的应用**

    
*在编辑器中的应用*
编辑器的所有数据都是Immutable的，这样的好处是：
1)不用关心数据之间的关联关系，因为每个数据都是独立的
2)不用担心状态被修改，减少了很多bug
3)实现Redo/Undo功能时非常简单，直接把Immutable的数据压入History的栈里即可，不用深拷贝/恢复数据。
    
*在引擎中的应用*
大部分函数的局部变量都是Immutable的（如使用tuple,record结构)。
    

    
    


**相关资料**
[Reason->Let Binding](https://reasonml.github.io/docs/en/let-binding)
[Reason->Record](https://reasonml.github.io/docs/en/record)
[facebook immutable.js 意义何在，使用场景？](https://www.zhihu.com/question/28016223)
[Introduction to Immutable.js and Functional Programming Concepts](https://auth0.com/blog/intro-to-immutable-js/)





- Mutable

**介绍**
对可变数据的任何操作，都会直接修改原数据。


**示例**
Reason通过"ref"关键字，标志变量为Mutable。
 
```js
let foo = ref(5);

let five = foo^; 

foo := 6;   //foo===five===6

```



Reason也可以通过"mutable"关键字，标志Record的字段为Mutable。 

```js
type person = {
  name: string,
  mutable age: int
};
let baby = {name: "Baby Reason", age: 5};
baby.age = baby.age + 1; /* 修改原数据baby的age为6 */

```


**在Wonder中的应用**

因为操作Mutable数据不会造成拷贝，没有垃圾回收cg的开销，所以在性能热点处，常常使用Mutable数据。
    

**相关资料**
[Reason->Mutable](https://reasonml.github.io/docs/en/mutation)



## 函数

函数是第一公民，函数是数据。


相关资料：
[如何理解在 JavaScript 中 "函数是第一等公民" 这句话?](https://www.zhihu.com/question/67652709)
[Reason->Function](https://reasonml.github.io/docs/en/function)






- 纯函数

**介绍**

> 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。


**示例**


```js
let a = 1;


/* func2是纯函数 */
let func2 = value => value;

/* func1是非纯函数，因为使用了外部变量"a" */
let func1 = () => a;


```



**在Wonder中的应用**

脚本的钩子函数(如init,update,dispose等函数)属于纯函数（但不能算严格的纯函数），这样是为了：
1)能够正确序列化
脚本会先序列化为字符串，保存在文件中（如编辑器导出的包中）；
然后在导入该文件时（如编辑器导入包），将脚本字符串反序列化为函数（执行：eval('(' + funcStr + ')')）。如果脚本的钩子函数不是纯函数(如调用了外部变量)，则会报错。

2)支持多线程
目前脚本是在主线程执行的，但因为它是纯函数，所以未来可以放在单独的脚本线程中执行，提高性能。


*注意*：
虽然纯函数好处很多，但Wonder中大多数的函数都是非纯函数，这是因为：
1)为了性能
2)为了简单易用，所以允许副作用，很少使用容器


    

**相关资料**
[第 3 章：纯函数的好处](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#%E8%BF%BD%E6%B1%82%E2%80%9C%E7%BA%AF%E2%80%9D%E7%9A%84%E7%90%86%E7%94%B1)


- 高阶函数



**介绍**
函数能够作为数据，成为高阶函数的参数或者返回值。




**示例**


```js
let func1 = func => func(1);

let func2 = value => value * 2;

func1(func2);   /* func1是高阶函数，因为func2是func1的参数 */
```


**在Wonder中的应用**

多个函数中常常有一些共同的逻辑，需要消除重复，可以通过提出一个私有的高阶函数来解决。具体示例如下：
重构前：
```js
let add1 = value => value + 2;

let add2 = value => value + 10;

let minus1 = value => value - 10;

let minus2 = value => value - 200;

let compute1 = value => value |> add1 |> minus1;

let compute2 = value => value |> add2 |> minus2;

/* compute1,compute2有重复逻辑 */

```

重构后：

```js
...

let _compute = (value, (addFunc, minusFunc)) =>
  value |> addFunc |> minusFunc;

let compute1 = value => _compute(value, (add1, minus1));

let compute2 = value => _compute(value, (add2, minus2));
```

    


**相关资料**
[理解 JavaScript 中的高阶函数](https://zhuanlan.zhihu.com/p/49579052)



- 柯西化


**介绍**
> 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。
你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用。


**示例**

```js
let func1 = (value1, value2) => value1 + value2;

let func2 = func1(1);

func2(2);   /* 3 */
```


**在Wonder中的应用**

应用的地方太多了，此处省略。


    


**相关资料**
[第 4 章: 柯里化（curry）](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8F%8C%E5%85%B3%E8%AF%AD%E5%92%96%E5%96%B1)
[Currying](https://fsharpforfunandprofit.com/posts/currying/)


## 类型


**相关资料**
[The "Understanding F# types" series](https://fsharpforfunandprofit.com/series/understanding-fsharp-types.html)

- 基本类型

**介绍**
Reason是强类型语言，包含int、float、string等基本类型。



**示例**

```js
type a = string;   /* 定义a为string类型 */

let str:a = "zzz";   /* 变量str为a类型 */
```


**在Wonder中的应用**

类型在wonder中应用广泛，包括以下的使用场景：
1)类型驱动设计
2)领域建模
3)枚举


    
    


**相关资料**

[Reason->Type](https://reasonml.github.io/docs/en/type)
[Algebraic type sizes and domain modelling](https://fsharpforfunandprofit.com/posts/type-size-and-design/)



- Discriminated Union Type


**介绍**
类型可以接受参数，还可以组合其它的类型。


**示例**

```js
type result('a, 'b) =
  | Ok('a)
  | Error('b);

type myPayload = {data: string};

let payloadResults: list(result(myPayload, string)) = [
  Ok({data: "hi"}),
  Ok({data: "bye"}),
  Error("Something wrong happened!")
];
```


**在Wonder中的应用**

1)作为容器的实现
2)是实现本文后面的Recursive Type的基础
    
    


**相关资料**
[Reason->Type Argument](https://reasonml.github.io/docs/en/more-on-type#type-argument)
[Reason->Null, Undefined & Option](https://reasonml.github.io/docs/en/null-undefined-option)
[Discriminated Unions](https://fsharpforfunandprofit.com/posts/discriminated-unions/)


- 抽象类型


**介绍**
有时候我们想定义一个类型，它不是某一个具体的类型，可以将其定义为抽象类型。


**示例**

```js
type value;

type a = value; /* a为value类型 */
```


**在Wonder中的应用**

包括以下的使用案例：
1)在封装WebGL api的FFI中([什么是FFI?](https://reasonml.github.io/docs/en/external#docsNav))，把WebGL的上下文定义为抽象类型。

示例代码如下：
```js
/* FFI */


/* 抽象类型 */
type webgl1Context;

[@bs.send]
external getWebgl1Context : ('canvas, [@bs.as "webgl"] _) => webgl1Context = "getContext";

[@bs.send.pipe: webgl1Context]
external viewport : (int, int, int, int) => unit = "";




/* client code */

/* canvasDom是canvas的dom，此处省略了获取它的代码 */
/* gl是webgl1Context类型 */
/* 编译后的js代码为：var gl = canvasDom.getContext("webgl"); */
let gl = getWebgl1Context(canvasDom);   

/* 编译后的js代码为：gl.viewport(0,0,100,100); */
gl |> viewport(0,0,100,100);

```


2)脚本->属性->value可以为int或者float类型，因此将value设为抽象类型，并且定义抽象类型和int、float类型之间的转换FFI。

示例代码如下：
```js

type scriptAttributeType =
  | Int
  | Float;


/* 抽象类型 */
type scriptAttributeValue;

type scriptAttributeField = {
  type_: scriptAttributeType,
  value: scriptAttributeValue
};

/* 定义scriptAttributeValue和int,float类型相互转换的FFI */

external intToScriptAttributeValue: int => scriptAttributeValue = "%identity";

external floatToScriptAttributeValue: float => scriptAttributeValue =
  "%identity";

external scriptAttributeValueToInt: scriptAttributeValue => int = "%identity";

external scriptAttributeValueToFloat: scriptAttributeValue => float =
  "%identity";
  
  
/* client code */

/* 创建scriptAttributeField，设置value的数据(int类型) */

let scriptAttributeField = {
    type_: Int,
    value:intToScriptAttributeValue(10) 
};



/* 修改scriptAttributeField->value */

let newScriptAttributeField = {
    ...scriptAttributeField,
    value: (scriptAttributeValueToInt(scriptAttributeField.value) + 1) |> intToScriptAttributeValue
};
```


    

**相关资料**
[抽象类型(Abstract Types)](https://ocaml.org/learn/tutorials/modules.zh.html#Abstract-Types)











- Recursive Type


**介绍**
从类型定义上看，可以看成是Discriminated Union Type，只是其中至少有一个union type为自身类型，即递归地指向自己。




**示例**
还是看代码好理解点，具体示例如下：
```js
type nodeId = int;

/* tree是Recursive Type，它的文件夹节点包含了子节点，而子节点的类型为自身 */
type tree =
  | LeafNode(nodeId)
  | FolderNode(
      nodeId,
      array(tree),
    );

```


**在Wonder中的应用**

    
*在编辑器中的应用*

Recursive Type常用在树中，如编辑器的资产树的类型就是Recursive Type。
    

    


**相关资料**
[The "Recursive types and folds" series](https://fsharpforfunandprofit.com/series/recursive-types-and-folds.html)
[Map as a Recursion Scheme in OCaml](http://keleshev.com/map-as-a-recursion-scheme-in-ocaml)





## 过程


- 组合

**介绍**
多个函数可以组合起来，使得前一个函数的返回值是后一个函数的输入，从而对数据进行管道处理。


**示例**

```js
let func1 = value => value1 + 1;

let func2 = value => value1 + 2;

10 |> func1 |> func2;   /* 13 */
```


**在Wonder中的应用**


    
    

*在引擎中的应用*


组合可以应用在多个层面，如函数层面和job层面。

```js
job = 多个函数的组合
```

我们来看下job组合的应用示例：

从时间序列上来看：
```js
引擎＝初始化+主循环
```

而初始化和每一次循环，都是多个job组合而成的管道操作：

```js
初始化 = create_canvas |> create_gl |> ...


每一次循环 = tick |> dispose |> reallocate_cpu_memory |> update_transform |> ...
```
    


**相关资料**

[第 5 章: 代码组合（compose）](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html)

- 递归

**介绍**

遍历操作可以分成两类：
迭代
递归

递归就是指函数调用自己，满足终止条件时结束。如深度优先遍历是递归操作，而广度优先遍历是迭代操作。

*注意：*
尽量写成尾递归，这样Reason会将其编译成迭代操作。


**示例**


```js
let rec func1 = (value, result) => {
    value > 3 ? result : func1(value + 1, result + value);
};

func1(1, 0);   /* 0+1+2+3=6; */
```


**在Wonder中的应用**

几乎所有的遍历都是尾递归，只有在少数使用Mutable和少数性能热点的地方，使用迭代操作（使用for或while命令）。
    


**相关资料**
[什么是尾递归？](https://www.zhihu.com/question/20761771)
[Reason->Recursive Functions](https://reasonml.github.io/docs/en/function#recursive-functions)





- 模式匹配

**介绍**
使用switch结构代替if else处理程序分支。


**示例**

```js
let func1 = value => {
    switch(value){
        | 0 => 10 
        | _ => 100
    }
};

func1(0);   /* 10 */
func1(2);   /* 100 */
```


**在Wonder中的应用**

主要用在下面三种场景：

1)取出容器的值

```js
type a = 
    | A(int)
    | B(string);
    
switch(a){
    | A(value) => value
    | B(value) => value
};
```

    
2)处理[Option](https://reasonml.github.io/docs/en/null-undefined-option)


```js
let a = Some(1);

switch(a){
    | None => ...
    | Some(value) => ...
}
```

3)处理枚举类型

```js
type a = 
    | A
    | B;
    
switch(a){
    | A => ...
    | B => ...
}
```


**相关资料**
[Reason->Pattern Matching!](https://reasonml.github.io/docs/en/pattern-matching)
[模式匹配](https://www.kancloud.cn/kancloud/functional-programm-for-rest/56937)




## 异步


- 函数反应式编程


**介绍**
处理异步，主要有以下的方法：
1)回调函数
缺点：过多的回调导致嵌套层次太深，容易陷入回调地狱，不易维护。
2)Promise
3)await,aync
4)使用函数反应式编程的流
优点：能够使用组合，像管道处理一样处理各种流，符合函数式编程的思维。

Wonder使用流来处理异步，其中也用到了Promise，不过都被封装成了流。



**示例**
使用[most库](https://github.com/cujojs/most/blob/master/docs/api.md)实现FRP，因为它的性能比Rxjs更好。
```js
/* 
输出：
next:2
next:4
next:6
complete
*/
let subscription =
  Most.from([|1, 2, 3|])
  |> Most.map(value => value * 2)
  |> Most.subscribe({
       "next": value => Js.log2("next:", value),
       "error": e => Js.log2("error:", e##message),
       "complete": () => Js.log("complete"),
     });


```


**在Wonder中的应用**

凡是异步操作，如事件处理、多线程等，都用流来处理。
    

**相关资料**
[你一直都错过的反应型编程](https://my.oschina.net/u/2288602?q=%E5%8F%8D%E5%BA%94%E5%9E%8B%E7%BC%96%E7%A8%8B)
[函数式反应型编程 (FRP) —— 实时互动应用开发的新思路](https://www.infoq.cn/article/functional-reactive-programming)
[函数式响应型编程(Functional Reactive Programming)会在什么问题上有优势?](https://www.zhihu.com/question/26079335)




## 容器

- 容器


**介绍**

为了领域建模，或者为了保证纯函数而隔离副作用，需要把值封装到容器中。外界只能操作容器，不直接操作值。


**示例**

1)领域建模示例

比如我们要开发一个图书管理系统，需要对“书”进行建模。
书有书号、页数这两个数据，有小说书、技术书两种类型。
建模为：

```js
type bookId = int;

type pageNum = int;

type book = 
    | Novel(bookId, pageNum)
    | Technology(bookId, pageNum);
    
```

现在我们创建一本小说，一本技术书，以及它们的集合：

```js
let novel = Novel(0, 100);

let technology = Technology(1, 200);

let bookList = [
    novel,
    technology
];
```

对“书”这个容器进行操作：

```js
let getPage = (book) => 
switch(book){
    | Novel(_, page) => page
    | Technology(_, page) => page
};


let setPage = (page, book) => 
switch(book){
    | Novel(bookId, _) => Novel(bookId, page)
    | Technology(bookId, _) => Technology(bookId, page)
};

/* client code */

/* 将技术书的页数设置为集合中所有书的总页数 */
let newTechnology =
bookList
|> List.fold_left((totalPage, book) => totalPage + getPage(book), 0)
|> setPage(_, technology);

```




**在Wonder中的应用**

包含以下使用场景：
1)领域建模
2)错误处理
3)处理空值
使用[Option](https://reasonml.github.io/docs/en/null-undefined-option)包装空值。

    

**相关资料**

[Railway Oriented Programming](https://fsharpforfunandprofit.com/rop/)
[The "Map and Bind and Apply, Oh my!" series](https://fsharpforfunandprofit.com/series/map-and-bind-and-apply-oh-my.html)
[强大的容器](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch8.html#%E2%80%9C%E7%BA%AF%E2%80%9D%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86)
[Monad](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch9.html)
[Applicative Functor](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#%E5%8D%8F%E8%B0%83%E4%BA%8E%E6%BF%80%E5%8A%B1)



## 多态


- GADT


**介绍**
全称为Generalized algebraic data type，可以用来实现函数参数多态。


**示例**
重构前，需要对应每种类型，定义一个isXXXEqual函数：
```js
let isIntEqual = (source: int, target: int) => source == target;

let isStringEqual = (source: string, target: string) => source == target;
  
  
isIntEqual(1, 1); /*true*/

isStringEqual("aaa", "aaa"); /*true*/
```

使用GADT重构后，对应多个类型，只有一个isEqual函数：

```js
type isEqual(_) =
  | Int: isEqual(int)
  | Float: isEqual(float)
  | String: isEqual(string);

let isEqual = (type g, kind: isEqual(g), source: g, target: g) =>
  switch (kind) {
  | _ => source == target
  };

isEqual(Int, 1, 1); /*true*/

isEqual(String, "aaa", "aaa"); /*true*/
```


**在Wonder中的应用**

1)契约检查
如需要判断两个变量是否相等，则使用GADT，定义一个assertEqual方法替换assertStringEqual,assertIntEqual等方法。

    
    

**相关资料**
[Why GADTs matter for performance（需要翻墙）](https://blog.janestreet.com/why-gadts-matter-for-performance/)
[维基百科->Generalized algebraic data type](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type)




- Module Functor

**介绍**

module可以作为参数，传递给functor，返回一个新的module。

类似于面向对象的“继承”，可以使用函子functor，在基module上扩展出新的module。


**示例**
```js
module type Comparable = {
  type t;

  let equal: (t, t) => bool;
};

module MakeAdd = (Item: Comparable) => {
  let add = (x: Item.t, newItem: Item.t, list: list(Item.t)) =>
    Item.equal(x, newItem) ? list : [newItem, ...list];
};

module A = {
  type t = int;
  let equal = (x1, x2) => x1 == x2;
};

/* module B有add函数，该方法调用了A.equal函数 */
module B = MakeAdd(A);

let list = B.add(1, 2, []);    /* list == [2] */
let list = list |> B.add(1, 1);    /* list == [2] */
```


**在Wonder中的应用**

    
*在编辑器中的应用*
    
1)错误处理
错误被包装为容器Result；
由于容器Result中的值的类型不一样，所以将Result分成RelationResult、SameDataResult。

这两类Result有共同的模式，因此可以提出基module:Result，然后增加MakeRelationResult、MakeSameDataResult这两个module functor。它们将Result作为参数，返回新的module:RelationResult、SameDataResult，从而消除重复。

    


**相关资料**
[Reason->Module Functions](https://reasonml.github.io/docs/en/module#module-functions-functors)





# 函数式编程学习资料

[JS 函数式编程指南](https://legacy.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details)
这本书作为我学习函数式编程的第一本书，非常容易上手，作者讲得很简单易懂，推荐～


[Awesome FP JS](https://github.com/stoeffel/awesome-fp-js)
收集了函数式编程相关的资料。



[F# for fun and profit](https://fsharpforfunandprofit.com/site-contents/)
这个博客讲了很多F#相关的函数式编程的知识，非常推荐！
如果你正在使用Reason或者Ocaml或者F#语言，建议到该博客中学习！


欢迎浏览上一篇博文：[用函数式编程，从0开发3D引擎和编辑器（一）](https://www.cnblogs.com/chaogex/p/10799388.html)
欢迎浏览下一篇博文：[用函数式编程，从0开发3D引擎和编辑器（三）：初步需求分析](https://www.cnblogs.com/chaogex/p/10978934.html)]]></description></item><item><title>用函数式编程，从0开发3D引擎和编辑器（一）</title><link>http://www.cnblogs.com/chaogex/archive/2019/05/01/10799388.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Wed, 01 May 2019 03:12:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/05/01/10799388.html</guid><description><![CDATA[# 介绍
大家好，欢迎你踏上3D编程之旅～

本系列的素材来自我们的产品:[Wonder-WebGL 3D引擎和编辑器](https://www.cnblogs.com/chaogex/p/10508464.html) 的整个开发过程，探讨了在从0开始构建3D引擎和编辑器的过程中，每一个重要的功能点、设计方案的思考、讨论、总结和延伸。

本系列避免陷入细节的实现代码，使用伪代码代替。所以没有可直接运行的代码，取而代之的是经过抽象和提炼的伪代码/模式。





# 为什么要写这个系列
我有三个小目标：
1.完全创造
完全从0开始，创造一个有深度、有难度、有挑战的产品。
所以Wonder被创造出来了，并且会持续地发展。

2.完全纪录
完全纪录创造的过程，把我整个人生都沉淀下来。
所以有了[打造3D引擎，第8000小时开始](https://www.douban.com/group/topic/78459659/)。


3.完全分享
完全分享所有的创造、纪录，把我走过的路分享给需要的人。
所以有了[Wonder开源](https://github.com/Wonder-Technology) 。



本系列为了完成第2个和第3个目标，会把开发Wonder的思考沉淀下来，进行提炼和升华，分享给世界，也分享给我自己。

希望对你有所帮助～



# 技术栈

- 使用[Reason语言](https://reasonml.github.io/docs/en/what-and-why)写伪代码

- 使用WebGL作为底层api





# 本系列特色

1.完全从0开始，素材来自我们的产品[Wonder](https://www.wonder-3d.com/)

我们会一边开发Wonder，一边在本系列写文章分享。
因为Wonder在不断更新中，所以本系列也会不断更新。

2.完全、彻底地使用函数式编程。

现在3D领域使用函数式编程的资料很少，主流还是使用面向对象。
我以前也是用面向对象，不过自从我开始接触函数式编程，就拥抱了它。
面向对象很好，函数式编程也很好。使用哪一个，是每个人的自由。

本系列希望能扩展大家的视野和思维，展示函数式编程的魅力。


3.不仅探讨3D引擎，而且以编辑器作为主线。

讨论编辑器的资料很少，讨论3D引擎+编辑器的更少。

本系列完全基于我们的实战经验，以编辑器作为主线，3D引擎作为底层实现。

两者的关系如下图：

![编辑器引擎关系2.png-6.7kB][1]



4.重点放在设计和思考上，避免实现细节

本系列希望展示来自于实战的思考和设计，在较高的层面进行探讨，所以会用伪代码作为实现的说明，避免细节的干扰。



5.类型驱动设计。尽量用Type和伪代码替代UML来探讨设计。

[Curry-Howard 同构](https://www.zhihu.com/question/22959608):

> 类型即命题，程序即证明


类型既然对应逻辑命题，那能用它来表示设计吗？
具体就是：
1）能表达领域模型吗？

2）能表达领域模型的交互关系吗？

3）能替代单元测试？

使用类型进行约束，然后在编译时检查和发现错误，从而不再需要单元测试。

4）能驱动设计吗？

这样就能快速验证设计方案：
通过定义类型来描述需求和设计，不需要具体实现；
验证通过后，再一一实现。


本系列使用[Reason语言](https://reasonml.github.io/docs/en/what-and-why)，大部分满足1和2，部分满足3和4。

这是因为Reason语言的类型没有[Idris](https://www.zhihu.com/question/55342708)强大，所以3和4不能完全满足。。。。。。

或许以后可以使用Idris来重写。。。。。。

不过总的来说，我对Reason语言还是非常满意的，详见我们在知乎上的总结-[如何评价 reasonml ?](https://www.zhihu.com/question/264265665/answer/293472713)。



- 参考资料

[程序与证明](https://my.oschina.net/lsgx/blog/487432)
[Designing with types](https://fsharpforfunandprofit.com/series/designing-with-types.html)










# 能给你带来什么收益？

1.了解Wonder的技术内幕

2.学习从0开发3D引擎和编辑器

3.学习函数式编程及其在3D领域的应用

4.学习3D编程的功能实现，如纹理、光照、模型等功能的实现

5.学习设计和架构，如Data Oriented、多线程、管道job等设计




# 写作规划

Wonder目前开发到1.0版本，因此本系列对应Wonder 0.1 - 1.0版本的内容。
(随着Wonder不断更新新版本，本系列也会对应更新）

Wonder 1.0产品展示：

[ ![editor_show.gif-1353.8kB][2]](https://www.wonder-3d.com/)



## 本系列目录

- [序言](https://www.cnblogs.com/chaogex/p/10799388.html)
- [函数式编程准备](https://www.cnblogs.com/chaogex/p/10807469.html)
- [初步需求分析](https://www.cnblogs.com/chaogex/p/10978934.html)
- 初步设计
- 搭建基础框架
- 操作GameObject
- 操作Component
- Redo/Undo
- 端对端测试
- 输出
- 多线程渲染
- 运行/停止
- 事件和CameraContronller组件
- IMGUI
- 增加资产Asset
- 导入/导出
- 发布本地包
- 快捷键
- Picking
- Transform Gizmo
- PWA








# 致谢

感谢你能读到这里，欢迎你提出各种建议或意见，为你服务是我的荣幸～感谢～





# 参考资料

[Wonder-WebGL 3D引擎和编辑器](https://www.cnblogs.com/chaogex/p/10508464.html)
[Curry-Howard 同构](https://www.zhihu.com/question/22959608)
[程序与证明](https://my.oschina.net/lsgx/blog/487432)
[Designing with types](https://fsharpforfunandprofit.com/series/designing-with-types.html)
[Reason语言](https://reasonml.github.io/docs/en/what-and-why)


  [1]: http://static.zybuluo.com/yangyc/m8dpvu2h7kkzlgild8fb9qn5/%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%95%E6%93%8E%E5%85%B3%E7%B3%BB2.png
  [2]: http://static.zybuluo.com/yangyc/iqbc0nv5xrdsn7h1tc33yty1/editor_show.gif

欢迎浏览下一篇博文：[用函数式编程，从0开发3D引擎和编辑器（二）：函数式编程准备](https://www.cnblogs.com/chaogex/p/10807469.html)]]></description></item><item><title>分享收集的Web 3D学习资源</title><link>http://www.cnblogs.com/chaogex/archive/2019/03/15/10538346.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Fri, 15 Mar 2019 09:48:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/03/15/10538346.html</guid><description><![CDATA[大家好，我在本文中分享了我收集的Web 3D相关的博客、书籍、教程、demo等内容，希望对大家学习有所帮助，谢谢～

# 相关博客

[Wonder技术](https://zhuanlan.zhihu.com/c_1089189122089947136)
[Wonder](https://www.wonder-3d.com/)是我们的产品，包含WebGL 3D引擎和编辑器。Wonder技术是Wonder在知乎上的专栏，分享Wonder的技术和资讯，欢迎大家关注～


[浅墨的游戏编程](https://zhuanlan.zhihu.com/game-programming)
作者写得非常详细，推荐～


[ZwqXin](http://www.zwqxin.com/)
比较老的博客，作者写得不错。


[our machinery](https://ourmachinery.com/post/)
原bitsquid引擎的开发者的新博客，分享了很多引擎设计、Data Oriented的干货，非常推荐！ 



# 教程

[WebGPU学习](https://zhuanlan.zhihu.com/p/95956384)
WebGPU是W3C维护的新一代Web图形API，对应DX12、Vulkan、Metal。该系列是我写的WebGPU实战教程，如果你想从0学习WebGPU，了解现代图形API的技术要点，欢迎你阅读它～

[WebGL入门](https://blog.csdn.net/lufy_Legend/column/info/WebGL)
WebGL的初级入门教程。

[Learn OpenGL](https://learnOpenGL.com/Introduction)
作者分成一个个专题，讲得非常仔细，读完后能够直接上手实战，推荐～


# WebGL demo

[WebGL Samples](https://WebGLsamples.org)
WebGL1的案例 

[WebGL 2 Examples](https://github.com/tsherif/WebGL2examples)
WebGL2的案例






# 新手入门


![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190315171912918-206873827.jpg)


《WebGL编程指南》



非常易懂的实战类书籍，让读者能零基础学习和应用WebGL。

我就是从这本书开始学习WebGL的：
1.我找到了《WebGL编程指南》这本书，把大部分demo实现了一遍；
2.再次第二遍实现demo，提炼3D引擎的雏形；
3.用提炼的引擎实现了一个“自由浏览场景”的demo。



推荐度：5星



[豆瓣书评](https://book.douban.com/subject/25909351/)

[下载地址](https://github.com/yyc-git/MyData/blob/master/3d/WebGL%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97.pdf)


相关资料：
[官网](https://sites.google.com/site/WebGLbook/)





![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190315172414797-1708296974.jpg)


《HTML5 Canvas核心技术：图形、动画与游戏开发》

本书不仅全面讲解了Canvas的API和如何利用Canvas进行图形绘制、动画制作、物理效果模拟、碰撞检测、游戏开发、移动应用开发，还包括大量实例，可操作性极强。

读者可以从本书中学习Canvas、2D游戏开发的基本概念，学习如何简单的2D游戏引擎。
虽然本书是关于2D的，但其中的游戏开发、游戏引擎相关内容跟3D还是有一定的共通性。



推荐度：4星


[豆瓣书评](https://book.douban.com/subject/24533314/)


[购买地址](https://www.taobao.com/list/product/html5canvas%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.htm)



![](https://img2018.cnblogs.com/blog/419321/202001/419321-20200103095305156-882754360.jpg)



《OpenGL超级宝典》


本书详细介绍了OpenGL 2.0的渲染流水线的各个阶段（如深度测试等），通俗易懂，适合入门。

虽然本书介绍OpenGL 2.0，但因为WebGL 1对应OpenGL 2.0，所以本书的知识点也可以套用在WebGL 1中。




推荐度：4.5星



[豆瓣书评](https://book.douban.com/subject/10774590/)

[下载pdf-百度网盘链接](https://pan.baidu.com/s/1ea_fH4YykK_88vf_zrhuiQ) 提取码: c212



# 创业经历

《Doom启示录》

本书讲述了卡马克创业的故事，非常有代入感。读者可以看下国外黑客是如何凭一己之力写出3D引擎的。推荐大家阅读～

推荐度：5星

[豆瓣书评](https://book.douban.com/subject/1152971/)


[下载地址](https://github.com/yyc-git/MyData/blob/master/3d/DOOM.pdf)

# 3D数学

![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190315172659028-958005101.jpg)


《3D数学基础 图形与游戏开发》

本书讲解矩阵、四元数等跟引擎开发非常相关的数学知识。

建议读者先大概浏览一遍，有一个印象，然后在实际开发引擎的过程中再查询该书的对应章节。


推荐度：4星


[豆瓣书评](https://book.douban.com/subject/1400419/)


[下载地址](https://github.com/yyc-git/MyData/blob/master/3d/3D%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/3D%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%20%E5%9B%BE%E5%BD%A2%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.pdf)


![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190315172428946-1339795710.jpg)


《计算几何--算法与应用(第三版)》

本书是关于几何相关的算法和应用。书中有部分算法（如求最小包围圆等）在3D引擎和工具开发中会被使用。

建议读者将其当成工具书，在开发中如果遇到相应问题，可查询该书对应章节。


推荐度：3.5星


[豆瓣书评](https://book.douban.com/subject/3893574/)


[下载地址](https://github.com/yyc-git/MyData/blob/master/3d/3D%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95--%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8(%E7%AC%AC%E4%B8%89%E7%89%88).pdf)


## 坐标系变换
[OpenGL坐标变换及其数学原理，两种摄像机交互模型（附源程序）](http://www.cnblogs.com/liangliangh/p/4089582.html)

[[OpenGL ES 03]3D变换：模型，视图，投影与Viewport](http://www.cnblogs.com/kesalin/archive/2012/12/06/3D_math.html)

[齐次坐标系入门级思考](https://oncemore.wang/blog/homogeneous/)


# 架构设计

![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190315172444360-2070224034.jpg)


《游戏编程模式》



这是一本在线书，讨论游戏中的设计模式。

这本书充满了实践经验，讨论得非常详细，有指导意义。

“状态模式”一章讨论了并行状态机、层次状态机、下推自动机。
“服务定位器”一章对我来说是第一次接触到这个模式。
“数据位置”一章是优化的重要和有用的方法，它强调了缓存命中的问题，其实就是在讲Data Oriented相关的内容。
“空间分割”这一章也很重要，可以使用该技术来组织场景对象。



推荐度：4.5星


[豆瓣书评](https://book.douban.com/subject/26880704/)

[在线阅读](https://gpp.tkchu.me/)

## Data Oriented

[A Data-Oriented Programming
Paradigm for Optimal Performance](http://twvideo01.ubm-us.net/o1/vault/gdcchina14/presentations/833779_MiloYip_ADataOriented_EN.pdf)

[Culling the Battlefield: Data Oriented Design in Practice](https://www.slideshare.net/DICEStudio/culling-the-battlefield-data-oriented-design-in-practice)



[Adventures in data-oriented design – Part 1: Mesh data](https://blog.molecular-matters.com/2011/11/03/adventures-in-data-oriented-design-part-1-mesh-data-3/)


[《Data-Oriented Design》](http://www.dataorienteddesign.com/dodmain/dodmain.html)


下面的链接可能需要开vpn才能访问，否则访问很慢：

[Building a Data-Oriented Entity System (part 1)](https://gamedev.autodesk.com/blogs/1/post/5289103338905524974)

[Building a Data-Oriented Entity System (Part 2: Components)](https://gamedev.autodesk.com/blogs/1/post/8872071455012261641)

[Building a Data-Oriented Entity System (Part 3: The Transform Component)](https://gamedev.autodesk.com/blogs/1/post/757303077912211655)

[Building a Data-Oriented Entity System (Part 4: Entity Resources)](https://gamedev.autodesk.com/blogs/1/post/1728389959875415220)


## ECS
[《守望先锋》架构设计与网络同步 -- GDC2017 精品分享实录](http://gad.qq.com/article/detail/28682)

[浅谈《守望先锋》中的 ECS 构架](https://blog.codingnow.com/2017/06/overwatch_ecs.html)





## 函数式编程
[JS 函数式编程指南](https://legacy.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details)
这本书作为我学习函数式编程的第一本书，非常容易上手，作者讲得很简单易懂，推荐～


[Awesome FP JS](https://github.com/stoeffel/awesome-fp-js)
收集了函数式编程相关的资料。



[F# for fun and profit](https://fsharpforfunandprofit.com/site-contents/)
这个博客讲了很多F#相关的函数式编程的知识，非常推荐！
如果你正在使用Reason或者Ocaml或者F#语言，建议到该博客中学习！



# 引擎

![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190315172504836-661616881.jpg)


《游戏引擎架构》

本书全方位讲解了3D引擎的设计以及一些重要的实现、优化细节，是一本好书！
本书的5、6、7、13、14章节对我开发的[Wonder.js引擎](https://github.com/Wonder-Technology/Wonder.js)的改进很有帮助，其中第14章有部分内容还讨论了Data Oriented相关的设计。

推荐度：5星


[豆瓣书评](https://book.douban.com/subject/25815142/)

[预览pdf下载地址](https://github.com/yyc-git/MyData/blob/master/3d/engine/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84.pdf)


《Game Engine Gems 1》
《Game Engine Gems 2》

[下载地址](https://github.com/yyc-git/MyData/tree/master/3d/engine/gems)


# 进阶



![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190315172532732-1477596866.jpg)


《WebGL Insights》

本书相当于WebGL的gems书，每个章节都是一个专题，介绍了浏览器是怎么实现WebGL的、一些基于WebGL的实现的图形渲染技术、现有的开源引擎（如babylonjs）的设计和优化等。

这是一本非常好的书，对深入WebGL、学习其他开源引擎的设计和优化、移动端WebGL开发和优化都很有帮助！


推荐度：5星


[豆瓣书评](https://book.douban.com/subject/26632686/)

[下载地址](https://github.com/yyc-git/MyData/blob/master/3d/WebGL%20Insights.pdf)

![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190315172602213-1704301465.jpg)


《OpenGL Insights》


本书相当于OpenGL的gems书了，每个章节都是一个专题，不仅包括OpenGL，也包括了WebGL方面的主题，是一本进阶的书籍。

书中WebGL方面的专题、性能专题以及移动方面的专题（比如介绍了tile-based架构)都是很有用的。

书中最后还给出了OpenGL ES2.0的渲染管线图。

推荐度：5星



[豆瓣书评](https://book.douban.com/subject/10795762/)


[下载地址](https://github.com/yyc-git/MyData/blob/master/3d/OpenGL%20Insights.pdf)


![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190315172611881-123774854.jpg)


《Real-Time Rendering》

本书讲得很全，覆盖了渲染的各个方面。不过不够深入，偏理论。

相关参考：

[【《Real-Time Rendering 3rd》 提炼总结】(一) 全书知识点总览](https://zhuanlan.zhihu.com/p/26259772)



推荐度：4.5星


[豆瓣书评](https://book.douban.com/subject/3213439/)


[下载地址](https://github.com/yyc-git/MyData/blob/master/3d/Real-Time%20Rendering%2C%20Third%20Edition.pdf)


# 专题讲解



## 地形

![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190315172623092-1570551001.jpg)


《Focus On 3D Terrain Programming》

这本书比较老了，不过挺容易上手实战的。我参考它实现了height map地形和分层地形。


推荐度：4星


[豆瓣书评](https://book.douban.com/subject/2377579/)


[下载地址](https://github.com/yyc-git/MyData/blob/master/3d/terrain/Focus%20On%203D%20Terrain%20Programming.pdf)


## GPU Gems 1-3

[下载地址](https://github.com/yyc-git/MyData/tree/master/3d/GPU%20Gems)

## GPU Pro 1-6


[下载地址](https://github.com/yyc-git/MyData/tree/master/3d/GPU%20Pro)





# 其他资源


[分享我收集的引擎、图形学、WebGL方面的电子资料](https://www.cnblogs.com/chaogex/p/5579365.html)


[我在2011-2014年收集的经典书和心得](https://github.com/yyc-git/MyData/blob/master/2011-2014%E5%B9%B4%E6%94%B6%E9%9B%86%E7%9A%84%E7%BB%8F%E5%85%B8%E4%B9%A6%E5%92%8C%E5%BF%83%E5%BE%97.doc)]]></description></item><item><title>8年，从2D到3D，我的学习之路</title><link>http://www.cnblogs.com/chaogex/archive/2019/03/14/10533026.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Thu, 14 Mar 2019 11:53:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/03/14/10533026.html</guid><description><![CDATA[[Mickey](https://www.cnblogs.com/xiaohaoxuezhang/) 写了一篇 [《一个本科毕业生创业两年的感悟》](https://www.cnblogs.com/xiaohaoxuezhang/p/10514573.html)，从他的视角，总结了我们合作的两年经历。

我也来写一篇，介绍我的学习之路，希望对大家有所帮助，谢谢大家～


# 我的学习方法
1.直接从0开始做项目，边做边学习，在做的过程中不断思考和反思当前的设计和实现，不断地修正，不断地迭代。
2.做完一个项目后，沉淀和升华：
a)根据做项目中遇到的问题，针对性地看一些经典书籍和学习资料
b)写一些文章，分享自己的学习经历和技术心得

# 我的学习经历

我从开始学编程到现在，一直都在前端领域学习。先后经历了开发网站->开发2D游戏和引擎->开发前端富应用->开发3D引擎和编辑器。



## 第一年从0开始，做一个行业平台的网站

非常感谢老师对我的信任，让我能在第一个项目就负责开发一个比较大规模的完整网站～

整个项目历时8个月，前端、后端、数据库我都要开发。

通过该项目，我学习了测试驱动的思想(后端和逻辑层写了很多测试)、分层架构、MVC、重构、领域驱动的思想，学习了前端、后端、数据库的技术。



## 从0开始，做Html5小游戏 

再次感谢老师的支持，让我能够自由地研究自己感兴趣的内容。

做完网站后，我先后开发了 贪吃蛇->连连看->炸弹人 这三个Html5游戏，中间又做了几个小网站。 其中，我完全使用测试驱动来开发炸弹人游戏。

详见：
[发布我制作的jQuery贪吃蛇游戏](https://www.cnblogs.com/chaogex/archive/2012/10/10/2717669.html)
[连连看](https://github.com/yyc-git/LianLianKan)
[炸弹人游戏开发系列](https://www.cnblogs.com/chaogex/p/3151033.html)


通过做游戏，我学习并应用了面向对象的思想和设计模式，学习了2D游戏中的基本概念和领域模型。


## 从炸弹人游戏中提炼2D引擎

从做的游戏中，我看到了一些通用模式，促使我开始提炼游戏引擎。

详见：
[提炼游戏引擎系列](https://www.cnblogs.com/chaogex/p/4149904.html)
[发布HTML5 2D游戏引擎YEngine2D](https://www.cnblogs.com/chaogex/p/4088630.html)



## 开发一个相对复杂的2D游戏，作为我的毕业设计

在拿到工作Offer后，我就开始毕业设计：使用提炼的2D引擎，开发一个即时战略的2D游戏。我还开发了对应的编辑器，用来编辑地图和关卡。

详见：
[发布HTML5 RTS游戏-古代战争](https://www.cnblogs.com/chaogex/p/4086142.html)


## 分享我在读书阶段收集的经典书

我在上学的时候，通过边做项目边学习，看了一些书。

此处分享我看了哪些书、看了几遍、有什么心得，详见：[2011-2014年收集的经典书和心得](https://github.com/yyc-git/MyData/blob/master/2011-2014%E5%B9%B4%E6%94%B6%E9%9B%86%E7%9A%84%E7%BB%8F%E5%85%B8%E4%B9%A6%E5%92%8C%E5%BF%83%E5%BE%97.doc)

WebGL、3D引擎等方面可以参考：
[分享收集的WebGL 3D学习资源](https://www.cnblogs.com/chaogex/p/10538346.html)
[分享我收集的引擎、图形学、WebGL方面的电子资料](https://www.cnblogs.com/chaogex/p/5579365.html)


## 开发最后一个2D游戏

我用提炼的引擎写了个demo。

详见：
[动作类游戏demo](https://github.com/yyc-git/Act)


## 开发钉钉

在工作上，我有幸加入了钉钉的前端开发团队，参与桌面版钉钉的开发。

我学习了Angular，开发了搜索、群组、快捷键等功能。

通过参与该项目，我学习了一个真正的商业项目是怎样开发的，也学习了前端的更多技术，感谢项目老大～


## 开始学习3D

此时我看到了Babylonjs的3D demo，非常震撼。我已经迫不及待地想要学习3D技术了！我加入了北京的一个创业公司，开始接触WebGL技术。

感谢该公司，技术上对我有很多启发～比如我第一次看到了类似于Unity的组件化架构的引擎，而我之前一直参考Cocos 2D，用的是继承架构。我也学习了使用渲染命令队列来解藕逻辑和渲染的设计思想。

我是如何开始学习WebGL的呢？
1.我找到了《WebGL编程指南》这本书，把大部分demo实现了一遍；
2.再次第二遍实现demo，提炼3D引擎的雏形；
3.用提炼的引擎实现了一个“自由浏览场景”的demo。


## 开发引擎

通过学习3D，我感受到了3D引擎的巨大魅力，我决定自己开发一个3D引擎！

辞职，回家，从0开始，开发[3D引擎](https://github.com/Wonder-Technology/Wonder.js)。

我学习了[函数式反应编程](https://infoq.cn/article/functional-reactive-programming)的思想，模仿Rxjs，写了个[Wonder-FRP](https://github.com/Wonder-Technology/Wonder-FRP)库，这就花了我1个月的时间，为我以后学习函数式编程埋下了伏笔。

我出于学习的目的，尽可能地加入更多的功能（模型，动画，地形，水，阴影。。。。。。），并没有考虑给别人使用。

虽然引擎是全覆盖的单元测试用例，并且我注重代码质量，但是性能方面没有过多地优化，也没有外部的使用反馈。所以引擎属于自己玩的玩具。

## 短暂的工作

开发了一年后，我认为需要到外界获取一些反馈和交流，所以我参加了工作，并在工作中收集相关反馈，继续改进引擎。

我用引擎做了一些demo，并开始应用到手机端。

同事反馈：引擎太笨重，应该更加地模块化。感谢同事对引擎的改进建议，让我看到了引擎很多的不足。


## 再次出发

辞职，回家，我决定重写引擎。

此时我开始学习函数式编程的思想，这再次刷新了我的认知。因此我从面向对象切换到函数式编程，开始重写设计引擎，立足于真正的商业应用，能够支持大型场景：
1.使用js库，进行函数式编程
2.支持多线程
3.支持WebGL2
4.支持延迟渲染


## 与Mickey合作，一起开发Wonder产品

随着Mickey的加入，我们开始真正的创业：开发引擎和编辑器，打造Wonder，建立Web 3D生态。
我继续开发引擎，Mickey开发编辑器。



## 再次重写

开发一段时间后，我认为js库进行函数式编程非常不方便，代码不好看，而且性能也不好。

我关注到[Reason](https://reasonml.github.io/)的发展，认为Reason已经足够成熟，可以使用了。

于是我们引擎和编辑器完全重写，从Typescript切换到Reason，使用[Data Oriented设计](https://www.wonder-3d.com/docs/docs/doc3-3/)，开始真正的函数式编程。



## Wonder发布1.0

从重写到发布，[《一个本科毕业生创业两年的感悟》](https://www.cnblogs.com/xiaohaoxuezhang/p/10514573.html)已经很好地总结了这段时间的经历。

终于，[Wonder 1.0正式版发布](https://www.cnblogs.com/chaogex/p/10508464.html)，完成了我们创业的第一步，交付了第一个可以真正使用的产品。

从学习3D，到发布1.0产品，经历了4年。

我们的引擎和编辑器开源，详见：
[Wonder.js引擎](https://github.com/Wonder-Technology/Wonder.js)
[Wonder-Editor编辑器](https://github.com/Wonder-Technology/Wonder-Editor)

## 未来。。。。。。

我们会继续开发Wonder 2.0版本，打造和完善Web 3D生态，为大家带来更多的便利和服务。

详见[路线图](https://www.wonder-3d.com/docs/docs/doc3-1/)。



# 我为什么一直走这条路？

因为兴趣，就会自发地想去学习，每天都有兴奋感。解决一个个问题后，也很有成就感。

我也看好Web 3D的潜力，这是一个有技术门槛，需要长期钻研，厚积薄发的领域，很适合我。

感谢互联网的便利，所有相关的知识都可以在网上搜索到。所以现在是最好的时代，能走到哪里全凭自己驱动。



# 我要走向何方？

我们做的Wonder产品－3D引擎和编辑器，技术上很有挑战，永无止境，这不就是对我最好的礼物吗？

我会持续地学习3D开发，把Wonder打造成世界上成熟的产品，让Web 3D开发变得轻而易举，为世界作出贡献。

# 致谢

感谢您能阅读到这里，每天都是最好的一天！

# 最后附上Wonder编辑器
[![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190311205946475-1669737326.gif)](https://www.wonder-3d.com/)]]></description></item><item><title>Reason的介绍和搭建Reason开发环境</title><link>http://www.cnblogs.com/chaogex/archive/2019/03/14/10528737.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Thu, 14 Mar 2019 02:44:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/03/14/10528737.html</guid><description><![CDATA[# Reason介绍
Reason是在Ocaml语言的基础上修改而来，专门提供给前端开发者使用。

Reason是函数式编程语言，使用Bucklescript编译器编译成javascript语言。

在我看来，至少有两大优点：
1.编译后的javascript优化得非常好，让我们能够高性能地使用函数式编程。
2.强类型和类型推导，让我们既不用向Typescript那样定义很多类型（Reason会帮我们推导类型），又可以享受强类型约束的好处（编译时能检查更多的错误）。

我们[Wonder](https://www.wonder-3d.com/)已经使用Reason两年的时间了，所有产品，包括前端后端，都用Reason语言写，非常好用。


下面是一些链接资料：
[Reason官网](https://reasonml.github.io/docs/en/what-and-why)
[如何评价 reasonml ? -> Wonder的回答](https://www.zhihu.com/question/264265665/answer/293472713)



# 如何在VSCode中搭建Reason的开发环境
建议使用VSCode编辑器来开发Reason，因为它的插件支持得最好。

具体搭建Reason开发环境的步骤如下：

1.执行“yarn global add bs-platform”

这一步是为了安装Reason的相关工具，如格式化工具bsrefmt等

2.安装VSCode

3.安装VSCode->Extensions->reason-vscode插件

4.设置reason-vscode，显示函数的类型签名

在VSCode->“设置”中，搜索到reason的设置，选中 “Show the type for each top-level value in a codelens”。
或者在setting.json中，加上：
```json
  "reason_language_server.per_value_codelens": true
```


5.克隆Reason-Example项目，学习如何开始开发： 

```js
git clone https://github.com/Wonder-Technology/Reason-Example.git
```


1)执行"yarn watch"

这样在写Reason的时候，会自动编译为js。


2)执行"yarn start"，在浏览器地址中输入 http://127.0.0.1:8080 ， 运行index.html页面
打开控制台，看到输出“1”


# 应用案例
案例就是我们Wonder的产品哈，详见：

[Wonder.js-基于WebGL的3D引擎](https://github.com/Wonder-Technology/Wonder.js)

[Wonder-Editor-基于Wonder.js的3D编辑器](https://github.com/Wonder-Technology/Wonder-Editor)]]></description></item><item><title>Wonder 1.0正式版发布-----WebGL 3D引擎和编辑器</title><link>http://www.cnblogs.com/chaogex/archive/2019/03/11/10508464.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Mon, 11 Mar 2019 00:26:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2019/03/11/10508464.html</guid><description><![CDATA[[![](https://img2018.cnblogs.com/blog/419321/201903/419321-20190311205946475-1669737326.gif)](https://www.wonder-3d.com/)


# 介绍

我们很荣幸地向大家发布[Wonder](https://www.wonder-3d.com/) 1.0正式版！免费、开源，不用注册，直接打开[在线编辑器](https://editor.wonder-3d.com/)即可[使用](https://www.wonder-3d.com/docs/docs/doc1-2/#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)！

Wonder是web端3D开发的解决方案，包括引擎、编辑器，致力于打造开放、分享、互助的生态。

您可以在[Wonder官方视频教程 ](https://forum.wonder-3d.com/t/wonder/43) 、[制作第一个项目](https://www.wonder-3d.com/docs/docs/doc1-6/)中学习如何开始。

Wonder功能上与Unity3D类似，但比起Unity3D我们有很多[优势](https://www.wonder-3d.com/docs/docs/doc1-8/#wonder比起unity3d-threejs等同类产品-有什么优势吗)。

我们使用[Reason语言](https://reasonml.github.io/en/)和函数式编程范式来开发。

详见[Wonder介绍](https://www.wonder-3d.com/docs/docs/doc1-2/)。



[FAQ](https://www.wonder-3d.com/docs/docs/doc1-8)

[官网](https://www.wonder-3d.com/)

[论坛](https://forum.wonder-3d.com/)

[在线编辑器](https://editor.wonder-3d.com/)

[Wonder-Editor编辑器 Github](https://github.com/Wonder-Technology/Wonder-Editor)

[Wonder.js引擎 Github](https://github.com/Wonder-Technology/Wonder.js)


# 开发历程

我们在[Github](https://github.com/Wonder-Technology)上开发引擎和编辑器，并且完全开源。

Wonder从2015年3月份开始，到发布1.0正式版，经历了4年的研发，将近7000次commit，70多次版本发布，将近3000个单元测试用例。

中间引擎完全重写了两次，编辑器完全重写了一次:

- 从Typescript到Reason语言
- 从继承到组件到Data Oriented
- 从面向对象到函数式编程

经历的不仅是语言的转换，更是思维模式的变化。




# 1.0主要内容

Wonder v1.0 主要实现了编辑器的核心流程：

- 组件化的gameObject
- 编辑和运行场景
- 资产管理
- 导入导出和发布



## 引擎主要特性

- 多线程渲染
- ECS架构
- Job管道
- 纹理
- 方向光和点光源
- 加载模型和场景
- 流加载
- imgui
- 事件
- instance


## 编辑器主要特性

- pwa
- 场景管理
- 编辑和运行场景
- transform gizmo
- 快捷键
- Redo/Undo
- 输出消息
- 资产管理
- 导入导出
- 发布本地包





# 使用场景

[使用场景](https://www.wonder-3d.com/docs/docs/doc1-2/#使用场景)



# 路线图

[路线图](https://www.wonder-3d.com/docs/docs/doc3-1)


# 联系我们
可以通过以下方式联系我们，期待您的交流

[论坛](https://forum.wonder-3d.com/)

QQ群： 106047770

邮箱： wonder@wonder-3d.com



# 感谢


我们非常感恩能加入到Web 3D领域的浪潮中，非常荣幸能够使用最新的技术和思想。

我们对产品精益求精，打造最好的产品。

我们尽心为用户服务，合力共建3D生态。

谢谢大家～]]></description></item><item><title>计算几何算法研究与实现：开篇</title><link>http://www.cnblogs.com/chaogex/archive/2016/08/10/5757385.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Wed, 10 Aug 2016 08:46:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2016/08/10/5757385.html</guid><description><![CDATA[参考《计算几何》一书
给出对应章节的思路和相关ts实现代码
给出习题解答

优先给出与我目前研究相关的算法实现
给出项目中遇到的算法问题，及我的解决方案

重点在于深度扩展：
可用多种思路来解同一个问题
给出相关的扩展思路和资料


预计篇幅：30+篇

目录]]></description></item><item><title>优化Webstorm</title><link>http://www.cnblogs.com/chaogex/archive/2016/07/18/5680187.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Mon, 18 Jul 2016 02:05:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2016/07/18/5680187.html</guid><description><![CDATA[Webstorm这个编辑器还是很强大的，而且版本更新得快，支持最新的typescript，就是性能越来越低。
本文总结了一些优化Webstorm的有效方法，希望对大家有所帮助！

#测试环境
Mac OS X 操作系统
Webstorm 11.0

#优化方法

##exclude项目中不用的文件
- 进入Settings->Project->Directories，把用不到的文件目录都Excluded（选中该文件目录，右击鼠标，点Excluded）
- 进入Settings->Editor->File Types，在最下面的Ignore files and folders中加入要ignore的文件或文件夹
- 在project窗口的文件夹上，右击鼠标，点击Mark Directory As->Excluded

##优化代码检查
- 进入Settings->Editor->Inspections，把用不到的检查都关掉
- 进入Settings->Editor->General，把最下面的Error highlighting->Autoreparse delay(ms) 改成比较大的值（如20000)

##去掉平时用不到的插件
进入Settings->Plugins，去掉平常用不到的插件，在一定程度上会提高软件打开时的加载速度。

##优化typescript编译
进入Settings->Languages & Frameworks->Typescript，取消Track changes


##优化文件保存

可以取消自动保存功能（建议保留该功能！）：

进入Settings->Apparence & Behavior->Synchronization，取消 Synchronize file on frame deactivation 和 Save files automatically 的选择。



##清除缓存

项目久了之后可以清除缓存：点击File -> Invalidate Caches / Restart



# 更多方法
[Increasing Memory Heap](https://www.jetbrains.com/help/idea/2016.1/increasing-memory-heap.html)

# 参考资料
[PhpStorm10 设置内存](http://my.oschina.net/u/144160/blog/702321)]]></description></item><item><title>WebGL图形学专题研究系列：开篇</title><link>http://www.cnblogs.com/chaogex/archive/2016/07/17/5679365.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sun, 17 Jul 2016 13:01:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2016/07/17/5679365.html</guid><description><![CDATA[研究专题技术
给出思路和相关实现代码（如果复杂就给出伪代码）
给出wonder.js引擎的相关应用示例
给出扩展知识点和相关资源


本系列博文的重点在于介绍图形学专题技术思路和展示引擎的应用示例，因此对于具体的实现，可以简略，给出思路和核心代码（或伪代码）即可


预计篇幅：15+篇


# 目录
model,view,projection matrix
transform
billboard
mirror reflection
normal map
model data parse and load serials(obj,gltf,dae...)(介绍converter的示例）
...more]]></description></item><item><title>分享我收集的引擎、图形学、WebGL方面的电子资料</title><link>http://www.cnblogs.com/chaogex/archive/2016/06/13/5579365.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Mon, 13 Jun 2016 13:40:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2016/06/13/5579365.html</guid><description><![CDATA[本文分享我这一年以来收集的我认为比较经典的电子资料，希望能对大家有所帮助！
本文会不断更新！

# 目录

- [WebGL Insights](#webgl_insights)
- [OpenGL Insights](#opengl_insights)
- [Game Programming Patterns](#patterns)
- [Design by Contract 原则与实践](#contract)
- [游戏引擎架构](#engine_architecture)
- [编程珠玑](#zhuji)


<a name="webgl_insights"></a>
#《WebGL Insights》

http://pan.baidu.com/s/1dF7ERG9

## 推荐度
5星

## 内容概要说明
   相当于webgl的gems书，包括了介绍浏览器是怎么实现webgl的、一些图形渲染基于webgl的实现、现有的开源引擎（如babylonjs）的设计和优化等。


## 目录说明
I. WebGL Implementations
1. ANGLE: A Desktop Foundation for WebGL 
2. Mozilla's Implementation of WebGL 
3. Continuous Testing of Chrome's WebGL Implementation 

II. Moving to WebGL
4. Getting Serious with JavaScript 
5. Emscripten & WebGL 
6. Data Visualization with WebGL: from Python to JavaScript 
7. Teaching an Introductory Computer Graphics Course with WebGL 

III. Mobile
8. Bug-Free and Fast Mobile WebGL 

IV. Engine Design
9. WebGL Engine Design in Babylon.js 
10. Rendering Optimizations in the Turbulenz Engine 
11. Performance and Rendering Algorithms in Blend4Web 
12. Sketchfab Material Pipeline: From File Variations to Shader Generation 
13. glslify: A module system for GLSL 
14. Budgeting Frame Time 

V. Rendering
15. Deferred Shading in Luma 
16. HDR Image-Based Lighting on the Web 
17. Real-Time Volumetric Lighting for WebGL 
18. Terrain Geometry - LOD Adapting Concentric Rings 

VI. Visualization
19. Data Visualization Techniques with WebGL 
20. hare3d - Rendering Large Models in the Browser 
21. The BrainBrowser Surface Viewer: WebGL-based Neurological Data Visualization 

VII. Interaction
22. Usability of WebGL Applications 
23. Designing Cameras for WebGL Applications 

## 我的心得与体会
   一本非常好的书，对深入里面Webgl、学习其他开源引擎的设计和优化、移动端webgl开发和优化等都很有帮助！
   


<a name="opengl_insights"></a>
#《OpenGL Insights》

http://pan.baidu.com/s/1gfCu7K3

# 推荐度
4星半

# 内容概要说明
   本书算是基于opengl的gems书了，每个章节是一个专题，不仅包括opengl，也包括了webgl方面的主题，是一本提高阶段的书籍。

# 目录说明
暂无

# 我的心得与体会
   书中的webgl方面的专题、性能专题以及移动方面的专题（比如介绍了tile-based架构)都是很有用的。
   而且书最后还给出了opengl es2.0的渲染管线图。
   不过还有些内容我现在暂时用不到（比如基于opengl 4.0 的tessellation shader，与occusion exclude相关的算法等），等到需要用到的时候，再来看。
   

<a name="patterns"></a>
#《Game Programming Patterns》

http://gameprogrammingpatterns.com/contents.html

## 推荐度
4星半


## contents
This is a online e-book that talks about design pattern in game.
First it revisit a part patterns(6 patterns) of gof, Then it discuss useful patterns that some of them are already applied in [Wonder.js engine](https://github.com/yyc-git/Wonder.js).

## catalogue
- Introduction
Architecture, Performance, and Games

- Design Patterns Revisited
Command
Flyweight
Observer
Prototype
Singleton
State

- Sequencing Patterns
Double Buffer
Game Loop
Update Method

- Behavioral Patterns
Bytecode
Subclass Sandbox
Type Object

- Decoupling Patterns
Component
Event Queue
Service Locator

- Optimization Patterns
Data Locality
Dirty Flag
Object Pool
Spatial Partition

## my experience
The book is full of practical experiences and the discussition is very detailed and instructive.

The "State pattern" chapter discuss the Concurrent State Machines, Hierarchical State Machines, Pushdown Automata that are instructive and will be useful.

The "Service Locator" chapter is new to me that it's the first time to touch the pattern.Though the author suggest that it can use DI instead of it in some cases.

The "Data Locality" chapter is important and a useful way for optimizing. It stresses the cache miss problem.

The "Spatial Partition" chapter is important too that i will use the technology to organize objects of scene.


<a name="engine_architecture"></a>
# 《游戏引擎架构》
试读版下载，没找到完整版：
http://pan.baidu.com/s/1hsyf20O


## 推荐度
5星

## 内容概要说明
   本书全方位讲解了3d引擎的设计以及一些重要的实现、优化细节，是一本好书！

## 目录说明
第一部分 基础	1
第1章 导论	3
1.1 典型游戏团队的结构	4
1.2 游戏是什么	7
1.3 游戏引擎是什么	10
1.4 不同游戏类型中的引擎差异	11
1.5 游戏引擎概观	22
1.6 运行时引擎架构	27
1.7 工具及资产管道	46
第2章 专业工具	53
2.1 版本控制	53
2.2 微软Visual Studio	61
2.3 剖析工具	78
2.4 内存泄漏和损坏检测	79
2.5 其他工具	80
第3章 游戏软件工程基础	83
3.1 重温C++及最佳实践	83
3.2 C/C++的数据、代码及内存	90
3.3 捕捉及处理错误	118
第4章 游戏所需的三维数学	125
4.1 在二维中解决三维问题	125
4.2 点和矢量	125
4.3 矩阵	139
4.4 四元数	156
4.5 比较各种旋转表达方式	164
4.6 其他数学对象	168
4.7 硬件加速的SIMD运算	173
4.8 产生随机数	180
第二部分 低阶引擎系统	183
第5章 游戏支持系统	185
5.1 子系统的启动和终止	185
5.2 内存管理	193
5.3 容器	208
5.4 字符串	225
5.5 引擎配置	234
第6章 资源及文件系统	241
6.1 文件系统	241
6.2 资源管理器	251
第7章 游戏循环及实时模拟	277
7.1 渲染循环	277
7.2 游戏循环	278
7.3 游戏循环的架构风格	280
7.4 抽象时间线	283
7.5 测量及处理时间	285
7.6 多处理器的游戏循环	296
7.7 网络多人游戏循环	304
第8章 人体学接口设备（HID）	309
8.1 各种人体学接口设备	309
8.2 人体学接口设备的接口技术	311
8.3 输入类型	312
8.4 输出类型	316
8.5 游戏引擎的人体学接口设备系统	318
8.6 人体学接口设备使用实践	332
第9章 调试及开发工具	333
9.1 日志及跟踪	333
9.2 调试用的绘图功能	337
9.3 游戏内置菜单	344
9.4 游戏内置主控台	347
9.5 调试用摄像机和游戏暂停	348
9.6 作弊	348
9.7 屏幕截图及录像	349
9.8 游戏内置性能剖析	349
9.9 游戏内置的内存统计和泄漏检测	356
第三部分 图形及动画	359
第10章 渲染引擎	361
10.1 采用深度缓冲的三角形光栅化基础	361
10.2 渲染管道	404
10.3 高级光照及全局光照	426
10.4 视觉效果和覆盖层	438
10.5 延伸阅读	446
第11章 动画系统	447
11.1 角色动画的类型	447
11.2 骨骼	452
11.3 姿势	454
11.4 动画片段	459
11.5 蒙皮及生成矩阵调色板	471
11.6 动画混合	476
11.7 后期处理	493
11.8 压缩技术	496
11.9 动画系统架构	501
11.10 动画管道	502
11.11 动作状态机	515
11.12 动画控制器	535
第12章 碰撞及刚体动力学	537
12.1 你想在游戏中加入物理吗	537
12.2 碰撞/物理中间件	542
12.3 碰撞检测系统	544
12.4 刚体动力学	569
12.5 整合物理引擎至游戏	601
12.6 展望：高级物理功能	616
第四部分 游戏性	617
第13章 游戏性系统简介	619
13.1 剖析游戏世界	619
13.2 实现动态元素：游戏对象	623
13.3 数据驱动游戏引擎	626
13.4 游戏世界编辑器	627
第14章 运行时游戏性基础系统	637
14.1 游戏性基础系统的组件	637
14.2 各种运行时对象模型架构	640
14.3 世界组块的数据格式	657
14.4 游戏世界的加载和串流	663
14.5 对象引用与世界查询	670
14.6 实时更新游戏对象	676
14.7 事件与消息泵	690
14.8 脚本	707
14.9 高层次的游戏流程	726
第五部分 总结	727
第15章 还有更多内容吗	729
15.1 一些未谈及的引擎系统	729
15.2 游戏性系统	730
参考文献	733


## 如何应用该书
   在实践（开发引擎、实现相关的算法等）时或者遇到问题时，可查阅本书的对应章节。

## 我的心得与体会
   本书的5、6、7、13、14章节对我[现在的引擎](https://github.com/yyc-git/Wonder.js)的改进就很有帮助！
   等我要实现骨骼动画时，需要再仔细研究11章节，然后提炼出动画引擎！
   

<a name="contract"></a>
# 《Design by Contract 原则与实践》
暂时没找到电子资料，建议到淘宝购买复印版（因为本书已经停版了）。

## 推荐度
4星

##内容概要说明
   本书通过实例，详细而层层推进地探讨了“契约式设计”地思想原则和实践方法，引入了Dbc地六大原则和六大准则，展示了它们地运用，分析了Dbc和继承地关系，介绍了框定规则、Dbc的好处和限制、观察者框架中的契约和先验条件检验；最后给出了一个Java范例，并探讨了契约在分析模型中的应用。
    本书思维严密，逻辑性很强。


## 目录说明
第1章 契约式设计初探	1 
1.1 概述	1 
1.2 顾客管理器范例	2 
1.3 一些问题	5 
1.4 customer_manager的契约	6 
1.5 临时总结	9 
1.6 运行时检测	11 
1.7 可靠的文档	13 
1.8 小结	15 
1.9 一言以蔽之	15 
1.10 下一步工作	15 
第2章 契约式设计的基本原则	17 
2.1 关于本章	17 
2.2 栈	18 
2.3 区分命令和查询	19 
2.4 命名规范	22 
2.5 区分基本查询和派生查询	23 
2.6 说明命令对基本查询的影响	26 
2.7 用不变式确定恒定特性	34 
2.8 类及其契约	36 
.2.9 基本查询是栈的一个概念模型	38 
2.10 六大原则	42 
2.11 下一步工作	43 

第3章 运用六大原则	47 
3.1 关于本章	47 
3.2 字典	47 
3.3 特性分离与分类	48 
3.4 后验条件	50 
3.5 先验条件	56 
3.6 不变式	62 
3.7 关于字典的完整的契约级概括	63 
3.8 小结	65 
3.9 练习	66 
第4章 契约的构造支持类-- 不可变列表	69 
4.1 关于本章	69 
4.2 支持线性结构	69 
4.3 契约只涉及表达式	70 
4.4 不可变列表	71 
4.5 不可变列表的契约	72 
4.5.1 基本查询	72 
4.5.2 创建命令	74 
4.5.3 派生查询count	74 
4.5.4 派生查询preceded_by	74 
4.5.5 派生查询item	75 
4.5.6 派生查询is_equal	77 
4.5.7 派生查询sublist	79 
4.6 小结	81 
4.7 练习	81 
第5章 六大原则在queue设计中的运用	83 
5.1 关于本章	83 
5.2 队列	83 
5.3 remove特性的契约	84 
5.4 将count作为一个派生特性	88 
5.5 initialize特性的契约	91 
5.6 head特性的契约	93 
5.7 put特性的契约	94 
5.8 更多派生查询	94 
5.9 小结	95 
5.10 练习	96 
第6章 契约式设计与继承	99 
6.1 关于本章	99 
6.2 超类和子类	99 
6.3 重新定义契约	100 
6.3.1 eiffel语法	104 
6.3.2 小结	107 
6.4 不变式和继承	108 
6.5 以被确保的后验条件定义超类	109 
6.6 两种继承	116 
6.7 小结	117 
6.8 练习	117 
第7章 框定规则	119 
7.1 关于本章	119 
7.2 变化规格和框定规则	119 
7.3 使用不可变列表为put撰写框定规则	121 
7.4 使用“forall”为put撰写框定规则	128 
7.5 框定规则的类别	130 
7.6 练习	132 
7.7 关于预处理器的补充说明	132 
第8章 契约式设计的收益	137 
8.1 关于本章	137 
8.2 几种优点	137 
8.3 更优秀的设计	138 
8.4 提高可靠性	140 
8.5 更出色的文档	140 
8.6 简化调试	142 
8.7 支持复用	142 
8.8 契约式设计与防御性编程	143 
8.8.1 防止程序接受错误的输入	143 
8.8.2 给程序穿上“防弹衣”	144 
8.8.3 防御性编程	145 
8.9 契约的一些开销和限制	146 
第9章 观察者(observer) 框架中的契约	149 
9.1 关于本章	149 
9.2 观察者框架	150 
9.3 不可变集合	152 
9.4 观察者的系缚和解缚	155 
9.5 通知（一个观察者）	156 
9.6 通知（多个观察者）	158 
97 性能问题	160 
9.8 框定规则	161 
9.9 保密	164 
9.10 练习	166 
第10章 满足先验条件	169 
10.1 关于本章	169 
10.2 例子	170 
10.3 满足并测试先验条件	170 
10.4 测试与检验	172 
10.5 一个简单的计数器类	173 
10.6 从用户角度看示例程序	174 
10.7 程序的内部结构	176 
10.8 程序的执行情况	178 
10.9 一个次要的细节	184 
10.10 小结	186 
10.11 练习	187 
第11章 java范例	189 
11.1 关于本章	189 
11.2 为什么选择java	190 
11.3 队列	190 
11.3.1 基本查询size()	192 
11.3.2 基本查询get()	193 
11.3.3 基本查询head()	193 
11.3.4 派生查询isempty()	194 
11.3.5 派生查询shallow copy()	194 
11.3.6 构造方法queue	195 
11.3.7 命令put	196 
11.3.8 命令remove	196 
11.3.9 小结	198 
11.4 字典	198 
11.4.1 名字	199 
11.4.2 不变式	200 
11.4.3 基本查询	200 
11.4.4 一个派生查询	201 
11.4.5 命令	201 
11.4.6 构造方法	202 
11.4.7 一组实现类	203 
11.5 没有icontract的java	203 
11.6 测试先验条件	207 
11.7 练习	212 
第12章 契约式分析	215 
12.1 关于本章	215 
12.2 一个用例	215 
12.3 分析模型中的契约	217 
12.4 withdrawcash用例的契约	217 
12.5 从分析到设计	220 
12.6 问题域和系统模型	221 
12.7 对象限制语言	224 
12.8 小结	225 
参考资料	227 
契约式设计	227 
统一建模语言uml	228 
eiffel和java编程语言	229 
观察者模式	229 
编译器和预处理器	229 
三个实用网站	230 
索引	245 


##如何应用该书
我的[Wonder.js引擎](https://github.com/yyc-git/Wonder.js)就使用了dbc，使用typescript的decorator来实现require和ensure,invariant。
现在我主要使用契约来替代防御性编程，检查先验条件和后验条件。

## 我的心得与体会
   Dbc对提高代码质量有帮助，可与单元测试结合起来：Dbc提供运行时检查（检查先验、后验条件，进行防御式检查和测试）；单元测试提供静态测试，测试功能代码。
   


<a name="zhuji"></a>
# 《编程珠玑》

http://pan.baidu.com/s/1pK7etzd

## 推荐度
5星

## 内容概要说明
   本书章节相互独立，在基础、性能、应用三个部分的主题中，给出了案例、经验、总结，并且每章后面还有习题，确实是一本很好的经典书籍！


## 目录说明
第一部分　基础
　　第1章　开篇
　　1.1　一次友好的对话
　　1.2　准确的问题描述
　　1.3　程序设计
　　1.4　实现概要
　　1.5　原理
　　1.6　习题
　　1.7　深入阅读
　　第2章　啊哈！算法
　　2.1　三个问题
　　2.2　无处不在的二分搜索
　　2.3　基本操作的威力
　　2.4　排序
　　2.5　原理
　　2.6　习题
　　2.7　深入阅读
　　2.8　变位词程序的实现（边栏）
　　第3章　数据决定程序结构
　　3.1　一个调查程序
　　.　3.2　格式信函编程
　　3.3　一组示例
　　3.4　结构化数据
　　3.5　用于特殊数据的强大工具
　　3.6　原理
　　3.7　习题
　　3.8　深入阅读
　　第4章　编写正确的程序
　　4.1　二分搜索的挑战
　　4.2　编写程序
　　4.3　理解程序
　　4.4　原理
　　4.5　程序验证的角色
　　4.6　习题
　　4.7　深入阅读
　　第5章　编程小事
　　5.1　从伪代码到c程序
　　5.2　测试工具
　　5.3　断言的艺术
　　5.4　自动测试
　　5.5　计时
　　5.6　完整的程序
　　5.7　原理
　　5.8　习题
　　5.9　深入阅读
　　5.10　调试（边栏）
　　第二部分　性能
　　第6章　程序性能分析
　　6.1　实例研究
　　6.2　设计层面
　　6.3　原理
　　6.4　习题
　　6.5　深入阅读
　　第7章　粗略估算
　　7.1　基本技巧
　　7.2　性能估计
　　7.3　安全系数
　　7.4　little定律
　　7.5　原理
　　7.6　习题
　　7.7　深入阅读
　　7.8　日常生活中的速算（边栏）
　　第8章　算法设计技术
　　8.1　问题及简单算法
　　8.2　两个平方算法
　　8.3　分治算法
　　8.4　扫描算法
　　8.5　实际运行时间
　　8.6　原理
　　8.7　习题
　　8.8　深入阅读
　　第9章　代码调优
　　9.1　典型的故事
　　9.2　急救方案集锦
　　9.3　大手术——二分搜索
　　9.4　原理
　　9.5　习题
　　9.6　深入阅读
　　第10章　节省空间
　　10.1　关键在于简单
　　10.2　示例问题
　　10.3　数据空间技术
　　10.4　代码空间技术
　　10.5　原理
　　10.6　习题
　　10.7　深入阅读
　　10.8　巨大的节省（边栏）
　　第三部分　应用
　　第11章　排序
　　11.1　插入排序
　　11.2　一种简单的快速排序
　　11.3　更好的几种快速排序
　　11.4　原理
　　11.5　习题
　　11.6　深入阅读
　　第12章　取样问题
　　12.1　问题
　　12.2　一种解决方案
　　12.3　设计空间
　　12.4　原理
　　12.5　习题
　　12.6　深入阅读
　　第13章　搜索
　　13.1　接口
　　13.2　线性结构
　　13.3　二分搜索树
　　13.4　用于整数的结构
　　13.5　原理
　　13.6　习题
　　13.7　深入阅读
　　13.8　一个实际搜索问题（边栏）
　　第14章　堆
　　14.1　数据结构
　　14.2　两个关键函数
　　14.3　优先级队列
　　14.4　一种排序算法
　　14.5　原理
　　14.6　习题
　　14.7　深入阅读
　　第15章　字符串
　　15.1　单词
　　15.2　短语
　　15.3　生成文本
　　15.4　原理
　　15.5　习题
　　15.6　深入阅读
　　第1版跋
　　第2版跋
　　附录a　算法分类
　　附录b　估算测试
　　附录c　时空开销模型
　　附录d　代码调优法则
　　附录e　用于搜索的c++类

## 如何应用该书
   可以当成字典书来查（如需要实现排序或者要对3d引擎优化时，可查看对应的章节)。

## 我的心得与体会
   书中的性能部分和应用的排序算法部分对我的[wonder.js引擎](https://github.com/yyc-git/Wonder.js)v0.5.6和v0.5.7版本的优化工作很有帮助。
   书中第4章关于契约的应用我也深有感触！
   还需要读第2遍，把每个章节的习题做一遍！
   书中确实字字是珠玑，值得仔细品味和研究！]]></description></item><item><title>提炼游戏引擎系列：第二次迭代（下）</title><link>http://www.cnblogs.com/chaogex/archive/2014/12/20/4175837.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sat, 20 Dec 2014 13:00:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/12/20/4175837.html</guid><description><![CDATA[#前言
本文为引擎提炼第二次迭代的下篇，将会完成引擎中动画、集合和事件管理相关类的重构。


##本文目的
1、提高引擎的通用性，完善引擎框架。
2、对应修改炸弹人游戏。



##本文主要内容
<ul>
    <li><a href="#Animation">修改动画</a></li>
    <li><a href="#Review">回顾与梳理</a></li>
    <li><a href="#Collection">修改Hash和Collection</a></li>
    <li><a href="#EventManager">修改EventManager</a></li>
    <li><a href="#whole">整体重构</a></li>
    <li><a href="#model">本文最终领域模型</a></li>
    <li><a href="#module">高层划分</a></li>
    <li><a href="#summary">总结</a></li>
    <li><a href="#code">本文源码下载</a></li>
    <li><a href="#reference">参考资料</a></li>
</ul>




<a name="Animation"></a>
#修改动画
##2D动画介绍
###实现原理
一组图片（或一个图的不同位置）在同一位置以一定的时间间隔显示，就形成了动画。

###精灵图片
我们可以将精灵的动画序列图合为一张大的图片，称之为精灵图片。
如炸弹人的精灵图片如下图所示：
![](http://images.cnitblog.com/blog/419321/201412/170758598904329.png)

###帧
动画的一“帧”指动画序列图片中的一张图片，如下图红框就是往左移动动画的一帧：
![](http://images.cnitblog.com/blog/419321/201412/170759116565623.png)

###帧数据
帧数据指帧图片左上顶点在精灵图片中的横轴、纵轴坐标x、y以及帧图片的宽width和高height。

##提出Frame、Animate、Animation、AnimationFrame、Geometry 
###当前设计
当前动画的设计可参考[炸弹人游戏开发系列（4）：炸弹人显示与移动->实现动画]( http://www.cnblogs.com/chaogex/p/3213041.html#animation)

**领域模型**
![](http://images.cnitblog.com/blog/419321/201412/170759418284775.jpg)


精灵的动画数据定义在炸弹人精灵数据SpriteData中，动画的帧数据定义在炸弹人FrameData中。
下面介绍当前的创建动画和播放动画的机制。


####创建动画
创建精灵类实例时会注入炸弹人精灵数据SpriteData，从而获得动画数据，序列图如下所示：
![](http://images.cnitblog.com/blog/419321/201412/200700230639144.jpg)


在initData方法中，炸弹人Scene会创建精灵类实例，将封装了精灵图片的引擎Bitmap实例和精灵类数据SpriteData注入到实例中。

相关代码

引擎Director
```js
        runWithScene: function (scene) {
                …
                this.setScene(scene);
                this._scene.init();
                …
            },
```

引擎Scene
```js
            init: function () {
                //调用initData钩子方法
                this.initData();
                …
            },
```
炸弹人Scene
```js
            initData: function () {
                …
                this._addElements();
                …
            },
            …
            _addElements: function () {
            …
                this.getLayer("playerLayer").addChilds(this._createPlayerLayerElement());
                …
            },
            …
            _createPlayerLayerElement: function () {
                …
                player = spriteFactory.createPlayer();
                …
            },
```
炸弹人SpriteFactory
```js
        createPlayer: function () {
            return new PlayerSprite(
                getSpriteData("player"), 
                bitmapFactory.createBitmap({ img: window.imgLoader.get("player"), width: bomberConfig.player.IMGWIDTH, height: bomberConfig.player.IMGHEIGHT})
            );
        },
```


炸弹人BitmapFactory
```js
        createBitmap: function (data) {
            …
            return new YE.Bitmap(bitmapData);
        }
```


引擎Sprite
```js
        Init: function (data, bitmap) {
			//获得包含精灵图片对象的bitmap实例
            this.bitmap = bitmap;
            …
			//获得初始动画id
            this.defaultAnimId = data.defaultAnimId;
			//获得动画数据
            this.anims = data.anims;
            …
        }
```




SpriteData定义了精灵的动画数据，其中一个动画对应一个引擎Animation实例，并注入了使用getFrames方法获得的帧数据FrameData。

炸弹GetSpriteData和SpriteData都在同一个文件中。

炸弹人GetSpriteData和SpriteData
```js
 var getSpriteData = (function () {
        var data = function () {
            return {
                …
				//初始播放动画id
                defaultAnimId: "stand_right",
				//动画数据
                anims: {
                    "stand_right": YE.Animation.create(getFrames("player", "stand_right")),
                    "stand_left": YE.Animation.create(getFrames("player", "stand_left")),
                    "stand_down": YE.Animation.create(getFrames("player", "stand_down")),
                …
            }

        return function (spriteName) {
            return data()[spriteName];
        };
    }());
```

炸弹GetFrameData和FrameData都在同一个文件中

炸弹人GetFrameData和FrameData
```js
  var getFrames = (function () {
…
     var frames = function () {
            return {
…
				//只有一帧的动画帧数据没有duration属性
                stand_right: [
                    {
                        x: offset.x, y: offset.y + 2 * height, width: sw, height: sh
                    }
                ],
…
                walk_up: [
                    { x: offset.x, y: offset.y + 3 * height, width: sw, height: sh, duration: 100 },
                    { x: offset.x + width, y: offset.y + 3 * height, width: sw, height: sh, duration: 100 },
                    { x: offset.x + 2 * width, y: offset.y + 3 * height, width: sw, height: sh, duration: 100 },
                    { x: offset.x + 3 * width, y: offset.y + 3 * height, width: sw, height: sh, duration: 100 }
                ],
…

        return function (who, animName) {
            return frames()[who][animName];
        };
}());
```


####播放动画
当玩家按下W键时，炸弹人会播放向上走动画，序列图如下所示：
![](http://images.cnitblog.com/blog/419321/201412/200710016103760.jpg)

序列图分为两个阶段：
1、玩家按下移动方向键后，游戏会设置要播放的动画
当玩家按下W键时，炸弹人PlayerSprite会执行炸弹人WalkUpState的walkUp方法，调用炸弹人PlayerSprite的setAnim方法，设置当前要播放的动画walk_up：
炸弹人PlayerSprite
```js
            __judgeAndSetDir: function () {
…
                //判断玩家是否按下了W键
                else if (window.keyState[YE.Event.KeyCodeMap.W] === true) {
                    this.P_context.walkUp();
                }
…
            },
```
炸弹人WalkUpState
```js
            P_setDir: function () {
                var sprite = this.P_context.sprite;

                //设置精灵当前动画为walk_up                
                sprite.setAnim("walk_up");
…
            },
…
            walkUp: function () {
                //调用父类WalkState的方法
                this.P_checkMapAndSetDir();
            }
```
炸弹人WalkState
```js
            P_checkMapAndSetDir: function () {
…
                //调用子类WalkUpState的方法
                this.P_setDir();
…
            },
```
引擎Sprite（炸弹人PlayerSprite的setAnim方法由引擎Sprite实现）
```js
            //设置当前动画
            setAnim: function (animId) {
                this.currentAnim = this.anims[animId];
            },
```

2、主循环更新动画帧，播放动画的当前帧
主循环会调用引擎Layer的run方法，执行炸弹人CharacterLayer在重写的onAfterDraw钩子方法中插入的__update方法和炸弹人PlayerSprite的draw方法。
__update方法负责更新动画帧，最终会委托引擎Animation的update方法实现；
draw方法负责绘制精灵，炸弹人PlayerSprite会在draw方法中访问引擎Sprite的currentAnim属性，获得当前动画实例（引擎Animation实例），调用它的getCurrentFrame方法，获得当前帧数据，然后结合bimap实例的img属性（精灵图片对象），绘制动画当前帧图片。


引擎Layer
```js
           //游戏主循环调用的方法
            run: function () {
                if (this._isChange()) {
…
					//绘制层中所有精灵
                   this.draw();
                   //触发onAterDraw钩子方法
                   this.onAfterDraw();
…
                }
            },
…
            draw: function () {
                this.iterator("draw", this.getContext());
            },
```

炸弹人CharacterLayer
```js
            onAfterDraw: function () {
                this.___update();
            },
…
            ___update: function () {
				//调用炸弹人PlayerSprite的update方法
                this.P_iterator("update");
            },

```

引擎Sprite（炸弹人PlayerSprite的update方法由引擎Sprite实现）
```js
                update: function () {
                    this._updateFrame(1000 / YE.Director.getInstance().getFps());
                },
…
                _updateFrame: function (deltaTime) {
                    if (this.currentAnim) {
    					//委托引擎Animation的update方法更新动画帧
                        this.currentAnim.update(deltaTime);
                    }
                }
```


炸弹人MoveSprite（炸弹人PlayerSprite的draw方法由炸弹人MoveSprite实现）
```js
           draw: function (context) {
                var frame = null;

                if (this.currentAnim) {
                    //取出当前帧
                    frame = this.currentAnim.getCurrentFrame();	
					//从bitmap.img中获得精灵图片对象，绘制动画当前帧
                    context.drawImage(this.bitmap.img, frame.x, frame.y, frame.width, frame.height, this.x, this.y, this.bitmap.width, this.bitmap.height);
                }
            },
```

###分析问题
当前设计有四个地方可以修改：
1、可提取帧数据FrameData的通用模式
炸弹人FrameData中每帧的数据都具有相同的结构，都包括帧在精灵图片中的位置属性x、y和帧的大小属性width、height以及帧播放时间duration属性：
炸弹人FrameData
```js
//只有一帧的动画帧数据没有duration属性，其duration属性值可以看为0
stand_right: [
    {
        x: offset.x, y: offset.y + 2 * height, width: sw, height: sh
    }
],
…
walk_up: [
    { x: offset.x, y: offset.y + 3 * height, width: sw, height: sh, duration: 100 },
    { x: offset.x + width, y: offset.y + 3 * height, width: sw, height: sh, duration: 100 },
    { x: offset.x + 2 * width, y: offset.y + 3 * height, width: sw, height: sh, duration: 100 },
    { x: offset.x + 3 * width, y: offset.y + 3 * height, width: sw, height: sh, duration: 100 }
],
```
可以将通用模式抽象出来，提出引擎Frame类，封装帧数据，提供帧操作的方法。
引擎Frame为实体类，一个Frame对应动画的一帧。

2、引擎Animation的职责不单一
现在引擎Animation既要负责帧数据的保存，又要负责帧的管理：
引擎Animation
```js
   namespace("YE").Animation = YYC.Class({
        Init: function (config) {
			//保存帧数据
            this._frames = YE.Tool.array.clone(config);
            this._init();
        },
        Private: {
            _frames: null,
            _frameCount: -1,
            _img: null,
            _currentFrame: null,
            _currentFrameIndex: -1,
            _currentFramePlayed: -1,

            _init: function () {
                this._frameCount = this._frames.length;

                this.setCurrentFrame(0);
            }
        },
        Public: {
            setCurrentFrame: function (index) {
                this._currentFrameIndex = index;
                this._currentFrame = this._frames[index];
                this._currentFramePlayed = 0;
            },
            /**
             * 更新当前帧
             * @param deltaTime 主循环的持续时间
             */
            update: function (deltaTime) {
                //如果没有duration属性（表示只有一帧），则返回
                if (this._currentFrame.duration === undefined) {
                    return;
                }

                //判断当前帧是否播放完成,
                if (this._currentFramePlayed >= this._currentFrame.duration) {

                    if (this._currentFrameIndex >= this._frameCount - 1) {
                        //当前是最后一帧,则播放第0帧
                        this._currentFrameIndex = 0;
                    } 
else {
                        //播放下一帧
                        this._currentFrameIndex++;
                    }
                    //设置当前帧
                    this.setCurrentFrame(this._currentFrameIndex);

                } 
else {
                    //增加当前帧的已播放时间.
                    this._currentFramePlayed += deltaTime;
                }
            },
            getCurrentFrame: function () {
                return this._currentFrame;
            }
        },

        Static: {
            create: function(config){
                return new this(config);
            }
        }

    });
```

可将其分解为Animation、Animate 、AnimationFrame三个类：
Animation为动画容器类，负责保存一个动画的所有帧数据。
Animate为帧管理类，负责管理一个动画的所有帧。
AnimationFrame为精灵动画容器类，负责保存精灵所有的动画。

它们的对应关系为：
Animation为实体类，一个Animation对应一个动画；
Animate为功能类，一个Animate对应一个Animation；
AnimationFrame为实体类，一个AnimationFrame对应精灵的所有动画。
另外一个Sprite对应一个AnimationFrame，引擎Sprite委托引擎AnimationFrame保存精灵动画。


3、引擎应该封装动画，提供操作API
动画操作属于精灵的基本操作，应该由引擎来负责动画的管理，向用户提供操作动画的API。


4、修改用户创建动画的方式
提取了新的引擎动画类后，需要修改用户代码中创建动画的方式。
目前有两种方式：
（1）初始化方式跟之前一样，只是对应修改炸弹人SpriteData和FrameData，将创建引擎Animation改为创建引擎Frame和Animate实例。
（2）直接在炸弹人精灵类中创建动画，删除炸弹人FrameData，删除炸弹人SpriteData的动画数据。

考虑到这只是修改用户代码，跟引擎没有关系，因此为了节省时间来，我选择第2种方式，具体使用引擎时用户可以自行决定初始化后动画的方式。






**初步设计的引擎领域模型**
现在给出通过分析后设计的引擎领域模型：
![](http://images.cnitblog.com/blog/419321/201412/170806539846966.jpg)



###具体实施
依次实施“分析问题”中提出的解决方案。

1、提出Frame

 - 封装帧数据

首先来看下炸弹人FrameData中一帧数据的组成：
```js
{ x: xxx, y: xxx, width: xxx, height: xxx, duration: xxx }
```
x、y为帧图片左上顶点在精灵图片中的位置，width、height为帧图片的大小，duration为每帧播放的时间。

因为一个动画中的所有帧的播放时间应该都是一样的，只是不同动画的帧播放时间不同，因此duration不应该放在引擎Frame中，而应该放到保存动画帧数据的Animation中。

因此，引擎Frame应该保存帧的x、y、width、height数据。

 - 一个Frame对应一个Img对象

目前动画的每帧都是从精灵的精灵图片中“切”出来的，而精灵图片保存在引擎Bitmap实例中，在创建精灵类实例时注入。
一个精灵只有一个bitmap实例，即一个精灵只对应1张精灵图片。
这样的设计导致精灵的所有动画的所有帧都只能来自同1张精灵图片，无法实现不同的动画的帧来自不同的精灵图片的需求。
因此，可以将精灵图片对象的引用保存到Frame中，从而一个Frame对应1张精灵图片。这样既可以实现每个动画对应不同的精灵图片，还可以实现每个动画的每帧对应不同的精灵图片，从而实现最大的灵活性。
现在可以这样创建引擎Frame实例：
```js
var frame1 = YE.Frame.create(img,x, y, sw, sh); 
```

 - 提出Geometry

此处传入create方法的参数过多，可以将后面与帧相关的4个数据提取为对象：
```js
var frame1 = YE.Frame.create(img, YE.rect(x, y, sw, sh));  
```
其中rect方法在新增的几何类Geometry中定义，负责将矩形区域的数据封装为对象。

相关代码

引擎Geometry
```js
    YE.rect = function (x, y, w, h) {
        return { origin: {x: x, y: y}, size: {width: w, height: h} };
    };
```
引擎Frame
```js
(function () {
    namespace("YE").Frame = YYC.Class({
        Init: function (img, rect) {
			//保存精灵图片对象的引用
            this._img = img;
            this._rect = rect;
        },
        Private: {
            _img: null,
            _rect: {}
        },
        Public: {
            getImg: function () {
                return this._img;
            },
            getX: function () {
                return this._rect.origin.x;
            },
            getY: function () {
                return this._rect.origin.y;
            },
            getWidth: function () {
                return this._rect.size.width;
            },
            getHeight: function () {
                return this._rect.size.height;
            }
        },
        Static: {
            create: function (bitmap, rect) {
                return new this(bitmap, rect);
            }
        }
    });
}());
```


2、分解Animation

 - 改造Animation为动画容器类，负责保存一个动画的所有帧数据。

改造后的引擎Animation
```js
namespace("YE").Animation = YYC.Class({
        Init: function (frames, duration) {
			//保存帧数据
            this._frames = frames;
			//保存每帧的播放时间
            this._duration = duration;
        },
        Private: {
            _frames: null,
            _duration: null
        },
        Public: {
            getFrames: function () {
                return this._frames;
            },
            getDuration: function () {
                return this._duration;
            }
        } ,
        Static: {
            create: function(frames, duration){
                return new this(frames, duration);
            }
        }
});
```

 - 提出Animate，负责管理动画的所有帧

因为引擎Animate需要保存一个动画的所有帧，所以继承Collection，获得集合特性：
引擎Animate
```js
(function () {
    namespace("YE").Animate = YYC.Class(YE.Collection, {
        Init: function (animation) {
            this.__anim = animation;
        },
        Private: {
            __anim: null,
                __frameCount: 0,
                __duration: 0,
                __currentFrame: null,
                __currentFrameIndex: 0,
                __currentFramePlayed: 0
        },
        Public: {
            /**
             * 更新当前帧
             * @param deltaTime 主循环的持续时间
             */
            update: function (deltaTime) {
                //判断当前帧是否播放完成,
                if (this.__currentFramePlayed >= this.__duration) {
                    if (this.__currentFrameIndex >= this.__frameCount - 1) {
                        //当前是最后一帧,则播放第0帧
                        this.__currentFrameIndex = 0;
                    }
                    else {
                        //播放下一帧
                        this.__currentFrameIndex++;
                    }
                    //设置当前帧
                    this.setCurrentFrame(this.__currentFrameIndex);

                }
                else {
                    //增加当前帧的已播放时间.
                    this.__currentFramePlayed += deltaTime;
                }
            },
            getCurrentFrame: function () {
                return this.__currentFrame;
            },
            init: function () {
				//调用父类Collection的API，保存动画的所有帧
                this.addChild(this.__anim.getFrames());

                this.__duration = this.__anim.getDurationPerFrame();
                //需要获得帧的数量
                this.__frameCount = this.getCount();

                this.setCurrentFrame(0);
            },
            setCurrentFrame: function (index) {
                this.__currentFrameIndex = index;
                this.__currentFrame = this.getChildAt(index);
                this.__currentFramePlayed = 0;
            }
        },
        Static: {
            create: function (animationFrame) {
                return new this(animationFrame);
            }
        }
    });
}());
```
因为Animate需要获得帧的数量，因此引擎Collection需要增加getCount方法，返回容器元素的个数：
引擎Collection
```js
            getCount: function () {
                return this._childs.length;
            },
```

 - 提出AnimationFrame，负责保存精灵所有的动画

因为引擎AnimationFrame需要保存多个动画，所以应该继承引擎Hash类，以动画名为key，动画实例为value的形式保存动画：
引擎AnimationFrame
```js
(function () {
    namespace("YE").AnimationFrame = YYC.Class({
        Init: function () {
            this._spriteFrames = YE.Hash.create();
        },
        Private: {
            _spriteFrames: null
        },
        Public: {
			//提供操作动画API

            getAnims: function () {
                return this._spriteFrames.getChilds();
            },
            getAnim: function (animName) {
                return this._spriteFrames.getValue(animName);
            },
            addAnim: function (animName, anim) {
                //加入动画时初始化动画
                anim.init();

                this._spriteFrames.add(animName, anim);
            }
        },
        Static: {
            create: function () {
                return new this();
            }
        }
    });
}());
```

 - 引擎Sprite与引擎AnimationFrame应该为组合关系

引擎Sprite
```js
        Init: function (data, bitmap) {
 …
            this._animationFrame = YE.AnimationFrame.create();
        },
```
3、引擎封装动画，提供操作API

 - 应该由引擎Sprite提供addAnim等操作动画API，还是暴露引擎AnimationFrame实例给用户，用户直接访问它的操作动画API？

如果由引擎Sprite提供操作动画API，那它的示例代码为：
```js
			//加入动画
            addAnim: function (animName, anim) {
                this._animationFrame.add(animName, anim)
            }
```
这种方式有下面的好处：
（1）对用户隐藏了AnimationFrame，减小了用户负担。
（2）增加了1层封装，可以更灵活地插入Sprite的逻辑。

但是也有缺点，如果AnimationFrame增加操作动画的API，则Sprite也要对应增加这些API，这样会增加Sprite的复杂度。

考虑到：
（1）Sprite提供的操作动画的API只是中间者方法，没有自己的逻辑。
（2）现在操作动画的API太少了，以后会不断增加。

因此目前来看，直接将AnimationFrame暴露给用户更加合适。



相关代码
引擎Sprite
```js
			//暴露引擎AnimationFrame实例给用户
            getAnimationFrame: function () {
                return this._animationFrame;
            },
```
用户可这样调用动画操作API：
```js
var sprite = new PlayerSprite();
sprite.getAnimationFrame().addAnim(xxx,xxx);
```

 - 引擎负责动画的管理

在“播放动画”中可以看到，用户参与了更新动画帧的机制，实现了绘制动画当前帧的逻辑：
（1）炸弹人CharacterLayer调用了炸弹人PlayerSprite的update方法（由引擎Sprite实现）。
炸弹人CharacterLayer
```js
          ___update: function () {
                this.P_iterator("update");
            },
…
            onAfterDraw: function () {
                this.___update();
            },
```

（2）炸弹人MoveSprite实现了“绘制动画当前帧”。
炸弹人MoveSprite
```js
           draw: function (context) {
                var frame = null;

                if (this.currentAnim) {
                    //取出当前帧
                    frame = this.currentAnim.getCurrentFrame();	
					//从bitmap.img中获得精灵图片对象，绘制动画当前帧
                    context.drawImage(this.bitmap.img, frame.x, frame.y, frame.width, frame.height, this.x, this.y, this.bitmap.width, this.bitmap.height);
                }
            },
```
这些属于底层机制和逻辑，应该由引擎负责。
因此，将其封装到引擎中。
具体来说引擎需要进行下面两个修改：
（1）封装“更新动画帧”的机制
引擎Layer增加update方法，在主循环中调用该方法：
引擎Layer的update方法负责调用层中所有精灵的update方法，而精灵update方法又调用引擎Animate的update方法，从而实现主循环中更新动画帧的机制。

序列图
![](http://images.cnitblog.com/blog/419321/201412/200746552199363.jpg)
 
引擎Layer
```js
            //游戏主循环调用的方法
            run: function () {
                this.update();
                …
            },
            …
            update: function () {
                this.P_iterator("update");
            },
```

引擎Sprite
```js
            update: function () {
                this._updateFrame(1000 / YE.Director.getInstance().getFps());
            },
            …
            _updateFrame: function (deltaTime) {
                if (this.currentAnim) {
					//调用引擎Animate的update方法
                    this.currentAnim.update(deltaTime);
                }
            }
```
引擎Animate
```js
            //更新当前帧
            update: function (deltaTime) {
                …
            },
```
（2）实现“绘制动画当前帧”逻辑
将炸弹人MoveSprite实现的“绘制动画当前帧”的逻辑提到引擎Sprite中。
由于不是所有的炸弹人精灵类的绘制逻辑都为该逻辑（如炸弹人MapElementSprite没有动画，不需要绘制动画帧，而是直接绘制图片对象），所以将提取的方法命名为drawCurrentFrame，与draw方法共存，供用户自行选择：
引擎Sprite
```js
			//绘制动画当前帧
            drawCurrentFrame: function (context) {
				//重构，提出getCurrentFrame方法
                var frame = this.getCurrentFrame();

                context.drawImage(
                    frame.getImg(),
                    frame.getX(), frame.getY(), frame.getWidth(), frame.getHeight(),
                    this.x, this.y, this.bitmap.width, this.bitmap.height
                );
            },
            getCurrentFrame: function () {
                if (this.currentAnim) {
                    return this.currentAnim.getCurrentFrame();
                }

                return null;
            },
…
            //保留绘制精灵图片对象方法
            draw: function (context) {
                context.drawImage(this.bitmap.img, this.x, this.y, this.bitmap.width, this.bitmap.height);
            },
```
炸弹人MoveSprite的draw方法改为直接调用引擎Sprite的drawCurrentFrame方法：
炸弹人MoveSprite
```js
            draw: function (context) {
                this.drawCurrentFrame(context);
            },
```

 - 清理引擎包含的用户逻辑

引擎Sprite包含的“设置精灵的初始动画” 逻辑属于用户逻辑，应该由用户类负责。
因此将引擎Sprite的defaultAnimId属性移到炸弹人MoveSprite中。
炸弹人MoveSprite
```js
        Init: function (data, bitmap) {
…
            this.defaultAnimId = data.defaultAnimId;
        },
```
引擎Sprite删除defaultAnimId属性

4、在炸弹人精灵类中创建动画，删除炸弹人FrameData，删除炸弹人SpriteData的动画数据。
修改炸弹人创建动画的方式，在炸弹人PlayerSprite和EnemySprite中创建动画，加入到精灵类的引擎AnimationFrame实例中，并设置精灵的默认动画。
炸弹人PlayerSprite
```js
           initData: function () {
                …
                var width = bomberConfig.player.WIDTH,
                    height = bomberConfig.player.HEIGHT,
                    offset = {
                        x: bomberConfig.player.offset.X,
                        y: bomberConfig.player.offset.Y
                    },
                    sw = bomberConfig.player.SW,
                    sh = bomberConfig.player.SH;

                //创建帧，传入精灵图片对象和帧图片区域大小数据
                var frame1 = YE.Frame.create(this.bitmap.img, YE.rect(offset.x, offset.y, sw, sh));  
                var frame2 = YE.Frame.create(this.getImg(), YE.rect(offset.x + width, offset.y, sw, sh));
                …

                //创建动画帧数组，加入动画的帧
                var animFrames1 = [];

                animFrames1.push(frame1);
                animFrames1.push(frame2);

                …

                //创建动画，设置动画的持续时间
                var animation1 = YE.Animation.create(animFrames1, 100);
                …

                //将动画加入到AnimationFrame实例中
                var animationFrame = this.getAnimationFrame();

                animationFrame.addAnim("walk_down", YE.Animate.create(animation1));
                …

                //设置默认动画
                this.setAnim("walk_down");
            }
```
EnemySprite
与PlayerSprite类似，此处省略


###总结

####重构后的领域模型
![](http://images.cnitblog.com/blog/419321/201412/170811274223271.jpg)

因为在炸弹人精灵类中创建动画，所以删除了炸弹人FrameData和炸弹人SpriteData的动画数据，炸弹人SpriteData不再关联引擎动画了。
增加了Frame类，引擎Animation被分解为AnimationFrame、Animate、Animation，它们相互之间有聚合关系。


####重构后的播放动画序列图
![](http://images.cnitblog.com/blog/419321/201412/170811414062209.jpg)


引擎封装并对用户隐藏了“更新动画帧”机制。
从引擎Animation中分离出来的引擎Animate负责动画帧的管理，引擎Sprite改为与引擎Animate交互。
炸弹人PlayerSprite的draw方法（由炸弹人MoveSprite实现）直接委托引擎Sprite的drawCurrentFrame方法。


####待重构点
至少还有下面几点需要进一步修改：
1、引擎应该提供将动画数据和动画逻辑分离的方式，提供创建动画的高层API。
引擎应该定义动画数据格式，封装创建动画的逻辑，用户可以按照引擎定义的数据格式，将动画数据分离到单独的文件中，调用高层API读取动画数据并创建动画。
2、引擎应该增加更多的动画操作API，如增加开始动画、结束动画等。


<a name="Review"></a>
#回顾与梳理
现在需要停下来，回顾一下之前的重构，查找并解决遗漏的问题。

##使用YE.rect方法重构炸弹人矩形区域数据为对象
###当前设计
在“修改动画”的重构中，提出了Geometry类，该类有YE.rect方法，负责将矩形区域的数据封装为对象。
引擎Geometry
```js
    YE.rect = function (x, y, w, h) {
        return { origin: {x: x, y: y}, size: {width: w, height: h} };
    };
```
炸弹人类中除了帧数据，还有其它的矩形区域数据。如炸弹人游戏中碰撞检测的数据：
炸弹人BombSprite
```js
                collideFireWithCharacter: function (sprite) {
…
                    fire = {
                        x: range[i].x,
                        y: range[i].y,
                        width: this.getWidth(),
                        height: this.getHeight()
                    };
                    obj2 = {
                        x: sprite.getPositionX(),
                        y: sprite.getPositionY(),
                        width: sprite.getWidth(),
                        height: sprite.getHeight()
                    };
                    if (YE.collision.col_Between_Rects(fire, obj2)) {
                        return true;
                    }
      …
                },
```
炸弹人EnemySprite
```js
            collideWithPlayer: function (sprite2) {
                var obj1 = {
                        x: this.getPositionX(),
                        y: this.getPositionY(),
                        width: this.getWidth(),
                        height: this.getHeight()
                    },
                    obj2 = {
                        x: sprite2.getPositionX(),
                        y: sprite2.getPositionY(),
                        width: sprite2.getWidth(),
                        height: sprite2.getHeight()
                    };
				//判断是否碰撞
                if (YE.collision.col_Between_Rects(obj1, obj2)) {
                    throw new Error();
                }
            },
```
引擎collision
```js
        //获得精灵的碰撞区域,
        getCollideRect: function (obj) {
            return {
                x1: obj.x,
                y1: obj.y,
                x2: obj.x + obj.width,
                y2: obj.y + obj.height
            }
        },
        /**
         *矩形和矩形间的碰撞
         **/
        col_Between_Rects: function (obj1, obj2) {
            var rect1 = this.getCollideRect(obj1);
            var rect2 = this.getCollideRect(obj2);

…
        }
```
###分析问题
可以用YE.rect方法将矩形区域数据定义为对象。


###具体实施
重构炸弹人BombSprite、EnemySprite的矩形区域数据为对象，对应修改引擎collision：
炸弹人BombSprite
```js
                collideFireWithCharacter: function (sprite) {
…
                    fire = YE.rect(range[i].x, range[i].y, this.getWidth(), this.getHeight());
                    obj2 = YE.rect(sprite.getPositionX(),sprite.getPositionY(),sprite.getWidth(),sprite.getHeight());
                    if (YE.collision.col_Between_Rects(fire, obj2)) {
                        return true;
                    }
      …
                },
```
炸弹人EnemySprite
```js
            collideWithPlayer: function (sprite2) {
                var obj1 = YE.rect(this.getPositionX(), this.getPositionY(), this.getWidth(), this.getHeight()),
                    obj2 = YE.rect(sprite2.getPositionX(), sprite2.getPositionY(), sprite2.getWidth(), sprite2.getHeight());

                if (YE.collision.col_Between_Rects(obj1, obj2)) {
                    throw new Error();
                }
            },
```
引擎collision
```js
	//根据rect的数据结构对应修改
    getCollideRect:function(obj) {
        return {
            x1: obj.origin.x,
            y1: obj.origin.y,
            x2: obj.origin.x + obj.size.width,
            y2: obj.origin.y + obj.size.height
        }
    },
```

##封装引擎Sprite的位置属性x、y，提供操作API
###当前设计
用户创建精灵实例时传入精灵初始坐标：
引擎Sprite
```js
Init: function (data, bitmap) {
…

    if (data) {
        //初始坐标
        this.x = data.x;
        this.y = data.y;
    }
…
},
```
用户可直接操作精灵的坐标属性x、y：
引擎Sprite
```js
        Public: {
…

            //精灵的坐标
            x: 0,
            y: 0,
```       



###分析问题

 - 应该封装引擎Sprite的位置属性x、y，向用户提供操作坐标的API。

这是因为：
1、便于以后扩展，在API中加入引擎Sprite的逻辑。
如可以在API中增加权限控制等逻辑。
2、引擎Sprite的坐标属性名为“x”、“y”，容易与其它object对象的属性名同名，影响可读性，相互干扰。
如引擎Sprite的getCellPosition方法返回包含x、y属性的方格坐标对象：
```js
                //获得坐标对应的方格坐标（向下取值）
                getCellPosition: function (x, y) {
                    return {
                        x: Math.floor(x / YE.Config.WIDTH),
                        y: Math.floor(y / YE.Config.HEIGHT)
                    }
                },
```
用户容易将该方法返回的坐标对象与精灵坐标混淆，从而误操作。

 - 用户应该使用操作坐标的方法来设置精灵的初始坐标，不应该在创建精灵实例时传入初始坐标。

因为这样可以：
1、增加灵活性
坐标与精灵改为关联关系，可以不强制用户在创建精灵实例时设置初始坐标，从而用户可自行决定何时设置。
2、减少复杂度
简化引擎Sprite的构造函数。


###具体实施
1、引擎Sprite增加setPosition、setPositionX、setPositionY、getPositionX、getPositionY方法，将x、y属性设为私有属性。
2、删除引擎Sprite构造函数的data形参。
3、对应修改炸弹人，改为使用引擎Sprite提供的操作坐标API。


引擎Sprite
```js
namespace("YE").Sprite = YYC.AClass({
    Init: function (bitmap) {
        …
    },
    Private: {
        …
        _x: 0,
        _y: 0
        …
    },
    Public:{
        …
        setPosition: function (x, y) {
            this._x = x;
            this._y = y;
        },
        setPositionX: function (x) {
            this._x = x;
        },
        setPositionY: function (y) {
            this._y = y;
        },
        getPositionX: function () {
            return this._x;
        },
        getPositionY: function () {
            return this._y;
        },
```


此处仅给出部分炸弹人类的对应修改：
引擎MoveSprite
```js
        Init: function (data, bitmap) {
			//只传入bitmap到引擎Sprite的构造函数中
            this.base(bitmap);
…

            this.setPosition(data.x, data.y);
        },
…
        __isMoving: function () {
            return this.getPositionX() % bomberConfig.WIDTH !== 0 || this.getPositionY() % bomberConfig.HEIGHT !== 0
        }
```


##封装引擎Sprite的bitmap属性
###当前设计
引擎Sprite的bitmap属性为引擎Bitmap实例，在创建精灵实例时传入： 
引擎Sprite
```js
        Init: function (bitmap) {
            this.bitmap = bitmap;
…
        },
…
        Public: {
            //bitmap为公有属性
            bitmap: null,
```

现在炸弹人可以直接操作它来获得精灵图片的相关数据。
如炸弹人PlayerSprite可访问bitmap属性的img属性来获得精灵图片对象：
炸弹人PlayerSprite
```js
     initData: function () {
        …
        var frame1 = YE.Frame.create(this.bitmap.img, YE.rect(offset.x, offset.y, sw, sh));
```


###分析问题
应该封装引擎Sprite的bitmap属性，向用户提供操作bitmap的API，这样用户就不需要知道bitmap的存在，减少用户负担。

因为精灵图片与精灵属于组合关系，应该在创建精灵时就设置精灵图片，所以保留引擎Sprite构造函数中传入bitmap实例的设计。
引擎Sprite应该增加setBitmap和setImg方法，满足用户更改精灵图片的需求。




###具体实施
引擎Sprite增加getImg、getWidth、getHeight、setBitmap、setImg方法，将bitmap属性改为私有属性：
引擎Sprite
```js
        Private: {
            _bitmap: null,
…
        Public:{
…
            //获得精灵图片对象
            getImg: function () {
                return this._bitmap.img;
            },
            //获得精灵宽度
            getWidth: function () {
                return this._bitmap.width;
            },
            //获得精灵高度
            getHeight: function () {
                return this._bitmap.height;
            },
            setBitmap: function(bitmap){
                 this._bitmap = bitmap;
            },
            setImg: function(img){
                 this._bitmap.img = img;
            },
```
对应修改用户类，使用引擎Sprite提供的API操作bitmap：
如炸弹人PlayerSprite
```js
     initData: function () {
        …
        var frame1 = YE.Frame.create(this.getImg(), YE.rect(offset.x, offset.y, sw, sh));
```





##删除引擎Sprite的getCellPosition方法
###当前设计
引擎Sprite的getCellPosition方法负责将精灵坐标转换为炸弹人游戏中使用的方格坐标：
引擎Sprite
```js
                //获得坐标对应的方格坐标
                getCellPosition: function (x, y) {
                    return {
                        x: Math.floor(x / YE.Config.WIDTH),
                        y: Math.floor(y / YE.Config.HEIGHT)
                    }
                },
```


###分析问题
该方法的逻辑与具体的游戏相关，属于用户逻辑，应该由用户实现。

###具体实施
将引擎Sprite的getCellPosition方法移到对应的炸弹人类中，将其修改为从炸弹人BomberConfig中获得方格大小：
如炸弹人MoveSprite
```js
            //获得坐标对应的方格坐标（向下取值）
            getCellPosition: function (x, y) {
                return {
                    x: Math.floor(x / bomberConfig.WIDTH),
                    y: Math.floor(y / bomberConfig.HEIGHT)
                }
            }
```


##删除引擎Config
###当前设计
在第一次迭代中，为了解除引擎和炸弹人Config的依赖，提出了引擎Config。
引擎Config
```js
namespace("YE").Config = {
    //方格宽度
    WIDTH: 30,
    //方格高度
    HEIGHT: 30,

    //画布
    canvas: {
        //画布宽度
        WIDTH: 600,
        //画布高度
        HEIGHT: 600,
        //定位坐标
        TOP: "0px",
        LEFT: "0px"
    }
};
```


###分析问题
因为：
（1）删除了引擎Sprite的getCellPosition方法后，引擎不再依赖引擎Config类了。
（2）引擎Config应该放置与引擎相关的配置属性，而现在放置的配置属性“方格大小”和“画布大小”均属于用户逻辑。

所以应该删除引擎Config。

###具体实施
删除引擎Config



##引擎类不应该依赖引擎collision
###当前设计
引擎Sprite定义了获得碰撞区域数据的getCollideRect方法，依赖了引擎collision。
![](http://images.cnitblog.com/blog/419321/201412/170817416407963.jpg)
 


引擎Sprite
```js
            getCollideRect: function () {
                var obj = {
                    x: this.x,
                    y: this.y,
                    width: this.bitmap.width,
                    height: this.bitmap.height
                };
                //调用了引擎collision的getCollideRect方法
                return YE.collision.getCollideRect(obj);
            },
```
###分析问题
引擎collision为碰撞算法类，与游戏相关，应该只供用户使用，引擎Sprite不应该依赖引擎collision。


###具体实施
需要进行下面的重构：
1、删除引擎Sprite的getCollideRect方法
现在炸弹人和引擎均没有用到引擎Sprite的getCollideRect方法，故将其删除。
2、引擎collision的getCollideRect方法改为私有方法
完成第一个重构后，炸弹人和引擎都不会用到引擎collision的getCollideRect方法，因此将其设为私有方法。


引擎collision
```js
    //改为私有方法
    function _getCollideRect(obj) {
…
    }

    return {
        //改为调用私有方法_getCollideRect
        col_Between_Rects: function (rect1, rect2) {
            var rect1 = _getCollideRect(rect1),
            	rect2 = _getCollideRect(rect2);
```


**领域模型**
重构后引擎collision只供用户使用了：
![](http://images.cnitblog.com/blog/419321/201412/170817246566807.jpg)




<a name="Collection"></a>
#修改Hash和Collection
现在回到主线，修改Hash和Collection。

##封装遍历集合的逻辑
###当前设计
引擎Hash没有实现“遍历集合”的逻辑。
引擎Collection实现了迭代器模式，提供了遍历集合的迭代器方法hasNext、next、resetCursor：
引擎Collection
```js
	//迭代器模式接口
    var IIterator = YYC.Interface("hasNext", "next", "resetCursor");

    namespace("YE").Collection = YYC.AClass({Interface: IIterator}, {
…
            hasNext: function () {
                if (this._cursor === this._childs.length) {
                    return false;
                }
                else {
                    return true;
                }
            },
            next: function () {
                var result = null;

                if (this.hasNext()) {
                    result = this._childs[this._cursor];
                    this._cursor += 1;
                }
                else {
                    result = null;
                }

                return result;
            },
            resetCursor: function () {
                this._cursor = 0;
            },
```

引擎Scene实现了遍历集合的逻辑：
```js
            _iterator: function (handler, args) {
                var args = Array.prototypethis.base().slice.call(arguments, 1),
                    i = null,
                    layers = this.getChilds();

                for (i in layers) {
                    if (layers.hasOwnProperty(i)) {
                        layers[i][handler].apply(layers[i], args);
                    }
                }
            },
```
引擎Layer封装了引擎Collection的迭代器方法，提供了外观方法P_iterator：
```js
            P_iterator: function (handler) {
                var args = Array.prototype.slice.call(arguments, 1),
                    nextElement = null;

                while (this.hasNext()) {
                    nextElement = this.next();
                    nextElement[handler].apply(nextElement, args);
                }
                this.resetCursor();
            }
```
由于炸弹人BombLayer要在遍历集合时加入判断逻辑，不能直接使用引擎Layer的P_iterator方法，所以它调用引擎Collection的迭代器方法，实现了“遍历集合”的逻辑：
炸弹人BombLayer
```js
            ___explodeInEffectiveRange: function (bomb) {
                var eachBomb = null;

                this.resetCursor();
                while (this.hasNext()) {
                    eachBomb = this.next();
					//加入了判断逻辑
                    if (eachBomb.isInEffectiveRange.call(eachBomb, bomb)) {
                        this.explode(eachBomb);
                    }
                }
                this.resetCursor();
            }
```
其它炸弹人Layer类使用引擎Layer的P_iterator方法遍历集合：
如炸弹人CharacterLayer
```js
            ___setDir: function () {
				//执行集合元素的setDir方法
                this.P_iterator("setDir");
            },
```       
            
###分析问题
当前设计有下面几个问题：
1、引擎Hash没有实现“遍历集合”的逻辑，导致需要继承Hash的引擎Scene自己实现。
2、引擎Layer封装的外观方法P_iterator不灵活，导致炸弹人BombLayer不能直接使用，只能调用引擎Collection的迭代器方法来实现。

因为：
1、“遍历集合”的逻辑与引擎集合类相关，应该统一由它们实现。
2、引擎Collection的迭代器方法属于实现“遍历集合”的底层方法，应该作为Collection的内部方法。外界只需要调用“遍历集合”的外观方法即可，不需要了解该方法是如何实现的。
3、用户不应该自己实现“遍历集合”的逻辑。
所以：
1、应该由引擎集合类统一实现“遍历集合”逻辑。
2、引擎集合类提供改进后的“遍历集合”的外观方法，隐藏引擎Collection的迭代器方法，其它引擎类和用户类直接调用外观方法即可。


###具体实施
引擎Collection删除迭代器接口，将迭代器方法设为私有方法，实现遍历集合的外观方法iterator：
引擎Collection
```js
	    //删除了迭代器接口
        namespace("YE").Collection = YYC.AClass({
…
            //实现外观方法iterator
            iterator: function (handler, args) {
                var args = Array.prototype.slice.call(arguments, 1),
                    nextElement = null;

                this._resetCursor();

				//改进设计，handler既可以为方法名，又可以为回调函数，这样炸弹人BombLayer在遍历集合时就可以通过传入自定义的回调函数来加入判断逻辑了
				
                if (YE.Tool.judge.isFunction(arguments[0])) {
                    while (this._hasNext()) {
                        nextElement = this._next();
                        handler.apply(nextElement, [nextElement].concat(args));
                    }
                    this._resetCursor();
                }
                else {
                    while (this._hasNext()) {
                        nextElement = this._next();
                        nextElement[handler].apply(nextElement, args);
                    }
                    this._resetCursor();
                }
            },
```
引擎Tool实现isFunction方法
```js
        isFunction: function (func) {
            return Object.prototype.toString.call(func) === "[object Function]";
        },
```

引擎Hash实现遍历集合的外观方法iterator。
引擎Hash
```js
           iterator: function (handler, args) {
                var args = Array.prototype.slice.call(arguments, 1),
                    i = null,
                    layers = this.getChilds();

                for (i in layers) {
                    if (layers.hasOwnProperty(i)) {
                        layers[i][handler].apply(layers[i], args);
                    }
                }
            }
```




引擎Scene、Layer和炸弹人Layer类使用引擎集合类的iterator方法：
引擎Scene
```js
            _initLayer: function () {
                this.iterator("init", this.__getLayers());
            }
```

引擎Layer
```js
            update: function () {
                this.iterator("update");
            },
```

炸弹人BombLayer直接使用引擎Collection的iterator方法，传入自定义的回调函数：
```js
            ___explodeInEffectiveRange: function (bomb) {
                var self = this;

                this.iterator(function(eachBomb){
                    if (eachBomb.isInEffectiveRange.call(eachBomb, bomb)) {
                        self.explode(eachBomb);
                    }
                });
            } ,
```

其它炸弹人Layer类示例：
炸弹人CharacterLayer
```js
            ___setDir: function () {
                this.iterator("setDir");
            },
```



##组合复用引擎集合类
###当前设计
目前引擎Collection、Hash为抽象类，引擎类需要继承Collection或Hash类来获得集合类特性。
引擎Collection
```js
namespace("YE").Collection = YYC.AClass({
```
引擎Hash
```js
namespace("YE").Hash = YYC.AClass({
```
引擎Layer通过继承引擎Collection来获得集合特性：
```js
namespace("YE").Layer = YYC.AClass(YE.Collection, {
```
引擎Scene通过继承引擎Hash来获得集合特性：
```js
namespace("YE").Scene = YYC.Class(YE.Hash, {
```

###分析问题
回顾在“[炸弹人游戏开发系列（3）：显示地图](http://www.cnblogs.com/chaogex/p/3175811.html)”中，进行了继承复用集合类Collection的设计。当时这样设计的原因如下：

> 1、通过继承来复用比起委托来说更方便和优雅，可以减少代码量。
> 2、从概念上来说，Collection和Layer都是属于集合类，应该属于一个类族。Collection是从Layer中提炼出来的，它是集合类的共性，因此Collection作为父类，Layer作为子类。


然而现在这个设计已经不合适了，因为：
1、这只适用于整体具有集合特性的情况，不适用于局部具有集合特性的情况。
如引擎Animate只是功能类，不是集合类，只是因为要操作动画的帧数据，需要一个内部容器来保存帧数据。
当前设计是让引擎Animate继承集合类Collection，造成整体与Collection耦合，只要两者有一个修改了，另外一个就可能受到影响。
更好的设计是Animate增加私有属性frames，它为Collection的实例。这样Animate就只有该属性与Collection耦合，当Animate的其它属性和方法修改时，不会影响到Collection；Collection修改时，也只会影响到Animate的frames属性。从而把影响减到了最小。


2、如果几个有集合特性的引擎类同属于一个类族，需要继承某个父类时，则会有冲突。
因为它们已经继承了集合类了，不能再继承另一个父类。






因此，将引擎Collection、Hash改成类，改为组合复用的方式来使用。


###具体实施
引擎Hash修改为类，增加create方法
```js
   namespace("YE").Hash = YYC.Class({
        …
        Static: {
            create: function () {
                return new this();
            }
        }
```
引擎Scene增加内部容器layers，组合复用Hash： 
```js
    Init: function () {
            this._layers = YE.Hash.create();
        },
        //改为通过_layers来进行集合操作
        //如将“this.getChilds()”改为“this._layers.getChilds()”
        
        Private: {
            _layers:null,

            _getLayers: function () {
                return this._layers.getChilds();
            },
            _initLayer: function () {
                this._layers.iterator("init", this._getLayers());
            }
        },
        Public: {
            addLayer: function (name, layer) {
                this._layers.add(name, layer);

                return this;
            },
            getLayer: function (name) {
                return this._layers.getValue(name);
            },
            run: function () {
                this._layers.iterator("onStartLoop");

                this._layers.iterator("run");
                this._layers.iterator("change");

                this._layers.iterator("onEndLoop");
            },
```

引擎AnimationFrame增加内部容器spriteFrames，组合复用Hash： 
```js
  Init: function () {
            this._spriteFrames = YE.Hash.create();
        },
        Private: {
            _spriteFrames: null
        },
        Public: {
            getAnims: function () {
                return this._spriteFrames.getChilds();
            },
            getAnim: function (animName) {
                return this._spriteFrames.getValue(animName);
            },
            addAnim: function (animName, anim) {
                anim.init();
                this._spriteFrames.add(animName, anim);
            }
```
引擎Collection修改为Class，增加create方法
```js
namespace("YE").Collection = YYC.Class({
        …
        Static: {
            create: function () {
                return new this();
            }
        }
```

引擎Layer增加内部容器_childs，组合复用Collection。
因为引擎Layer需要向用户提供集合操作API，因此增加getChildAt、removeAll、iterator等中间者方法，封装内部容器：
```js
        namespace("YE").Layer = YYC.AClass({
            Init: function (id, zIndex, position) {
                …
                this._childs = YE.Collection.create();
            },
            …
            removeAll: function () {
                this._childs.removeAll();
            },
            addChild: function (element) {
                this._childs.addChild(element);
                element.init();
            },
            getChildAt: function (index) {
                return this._childs.getChildAt(index);
            },
            iterator: function (handler, args) {
                this._childs.iterator.apply(this._childs, arguments);
            },
            getChilds: function () {
                return this._childs.getChilds();
            },
```

引擎Animate增加内部容器frames，组合复用Collection：
```js
        Init: function (animation) {
            …
            this._frames = YE.Collection.create();
        },
…
        Public:{
…
            init: function () {
                this._frames.addChilds(this._anim.getFrames());
…
                this._frameCount = this._frames.getCount();
…
            },
            setCurrentFrame: function (index) {
…
                this._currentFrame = this._frames.getChildAt(index);
…
            }
```





<a name="EventManager"></a>
#修改EventManager
用户可指定绑定事件的对象target和处理方法的上下文handlerContext。
###当前设计
用户只能绑定全局事件，处理方法的this只能指向window：
引擎EventManager
```js
addListener: function (event, handler) {
…
	//现在写死了，用户只能绑定window的事件，handler的this只能指向window
    YE.Tool.event.addEvent(window, eventType, handler);
…
},
```

###分析问题
实际的游戏开发中，用户不仅需要绑定全局事件，还需要绑定具体dom的事件，而且也可能需要指定事件处理方法的this。
因此，修改为由用户传入绑定事件的对象target和处理方法的上下文handlerContext。


###具体实施
修改引擎EventManager的addListener方法，增加形参target和handlerContext：
引擎EventManager
```js
        addListener: function (event, handler, target, handlerContext) {
…
			//如果用户指定了handlerContext，则将handler的this指向handlerContext
            if (handlerContext) {
                _handler = YE.Tool.event.bindEvent(handlerContext, handler);
            }
			//否则handler的this指向默认的window
            else {
                _handler = handler;
            }
			//绑定事件到用户指定的target，默认为绑定全局事件
            YE.Tool.event.addEvent(target || window, eventType, _handler);
…
        },
```
##将keyListeners设为私有属性
现在keyListeners为闭包内部成员：
引擎EventManager
```js
(function () {
    var _keyListeners = {};
    
    namespace("YE").EventManager = {
```

为了方便测试（EventManager的单元测试需要修改EventManager的_keyListeners属性），将其修改为EventManager的私有属性。
引擎EventManager
```js
    namespace("YE").EventManager = {
        _keyListeners: {},
```


<a name="whole"></a>
#整体重构
所有的引擎类已经重构完毕，我们需要站在整个引擎的层面进行进一步的重构。


##整理文件结构
###将引擎依赖的jsExtend库引入到引擎中
现在引擎依赖了YOOP和jsExtend库。
根据引擎设计原则“尽可能少地依赖外部文件”，考虑到jsExtend是我开发的、没有发布的库，可以将其引入，作为引擎的内部库。
而YOOP是我开发的、独立发布库，引擎不应该引入该库。
**划分引擎文件结构**
现在所有引擎文件均在一个文件夹yEngine2D中，不方便维护，应该划分引擎包，每个包对应一个文件夹，把引擎文件移到对应包的文件夹中。

划分后的包图
![](http://images.cnitblog.com/blog/419321/201412/170826531568686.jpg) 
划分后的文件结构
![](http://images.cnitblog.com/blog/419321/201412/170822482031221.png)

其中import文件夹放置引擎的内部库。



##整体修改
###引擎类的私有和保护成员加上引擎专有前缀“ye_”
####当前设计
引擎类的私有和保护成员没有专门的前缀。
如引擎Sprite
```js
        Private: {
            _animationFrame: null,
…
            _updateFrame: function (deltaTime) {
…
            }
        },
```
####分析问题
为了防止继承引擎类的用户类的私有和保护成员与引擎类成员同名，可继承重写的引擎类（如引擎Sprite）的私有和保护成员需要加上“ye_”前缀。
另外，为了统一引擎类的成员命名，所有的引擎类的私有和保护成员都应该加上该前缀。
然而目前引擎类没有保护成员，因此只对引擎类私有成员加上前缀。

####具体实施
如引擎Sprite
```js
        Private: {
            ye_animationFrame: null,
…
            ye_updateFrame: function (deltaTime) {
…
            }
        },
```



###用户可直接创建抽象引擎类Scene、Layer、Sprite的实例
####当前设计
引擎Scene、Layer、Sprite为抽象类，没有创建自身实例的create方法。

####分析问题
这几个类为抽象类，照理来说不能创建自身实例，但是为了减少用户负担，用户应该在没有自己的逻辑时，直接复用这几个抽象引擎类，创建它们的实例。

####具体实施
引擎Scene、Layer、Sprite增加create方法，创建继承于抽象类的空子类实例。
引擎Scene
```js
   Static: {
            create: function () {
                var T = YYC.Class(YE.Scene, {
                    Init: function () {
                        this.base();
                    },
                    Public: {
                    }
                });

                return new T();
            }
        }
```
引擎Layer
```js
        Static: {
            create: function (id, zIndex, position) {
                if (arguments.length === 3) {
                    var T = YYC.Class(YE.Layer, {
                        Init: function (id, zIndex, position) {
                            this.base(id, zIndex, position);
                        }
                    });
                    return new T(id, zIndex, position);
                }
                else {
                    var T = YYC.Class(YE.Layer, {
                        Init: function () {
                            this.base();
                        }
                    });
                    return new T();
                }
            }
        }
```
引擎Sprite
```js
     Static: {
            create: function (bitmap) {
                var T = YYC.Class(YE.Sprite, {
                    Init: function (bitmap) {
                        this.base(bitmap);
                    },
                    Public: {
                    }
                });

                return new T(bitmap);
            }
        }
```
如果用户想要创建一个没有用户逻辑的精灵类，可以直接创建引擎Sprite的实例：
```js
var sprite = YE.Sprite.create(bitmap);
//可以直接使用引擎Sprite自带的方法
sprite.draw(context);
```

###将引擎类闭包中需要用于单元测试的内部成员设为引擎类的静态成员

####当前设计
现在常量、枚举值等是作为引擎类闭包的内部成员：
如引擎Director
```js
(function () {
	//内部变量
    var _instance = null;
	//内部枚举值
    var GameState = {
        NORMAL: 0,
        STOP: 1
    };
    //内部常量
    var STARTING_FPS = 60;

    namespace("YE").Director = YYC.Class({
```


####分析问题
单元测试需要操作闭包的内部成员，但是现在不能直接访问到它们，只能绕个弯，在引擎类中增加操作内部成员的测试方法，然后在单元测试中通过这些方法来操作闭包内部成员：
如引擎Director
```js
        Static: {
…
			//获得闭包内部枚举值GameState
            forTest_getGameState: function () {
                return GameState
            }
```
引擎DirectorSpec单元测试
```js
        it("设置游戏状态为STOP", function () {
            director.stop();
			
			//调用forTest_getGameStatus方法获得内部枚举值GameState
            expect(director. ye_gameState).toEqual(YE.Director.forTest_getGameStatus().STOP);
        });
```
在产品代码中增加了测试代码，这是个坏味道，应该只有测试代码知道产品代码，而产品代码不知道测试代码。
因此，将引擎类闭包中需要用于单元测试的内部成员设为引擎类的静态成员。
另外，因为静态成员不会被子类继承和覆盖，所以静态私有和保护成员不需要加上引擎专有前缀“ye_”。


####具体实施
将引擎类闭包中需要用于单元测试的内部成员设为引擎类的静态成员。

引擎Director将_instance、STARTING_FPS和GameState设为静态变量：
```js
(function () {
    namespace("YE").Director = YYC.Class({
        …
        Private:{
            …
            ye_updateFps: function (time) {
            …
                //访问静态成员
                this.ye_fps = YE.Director.STARTING_FPS;
                …
            },
            …
        },
    …
    Static: {
        _instance: null,
            STARTING_FPS: 60,
            GameState: {
            NORMAL: 0,
                STOP: 1
        },
    
        getInstance: function () {
            //静态方法中可通过this直接访问静态成员
            if (this._instance === null) {
                this._instance = new this();
            }
            return this._instance;
        }
```
引擎Layer将画布状态枚举值State设为静态变量
```js
       Static: {
            State: {
                NORMAL: 0,
                CHANGE: 1
            },
            ...
```



<a name="model"></a>
#本文最终领域模型
![](http://images.cnitblog.com/blog/419321/201412/170826395627334.jpg)
此处省略了炸弹人中与引擎类无关的类。



<a name="module"></a>
#高层划分
##包图
划分的包与文件结构对应：
![](http://images.cnitblog.com/blog/419321/201412/170826531568686.jpg) 
##对应的领域模型
- 核心包
放置引擎的核心类。
    - Main
    - Director
    - Scene
    - Layer
    - Sprite
 - 算法包
放置通用的算法类。
    - AStar
    - collision
 - 动画包
放置游戏动画的相关类。
    - AnimationFrame
    - Animation
    - Animate
    - Frame
 - 加载包
负责游戏资源的加载和管理。
    - ImgLoader
 - 数据结构包
放置引擎的基础结构类。
    - Collection
    - Hash
    - Bitmap
    - Geometry
 - 通用工具包
放置引擎通用的方法类。
    - Tool
 - 事件管理包
负责事件的管理。
    - Event
    - EventManager
 - 内部库包
放置引擎引入的库。
    - jsExtend





<a name="summary"></a>
#总结
经过第二次迭代，基本消除了引擎包含的用户逻辑，从而能够在其它游戏中使用该引擎了。
不过这只是刚开始而已，引擎还有很多待重构点，引擎的设计和功能也很不完善，相关的配套工具也没有建立，还需要应用到实际的游戏开发中，不断地修改引擎，加深对引擎的理解。



<a name="code"></a>
#本文源码下载
[GitHub](https://github.com/yyc-git-show/extractEngine_code/tree/master/4)

<a name="reference"></a>
#参考资料
[炸弹人游戏系列](http://www.cnblogs.com/chaogex/tag/%E7%82%B8%E5%BC%B9%E4%BA%BA%E6%B8%B8%E6%88%8F/)

#上一篇博文
[提炼游戏引擎系列：第二次迭代（上）](http://www.cnblogs.com/chaogex/p/4164074.html)]]></description></item><item><title>提炼游戏引擎系列：第二次迭代（上）</title><link>http://www.cnblogs.com/chaogex/archive/2014/12/15/4164074.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Mon, 15 Dec 2014 00:15:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/12/15/4164074.html</guid><description><![CDATA[#前言
上文完成了引擎提炼的第一次迭代，搭建了引擎的整体框架，本文会进行引擎提炼的第二次迭代，进一步提高引擎的通用性，完善引擎框架。

由于第二次迭代内容过多，因此分为上、下两篇博文，本文为上篇。

##本文目的
1、提高引擎的通用性，完善引擎框架。
2、对应修改炸弹人游戏。



##本文主要内容
<ul>
    <li><a href="#Main">修改Main</a></li>
    <li><a href="#Director">修改Director</a></li>
    <li><a href="#Scene">修改Scene</a></li>
    <li><a href="#Layer">修改Layer</a></li>
    <li><a href="#Sprite">修改Sprite</a></li>
    <li><a href="#code">本文源码下载</a></li>
    <li><a href="#reference">参考资料</a></li>
</ul>

##第一次迭代后的引擎领域模型
![](http://images.cnitblog.com/blog/419321/201412/142146535098499.jpg)


##开发策略
本文会对引擎领域模型从左到右一一进行分析， 二次提炼和重构引擎类。

###本文迭代步骤
![](http://images.cnitblog.com/blog/419321/201412/142148095095584.jpg)



###迭代步骤说明

 - 确定要重构的引擎类

按照第一次迭代提出的引擎领域模型，从左往右一一分析，判断是否需要重构。

 - 发现问题

从是否包含用户逻辑、是否违反引擎设计原则、是否可从炸弹人类中提炼更多的通用模式等方面来审视引擎类，如果存在问题则给出引擎类与问题相关的当前设计。

 - 分析问题

分析当前设计，指出其中存在的问题，给出问题的解决方案。

 - 具体实施

按照解决方案修改当前设计。

 - 通过游戏的运行测试
 - 修改并通过引擎的单元测试

通过游戏运行测试和引擎单元测试后，继续分析该引擎类，发现并解决下一个问题。

 - 完成本次迭代

解决了引擎类所有的问题后，就可以确定下一个要重构的引擎类，进入新一轮迭代。

##不讨论测试
因为测试并不是本系列的主题，所以本系列不会讨论专门测试的过程，“本文源码下载”中也没有单元测试代码。
您可以在最新的引擎版本中找到引擎完整的单元测试代码： [YEngine2D](https://github.com/yyc-git/YEngine2D)



<a name="Main"></a>
#修改Main
##改为继承重写
上文对用户使用引擎的方式进行了思考，给出了“引擎Main、Director采用实例重写的方式”的设计。
但是现在重新思考后，发现Main采用实例重写的方式并不合适。

###当前设计
领域模型 
![](http://images.cnitblog.com/blog/419321/201412/142148366034963.jpg)




引擎Main
```js
(function () {
    var _instance = null;

    namespace("YE").Main = YYC.Class({
        Init: function () {
            this._imgLoader = new YE.ImgLoader();
        },
        Private: {
         _imgLoader: null,

            _prepare: function () {
                this.loadResource();

                this._imgLoader.onloading = this.onloading;
                this._imgLoader.onload = this.onload;

                this._imgLoader.onload_game = function () {
                    var director = YE.Director.getInstance();

                    director.init();
                    director.start();
                }
            }
        },
        Public: {
            init: function () {
                this._prepare();
                this._imgLoader.done();
            },
            getImg: function (id) {
                return this._imgLoader.get(id);
            },
            load: function (images) {
                this._imgLoader.load(images);
            },

            //* 钩子

            loadResource: function () {
            },
            onload: function () {
            },
            onloading: function (currentLoad, imgCount) {
            }
        },
        Static: {
            getInstance: function () {
                if (_instance === null) {
                    _instance = new this();
                }
                return _instance;
            }
        }
    });
}());
``` 
炸弹人Main
```js
(function(){
    //获得引擎Main实例
    var main = YE.Main.getInstance();

    var _getImg = function () {
        …
    };

    var _addImg = function (urls, imgs) {
        …
    };

    var _hideBar = function () {
        …
    };
    //重写引擎Main实例的钩子

    main.loadResource = function () {
        this.load(_getImg());
    };
    main.onloading = function (currentLoad, imgCount) {
        $("#progressBar_img_show").progressBar(parseInt(currentLoad * 100 / imgCount, 10));     //调用进度条插件
    };
    main.onload = function () {
        _hideBar();
    };
}());
```
其它炸弹人类通过调用引擎Main的getImg方法来获得加载的图片对象。
```js
var img = YE.Main.getInstance().getImg(imgId);	//获得id为imgID的图片对象
```
页面调用引擎Main的init方法进入游戏
```js
<script type="text/javascript">
    (function () {
        YE.Main.getInstance().init();
    })();
</script>
```

###分析问题
因为炸弹人Main与引擎Main都属于“入口”概念，负责资源加载的管理，所以炸弹人Main与引擎Main应该为继承关系，引擎Main需要改造为可被继承的类，炸弹人Main也要改造为继于引擎Main。


###具体实施
引擎Main应该为抽象类，不再为单例：

引擎Main
```js
(function () {
namespace("YE").Main = YYC.AClass({
…
    });
}());
```



炸弹人Main改为单例并继承引擎Main，提供getImg方法返回图片对象，供其它用户类调用。
炸弹人Main
```js
(function () {
    var Main  = YYC.Class(YE.Main, {
        Private:{
            _getImg: function () {
                …
            },

            _addImg: function (urls, imgs) {
                …
            },

            _hideBar: function () {
                …
            }
        },
        Public:{
            //返回对应id的图片对象
            getImg:function(id){
                return this.base(id);
            },

            loadResource: function () {
                this.load(_getImg());
            },
            onloading: function (currentLoad, imgCount) {
                $("#progressBar_img_show").progressBar(parseInt(currentLoad * 100 / imgCount, 10));
            },
            onload: function () {
                this._hideBar();
            }
        },
        Static: {
            getInstance: function () {
                if (_instance === null) {
                    _instance = new this();
                }
                return _instance;
            }
        }

    });

    window.Main = Main ;
}());
```
其它炸弹人类改为调用炸弹人Main的getImg方法来获得图片数据。
```js
var img = Main.getInstance().getImg(imgId); 
```


页面改为调用炸弹人Main的init方法
```js
<script type="text/javascript">
    (function () {
       Main.getInstance().init();
    })();
</script>
```
####引擎Main不应该封装ImgLoader
进行上面的修改后，运行测试时会报错，错误信息为炸弹人Main在重写的onload方法中调用的“this._hideBar”为undefined。
造成这个错误的原因是在第一次迭代的设计中，引擎Main封装了引擎ImgLoader，将它的onload与ImgLoader的onload绑定在了一起，导致执行炸弹人Main的onload时，this指向了引擎ImgLoader实例imgLoader，而不是指向炸弹人Main。
引擎Main
```js
            _prepare: function () {
…
			    //绑定了引擎Main和引擎ImgLoader的钩子
                this._imgLoader.onloading = this.onloading;
                this._imgLoader.onload = this.onload;
…
            }
        },
        Public: {
            init: function () {
                this._prepare();
…
            },
            getImg: function (id) {
                return this._imgLoader.get(id);
            },
```


引擎Main提供了getImg方法来获得引擎ImgLoader实例imgLoader保存的图片对象。
引擎Main改为继承重写后，由于其他炸弹人类不能直接访问到引擎Main的getImg方法，所以炸弹人必须增加getImg方法，对其它炸弹人类暴露引擎Main的getImg方法。
这样的设计是不合理的，引擎Main的getImg方法并不是设计为被用户重写的方法，而且炸弹人Main也不需要知道引擎Main的getImg方法的实现，这增加了用户的负担，违反了引擎设计原则“尽量减少用户负担”。



因此，引擎Main不再封装imgLoader，而是将其暴露给炸弹人Main，再由它暴露给其它炸弹人类。

具体来说就是，引擎Main删除getImg、load方法，将imgLoader属性设为公有属性；炸弹人Main将imgLoader设为全局属性，直接重写imgLoader的onload、onloading钩子，并删除getImg方法。。
这样其它炸弹人类可以直接访问引擎Main的imgLoader属性，调用它的get方法来获得图片数据

由于炸弹人没有要插入到引擎Main的用户逻辑，因此引擎Main删除onload、onloading钩子。

修改后相关代码
引擎Main
```js
        Private: {
			//删除了onload和onloading钩子，不再绑定引擎Main和引擎ImgLoader的钩子了
            _prepare: function () {
…
            }
        },
        Public: {
    		//imgLoader作为公有属性
             imgLoader: null,
```


炸弹人Main
```js
            loadResource: function () {
				//获得引擎Main的imgloader
                var loader = this.imgLoader,
                    self = this;

				//重写imgLoader的钩子
                loader.load(this._getImg());

                loader.onloading = function (currentLoad, imgCount) {
                    …
                };
                loader.onload = function (imgCount) {
…
                };
				
				//imgLoader设为全局属性，供其它炸弹人类操作
                window.imgLoader = this.imgLoader;
            }
```
其它炸弹人类通过window.imgLoader.get方法获得图片数据



###重构后的领域模型
![](http://images.cnitblog.com/blog/419321/201412/142158596347767.jpg)



<a name="Director"></a>
#修改Director
##炸弹人Game的名字与其职责不符
引擎Director暂时找不出问题，因此来看下与它相关的炸弹人Game。
###当前设计
现在炸弹人Game实例重写了引擎Director。
引擎Scene不能被重写，只能提供API供炸弹人Game和引擎Director调用。


**重构前领域模型**
![](http://images.cnitblog.com/blog/419321/201412/142159434937301.jpg)


炸弹人Game
```js
(function () {
    var director = YE.Director.getInstance();

    var Game = YYC.Class({
…
        Public: {
      
       init: function () {
                 //初始化游戏全局状态
                window.gameState = window.bomberConfig.game.state.NORMAL;


                window.subject = new YYC.Pattern.Subject();

                this.sleep = 1000 / director.getFps();

                //初始化游戏场景

                this._createScene();
                this._addElements();
                this._initLayer();
                this._initEvent();

                window.subject.subscribe(this.scene.getLayer("mapLayer"), this.scene.getLayer("mapLayer").changeSpriteImg);
            },
			//管理游戏状态
            judgeGameState: function () {
   …
            }
        }
    });

    var game = new Game();

    director.init = function () {
        game.init();

        //设置场景
        this.setScene(game.scene);
    };
    director.onStartLoop = function () {
        game.judgeGameState();
    };
}());
```
引擎Scene
```js
//引擎Scene为普通的类，向炸弹人类和引擎类提供API
namespace("YE").Scene = YYC.Class(YE.Hash, {
…
```

###分析问题
炸弹人Game现在只负责初始化游戏场景和管理游戏状态的逻辑，该逻辑属于场景的范围，不属于统一调度的范围，因此Game应该改造为炸弹人场景类，与引擎Scene对应，而不是与引擎Director对应。
考虑到炸弹人场景类与引擎Scene同属一个概念，因此炸弹人场景类应该使用继承重写的方式来使用引擎Scene。
由于引擎Director依赖引擎Scene，而引擎Scene不依赖引擎Director，所以炸弹人场景类也不应该再依赖引擎Director。

因此，应该进行下面的重构：
1、改造引擎Scene类为可被继承重写的类。
2、将炸弹人Game改造为炸弹人场景类Scene，继承重写引擎Scene。
3、引擎Director应该改造为一个封闭的单例类，用户不能重写，向引擎类和用户类提供主循环和场景操作相关的API。将它的钩子方法移到引擎Scene类，炸弹人Game对引擎Director钩子方法的重写变为对引擎Scene钩子方法的重写，对应修改钩子方法的调用机制。


###具体实施
按照下面的步骤重构：
1、改造引擎Scene为可被继承的类，将引擎Director的钩子移到其中；
2、将炸弹人Game改造为场景类Scene，继承重写引擎Scene；
3、改造引擎Director，修改钩子方法的调用机制；
4、重构相关的引擎类和炸弹人类。






####改造引擎Scene类为可被继承的类
引擎Scene改为抽象类，将引擎Director的init、onStartLoop、onEndLoop钩子方法移到其中。

引擎Scene
```js
(function () {
    namespace("YE").Scene = YYC.AClass({
…
        Public: {
…
                init: function () {
                },
                onStartLoop: function () {
                },
                onEndLoop: function () {
                }
        }
   
    });
}());
```
引擎Director删除钩子方法


####将炸弹人Game改造为场景类Scene，继承重写引擎Scene
Game进行下面的修改：
（1）炸弹人Game重命名为Scene。
（2）继承引擎Scene，重写钩子方法init和onStartLoop。
（3）删除scene属性，将调用scene属性的成员改为调用自身的成员（“self/this.scene.xxx”改为“self/this.xxx”）。
（4）不再创建scene实例了，对应修改_createScene方法，删除其中的“创建scene”逻辑，保留“加入层”逻辑，将其重命名为_addLayer。


炸弹人Scene
```js
 var Scene = YYC.Class(YE.Scene, {
    Private: {
        _sleep: 0,

        _addLayer: function () {
            this.addLayer("mapLayer", layerFactory.createMap());
            this.addLayer("enemyLayer", layerFactory.createEnemy(this._sleep));
            this.addLayer("playerLayer", layerFactory.createPlayer(this._sleep));
            this.addLayer("bombLayer", layerFactory.createBomb());
            this.addLayer("fireLayer", layerFactory.createFire());
        },
        _addElements: function () {
            var mapLayerElements = this._createMapLayerElement(),
                playerLayerElements = this._createPlayerLayerElement(),
                enemyLayerElements = this._createEnemyLayerElement();

            this.addSprites("mapLayer", mapLayerElements);
            this.addSprites("playerLayer", playerLayerElements);
            this.addSprites("enemyLayer", enemyLayerElements);
        },
        _createMapLayerElement: function () {
            …
        },
        _getMapImg: function (i, j, mapData) {
            …
        },
        _createPlayerLayerElement: function () {
            …
        },
        _createEnemyLayerElement: function () {
            ….
        },
        _initLayer: function () {
            this.initLayer();
        },
        _initEvent: function () {
            …
        },
        _judgeGameState: function () {
            …
        },
        _gameOver: function () {
            …
        },
        _gameWin: function () {
…
    }
},
    Public: {
        //重写引擎Scene的init钩子
        init: function(){
            window.gameState = window.bomberConfig.game.state.NORMAL;
    
            window.subject = new YYC.Pattern.Subject();
    
            this.sleep = 1000 / director.getFps();
    
            this._addLayer();
            this._addElements();
            this._initLayer();
            this._initEvent();
    
            window.subject.subscribe(this.getLayer("mapLayer"), this.getLayer("mapLayer").changeSpriteImg);
        },
        //重写引擎Scene的onStartLoop钩子
        onStartLoop: function(){
            this._judgeGameState();
        }
    }
});
```




####改造引擎Director类
修改了引擎Director和引擎Scene的钩子方法后，需要对应修改这些钩子方法的调用机制。
**当前设计**
在修改前先来看下引擎Main、Director、Scene以及炸弹人Game之间关于场景的交互机制：
![](http://images.cnitblog.com/blog/419321/201412/142234363214372.jpg)
 

完成加载图片后会触发引擎ImgLoader的onload_game钩子，该钩子被引擎Main重写，触发引擎Director的init钩子，执行炸弹人Game插入的初始化场景的逻辑，：

引擎Main
```js
            _prepare: function () {
…

				//加载图片完成后，触发引擎ImgLoader的onload_game钩子
                this._imgLoader.onload_game = function () {
                    var director = YE.Director.getInstance();
					//触发init钩子
		            director.init();
					director.start();
                }
            }
…
```
炸弹人Game
```js
_createScene: function () {
    this.scene = new YE.Scene();
…
},
…
init: function () {
…
	this. _createScene();
…
}

var director = YE.Director.getInstance();
…
//重写引擎Director的init钩子
director.init = function () {
    game.init();

    //调用引擎Director的setScene方法，设置当前场景
    this.setScene(game.scene);
};
```
然后onload_game会调用引擎Director的start方法，启动主循环，触发引擎Director的钩子方法onStartLoop和onEndLoop，执行炸弹人Game重写插入的场景逻辑：
引擎Main
```js
            _prepare: function () {
…

				//加载图片完成后，触发引擎ImgLoader的onload_game钩子
                this._imgLoader.onload_game = function () {
                    var director = YE.Director.getInstance();
					director.init();
					//调用start方法
					director.start();
                }
            }
```
炸弹人Game
```js
    var director = YE.Director.getInstance();
…
 	//重写引擎Director的onStartLoop钩子
    director.onStartLoop = function () {
      game.judgeGameState();
    };
```

引擎Director
```js
start:function(){
…
    //启动主循环
    window.requestNextAnimationFrame(function (time) {
        self._run(time);
    });
…
},
…
_run: function (time) {
    var self = this;
    //主循环逻辑在_loopBody方法中
    this._loopBody(time);

    if (this._gameState === GameState.STOP) {
        return;
    }

    window.requestNextAnimationFrame(function (time) {
        self._run(time);
    });
},
_loopBody: function (time) {
…
    //触发自己的onStartLoop和onEndLoop钩子
    this.onStartLoop();
…

    this.onEndLoop();
},
```


**修改后的设计**
进行下面四个修改：
（1）onload_game不再调用引擎Director的init方法。
（2）onload_game会传入引擎Main创建的炸弹人Scene实例（这只是临时解决方案，这样的设计导致了引擎Main依赖炸弹人Scene，违反了引擎设计原则！后面会进行重构）到引擎Director的start方法中。
（3）引擎Director的start方法会触发炸弹人Scene实例的init钩子方法，并设置该实例为当前场景。
（4）引擎Director在主循环中改为触发当前场景的onStartLoop和onEndLoop钩子方法。

修改后的场景的交互机制序列图
![](http://images.cnitblog.com/blog/419321/201412/142234576814330.jpg)




引擎Main
```js
            _prepare: function () {
…
                this. _imgLoader.onload_game = function () {
                    var director = YE.Director.getInstance();	
                    //传入创建的炸弹人场景实例
                    director.start(new Scene());	
                };
            }
```
引擎Director 
```js
            start: function (scene) {
                var self = this;

				//触发场景的init钩子
                scene.init();
				//设置为当前场景
                this.setScene(scene);
…
            },
```
引擎Director 
```js
            _loopBody: function (time) {
…
                this._scene.onStartLoop();
…
                this._scene.onEndLoop();
            },
```


###重构相关的引擎类和炸弹人类

####引擎Director类的start方法重命名为runWithScene

由于start方法传入了炸弹人Scene的实例，所以将该方法重命名为runWithScene更合适：
引擎Director
```js
runWithScene:function(scene){
…
}
```
引擎Main
```js
            _prepare: function () {
…
                this._imgLoader.onload_game = function () {
                    var director = YE.Director.getInstance();

					//改为调用引擎Director的runWithScene方法
                    director.runWithScene(new Scene());
                };
            }
```


####解除引擎Main对炸弹人Scene的依赖
现在引擎Main创建了炸弹人Scene的实例：
引擎Main
```js
            _prepare: function () {
…

                this. _imgLoader.onload_game = function () {
                    var director = YE.Director.getInstance();	

					//创建并注入炸弹人Scene实例
                    director.runWithScene (new Scene());	
                };
            }
```
这导致了引擎依赖用户，违反了引擎设计原则。
因为引擎ImgLoader的onload_game与onload钩子执行时间相同，所以可以将onload_game中的逻辑移到炸弹人Main重写ImgLoader的onload钩子中，由炸弹人Main创建炸弹人Scene实例，解除了引擎Main对炸弹人Scene的依赖：
炸弹人Main
```js
                loadResource: function () {
…
                    loader.onload = function (imgCount) {
…    
                        YE.Director.getInstanc.runWithScene(new Scene());
                    };
…
                }
```

####删除引擎ImgLoader的onload_game钩子
ImgLoader的onload_game钩子和onload钩子重复了，这是第一次迭代提出的临时解决方案。
现在onload_game钩子已经没有用了，因此将其删除。



####引擎类继承重写的钩子方法都设成虚方法
继承重写的钩子方法是设计为被用户继承重写的，属于多态，应该将其设为虚方法。
对于实例重写的钩子方法，用户只是重写实例的钩子方法，并没有继承引擎类，不属于多态，不设为虚方法。

又由于用户不是必须要重写钩子方法，因此钩子方法不应该设为抽象方法。

引擎Main
```js
         Virtual:{
                loadResource: function () {
                }
            }
```
引擎Scene
```js
            Virtual: {
                init: function () {
                },
                onStartLoop: function () {
                },
                onEndLoop: function () {
                }
            }
``` 


####游戏结束时引擎要停止所有定时器
目前引擎Director只有退出主循环的机制：
引擎Director
```js
            _run: function (time) {
                var self = this;

                this._loopBody(time);
				//如果游戏状态为STOP，则退出主循环
                if (this._gameState === YE.Director.GameState.STOP) {
                    return;
                }

                window.requestNextAnimationFrame(function (time) {
                    self._run(time);
                });
            },
…
            stop: function () {
                this._gameStatus = GameStatus.STOP;
            }
```

用户可能会在游戏中调用setTimeout、setInterval方法设置定时器，所以引擎需要在游戏结束时停止这些定时器。
因此，引擎Director的stop方法增加停止所有定时器的逻辑：
引擎Director
```js
            stop: function () {
…
                YE.Tool.async.clearAllTimer();
            }
```
引擎Tool增加clearAllTimer方法，使用暴力清除法停止所有的定时器：
引擎Tool
```js
namespace("YE.Tool").async = {
        /**
         * 清空序号在1-500范围中的定时器
         */
        clearAllTimer: function () {
            var i = 0,
                num = 0,
                timerNum = 500, //最大定时器个数
                firstIndex = 0;

            firstIndex = 1;
            num = firstIndex + timerNum;    //循环次数

            for (i = firstIndex; i < num; i++) {
                window.clearTimeout(i);
            }
            for (i = firstIndex; i < num; i++) {
                window.clearInterval(i);
            }
        }
    }
```
**兼容IE**
clearAllTimer方法在IE浏览器中有问题。虽然定时器序号在所有浏览器中都是每次只加1，但是在IE浏览器中，每次刷新浏览器后定时器起始序号会叠加，导致IE中起始序号可能很大（而在Chrome和Firefox中定时器序号的起始值始终为1），可能超出定时器的清理范围。
因此需要用户使用定时器时要保存任意一个定时器的序号到引擎中，并将clearAllTimer方法改为清空该序号前后一定范围内的定时器。

修改后代码
引擎Tool
```js
      /**
         * 清空序号在index前后timerNum范围中的定时器
         * @param index 定时器序号
         */
        clearAllTimer: function (index) {
            var i = 0,
                num = 0,
                timerNum = 250, 
                firstIndex = 0;

            //获得最小的定时器序号
            firstIndex = (index - timerNum >= 1) ? (index - timerNum) : 1;
			//循环次数
            num = firstIndex + timerNum * 2;    

            for (i = firstIndex; i < num; i++) {
                window.clearTimeout(i);
            }
            for (i = firstIndex; i < num; i++) {
                window.clearInterval(i);
            }
	}
```
引擎Director增加保存定时器序号的_timeIndex属性，在stop方法中将_timeIndex传入clearAllTimer，并增加设置定时器序号的方法setTimerIndex：
引擎Director
```js
		    _timerIndex: 0,
…
            stop: function () {
…
                YE.Tool.async.clearAllTimer(this._timerIndex);
            },
            setTimerIndex: function (index) {
                this._timerIndex = index;
            }
```

对应修改炸弹人源码，调用引擎Director的setTimerIndex方法保存任意一个定时器的序号到引擎中：
炸弹人BombLayer
```js
            explode: function (bomb) {
…

                index = setTimeout(function () {
…
                }, 300);

				//保存定时器序号
                YE.Director.getInstance().setTimerIndex(index);
            },
```


###重构后的领域模型
![](http://images.cnitblog.com/blog/419321/201412/142214089936316.jpg)



<a name="Scene"></a>
#修改Scene
##删除change方法
###当前设计
主循环调用了引擎Scene的change方法，它又调用了场景内层的change方法。

引擎Scene
```js
            change: function () {
                this.__iterator("change");
            },
            run: function () {
                this.__iterator("run");
            },
```
引擎Director
```js
        _loopBody: function (time) {
…
                this._scene.run();
				this._scene.change();
…
            },
```

###分析问题
引擎Scene的change方法没有自己的逻辑。因此删除change方法，将其合并到引擎Scene的主循环方法run中。

###具体实施
引擎Scene
```js
            run: function () {
                this.__iterator("run");
                this.__iterator("change");
            },
```
引擎Director
```js
        _loopBody: function (time) {
…
				//不再调用场景的change方法了

                this._scene.run();
…
            },
```



##不应该关联引擎Sprite
###当前设计

现在引擎Scene提供了addSprites方法，负责将精灵加入到层中：

 

引擎Scene
```js
            addSprites: function (name, elements) {
                this.getLayer(name).addChilds(elements);
            },
```

炸弹人Scene
```js
            _addElements: function () {
                var mapLayerElements = this._createMapLayerElement(),
                    playerLayerElements = this._createPlayerLayerElement(),
                    enemyLayerElements = this._createEnemyLayerElement();

                this.addSprites("mapLayer", mapLayerElements);
                this.addSprites("playerLayer", playerLayerElements);
                this.addSprites("enemyLayer", enemyLayerElements);
            },
```

###分析问题
引擎Director、Scene、Layer、Sprite分别对应不同的层面，上层不应该跨层依赖下层（引擎Director是个特例，因为其它引擎类可能需要调用它提供的操作主循环的API，因此它可被下层跨层依赖）：
![](http://images.cnitblog.com/blog/419321/201412/150644022341096.jpg) 

当前设计造成了引擎Scene关联引擎Sprite，应该去掉两者的关联：
![](http://images.cnitblog.com/blog/419321/201412/150649502502485.jpg)



###具体实施
引擎Scene删除addSprites方法。
炸弹人Scene改为先获得layer，然后再调用layer的addChilds方法来实现加入精灵到层中：
炸弹人Scene
```js
            _addLayer: function () {
                this.getLayer("mapLayer").addChilds(this._createMapLayerElement());
                this.getLayer("playerLayer").addChilds(this._createPlayerLayerElement());
                this.getLayer("enemyLayer").addChilds(this._createEnemyLayerElement());            },
```

<a name="Layer"></a>
#修改Layer
##封装画布操作
###当前设计
现在画布的操作由用户负责，用户需要实现setCanvas方法，指定层对应的画布，将画布dom保存到引擎Layer的P_canvas属性中，并设置画布的位置。引擎Layer则直接通过用户设置好的P_canvas属性来操作画布：

引擎Layer
```js
            Abstract: {
				//抽象方法，由用户实现
                setCanvas: function () {
                },
…
```
炸弹人BombLayer
```js
    var BombLayer = YYC.Class(YE.Layer, {
…
            setCanvas: function () {
                this.P_canvas = document.getElementById("bombLayerCanvas");
                var css = {
                    "position": "absolute",
                    "top": bomberConfig.canvas.TOP,
                    "left": bomberConfig.canvas.LEFT,
                    "z-index": 1
                };

                $("#bombLayerCanvas").css(css);
            },
```



引擎Layer还将画布canvas的context属性暴露给了用户：

引擎Layer
```js
            __getContext: function () {
				//获得画布的context，暴露给用户
                this.P_context = this. P_canvas.getContext("2d");
            },
```
炸弹人BombLayer
```js
            draw: function () {
				//炸弹人可直接访问画布的context
                this.iterator("draw", this.P_context);
            },
```





###分析问题
画布操作属于底层逻辑，不应该由用户实现，应该由引擎封装，向用户提供操作画布的API。

因此，进行下面的重构：
（1）引擎Layer封装画布，向用户提供操作画布的API。
（2）引擎Layer封装画布的context属性，向用户提供操作context的API。

###具体实施
按照下面的步骤重构：
1、封装画布
（1）将P_canvas属性改为私有属性。
（2）引擎Layer增加操作画布的API。
（3）修改用户Layer类的setCanvas方法，用户不再直接操作画布，而是通过引擎Layer提供的API来操作画布。
（4）引擎Layer的构造函数增加设置画布的逻辑，这样用户就可以通过“创建用户Layer实例时传入画布参数”来设置画布。
（5）引擎Layer删除setCanvas方法，不再限定用户在setCanvas方法中设置画布。 


2、封装context。
将P_context改为私有属性，并提供getContext方法。

####封装canvas
**1、将保护属性P_canvas改成私有属性__canvas**
引擎Layer
```js
Private:{
    __canvas: null,
…
},
```



**2、增加setCanvasByID、setWidth、setHeight、setZIndex、setPosition方法**

相关代码

引擎Layer
```js
Public:{
    //保存对应id的画布
    setCanvasByID: function (canvasID) {
        this.__canvas = document.getElementById(canvasID);
    },
    //设置画布宽度
    setWidth: function (width) {
        this.__canvas.width = width;
    },
    //设置画布高度
    setHeight: function (height) {
        this.__canvas.height = height;
    },
    //设置画布层级顺序
    setZIndex: function (zIndex) {
        this.__canvas.style.zIndex = zIndex;
    },
    //设置画布坐标
    setPosition: function (x, y) {
        this.__canvas.style.top = x.toString() + "px";
        this.__canvas.style.left = y.toString() + "px";
    },
```   

引擎Layer的setPosition方法对top和left值加上了“px”字符串，因此需要对应修改炸弹人Config设置的画布坐标：
炸弹人Config
修改前
```js
    canvas: {
…
        TOP: "0px",
        LEFT: "0px"
    },
```
修改后
```js
    canvas: {
…
        TOP: 0,
        LEFT: 0
    },
```




**3、修改用户Layer类的setCanvas方法，用户不再直接操作画布，而是通过引擎Layer提供的API来操作画布**
相关代码
炸弹人BombLayer
```js
            setCanvas: function () {
                this.setCanvasByID("bombLayerCanvas");
                this.setPosition(bomberConfig.canvas.TOP, bomberConfig.canvas.LEFT);
                this.setZIndex(1);
            },
```
炸弹人EnemyLayer
```js
            setCanvas: function () {
                this.setCanvasByID("enemyLayerCanvas");
                this.setAnchor(bomberConfig.canvas.TOP, bomberConfig.canvas.LEFT);
                this.setZIndex(3);
            },
```
炸弹人FireLayer
```js
            setCanvas: function () {
                this.setCanvasByID("fireLayerCanvas");
                this.setAnchor(bomberConfig.canvas.TOP, bomberConfig.canvas.LEFT);
                this.setZIndex(2);
            },
```
炸弹人MapLayer
```js
            setCanvas: function () {
…

                this.setCanvasByID("mapLayerCanvas");
                this.setAnchor(bomberConfig.canvas.TOP, bomberConfig.canvas.LEFT);
                this.setZIndex(0);
            },
```
炸弹人PlayerLayer
```js
            setCanvas: function () {
                this.setCanvasByID("playerLayerCanvas");
                this.setAnchor(bomberConfig.canvas.TOP, bomberConfig.canvas.LEFT);
                this.setZIndex(3);
            },
```


**4、引擎Layer的构造函数增加设置画布的逻辑**

在构造函数中判断是否传入了画布参数，如果传入则调用操作画布API设置画布：
引擎Layer
```js
        Init: function (id, zIndex, position) {
            if (arguments.length === 3) {
                this.setCanvasByID(id);
                this.setZIndex(zIndex);
                this.setPosition (position.x, position.y);
            }
        },
```

这样用户就有两种方式设置画布了：
（1）创建用户Layer实例时传入画布参数。
（2）在setCanvas方法中调用画布操作API。



**5、引擎Layer删除setCanvas方法，不再限定用户必须在setCanvas方法中设置画布**
因为用户可以在创建用户Layer实例时设置画布，所以“强迫用户在setCanvas抽象方法中设置画布”的设计就不合适了。
因此，引擎Layer删除setCanvas方法，对应修改引擎Scene，初始化层时不再调用layer的setCanvas方法了：
引擎Scene
```js
            initLayer: function () {
                //this.__iterator("setCanvas");
…
            }
```

 - 用户需要什么时候设置画布？

因为引擎Layer初始化时需要获得画布的context属性，所以用户需要在这之前设置画布：
引擎Layer
```js
                init: function () {
                    this.__getContext();
                },
```
因此，用户除了可在创建用户Layer实例时设置画布，还可以在引擎Layer初始化之前设置画布。

如炸弹人BombLayer可重写引擎Layer的init方法，在执行引擎Layer初始化前设置画布：
```js
            ___setCanvas: function () {
                this.setCanvasByID("bombLayerCanvas");
                this.setPosition(bomberConfig.canvas.TOP, bomberConfig.canvas.LEFT);
                this.setZIndex(1);
            },
…
            init: function (layers) {
				this. ___setCanvas();	//在执行引擎初始化逻辑前设置画布
…
				this.base();	//执行父类引擎Layer的init方法
            },
```


####封装context
将P_context改为私有属性__context，并提供getContext方法
引擎Layer
```js
            __context: null,
…
            getContext: function () {
                return this.__context;
            },
```

对应修改用户Layer类，使用getContext来获得__context
如炸弹人BombLayer
```js
            draw: function () {
                this.iterator("draw", this.getContext());
            },
```



##引擎执行层的初始化
###当前设计
引擎Scene提供初始化层的方法initLayer，由炸弹人Scene在场景初始化时调用，执行场景内层的初始化：

引擎Scene
```js
           initLayer: function () {
                this.__iterator("init", this.__getLayers());
            },
```
炸弹人Scene
```js
            init: function () {
 …
                this._initLayer();
…
            },
…
            _initLayer: function () {
…
                this.initLayer();
            },
```

###分析问题
 “执行层的初始化”属于底层逻辑，应该由引擎负责，引擎类Scene应该对用户隐藏initLayer方法。


###具体实施
将引擎Scene的initLayer设为私有方法，并在引擎Scene的init钩子方法中调用：
引擎Scene
```js
            __initLayer: function () {
                this.__iterator("init", this.__getLayers());
            }
…
            init: function () {
                this.__initLayer();
            },
```
不过这样修改后，炸弹人Scene在重写init钩子时就需要先执行引擎Scene的初始化逻辑，再执行自己的用户逻辑，违反了引擎设计原则“尽量减少用户负担”，会在后面进行重构。
炸弹人Scene
```js
            init: function () {
                //执行引擎类初始化逻辑
                this.base();
                
               //用户初始化逻辑 
                …
            }
```








##分离引擎的初始化逻辑与用户的初始化逻辑
###当前设计
现在引擎Scene、引擎Layer、引擎Sprite提供了init钩子方法，负责引擎类的初始化。该方法为虚方法，用户可重写，加入自己的初始化逻辑。

用户代码示例：
炸弹人Scene
```js
              init: function () {
            	//执行引擎类初始化逻辑
                this.base();
            
            	//用户初始化逻辑
                this._sleep = 1000 / director.getFps();
                …
            }
```

炸弹人BombLayer
```js
            init: function (layers) {
				//执行引擎类初始化逻辑
                this.base();

				//用户初始化逻辑
                this.fireLayer = layers.fireLayer;
                …
            }
```

炸弹人MoveSprite
```js
            init: function () {
				//执行引擎类初始化逻辑
                this.base();

				//用户初始化逻辑
                this.P_context.setPlayerState(this.__getCurrentState());
                …
            }
```






###分析问题
用户在加入自己的初始化逻辑时，需要先执行引擎类的初始化逻辑，导致用户不仅需要知道引擎类的初始化逻辑，还需要知道用户初始化逻辑和引擎初始化逻辑的调用顺序，违反了引擎设计原则“尽量减少用户负担”。

因此，引擎Scene、Layer、Sprite类的初始化应该由引擎负责并对用户隐藏，将引擎的初始化逻辑与用户的初始化逻辑分离。




###具体实施
引擎Sprite、Layer、Sprite增加initData钩子方法，用户可重写它来插入自己的初始化逻辑。而引擎的init方法不再作为钩子方法供用户重写，它负责引擎的初始化和调用initData方法执行用户的初始化。

**关于“引擎的init方法中调用initData方法的顺序”的思考**
因为用户依赖于引擎，所以照理说应该先进行引擎类的初始化，然后再调用initData方法进行用户的初始化，这样用户初始化时就可获得引擎类初始化后的状态。

然而对于引擎Layer来说，它的初始化逻辑需要操作画布，需要用户先设置好画布。
用户可以在创建用户Layer实例时设置画布，也可以在重写的initData方法中设置画布。对于引擎来说要做最坏的假设，即假设用户在initData方法中设置画布，这样的话引擎Layer就必须在init方法中先调用initData方法，再进行自己的初始化。

同样，引擎Scene也需要用户先加入层到场景中，然后才能执行自己的场景初始化逻辑。
所以Scene和Layer应该先调用initData钩子方法，然后再执行自己的初始化逻辑。

而引擎Sprite的初始化逻辑与用户没有顺序依赖，因而引擎Sprite可以先进行引擎类的初始化，然后再调用initData进行用户的初始化。

相关代码

引擎Scene
```js
			init: function () {
                //需要用户先加入层到场景中后，才能初始化层
                this.initData();
                
                this.__initLayer();
            },

            //*钩子
            Virtual: {
                initData: function(){
                },
```
引擎Layer
```js
            init: function (layers) {
				//需要用户设置画布后，才能初始化画布
				//这里将layers传入initData中
                this.initData(layers);

                this.__getContext();
				this.__initCanvas();
            },
            Virtual: {
                initData: function (layers) {
                },
```
引擎Sprite
```js
            init: function () {
                //引擎可以先执行自己的初始化逻辑，再执行用户的初始化逻辑
                this.setAnim(this.defaultAnimId);

                this.initData();
            },
…
            Virtual: {
                initData: function () {
                },
```

用户代码示例：
炸弹人Scene
```js
            initData: function () {
                //执行用户初始化逻辑
                …
            }
```
炸弹人BombLayer
```js
            initData: function (layers) {
                //执行用户初始化逻辑
                …
            }
```
炸弹人MoveSprite
```js
            initData: function () {
                //执行用户初始化逻辑
                …
            }
```




##clear方法只负责清除画布
###当前设计

引擎Layer的clear方法会根据参数个数来判断是清除所有的精灵，还是清除指定的精灵：
引擎Layer
```js
                clear: function (sprite) {
                    if (arguments.length === 0) {
						//清除所有层内精灵
                        this.P_iterator("clear", this.__context);
                    }
                    else if (arguments.length === 1) {
						//清除指定的精灵
                        sprite.clear(this.__context);
                    }
                },
```
用户代码示例：
炸弹人BombLayer
```js
            ___removeBomb: function (bomb) {
				//从画布中清除bomb精灵
                this.clear(bomb);	
…
            },
```



###分析问题
引擎Layer的clear方法的判断逻辑是多余的，因为引擎Sprite的clear方法是供用户调用的，如果用户想要清除某个精灵，可以直接调用该精灵的clear方法。
又因为引擎Layer最清楚层内的所有精灵，所以它的clear方法保留“清除层内所有精灵”的逻辑。
###具体实施
引擎Layer的clear方法只负责清除层内所有精灵。

引擎Layer
```js
                clear: function () {
                    this. P_iterator ("clear", this.__context);
                }
```
炸弹人BombLayer
```js
            ___removeBomb: function (bomb) {
				//直接调用bomb精灵的clear方法
                bomb.clear(this.getContext());
…
            },
```

##继续修改引擎Layer和Sprite的clear方法
###当前设计
引擎Layer的clear方法通过调用层内所有精灵的clear方法，达到清空画布的目的：
引擎Layer
```js
                clear: function () {
                    this.iterator("clear", this._context);
                },
```

引擎Sprite的clear方法直接清空画布：
引擎Sprite
```js
                clear: function (context) {
                    //直接清空画布区域
                    context.clearRect(0, 0, YE.Config.canvas.WIDTH, YE.Config.canvas.HEIGHT);
                }
```
炸弹人MapLayer实现了“清空画布”的逻辑：
炸弹人MapLayer
```js
            clear: function () {
                this.P_context.clearRect(0, 0, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
…
            },
```
###分析问题
当前设计有下面几个问题：
（1）引擎Sprite的clear方法应该只负责从画布中清除自己，“清空画布”的逻辑应该由引擎Layer的clear方法负责。
（2）引擎Layer的clear方法应该直接清空画布。
（3）“清空画布”属于底层逻辑，不应该由用户类实现。

###具体实施
引擎Layer的clear方法负责清空画布：
引擎Layer
```js
                clear: function () {
                    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
                },
```
引擎Sprite的clear方法负责从画布中清除自己：
引擎Sprite
```js
                clear: function (context) {
                    context.clearRect(this.x, this.y, this.bitmap.width, this.bitmap.height);
                }
```

因为用户类可能需要知道画布大小，因此引擎Layer增加getCanvasWidth、getCanvasHeight方法：
引擎Layer
```js
                getCanvasWidth: function () {
                    return this._canvas.width;
                },
                getCanvasHeight: function () {
                    return this._canvas.height;
                },
…
                //对应修改clear方法
 				clear: function () {
                    this._context.clearRect(0, 0, this. getCanvasWidth(), this. getCanvasHeight());
                },
```


修改炸弹人MapLayer，直接调用引擎Layer的clear方法清除画布：
炸弹人MapLayer
```js
            clear: function () {
                this.base();
…
            },
```





##封装run方法
###当前设计
引擎类的run方法封装了引擎类在主循环中的逻辑，该方法由上层引擎类在主循环中调用。
（关于引擎run方法的作用，可参考[《炸弹人游戏开发系列（4）》](http://www.cnblogs.com/chaogex/p/3213041.html)的“增加run方法”一节]）


引擎Director
```js
            _loopBody: function (time) {
…
				//调用场景的run方法
                this._scene.run();
…
            },
…
            _run: function (time) {
                var self = this;

                this._loopBody(time);

…

                window.requestNextAnimationFrame(function (time) {
                    self._run(time);
                });
            },
```


引擎Scene
```js
            run: function () {
				//调用场景内层的run方法
                this.__iterator("run");
…
            },
```
现在引擎Layer向用户提供了P_render方法，而它的run方法为抽象方法，由用户实现：
引擎Layer
```js
            P_render: function () {
                if (this.P_isChange()) {
                    this.clear();
                    this.draw();
                    this.setStateNormal();
                }
            }
…
        Abstract: {
…
            run: function () {
            }
```


我们来看下炸弹人Layer类实现的run方法：
炸弹人BombLayer
```js
            run: function () {
                this.P_render();
            }
```
炸弹人FireLayer
```js
            run: function () {
                this.P_render();
            }
```
炸弹人MapLayer
```js
            run: function () {
                if (this.P_isChange()) {
                    this.clear();
                    this.draw();
                }
            }
```
炸弹人CharacterLayer
```js
run: function () {
    this.___setDir();
    this.___move();
    this.___render();
}
…
___render: function () {
    if (this.P_isChange()) {
        this.clear();
        this.___update(this.___deltaTime);
        this.draw();
        this.setStateNormal();
    }
}
```
炸弹人EnemyLayer
```js
            run: function () {
                if (this.collideWithPlayer()) {
                    window.gameState = window.bomberConfig.game.state.OVER;
                    return;
                }

                this.__getPath();

				//调用Character->run
                this.base();
            }
```
炸弹人PlayerLayer
```js
            run: function () {
                if (keyState[YE.Event.KeyCodeMap.SPACE]) {
                    this.createAndAddBomb();
                    keyState[YE.Event.KeyCodeMap.SPACE] = false;
                }

				//调用Character->run
                this.base();
            }
```

###分析问题
引擎Layer应该实现主循环逻辑，并且由于这属于底层逻辑，应该对用户隐藏。
因此，引擎Layer应该实现并对用户隐藏run方法。
下面从三个步骤进行分析：
1、识别出炸弹人Layer类的run方法的通用模式。
2、将其提到引擎Layer的run方法中。
3、在引擎Layer的run方法中调用增加的钩子方法，执行炸弹人Layer类插入的逻辑。

####识别出炸弹人Layer的run方法的通用模式
分析炸弹人Layer类的相关代码，可以看到炸弹人BombLayer、FireLayer的run方法直接调用了引擎Layer的P_render方法；
炸弹人MapLayer的run方法与P_render方法相比，虽然少调用了引擎Layer的setStateNormal方法，但因为引擎Scene的run方法会调用MapLayer的change方法，而它又会调用引擎Layer的setStateNormal方法，所以MapLayer的run方法也等效于调用了P_render方法。
引擎Scene
```js
            run: function () {
                this.__iterator("run");
                this.__iterator("change");
            },
```      
炸弹人MapLayer
```js
            change: function () {
                this.setStateNormal();
            },
```
再来看下CharaterLayer的run方法，它调用了___render方法，该方法与P_render方法相比，多调用了“___update”方法。

而EnemyLayer、PlayerLayer继承CharacterLayer，它们的run方法都调用CharacterLayer的run方法，也就是说都调用了___render方法。

由此可见，炸弹人Layer类的run方法的通用模式是都调用了引擎Layer的P_render方法，只是有些炸弹人Layer类还有自己要插入的逻辑。

####提取通用模式到引擎Layer的run方法中
再来看下引擎Layer的P_render方法是否需要重构：
```js
            P_render: function () {
                if (this.P_isChange()) {
                    this.clear();
                    this.draw();
                    this.setStateNormal();
                }
            }
```
（1）判断是否包含用户逻辑
它调用的都是引擎类Layer的方法，没有包含用户逻辑。
（2）判断是否具有通用性
所有用户Layer类在每次主循环中都要先判断画布的状态，如果状态为CHANGE，表明画布更改过，则先清除画布，然后绘制画布，最后设置画布状态为NORMAL，因此该方法具有通用性。

综上所述，可以将P_render方法直接合并到引擎Layer的run方法中。


####增加onAfterDraw钩子方法
炸弹人CharacterPlayer的run方法调用了自己的“___update”方法，该方法需要在引擎Layer的run方法中执行。
为了能让CharacterPlayer及其子类直接使用引擎Layer的run方法，引擎Layer需要增加onAfterDraw钩子方法，并在run方法中调用该钩子。

###具体实施
将引擎Layer的P_render方法合并到run方法中，增加onAfterDraw钩子方法：
引擎Layer
```js
            run: function () {
                if (this.P_isChange()) {
                    this.clear();
                    this.draw();
					//触发onAfterDraw钩子
                    this.onAfterDraw();
                    this.setStateNormal();
                }
            },
            Virtual: {
…
                onAfterDraw: function () {
                }
            },
```

对应修改炸弹人BombLayer、FireLayer、MapLayer，删除run方法

炸弹人CharacterLayer、EnemyLayer、PlayerLayer由于还有其它的用户逻辑需要在引擎Layer的run方法之前执行，所以暂时保留run方法（后面会重构）：
炸弹人CharacterLayer
```js
                run: function () {
                    this.___setDir();
                    this.___move();
					//调用引擎Layer的run方法
					this.base();
                },
                onAfterDraw: function () {
                    this.___update(this.___deltaTime);
                }
```
炸弹人EnemyLayer
```js
            run: function () {
                if (this.collideWithPlayer()) {
                    window.gameState = window.bomberConfig.game.state.OVER;
                    return;
                }

                this.__getPath();

				//调用Character的run方法
                this.base();
            }
```
炸弹人PlayerLayer
```js
            run: function () {
                if (keyState[YE.Event.KeyCodeMap.SPACE]) {
                    this.createAndAddBomb();
                    keyState[YE.Event.KeyCodeMap.SPACE] = false;
                }

				//调用Character的run方法
                this.base();
            }
```


##增加onStartLoop、onEndLoop钩子
###当前设计
经过上一步的修改后，炸弹人CharacterLayer、EnemyLayer、PlayerLayer仍然要重写引擎Layer的run方法，没有达到“引擎Layer对用户隐藏run方法”的设计目的。

###分析问题
引擎和用户的run方法的逻辑现在混杂到了一起。
在前面的“应该将引擎的初始化逻辑与用户的初始化逻辑分离”重构中，我们已经看到这种设计很不好，应该将引擎逻辑和用户的逻辑分离。

###具体实施
参考引擎Scene，引擎Layer也提出onStartLoop、onEndLoop钩子方法，这两个钩子分别在引擎Layer的run方法执行前、后触发。


引擎Layer
```js
            Virtual:{
…
                onStartLoop: function () {
                },
                onEndLoop: function () {
                }
```
在引擎Scene的run方法中触发引擎Layer的钩子：
引擎Scene
```js
            run: function () {
                this.__iterator("onStartLoop");

                this.__iterator("run");
                this.__iterator("change");

                this.__iterator("onEndLoop");
            },
```

对应修改炸弹人CharacterLayer、EnemyLayer、PlayerLayer，将自己的逻辑放到钩子中，不再重写引擎Layer的run方法：
炸弹人CharacterLayer
```js
                onStartLoop: function () {
                    this.___setDir();
                    this.___move();
                },
```
炸弹人EnemyLayer
```js
            onStartLoop: function () {
                if (this.collideWithPlayer()) {
                    window.gameState = window.bomberConfig.game.state.OVER;
                    return;
                }

                this.__getPath();
				//调用CharacterLayer的onStartLoop
                this.base();
            }
```
炸弹人PlayerLayer
```js
            onStartLoop: function () {
                if (keyState[YE.Event.KeyCodeMap.SPACE]) {
                    this.createAndAddBomb();
                    keyState[YE.Event.KeyCodeMap.SPACE] = false;
                }
				//调用CharacterLayer的onStartLoop
                this.base();
            }
```


##将P_isNorml、P_isChange改成私有方法
###分析问题

经过“封装run方法”的修改后，用户Layer类不会再用到引擎Layer的P_isChange、P_isNorml方法了，因此将其设为私有方法。

###具体实施

引擎Layer
```js
            __isChange: function () {
                return this.__state === State.CHANGE;
            },
            __isNormal: function () {
                return this.__state === State.NORMAL;
            }
```

##提取炸弹人draw方法的通用模式
继续从炸弹人Layer类中提取通用模式。
###当前设计
现在引擎Layer的draw方法为抽象方法，由用户实现：
引擎Layer
```js
        Abstract: {
…
            draw: function () {
            },
```
炸弹人BombLayer、CharacterLayer、FireLayer的draw方法具有共同的模式，都是绘制所有精灵：
```js
            draw: function () {
                this.iterator("draw", this.getContext());
            },
```

###分析问题
可将通用模式提到引擎Layer的draw方法中。
又由于不是所有炸弹人Layer类的绘制逻辑都是“绘制所有精灵”，所以将draw方法设为虚方法，用户可重写该方法实现不同的逻辑。


###具体实施
实现引擎Layer的draw方法，对应删除炸弹人BombLayer、CharacterLayer、FireLayer的draw方法。
引擎Layer
```js
			Virtual:{
…
                draw: function () {
                    this.iterator("draw", this.getContext());
                },
```



##增加钩子方法isChange，change方法不再为抽象方法
###当前设计
现在引擎Layer的change方法为抽象方法，由用户实现，通过调用引擎Layer提供的setStateChange和setStateNormal方法来设置画布状态。

**画布状态的作用**
引擎Layer在主循环中会判断画布状态，如果为CHANGE，则重绘画布，否则不重绘。


引擎Layer
```js
        Abstract: {
            change: function () {
            }
        }
```
用户代码示例：
如炸弹人BombLayer
```js
            change: function () {
                //如果炸弹人放置了炸弹，则设置画布状态为CHANGE，从而在下次主循环时重绘画布，显示炸弹
                if (this.___hasBomb()) {
                    this.setStateChange();
                }
            }
```


###分析问题
其实用户只需要决定下次主循环时是否重绘画布，而不需要知道画布状态。根据引擎设计原则“尽量减少用户负担”，引擎Layer应该对用户隐藏“画布状态”。






###具体实施
引擎Layer增加虚方法isChange，用户可以重写该方法，如果需要重绘则返回true，否则返回false。
引擎Layer的change方法会调用isChange方法，根据返回值判断是调用setStateChange方法，还是调用setStateNormal方法。

因为用户可能需要在isChange方法之外设置画布状态，所以引擎Layer保留setStateNormal、setStateChange方法供用户调用。



引擎Layer
```js
            change: function () {
                if(this.isChange() === true){
                    this.setStateChange();
                }
                else{
                    this.setStateNormal();
                }
            },
            Virtual: {
…
                isChange: function(){
                    return true;
                },
```
炸弹人只需要重写isChange方法
如炸弹人BombLayer
```js
            isChange: function () {
                if (this.___hasBomb()) {
                    return true;
                }
            }
```


##思考

 - 引擎Layer现在没有抽象方法了，但仍然应该为抽象类

如果引擎Layer为类，则用户就不能有继承引擎Layer的抽象子类。

例如：用户可能有多个Layer类，对应多个画布，可能需要从中提出抽象基类，抽象基类也需要继承引擎Layer。如果引擎Layer为类，则提出抽象基类不能继承它。




<a name="Sprite"></a>
#修改Sprite
##引擎执行精灵的初始化
###当前设计
目前由用户负责执行精灵的初始化：
炸弹人Scene
```js
           _createPlayerLayerElement: function () {
                var element = [],
                    player = spriteFactory.createPlayer();
                    
				//执行玩家精灵的初始化
                player.init();
                …
            },
            _createEnemyLayerElement: function () {
                var element = [],
                    enemy = spriteFactory.createEnemy(),
                    enemy2 = spriteFactory.createEnemy2();

				//执行敌人精灵的初始化
                enemy.init();
                enemy2.init();
                …
            },
```

###分析问题
“执行精灵的初始化”属于底层逻辑，应该由引擎负责执行。

**由哪个引擎类负责**
因为引擎Layer负责管理层内精灵，所以应该由它负责。

**在哪里执行精灵的初始化**
有两个选择：
1、在初始化层时执行层中的所有精灵的初始化。
2、在加入精灵到层中时执行精灵的初始化。

因为在初始化层时，不一定加入了精灵到层中，所以应该选择在加入精灵到层中时执行精灵的初始化。



###具体实施
引擎Layer重写引擎Collection的addChilds方法，加入精灵到层中时执行精灵的初始化：
引擎Layer
```js
        namespace("YE").Layer = YYC.AClass(YE.Collection, {
…
            addChilds: function (elements) {
                this.base(elements);

                elements.forEach(function(e){
                    //执行精灵的初始化
                    e.init();	
                });
            },
```

炸弹人Scene不再负责执行精灵的初始化了。



修改后，游戏运行测试会报错。因为在加入地图精灵到层中时，会执行地图精灵的初始化，设置地图精灵的默认动画。然而地图精灵没有动画，其defaultAnimId为undefined，所以执行setAnim方法时会报错。

引擎Sprite
```js
            init: function () {
                    //显示默认动画
                    this.setAnim(this.defaultAnimId);

…
            },
```
为了让游戏运行通过，暂时在引擎Sprite的init方法中加入defaultAnimId的判断：
引擎Sprite
```js
            init: function () {
                //如果有默认动画Id，则显示默认动画
                if (this.defaultAnimId) {
                    this.setAnim(this.defaultAnimId);
                }

…
            },
```
其实可以看到，引擎Sprite的defaultAnimId属性是默认动画的id，属于用户逻辑，后面会进行重构，去除该用户逻辑。




##提取炸弹人中每次主循环持续时间的计算逻辑到引擎Sprite的update方法中
###当前设计
游戏需要计算每次主循环持续时间deltaTime，用于在动画管理中计算当前帧播放的时间，确定是否对当前帧进行切换等操作。
目前由炸弹人实现deltaTime的计算。炸弹人Scene计算deltaTime，然后传入炸弹人Layer，然后再传入炸弹人精灵的update方法（引擎Sprite实现），最后传入引擎Animation的update方法。

炸弹人Scene
```js
initData: function(){
…
    this._sleep = 1000 / director.getFps();	//计算本次主循环持续时间，保存到_sleep属性中
…
},
…
_addLayer: function () {
…
    //deltaTime传入layer
    this.addLayer("enemyLayer", layerFactory.createEnemy(this._sleep));
    this.addLayer("playerLayer", layerFactory.createPlayer(this._sleep));
…
},
```
炸弹人CharacterLayer
```js
Init: function (deltaTime) {
    this.___deltaTime = deltaTime;
},
…
___update: function (deltaTime) {
    //deltaTime传入炸弹人精灵的update方法
    this.iterator("update", deltaTime);
},
…
onAfterDraw: function () {
    this.___update(this.___deltaTime);
}
```
引擎Sprite
```js
update: function (deltaTime) {
    this._updateFrame(deltaTime);
},
…
_updateFrame: function (deltaTime) {
    if (this.currentAnim) {
        //deltaTime传入引擎Animation的update方法
        this.currentAnim.update(deltaTime);
    }
}
```
引擎Animation
```js
            update: function (deltaTime) {
…
                    //根据deltaTime，计算当前帧的已播放时间
                    this._currentFramePlayed += deltaTime;
…
            },
```


###分析问题
1、引擎负责计算帧率fps，所以它知道如何计算deltaTime。
2、deltaTime与主循环密切相关，而主循环是由引擎来负责的。

因此，应该由引擎计算deltaTime。

**由哪个引擎类负责？**
（1）只有引擎Animation需要用到deltaTime，而它又是由引擎Sprite的update方法传入的，引擎Sprite是直接关联方。
（2）引擎Scene和引擎Layer都只是传递deltaTime值，没有自己的逻辑。
（3）计算deltaTime需要获得引擎Director的帧率，引擎Sprite能够访问引擎Director，从而能够计算deltaTime。

因此应该由引擎Sprite负责。


###具体实施
引擎Sprite的update方法负责计算deltaTime：
引擎Sprite
```js
            update: function () {
     			this._updateFrame(1000 / YE.Director.getInstance().getFps());
            },
```
对应修改炸弹人Scene和炸弹人CharacterLayer，不再负责计算和传递deltaTime了。

<a name="code"></a>
#本文源码下载
[GitHub](https://github.com/yyc-git-show/extractEngine_code/tree/master/4)

<a name="reference"></a>
#参考资料
[炸弹人游戏系列](http://www.cnblogs.com/chaogex/tag/%E7%82%B8%E5%BC%B9%E4%BA%BA%E6%B8%B8%E6%88%8F/)

#上一篇博文
[提炼游戏引擎系列：第一次迭代](http://www.cnblogs.com/chaogex/p/4158580.html)

#下一篇博文
[提炼游戏引擎系列：第二次迭代（下）](http://www.cnblogs.com/chaogex/p/4175837.html)]]></description></item><item><title>提炼游戏引擎系列：第一次迭代</title><link>http://www.cnblogs.com/chaogex/archive/2014/12/12/4158580.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Thu, 11 Dec 2014 23:44:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/12/12/4158580.html</guid><description><![CDATA[#前言
上文我们完成了引擎的初步设计，本文进行引擎提炼的第一次迭代，从炸弹人游戏中提炼引擎类，搭建引擎的整体框架。


##名词解释

 - 用户

“用户”是个相对的概念，指使用的一方法，默认指游戏开发者。
当相对于某个引擎类时，“用户”就是指引擎类的使用方；当相对于整个引擎时，“用户”就是指引擎的使用方。

 - 用户逻辑

引擎使用方的逻辑，默认指与具体游戏相关的业务逻辑。
 
##本文目的
1、参考引擎初步领域模型，从炸弹人参考模型中提炼出对应的通用类，搭建引擎框架。
2、将炸弹人游戏改造为基于引擎实现。
 
##本文主要内容
<ul>
    <li><a href="#namespace">修改namespace方法，提出Tool</a></li>
    <li><a href="#ImgLoader">提出ImgLoader</a></li>
    <li><a href="#Main">提出Main</a></li>
    <li><a href="#Director">提出Director</a></li>
    <li><a href="#Scene">提出Scene和Hash</a></li>
    <li><a href="#Layer">提出Layer和Collection</a></li>
    <li><a href="#Sprite">提出Sprite、Config和collision</a></li>
    <li><a href="#Factory">提出Factory</a></li>
    <li><a href="#Animation">提出Animation</a></li>
    <li><a href="#AI">提出AI</a></li>
    <li><a href="#EventManager">提出EventManager和Event</a></li>
    <li><a href="#DataOpertor">提出DataOperator</a></li>
    <li><a href="#Data">提出Data</a></li>
    <li><a href="#model">本文最终领域模型</a></li>
    <li><a href="#module">高层划分</a></li>
    <li><a href="#summary">总结</a></li>
    <li><a href="#code">本文源码下载</a></li>
    <li><a href="#reference">参考资料</a></li>
</ul>
 
##炸弹人的参考模型
![](http://images.cnitblog.com/blog/419321/201412/112119302284476.jpg)

 
##引擎初步领域模型
![](http://images.cnitblog.com/blog/419321/201412/120708044156625.jpg)





##开发策略
按照引擎初步领域模型从左往右的顺序，确定要提炼的引擎类，从炸弹人参考模型对应的炸弹人类中提炼出通用的引擎类。
**本文迭代步骤**
![](http://images.cnitblog.com/blog/419321/201412/112120301961563.jpg)
**迭代步骤说明**

 - 确定要提炼的引擎类

按照“引擎初步领域模型”从左往右的顺序依次确定要提炼的引擎类。
每次迭代提炼一个引擎类，如果有强关联的引擎类，也一并提出。

 - 提炼引擎类

从炸弹人参考模型中确定对应的炸弹人类，从中提炼出可复用的、通用的引擎类。

 - 重构提炼的引擎类

如果提炼的引擎类有坏味道，或者包含了用户逻辑，就需要进行重构。

 - 炸弹人改造为基于引擎实现

对应修改炸弹人类，使用提炼的引擎类。
这样能够站在用户角度发现引擎的改进点，得到及时反馈，从而马上重构。

 - 通过游戏的运行测试

通过运行测试，修复由于修改炸弹人代码带来的bug。

 - 重构引擎

如果有必要的话，对引擎进行相应的重构。
下面的几个原因会导致重构引擎：
1、提炼出新的引擎类后，与之关联的引擎类需要对应修改。
2、得到了新的反馈，需要改进引擎。
3、违反了引擎设计原则。
4、处理前面遗留的问题

 - 通过游戏的运行测试

通过运行测试，修复炸弹人和引擎的bug。

 - 编写并通过引擎的单元测试

因为引擎是从炸弹人代码中提炼出来的，所以引擎的单元测试代码可以参考或者直接复用炸弹人的单元测试代码。
炸弹人代码只进行运行测试，不进行单元测试。因为本系列的重点是提炼引擎，不是二次开发炸弹人，这样做可以节省精力，专注于引擎的提炼。

 - 完成本次迭代

进入新一轮迭代，确定下一个要提炼的引擎类。

**思考**
1、为什么先提炼引擎，后进行引擎的单元测试？
在炸弹人开发中，我采用TDD的方式，即先写测试，再进行开发，然而这里不应该采用这种方式，这是因为：
（1）我已经有了一定的游戏开发经验了，可以先进行一大步的开发，然后再写对应的测试来覆盖开发。
（2）在提炼引擎类前我只知道引擎类的大概的职责，不能确定引擎类的详细设计。在提炼的过程中，引擎类会不停的变化，如果先写了引擎类的单元测试代码，则需要不停地修改，浪费很多时间。
2、为什么要先进行游戏的运行测试，再进行引擎的单元测试？
因为：
（1）炸弹人游戏并不复杂，如果运行测试失败，也能比较容易地定位错误
（2）先进行游戏的运行测试，不用修改单元测试代码就能直接修复发现的引擎bug，这样之后进行的引擎单元测试就能比较顺利的通过，节省时间。
##不讨论测试
因为测试并不是本系列的主题，所以本系列不会讨论专门测试的过程，“本文源码下载”中也没有单元测试代码！
您可以在最新的引擎版本中找到引擎完整的单元测试代码： [YEngine2D](https://github.com/yyc-git/YEngine2D)
 


##引擎使用方式的初步研究
在[开篇介绍]( http://www.cnblogs.com/chaogex/p/4149904.html)中，给出了引擎的三种使用方式：直接使用引擎类提供的API、继承重写、实例重写，现在来研究下后两种使用方式。

继承重写应用了模板模式，由引擎类搭建框架，将变化点以钩子方法、虚方法和抽象成员的形式提供给用户子类实现。

实例重写也是应用了模板模式的思想，引擎类也提供钩子方法供用户类重写，不过用户类并不是继承复用引擎类，而是委托复用引擎类。
继承重写与实例重写的区别，实际上就是继承与委托的区别。

**继承重写和实例重写的比较**
共同点
（1）都是单向关联，即用户类依赖引擎类，引擎类不依赖用户类。
（2）用户都可以插入自己的逻辑到引擎中。
 
不同点
（1）继承重写通过继承的方式实现引擎类的使用，实例重写通过委托的方式实现引擎类的使用
（2）继承重写不仅提供了钩子方法，还提供了虚方法、抽象成员供用户重写，实例重写则只提供了钩子方法。



实例重写的优势主要在于用户类与引擎类的关联性较弱，用户类只与引擎类实例的钩子方法耦合，不会与整个引擎类耦合。
继承重写的优势主要在于父类和子类代码共享，提高代码的重用性。 

**什么时候用继承重写**
当用户类与引擎类同属于一个概念，引擎类是精心设计用于被继承的类时，应该用继承重写。

**什么时候用实例重写**
当用户类需要插入自己的逻辑到引擎类中而又不想与引擎类紧密耦合时，应该用实例重写。
 

 
**本文选用的方式**
因为引擎Main和Director是从炸弹人Main、Game中提出来的，不是设计为可被继承的类，所以引擎Main、Director采用实例重写的方式，
（它们的使用方式会在第二次迭代中修改）
 
引擎Layer和Sprite是从炸弹人Layer、Sprite中提出来的，都是抽象基类，本身就是设计为被继承的类，所以引擎Layer和Sprite采用继承重写的方式。
 
其它引擎类不能被重写，而是提供API，供引擎类或用户类调用。
（第二次迭代会将引擎Scene改为继承重写的方式）
 
 
 



<a name="namespace"></a> 
#修改namespace方法，提出Tool
##修改namespace方法
引擎使用命名空间来组织，引擎的顶级命名空间为YE。
在炸弹人开发中，我使用工具库YTool的namespace方法来定义命名空间。
分析YTool的namespace方法：
```js
var YToolConfig = {
    topNamespace: "YYC",	//指定了顶级命名空间为YYC
    toolNamespace: "Tool"
};
...

namespace: function (str) {
    var parent = window[YToolConfig.topNamespace],　
    parts = str.split('.'),
        i = 0,
        len = 0;

    if (str.length == 0) {
        throw new Error("命名空间不能为空");
    }
    if (parts[0] === YToolConfig.topNamespace) {
        parts = parts.slice(1);
    }

    for (i = 0, len = parts.length; i < len; i++) {
        if (typeof parent[parts[i]] === "undefined") {
            parent[parts[i]] = {};
        }
        parent = parent[parts[i]];
    }

    return parent;
},
```
该方法指定了顶级命名空间为YYC，不能修改，这显然不符合引擎的“顶级命名空间为YE”的需求。
因此将其修改为不指定顶级命名空间，并设为全局方法：
```js
(function(){
    var extend = function (destination, source) {
        var property = "";

        for (property in source) {
            destination[property] = source[property];
        }
        return destination;
    };

    (function () {

        /**
         * 创建命名空间。
         示例：
         namespace("YE.Collection");
         */
        var global = {
            namespace: function (str) {
                var parent = window,
                    parts = str.split('.'),
                    i = 0,
                    len = 0;

                if (str.length == 0) {
                    throw new Error("命名空间不能为空");
                }

                for (i = 0, len = parts.length; i < len; i++) {
                    if (typeof parent[parts[i]] === "undefined") {
                        parent[parts[i]] = {};
                    }
                    parent = parent[parts[i]];  //递归增加命名空间
                }

                return parent;
            }
        };

        extend(window, global);
    }());
}());
```
##提出Tool类
不应该直接修改YTool的namespace方法，而应该将修改后的方法提取到引擎中，因为：
（1）导致引擎依赖工具库YTool
YTool中的很多方法引擎都使用不到，如果将修改后的namespace方法放到YTool中，在使用引擎时就必须引入YTool。
这样做会增加引擎的不稳定性，增加整个引擎文件的大小，违反引擎设计原则“尽量减少引擎依赖的外部文件”。
（2）导致大量关联代码修改
我的很多代码都使用了YTool，如果修改了YTool的namespace方法，那么使用了YTool的namespace方法的相关代码可能都需要进行修改。

所以，引擎增加Tool类，负责放置引擎内部使用的通用方法，将修改后的namespace方法放在Tool类中，从而将引擎的依赖YTool改为依赖自己的Tool。
同理，在后面的提炼引擎类时，将引擎类依赖的YTool的方法也全部转移到Tool类中。
引擎Tool的命名空间为YE.Tool。
因为引擎Tool类仅供引擎内部使用，所以炸弹人仍然依赖YTool，而不依赖引擎Tool类。
##领域模型
![](http://images.cnitblog.com/blog/419321/201412/112128140094693.jpg)


<a name="ImgLoader"></a> 
#提出ImgLoader
按照从左到右的提炼顺序，首先要提炼引擎初步领域模型中的LoaderResource。
##提炼引擎类
领域类LoaderResource负责加载各种资源，对应炸弹人PreLoadImg类，该类本身就是一个独立的图片预加载组件（参考发布我的图片预加载控件YPreLoadImg v1.0），可直接提炼到引擎中。

我将其重命名为ImgLoader，加入到命名空间YE中，代码如下：
引擎ImgLoader
```js
namespace("YE").ImgLoader = YYC.Class({
    Init: function (images, onstep, onload) {
        this._checkImages(images);

        this.config = {
            images: images || [],
            onstep: onstep || function () {
            },
            onload: onload || function () {
            }
        };
        this._imgs = {};
        this.imgCount = this.config.images.length;
        this.currentLoad = 0;
        this.timerID = 0;

        this.loadImg();
    },
    Private: {
        _imgs: {},

        _checkImages: function (images) {
            var i = null;

            for (var i in images) {
                if (images.hasOwnProperty(i)) {
                    if (images[i].id === undefined || images[i].url === undefined) {
                        throw new Error("应该包含id和url属性");
                    }
                }
            }
        }
    },
    Public: {
        imgCount: 0,
        currentLoad: 0,
        timerID: 0,

        get: function (id) {
            return this._imgs[id];
        },
        loadImg: function () {
            var c = this.config,
                img = null,
                i,
                self = this,
                image = null;

            for (i = 0; i < c.images.length; i++) {
                img = c.images[i];
                image = this._imgs[img.id] = new Image();
                
                image.onload = function () {
                    this.onload = null;   
                    YYC.Tool.func.bind(self, self.onload)();
                };
                image.src = img.url;

                this.timerID = (function (i) {
                    return setTimeout(function () {
                        if (i == self.currentLoad) {
                            image.src = img.url;
                        }
                    }, 500);
                })(i);
            }
        },
        onload: function (i) {
            clearTimeout(this.timerID);
            this.currentLoad++;
            this.config.onstep(this.currentLoad, this.imgCount);
            if (this.currentLoad === this.imgCount) {
                this.config.onload(this.currentLoad);
            }
        },
        dispose: function () {
            var i, _imgs = this._imgs;
            for (i in _imgs) {
                _imgs[i].onload = null;
                _imgs[i] = null;
            }
            this.config = null;
        }
    }
});
``` 
 
##炸弹人使用提炼的引擎类
对应修改炸弹人Main，改为使用引擎ImgLoader加载图片：
炸弹人Main修改前
```js
        init: function () {
            window.imgLoader = new YYC.Control.PreLoadImg(…);
        },
``` 
炸弹人Main修改后
```js
        init: function () {
            window.imgLoader = new YE.ImgLoader(...);
        },
```
 

##领域模型
![](http://images.cnitblog.com/blog/419321/201412/112127287753875.jpg)



 
 
 
 
<a name="Main"></a>  
#提出Main
接着就是提炼依赖LoadResource的Main。





##提炼引擎类
领域类Main负责启动游戏，对应炸弹人Main。
先来看下相关代码：	
炸弹人Main
```js
var main = (function () {
    var _getImg = function () {
        var urls = [];
        var i = 0, len = 0;

        var map = [
            { id: "ground", url: getImages("ground") },
            { id: "wall", url: getImages("wall") }
        ];
        var player = [
            { id: "player", url: getImages("player") }
        ];
        var enemy = [
            { id: "enemy", url: getImages("enemy") }
        ];
        var bomb = [
            { id: "bomb", url: getImages("bomb") },
            { id: "explode", url: getImages("explode") },
            { id: "fire", url: getImages("fire") }
        ];

        _addImg(urls, map, player, enemy, bomb);

        return urls;
    };
    var _addImg = function (urls, imgs) {
        var args = Array.prototype.slice.call(arguments, 1),
            i = 0,
            j = 0,
            len1 = 0,
            len2 = 0;

        for (i = 0, len1 = args.length; i < len1; i++) {
            for (j = 0, len2 = args[i].length; j < len2; j++) {
                urls.push({ id: args[i][j].id, url: args[i][j].url });
            }
        }
    };

    var _hideBar = function () {
        $("#progressBar").css("display", "none");
    };

    return {
        init: function () {
            //使用引擎ImgLoader加载图片
            window.imgLoader = new YE.ImgLoader(_getImg(), function (currentLoad, imgCount) {
                $("#progressBar_img_show").progressBar(parseInt(currentLoad * 100 / imgCount, 10));     //调用进度条插件
            }, YYC.Tool.func.bind(this, this.onload));
        },
        onload: function () {
            _hideBar();

            var game = new Game();
            game.init();
            game.start();
        },
    };

    window.main = main;
}());
```
炸弹人Main负责以下的逻辑：
（1）定义要加载的图片数据
（2）创建ImgLoader实例，加载图片
（3）完成图片加载后，启动游戏
（4）提供入口方法，由页面调用

可以将第4个逻辑提到引擎Main中，由引擎搭建一个框架，炸弹人Main负责填充具体的业务逻辑。



引擎Main：
```js
(function () {
    var _instance = null;

    namespace("YE").Main = YYC.Class({
        Init: function () {
        },
        Public: {
            init: function () {
                this. loadResource ();
            },
                //* 钩子

                loadResource: function () {
                }
        },
        Static: {
            getInstance: function () {
                if (instance === null) {
                    _instance = new this();
                }
                return _instance;
            }
        }
    });
}());
```

分析引擎Main

 - 使用方式为实例重写

提供了loadResource钩子方法供用户重写。

 - 单例

因为游戏只有一个入口类，因此引擎Main为单例类。

 - 框架设计

页面调用引擎Main的init方法进入游戏，init方法调用钩子方法loadResource，该钩子方法由炸弹人Main重写，从而实现在引擎框架中插入用户逻辑。


##炸弹人使用提炼的引擎类
炸弹人Main通过重写引擎Main的loadResource钩子方法来插入用户逻辑。
炸弹人Main 
```js
(function () {
    var main = YE.Main.getInstance();


    var _getImg = function () {
        ...
    };

    var _addImg = function (urls, imgs) {
        ...
    };

    var _hideBar = function () {
        ...
    };

    var _onload = function(){
        …
    };

    //重写引擎Main的loadResource钩子
    main.loadResource =function () {
        window.imgLoader = new YE.ImgLoader(_getImg(), function (currentLoad, imgCount) {
            $("#progressBar_img_show").progressBar(parseInt(currentLoad * 100 / imgCount, 10));
        }, YYC.Tool.func.bind(this,_onload));
    }
}());
```


修改页面，调用引擎Main的init方法进入游戏：
页面修改前
```html
<script type="text/javascript">
(function () {
	//调用炸弹人Main的init方法
        main.init();
    })();
</script>
``` 
页面修改后
```html
<script type="text/javascript">
    (function () {
        YE.Main.getInstance().init();
    })();
</script>
```


##重构引擎
###引擎Main应该负责加载图片，对用户隐藏引擎ImgLoader
炸弹人应该只负责定义要加载的图片和在加载图片过程中要插入的用户逻辑，不需要知道如何加载图片。这个工作应该交给引擎Main，由它封装引擎ImgLoader，向用户提供操作图片的方法和在加载图片的过程中插入用户逻辑的钩子方法。

1、重构引擎ImgLoader

由于引擎ImgLoader设计僵化，需要先进行重构。
现在来看下引擎ImgLoader的构造函数
```js
Init: function (images, onstep, onload) {
        this._checkImages(images);

        this.config = {
            images: images || [],
            onstep: onstep || function () {
            },
            onload: onload || function () {
            }
        };
        this._imgs = {};
        this.imgCount = this.config.images.length;
        this.currentLoad = 0;
        this.timerID = 0;

        this.loadImg();
    },
```
 “设置加载图片的回调函数”和“加载图片”的逻辑和ImgLoader构造函数绑定在了一起，创建ImgLoader实例时会执行这两项任务。
需要将其从构造函数中分离出来，由用户自己决定何时执行这两个任务。
因此进行下面的重构：
（1）将回调函数onstep重命名为onloading，将onload、onloading从构造函数中提出，作为钩子方法。
（2）将图片数据images的设置和检查提取到新增的load方法中。
（3）提出done方法，负责调用_loadImg方法加载图片。 
 
引擎ImgLoader修改后
```js
namespace("YE").ImgLoader = YYC.Class({
        Init: function () {
        },
        Private: {
            _images: [],
            _imgs: {},

            //修改了原来的_checkImages方法，现在传入的图片数据可以为单个数据，也可为数组形式的多个数据
            _checkImages: function (images) {
                var i = 0,
                    len = 0;

                if (YYC.Tool.judge.isArray(images)) {
                    for (len = images.length; i < len; i++) {
                        if (images[i].id === undefined || images[i].url === undefined) {
                            throw new Error("应该包含id和url属性");
                        }
                    }
                }
                else {
                    if (images.id === undefined || images.url === undefined) {
                        throw new Error("应该包含id和url属性");
                    }
                }
            },
            //将onload改为私有方法
            _onload: function (i) {
                …

                //调用钩子

                this.onloading(this.currentLoad, this.imgCount);

                if (this.currentLoad === this.imgCount) {
                    this.onload(this.imgCount);
                }
            },
            //改为私有方法
            _loadImg: function () {
                …
            }
        }
    },
    Public: {
…

        done: function () {
            this._loadImg();
        },
        //负责检查和保存图片数据
        load: function (images) {
            this._checkImages(images);
    
            if (YYC.Tool.judge.isArray(images)) {
                this._images = this._images.concat(images);
            }
            else {
                this._images.push(images);
            }
            this.imgCount = this._images.length;
        },
…

        //*钩子
    
        onloading: function (currentLoad, imgCount) {
        },
        onload: function (imgCount) {
        }
    }
});
```

2、重构引擎Main

现在回到引擎Main的重构，通过下面的重构来实现封装引擎ImgLoader，向用户提供钩子方法和操作图片的方法:
（1）构造函数中创建ImgLoader实例
（2）init方法中调用ImgLoader的done方法加载图片
（3）提供getImg和load方法来操作图片数据
（4）增加onload、onloading钩子，将其与ImgLoader的onload、onloading钩子绑定到一起。

绑定钩子的目的是为了让炸弹人Main只需要知道引擎Main的钩子，从而达到引擎Main封装引擎ImgLoader的目的。
这个方案并不是很好，在第二次迭代中会修改。


引擎Main修改后
```js
(function () {
    var _instance = null;

    namespace("YE").Main = YYC.Class({
        Init: function () {
            this._imgLoader = new YE.ImgLoader();
        },
        Private: {
            _imgLoader: null,

            _prepare: function () {
                this.loadResource();

                this._imgLoader.onloading = this.onloading;
                this._imgLoader.onload = this.onload;
            }
        },
        Public: {
            init: function () {
                this._prepare();
                this._imgLoader.done();
            },
            getImg: function (id) {
                return this._imgLoader.get(id);
            },
            load: function (images) {
                this._imgLoader.load(images);
            },

            //* 钩子

            loadResource: function () {
            },
            onload: function () {
            },
            onloading: function (currentLoad, imgCount) {
            }
        },
…
    });
}());
```

3、修改炸弹人Main

炸弹人Main在重写的引擎Main的loadResource方法中重写引擎Main的onload、onloading钩子方法，这相当于重写了imgLoader的onload、onloading钩子方法，从而在加载图片的过程中插入用户逻辑。


炸弹人Main
```js
(function () {
   …

    main.loadResource = function () {
        this.load(_getImg());
    };
    main.onloading = function (currentLoad, imgCount) {
        $("#progressBar_img_show").progressBar(parseInt(currentLoad * 100 / imgCount, 10));
    };
    main.onload = function () {
        _hideBar();

        var game = new Game();
        game.init();
        game.start();
    };
}());
``` 
 
###将依赖的YTool方法移到Tool
修改后的引擎ImgLoader需要调用YTool的isArray方法，将其移到引擎Tool中。
引擎Tool
```js
    namespace("YE.Tool").judge = {
        isArray: function (val) {
            return Object.prototype.toString.call(val) === "[object Array]";
        }
    };
``` 
对应修改ImgLoader，将YYC.Tool调用改为YE.Tool
...
            if (YE.Tool.judge.isArray(images)) {
…
            }
 
##领域模型
![](http://images.cnitblog.com/blog/419321/201412/112127468211988.jpg)




<a name="Director"></a> 
#提出Director
继续往右提炼Director。

##提炼引擎类
领域类Director负责游戏的统一调度，对应炸弹人的Game类
炸弹人Game
```js
 (function () {
    //初始化游戏全局状态
    window.gameState = window.bomberConfig.game.state.NORMAL;

    var Game = YYC.Class({
        Init: function () {
            window.subject = new YYC.Pattern.Subject();
        },
        Private: {
            _createLayerManager: function () {
                this.layerManager = new LayerManager();
                this.layerManager.addLayer("mapLayer", layerFactory.createMap());
                this.layerManager.addLayer("enemyLayer", layerFactory.createEnemy(this.sleep));
                this.layerManager.addLayer("playerLayer", layerFactory.createPlayer(this.sleep));
                this.layerManager.addLayer("bombLayer", layerFactory.createBomb());
                this.layerManager.addLayer("fireLayer", layerFactory.createFire());
            },
            _addElements: function () {
                var mapLayerElements = this._createMapLayerElement(),
                    playerLayerElements = this._createPlayerLayerElement(),
                    enemyLayerElements = this._createEnemyLayerElement();

                this.layerManager.addSprites("mapLayer", mapLayerElements);
                this.layerManager.addSprites("playerLayer", playerLayerElements);
                this.layerManager.addSprites("enemyLayer", enemyLayerElements);
            },
            _createMapLayerElement: function () {
                var i = 0,
                    j = 0,
                    x = 0,
                    y = 0,
                    row = bomberConfig.map.ROW,
                    col = bomberConfig.map.COL,
                    element = [],
                    mapData = mapDataOperate.getMapData(),
                    img = null;

                for (i = 0; i < row; i++) {
                    y = i * bomberConfig.HEIGHT;

                    for (j = 0; j < col; j++) {
                        x = j * bomberConfig.WIDTH;
                        img = this._getMapImg(i, j, mapData);
                        element.push(spriteFactory.createMapElement({ x: x, y: y }, bitmapFactory.createBitmap({ img: img, width: bomberConfig.WIDTH, height: bomberConfig.HEIGHT })));
                    }
                }

                return element;
            },
            _getMapImg: function (i, j, mapData) {
                var img = null;

                switch (mapData[i][j]) {
                    case 1:
                        img = YE.Main.getInstance().getImg("ground");
                        break;
                    case 2:
                        img = YE.Main.getInstance().getImg("wall");
                        break;
                    default:
                        break
                }

                return img;
            },
            _createPlayerLayerElement: function () {
                var element = [],
                    player = spriteFactory.createPlayer();

                player.init();
                element.push(player);

                return element;
            },
            _createEnemyLayerElement: function () {
                var element = [],
                    enemy = spriteFactory.createEnemy(),
                    enemy2 = spriteFactory.createEnemy2();

                enemy.init();
                enemy2.init();
                element.push(enemy);
                element.push(enemy2);

                return element;
            },
            _initLayer: function () {
                this.layerManager.initLayer();
            },
            _initEvent: function () {
                //监听整个document的keydown,keyup事件
                keyEventManager.addKeyDown();
                keyEventManager.addKeyUp();
            },
            _judgeGameState: function () {
                switch (window.gameState) {
                    case window.bomberConfig.game.state.NORMAL:
                        break;
                    case window.bomberConfig.game.state.OVER:
                        this.gameOver();
                        return "over";
                        break;
                    case window.bomberConfig.game.state.WIN:
                        this.gameWin();
                        return "over";
                        break;
                    default:
                        throw new Error("未知的游戏状态");
                }
                return false;
            }
        },
        Public: {
            sleep: 0,
            layerManager: null,
            mainLoop: null,

            init: function () {
                this.sleep = Math.floor(1000 / bomberConfig.FPS);
                this._createLayerManager();
                this._addElements();
                this._initLayer();
                this._initEvent();

                window.subject.subscribe(this.layerManager.getLayer("mapLayer"), this.layerManager.getLayer("mapLayer").changeSpriteImg);
            },
            start: function () {
                var self = this;

                this.mainLoop = window.setInterval(function () {
                    self.run();
                }, this.sleep);
            },
            run: function () {
                if (this._judgeGameState() === "over") {
                    return;
                }

                this.layerManager.run();
                this.layerManager.change();
            },
            gameOver: function () {
                YYC.Tool.asyn.clearAllTimer(this.mainLoop);
                alert("Game Over！");
            },
            gameWin: function () {
                YYC.Tool.asyn.clearAllTimer(this.mainLoop);
                alert("You Win！");
            }
        }
    });

    window.Game = Game;
}());
```
炸弹人Game负责游戏的统一调度，包括以下的逻辑：
（1）初始化场景
（2）调度layerManager
（3）控制主循环
（4）计算帧率fps
（5）管理游戏状态


其中控制主循环、调度layerManager、计算fps的逻辑可以提取到引擎Director中：
引擎Director
```js
(function () {
    var _instance = null;
    var GameStatus = {
        NORMAL: 0,
        STOP: 1
};
var STARTING_FPS = 60;

    namespace("YE").Director = YYC.Class({
        Private: {
            _startTime: 0,
            _lastTime: 0,

            _fps: 0,

            _layerManager: null,
            //内部游戏状态
            _gameState: null,


            _getTimeNow: function () {
                return +new Date();
            },
            _run: function (time) {
                var self = this;

                this._loopBody(time);

                if (this._gameState === GameStatus.STOP) {
                    return;
                }

                window.requestNextAnimationFrame(function (time) {
                    self._run(time);
                });
            },
            _loopBody: function (time) {
                this._tick(time);

                this.onStartLoop();

                this._layerManager.run();
                this._layerManager.change();

                this.onEndLoop();
            },
            _tick: function (time) {
                this._updateFps(time);
                this.gameTime = this._getTimeNow() - this._startTime;
                this._lastTime = time;
            },
            _updateFps: function (time) {
                if (this._lastTime === 0) {
                    this._fps =STARTING_FPS;
                }
                else {
                    this._fps = 1000 / (time - this._lastTime);
                }
            }
        },
        Public: {
            gameTime: null,

            start: function () {
                var self = this;

                this._startTime = this._getTimeNow();

                window.requestNextAnimationFrame(function (time) {
                    self._run(time);
                });
            },
            setLayerManager: function (layerManager) {
                this._layerManager = layerManager;
            },
            getFps: function () {
                return this._fps;
            },
            stop: function () {
                this._gameState = GameStatus.STOP;
            },


            //*钩子

            init: function () {
            },
            onStartLoop: function () {
            },
            onEndLoop: function () {
            }

        },
        Static: {
            getInstance: function () {
                if (_instance === null) {
                    _instance = new this();
                }
                return _instance;
            }
        }
    });
}()); 
``` 
 
###分析引擎Director
####使用方式为实例重写
引擎Director提供了init、onStartLoop、onEndLoop钩子方法供用户重写。
引擎会在加载完图片后调用钩子方法init，用户可以通过重写该钩子，插入初始化游戏的用户逻辑。
onStartLoop、onEndLoop钩子分别在每次主循环开始和结束时调用，插入用户逻辑：
引擎Director
```js
            _loopBody: function (time) {
                this._tick(time);
				
                this.onStartLoop();

…

                this.onEndLoop();
            },
```

####单例
因为全局只有一个Director，因此为单例。
####主循环
#####使用requestAnimationFrame实现主循环
炸弹人Game中使用setInterval方法，而引擎Director使用requestAnimationFrame方法实现主循环。这是因为可以通过setTimeout和setInterval方法在脚本中实现动画，但是这样效果可能不够流畅，且会占用额外的资源。
参考《HTML5 Canvas核心技术：图形、动画与游戏开发》中的论述：

> 它们有如下的特征： 
> 1、即使向其传递毫秒为单位的参数，它们也不能达到ms的准确性。这是因为javascript是单线程的，可能会发生阻塞。
> 2、没有对调用动画的循环机制进行优化。
> 3、没有考虑到绘制动画的最佳时机，只是一味地以某个大致的事件间隔来调用循环。
> 其实，使用setInterval或setTimeout来实现主循环，根本错误就在于它们抽象等级不符合要求。我们想让浏览器执行的是一套可以控制各种细节的api，实现如“最优帧速率”、“选择绘制下一帧的最佳时机”等功能。但是如果使用它们的话，这些具体的细节就必须由开发者自己来完成。


requestAnimationFrame不需要使用者指定循环间隔时间，浏览器会基于当前页面是否可见、CPU的负荷情况等来自行决定最佳的帧速率，从而更合理地使用CPU。 
需要注意的时，不同的浏览器对于requestAnimationFrame、cancelNextRequestAnimationFrame的实现不一样，因此需要定义通用的方法，放到引擎Tool类中。
引擎Tool
```js
/**
* 来自《HTML5 Canvas核心技术：图形、动画与游戏开发》
*/
 window.requestNextAnimationFrame = (function () {
            var originalWebkitRequestAnimationFrame = undefined,
                wrapper = undefined,
                callback = undefined,
                geckoVersion = 0,
                userAgent = navigator.userAgent,
                index = 0,
                self = this;

            // Workaround for Chrome 10 bug where Chrome
            // does not pass the time to the animation function

            if (window.webkitRequestAnimationFrame) {
                // Define the wrapper

                wrapper = function (time) {
                    if (time === undefined) {
                        time = +new Date();
                    }
                    self.callback(time);
                };

                // Make the switch

                originalWebkitRequestAnimationFrame = window.webkitRequestAnimationFrame;

                window.webkitRequestAnimationFrame = function (callback, element) {
                    self.callback = callback;

                    // Browser calls the wrapper and wrapper calls the callback

                    originalWebkitRequestAnimationFrame(wrapper, element);
                }
            }

            // Workaround for Gecko 2.0, which has a bug in
            // mozRequestAnimationFrame() that restricts animations
            // to 30-40 fps.

            if (window.mozRequestAnimationFrame) {
                // Check the Gecko version. Gecko is used by browsers
                // other than Firefox. Gecko 2.0 corresponds to
                // Firefox 4.0.

                index = userAgent.indexOf('rv:');

                if (userAgent.indexOf('Gecko') != -1) {
                    geckoVersion = userAgent.substr(index + 3, 3);

                    if (geckoVersion === '2.0') {
                        // Forces the return statement to fall through
                        // to the setTimeout() function.

                        window.mozRequestAnimationFrame = undefined;
                    }
                }
            }

            return  window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||

                function (callback, element) {
                    var start,
                        finish;

                    window.setTimeout(function () {
                        start = +new Date();
                        callback(start);
                        finish = +new Date();

                        self.timeout = 1000 / 60 - (finish - start);

                    }, self.timeout);
                };
        }());


window.cancelNextRequestAnimationFrame = window.cancelRequestAnimationFrame
|| window.webkitCancelAnimationFrame
|| window.webkitCancelRequestAnimationFrame
|| window.mozCancelRequestAnimationFrame
|| window.oCancelRequestAnimationFrame
|| window.msCancelRequestAnimationFrame
|| clearTimeout;
```

#####控制主循环
主循环的逻辑封装在_run方法中。
start方法负责启动主循环。

**退出主循环的机制**
为了能够退出主循环，增加内部游戏状态_gameState。用户可调用引擎Director的stop方法来设置内部游戏状态为STOP，然后Director会在主循环中的_run方法中判断内部游戏状态，如果为STOP状态，则退出主循环。

引擎Director
```js
            _run: function (time) {
                var self = this;

                this._loopBody(time);

                if (this._gameState === GameStatus.STOP) {
                    //退出主循环
                    return;	
                }

                window.requestNextAnimationFrame(function (time) {
                    self._run(time);
                });
            },
…
            stop: function () {
                this._gameState = GameStatus.STOP;
            },
```
这里有同学可能会问为什么stop方法不直接调用cancelNextRequestAnimationFrame方法来结束主循环？
参考代码如下所示：
```js
引擎Director
            _run: function (time) {
                var self = this;

                this._loopBody(time);
                
                //删除游戏状态的判断

                this._loopId = window.requestNextAnimationFrame(function (time) {
                    self._run(time);
                });
            },
…
            stop: function () {
				//直接在stop方法中结束主循环
                window.cancelNextRequestAnimationFrame(this._loopId);
            }
```
这是因为：
如果用户是在引擎的钩子中调用stop方法，由于引擎的钩子方法都是在主循环中调用的（_loopBody方法中调用），所以不能结束主循环！ 
```js
            //该方法包含了主循环逻辑，所有的钩子方法都是在该方法中调用 
            _loopBody: function (time) {
                this._tick(time);

                this._scene.onStartLoop();
                this._scene.run();
                this._scene.onEndLoop();
            },
```
只有当用户在引擎主循环外部调用stop方法时，才可以结束主循环。
详见《深入理解requestAnimationFrame》中的[“为什么在callback内部执行cancelAnimationFrame不能取消动画”]( http://www.cnblogs.com/chaogex/p/3960175.html#question) 



####调度layerManager
目前LayerManager为炸弹人类，用户通过调用引擎Director的setLayerManager方法将其注入到引擎Director中。

**领域模型**
![](http://images.cnitblog.com/blog/419321/201412/112126203684109.jpg) 

引擎Director在主循环中调用layerManager实例的run和change方法，执行炸弹人LayerManager的主循环逻辑。

 - 为什么要由用户注入LayerManager实例，而不是直接在引擎Director中创建LayerManager实例？

（1）根据引擎设计原则“引擎不应该依赖用户，用户应该依赖引擎”，LayerManager为用户类，引擎不应该依赖用户。

（2）这样会降低引擎Director的通用性
引擎Director应该操作抽象角色，而不应该直接操作具体的“层管理”类，这样会导致具体的“层管理”类变化时，引擎Director也会受到影响。

因此，此处采用“由用户注入”的设计更加合理。

 - 为什么由引擎Director调用炸弹人LayerManager的change方法？

LayerManager的change方法负责调用每个层的change方法，设置画布的状态（主循环中会判断画布状态，决定是否更新画布）：
炸弹人LayerManager
```js
            change: function () {
                this.__iterator("change");
            }
```

change方法的调用有两个选择：
（1）由用户调用
用户可在重写引擎Director提供的钩子方法中（如onEndLoop），调用炸弹人LayerManager的change方法
（2）由引擎调用
引擎Director主循环在调用layerManager的run方法后调用layerManager的change方法。

因为：
（1）设置画布状态的逻辑属于通用逻辑
（2）引擎对什么时候设置画布状态有最多的知识

所以应该由引擎Director调用。


####计算帧率fps
引擎Director的_updateFps方法负责根据上一次主循环执行时间计算fps：
```js
        	//time为当前主循环的开始时间（从1970年1月1日到当前所经过的毫秒数）
        	//lastTime为上一次主循环的开始时间
            _updateFps: function (time) {
                if (this._lastTime === 0) {
                    this._fps = STARTING_FPS;
                }
                else {
                    this._fps = 1000 / (time - this._lastTime);
                }
            }
```
其中引擎Director的STARTING_FPS定义了初始的fps，“time-this._lastTime”计算的是上次主循环的执行时间。
如果为第一次主循环，lastTime为0，fps为初始值；
否则，fps为上次主循环执行时间的倒数。



##炸弹人使用提炼的引擎类 
###修改炸弹人Game 
炸弹人Game改为只负责初始化场景和管理游戏状态，其它逻辑委托引擎实现。

炸弹人Game
```js
(function () {
	//获得引擎Director实例，从而可实例重写。
    var director = YE.Director.getInstance();

    var Game = YYC.Class({
        Init: function () {
        },
        Private: {
                ...
            _gameOver: function () {
                director.stop();	//结束主循环
                alert("Game Over！");
            },
            _gameWin: function () {
                director.stop();	//结束主循环
                alert("You Win！");
            }
        },
        Public: {
…

            init: function () {
                //初始化游戏全局状态
                window.gameState = window.bomberConfig.game.state.NORMAL;

                window.subject = new YYC.Pattern.Subject();

			//调用引擎Director的getFps方法获得fps
                this.sleep = 1000 / director.getFps();
…
            },
            judgeGameState: function () {
…
            }
        }
    });


    var game = new Game();

    //重写引擎Director的init钩子
    director.init = function () {
        game.init();

        //设置场景
        this.setLayerManager(game.layerManager);
    };

    //重写引擎Director的onStartLoop钩子
    director.onStartLoop = function () {
        game.judgeGameState();
    };
}()); 
```
**重构炸弹人Game**

 - 移动逻辑

将Game中属于“初始化场景”职责的“初始化游戏全局状态”和“创建Subject实例”逻辑提到Game的 init方法中。 

 - 将gameOver、gameWin设为私有方法，judgeGameState设为公有方法

因为只有Game调用这两个方法，因此将其设为私有方法。
而judgeGameState方法被director的钩子方法调用，因此将其设为公有方法。



**炸弹人Game实例重写引擎Director** 

 - 重写引擎Director的init钩子

在init钩子中，炸弹人插入了Game的初始化场景的逻辑，注入了Game创建的layerManager实例。

 - 删除start和run方法

这部分职责已经移到引擎Director中了，所以Game删除start和run方法，由引擎负责控制主循环。

 - 重写了Director的onStartLoop钩子，实现了炸弹人游戏的结束机制

修改了Game的gameOver、gameWin方法，改为调用director.stop方法来结束主循环。
将Game的run方法的“关于全局游戏状态判断”的逻辑移到Director的onStartLoop钩子中，引擎会在每次主循环开始时判断一次全局游戏状态，决定是否调用Game的gameOver或gameWin方法结束游戏。


###修改炸弹人Main
为了能通过游戏的运行测试，先修改炸弹人Main重写引擎Main的onload钩子，改为调用引擎Director的init和start方法来执行游戏初始化并启动主循环。
炸弹人Main修改前
```js
    main.onload = function () {
…
        var game = new Game();
        game.init();
        game.start();
    };
```
炸弹人Main修改后
```js
    main.onload = function () {
…
              var director = YE.Director.getInstance();
                director.init();
                director.start();
    };
```


##重构引擎

 - 将炸弹人Main的“执行游戏初始化并启动主循环”的逻辑移到引擎Main中

因为：
（1）“执行游戏初始化”的逻辑具体是调用Director的钩子方法init，而钩子方法应该由引擎调用。
（2）“执行游戏初始化”和“启动主循环”的逻辑应该由入口类负责，也就是说可以由引擎Main或炸弹人Main负责。因为该逻辑与引擎更相关，并且考虑到引擎设计原则“尽量减少用户负担”，所以应该由引擎Main负责。

所以应该由引擎Main负责该逻辑。

因此修改引擎ImgLoader，增加onload_game钩子；然后在引擎Main中重写ImgLoader的onload_game钩子，实现“执行游戏初始化并启动主循环”的逻辑；最后修改炸弹人Main重写引擎Main的onload钩子，不再调用引擎Director的init和start方法。

**为什么引擎ImgLoader要增加onload_game钩子？**
因为现在引擎ImgLoader的钩子是供炸弹人Main重写的，引擎Main无法重写引擎ImgLoader的钩子来执行“执行游戏初始化并启动主循环”逻辑，所以引擎ImgLoader增加内部钩子onload_game，供引擎Main重写，而炸弹人Main则负责在重写的引擎ImgLoader的onload钩子中实现“加载图片完成到执行游戏初始化并启动主循环”之间的用户逻辑。


相关代码
引擎ImgLoader
```js
        _onload: function (i) {
...

            if (this.currentLoad === this.imgCount) {
		        //图片加载完成后调用onload和onload_game钩子
                this.onload(this.imgCount);
                this.onload_game();
            }
        },
...

        //*内部钩子

        onload_game: function () {
        },
...
    }
```
引擎Main
```js
_prepare: function () {
    this.loadResource();

    this._imgLoader.onloading = this.onloading;
    this._imgLoader.onload = this.onload;

    this._imgLoader.onload_game = function () {
        var director = YE.Director.getInstance();

        director.init();
        director.start();
    }
}
```
炸弹人Main
```js
            main.onload = function () {
		        //隐藏资源加载进度条
                _hideBar();
            };
``` 
 
###待重构点
引擎ImgLoader的onload钩子和onload_game钩子重复了，两者都是在加载图片完成后调用。
提出onload_game钩子只是一个临时的解决方案，在第二次迭代中会删除它。


##领域模型
![](http://images.cnitblog.com/blog/419321/201412/112127124465319.jpg)


 
<a name="Scene"></a>  
#提出Scene和Hash
现在应该提出Scene领域类，使引擎Director依赖引擎Scene，而不是依赖炸弹人LayerManager。
由于Scene继承于Hash，因此将Hash也一起提出。

 
 
##提炼引擎类
领域类Scene负责管理场景，对应炸弹人LayerManager；领域类Hash为哈希结构的集合类，对应炸弹人Hash。
炸弹人LayerManager是一个容器类，负责层的管理，属于通用类，可直接提取到引擎中，重命名为Scene。
炸弹人Hash是一个独立的抽象类，可直接提取到引擎中

 
引擎Hash
```js
(function () {
    namespace("YE").Hash = YYC.AClass({
        Private: {
            //容器
            _childs: {}
        },
        Public: {
            getChilds: function () {
                return this._childs;
            },
            getValue: function (key) {
                return this._childs[key];
            },
            add: function (key, value) {
                this._childs[key] = value;
                return this;
            }
        }
    });
}());
``` 
 
 
引擎Scene
```js
(function () {
    namespace("YE").Scene = YYC.Class(YE.Hash, {
        Private: {
            __iterator: function (handler, args) {
                var args = Array.prototype.slice.call(arguments, 1),
                    i = null,
                    layers = this.getChilds();

                for (i in layers) {
                    if (layers.hasOwnProperty(i)) {
                        layers[i][handler].apply(layers[i], args);
                    }
                }
            },
            __getLayers: function () {
                return this.getChilds();
            }
        },
        Public: {
            addLayer: function (name, layer) {
                this.add(name, layer);
                return this;
            },
            getLayer: function (name) {
                return this.getValue(name);
            },
            addSprites: function (name, elements) {
                this.getLayer(name).appendChilds(elements);
            },
            initLayer: function () {
                this.__iterator("setCanvas");
                this.__iterator("init", this.__getLayers());
            },
            run: function () {
                this.__iterator("run");
            },
            change: function () {
                this.__iterator("change");
            }
        }
    });
}());
``` 


##炸弹人使用提炼的引擎类
###重构炸弹人Game，改为依赖引擎Scene
因为炸弹人LayerManager重构为引擎Scene了，因此炸弹人Game也要对应修改为依赖引擎Scene。

**领域模型**
![](http://images.cnitblog.com/blog/419321/201412/112129037285217.jpg)

将Game的layerMangaer属性重命名为scene，并重命名_createLayerManager方法为_createScene，改为创建引擎Scene实例。
炸弹人Game
```js
 _createScene: function () {
    this.scene = new YE.Scene();
    this.scene.addLayer("mapLayer", layerFactory.createMap());
    this.scene.addLayer("enemyLayer", layerFactory.createEnemy(this.sleep));
    this.scene.addLayer("playerLayer", layerFactory.createPlayer(this.sleep));
    this.scene.addLayer("bombLayer", layerFactory.createBomb());
    this.scene.addLayer("fireLayer", layerFactory.createFire());
},
_addElements: function () {
…
    this.scene.addSprites("mapLayer", mapLayerElements);
    this.scene.addSprites("playerLayer", playerLayerElements);
    this.scene.addSprites("enemyLayer", enemyLayerElements);
},
…
_initLayer: function () {
    this.scene.initLayer();
},
…
init: function () {
…
    this._createScene(); 
…
}
```
##重构引擎
因为引擎Director依赖引擎Scene了，所以应该将_layerManager属性重命名为scene，将setLayerManager方法重命名为setScene。
引擎Director
```js
            _scene: null,

…
            _loopBody: function (time) {
…

	            this._scene.run();
                this._scene.change();
…
            },
…
            setScene: function (scene) {
                this._scene = scene;
            },
```
 

对应修改Game，改为调用setScene方法：
炸弹人Game
```js
director.init = function () {
…

    //设置场景
    this.setScene(game.scene);
};
```
##领域模型
![](http://images.cnitblog.com/blog/419321/201412/112127561656108.jpg)
 
 
 
 
 
<a name="Layer"></a> 
#提出Layer和Collection
现在应该提出Layer领域类，使引擎Scene依赖引擎Layer。
由于Layer继承于Collection类，因此将Collection也一起提出。


##提炼引擎类
领域类Layer负责层内精灵的统一管理，对应炸弹人的Layer。
领域类Collection为线性结构的集合类，对应炸弹人Collection.
炸弹人Layer是一个抽象类，负责精灵的管理，具有通用性，直接提取到引擎中。
炸弹人Collection是一个独立的类，可直接提取到引擎中
引擎Layer
```js
(function () {
    namespace("YE").Layer = YYC.AClass(Collection, {
        Init: function () {
        },
        Private: {
            __state: bomberConfig.layer.state.CHANGE,

            __getContext: function () {
                this.P_context = this.P_canvas.getContext("2d");
            }
        },
        Protected: {
            P_canvas: null,
            P_context: null,

            P_isChange: function () {
                return this.__state === bomberConfig.layer.state.CHANGE;
            },
            P_isNormal: function () {
                return this.__state === bomberConfig.layer.state.NORMAL;
            },
            P_iterator: function (handler) {
                var args = Array.prototype.slice.call(arguments, 1),
                    nextElement = null;

                while (this.hasNext()) {
                    nextElement = this.next();
                    nextElement[handler].apply(nextElement, args);  //要指向nextElement
                }
                this.resetCursor();
            },
            P_render: function () {
                if (this.P_isChange()) {
                    this.clear();
                    this.draw();
                    this.setStateNormal();
                }
            }
        },
        Public: {
            remove: function (sprite) {
                this.base(function (e, obj) {
                    if (e.x === obj.x && e.y === obj.y) {
                        return true;
                    }
                    return false;
                }, sprite);
            },
            setStateNormal: function () {
                this.__state = bomberConfig.layer.state.NORMAL;
            },
            setStateChange: function () {
                this.__state = bomberConfig.layer.state.CHANGE;
            },
            Virtual: {
                init: function () {
                    this.__getContext();
                },
                clear: function (sprite) {
                    if (arguments.length === 0) {
                        this.P_iterator("clear", this.P_context);
                    }
                    else if (arguments.length === 1) {
                        sprite.clear(this.P_context);
                    }
                }
            }
        },
        Abstract: {
            setCanvas: function () {
            },
            change: function () {
            },
            draw: function () {
            },
            //游戏主循环调用的方法
            run: function () {
            }
        }
    });
}());
``` 
引擎Collecton
```js
(function () {
    //*使用迭代器模式

    var IIterator = YYC.Interface("hasNext", "next", "resetCursor");


    namespace("YE").Collection = YYC.AClass({Interface: IIterator}, {
        Private: {
            //当前游标
            _cursor: 0,
            //容器
            _childs: []
        },
        Public: {
            getChilds: function () {
                return YYC.Tool.array.clone(this._childs);
            },
            getChildAt: function (index) {
                return this._childs[index];
            },
            appendChild: function (child) {
                this._childs.push(child);

                return this;
            },
            appendChilds: function (childs) {
                var i = 0,
                    len = 0;

                for (i = 0, len = childs.length; i < len; i++) {
                    this.addChild(childs[i]);
                }
            },
            removeAll: function () {
                this._childs = [];
            },
            hasNext: function () {
                if (this._cursor === this._childs.length) {
                    return false;
                }
                else {
                    return true;
                }
            },
            next: function () {
                var result = null;

                if (this.hasNext()) {
                    result = this._childs[this._cursor];
                    this._cursor += 1;
                }
                else {
                    result = null;
                }

                return result;
            },
            resetCursor: function () {
                this._cursor = 0;
            },
            Virtual: {
                remove: function (func, child) {
                    this._childs.remove(func, child);
                }
            }
        }
    });
}());
```

###分析
将引擎Collection依赖YTool的clone方法提到引擎Tool中。
 
引擎Tool
```js
 namespace("YE.Tool").array = {
        /*返回一个新的数组，元素与array相同（地址不同）*/
        clone: function (array) {
            var new_array = new Array(array.length);
            for (var i = 0, _length = array.length; i < _length; i++) {
                new_array[i] = array[i];
            }
            return new_array;
        }
    };
``` 
 对应修改引擎Collection
```js
          getChilds: function () {
                return YE.Tool.array.clone(this._childs);
            },
```
 
##重构提炼的引擎类
###重构Collection
引擎Collection重命名appendChild、appendChilds为addChild、addChilds：
 
引擎Collection
```js
addChild: function (child) {
…
},
addChilds: function (childs) {
…
},
``` 
 
 
###重构Layer
现在引擎Layer依赖炸弹人Config定义的枚举值State：
引擎Layer
```js
        Private: {
            __state: bomberConfig.layer.state.CHANGE,
        …
        Protected: {
        …
            P_isChange: function () {
                return this.__state === bomberConfig.layer.state.CHANGE;
            },
            P_isNormal: function () {
                return this.__state === bomberConfig.layer.state.NORMAL;
            },
        …

        Public: {
        …
            setStateNormal: function () {
                this.__state = bomberConfig.layer.state.NORMAL;
            },
            setStateChange: function () {
                this.__state = bomberConfig.layer.state.CHANGE;
            },
```
因为引擎Layer不应该依赖用户类，因此应该将枚举值State移到引擎类中。又因为State为画布状态，与引擎Layer相关，因此将其提出来直接放到引擎Layer中，解除引擎Layer对炸弹人Config的依赖。

引擎Layer
```js
	//定义State枚举值
    var State = {
        NORMAL: 0,
        CHANGE: 1
    };

    namespace("YE").Layer = YYC.AClass(YE.Collection, {
        Init: function () {
        },
        Private: {
            __state: State.CHANGE, 
…
        Protected: {
… 
            P_isChange: function () {
                return this.__state === State.CHANGE;
            },
            P_isNormal: function () {
                return this.__state === State.NORMAL;
            },
…
        Public: {
…
            setStateNormal: function () {
                this.__state = State.NORMAL;
            },
            setStateChange: function () {
                this.__state = State.CHANGE;
            },
```


##炸弹人使用提炼的引擎类 
###炸弹人层类改为继承引擎Layer
由于引擎Layer的使用方式为继承重写，所以修改炸弹人BombLayer、CharacterLayer、FireLayer、MapLayer、PlayerLayer，继承引擎Layer：
```js
var BombLayer = YYC.Class(YE.Layer, {
…

var CharacterLayer = YYC.Class(YE.Layer, {
…

var FireLayer = YYC.Class(YE.Layer, {
…

var MapLayer = YYC.Class(YE.Layer, {
…

var PlayerLayer = YYC.Class(YE.Layer, {
```
 
##领域模型
![](http://images.cnitblog.com/blog/419321/201412/112127358066621.jpg) 
 




<a name="Sprite"></a>  
#提出Sprite、Config和collision
现在应该提出Sprite类，使引擎Layer依赖引擎Sprite。
##提炼引擎类
领域类Sprite为精灵类，对应炸弹人的Sprite。
炸弹人Sprite作为抽象类，提炼了炸弹人精灵类的共性，具有通用性，因此将其直接提取到引擎中。
引擎Sprite
```js
(function () {
    namespace("YE").Sprite = YYC.AClass({
        Init: function (data, bitmap) {
            this.bitmap = bitmap;

            if (data) {
                //初始坐标
                this.x = data.x;
                this.y = data.y;

                this.defaultAnimId = data.defaultAnimId;
                this.anims = data.anims;
            }
        },
        Private: {
            //更新帧动画
            _updateFrame: function (deltaTime) {
                if (this.currentAnim) {
                    this.currentAnim.update(deltaTime);
                }
            }
        },
        Public: {
            //bitmap实例
            bitmap: null,

            //精灵的坐标
            x: 0,
            y: 0,

            //精灵动画集合
            anims: null,
            //默认的动画id
            defaultAnimId: null,

            //当前的Animation.
            currentAnim: null,

            //设置当前动画
            setAnim: function (animId) {
                this.currentAnim = this.anims[animId];
            },
            //重置当前帧
            resetCurrentFrame: function (index) {
                this.currentAnim && this.currentAnim.setCurrentFrame(index);
            },
            //取得精灵的碰撞区域,
            getCollideRect: function () {
                var obj = {
                    x: this.x,
                    y: this.y,
                    width: this.bitmap.width,
                    height: this.bitmap.height
                };

                return YE.collision.getCollideRect(obj);
            },
            Virtual: {
                init: function () {
                    //初始化时显示默认动画
                    this.setAnim(this.defaultAnimId);
                },
                // 更新精灵当前状态.
                update: function (deltaTime) {
                    this._updateFrame(deltaTime);
                },
                //获得坐标对应的方格坐标（向下取值）
                getCellPosition: function (x, y) {
                    return {
                        x: Math.floor(x / YE.Config.WIDTH),
                        y: Math.floor(y / YE.Config.HEIGHT)
                    }
                },
                draw: function (context) {
                    context.drawImage(this.bitmap.img, this.x, this.y, this.bitmap.width, this.bitmap.height);
                },
                clear: function (context) {
                    //直接清空画布区域
                    context.clearRect(0, 0, YE.Config.canvas.WIDTH, YE.Config.canvas.HEIGHT);
                }
            }
        }
    });
}());
```
##重构提炼的引擎类
###提出Config 
现在引擎Sprite引用了炸弹人Config类定义的“方格大小”和“画布大小”：
引擎Sprite
```js
                getCellPosition: function (x, y) {
                    return {
                        x: Math.floor(x / bomberConfig.Config.WIDTH),
                        y: Math.floor(y / bomberConfig.Config.HEIGHT)
                    }
                },
…
                clear: function (context) {
                    context.clearRect(0, 0, bomberConfig.Config.canvas.WIDTH, bomberConfig.Config.canvas.HEIGHT);
                }
```
有下面几个问题：
1、引擎Sprite依赖了炸弹人Config，违背了引擎设计原则“不应该依赖用户”。 
2、“方格大小”和“画布大小”与精灵无关，因此不应该像引擎Layer的枚举值State一样放在Sprite中
因此，引擎提出Config配置类，将“方格大小”和“画布大小”放在其中，使引擎Sprite依赖引擎Config。
引擎Config
```js
namespace("YE").Config = {
    //方格宽度
    WIDTH: 30,
    //方格高度
    HEIGHT: 30,

    //画布
    canvas: {
        //画布宽度
        WIDTH: 600,
        //画布高度
        HEIGHT: 600
    }
``` 
对应修改引擎Sprite，依赖引擎Config
引擎Sprite
```js
                getCellPosition: function (x, y) {
                    return {
                        x: Math.floor(x / YE.Config.WIDTH),
                        y: Math.floor(y / YE.Config.HEIGHT)
                    }
                },
…
                clear: function (context) {
                    context.clearRect(0, 0, YE.Config.canvas.WIDTH, YE.Config.canvas.HEIGHT);
                }
```
####待重构点
引擎Config应该放置与引擎相关的、与用户逻辑无关的配置属性，而“方格大小”和“画布大小”与具体的游戏逻辑相关，属于用户逻辑，不应该放在引擎Config中。
另外，引擎Sprite访问了“方格大小”和“画布大小”，混入了用户逻辑。因此引擎Sprite还需要进一步提炼和抽象。
这个重构放到第二次迭代中进行。

####炸弹人和引擎都有Config配置类，两者有什么区别？
炸弹人Config放置与用户逻辑相关的配置属性，引擎Config放置与引擎相关的配置属性，炸弹人类应该只访问炸弹人的Config类，而引擎类应该只访问引擎Config类。

###提出collision
引擎Sprite使用了炸弹人collision的getCollideRect方法来获得碰撞区域数据：
引擎Sprite
```js
            getCollideRect: function () {
…
                return YYC.Tool.collision.getCollideRect(obj);
            },
```

考虑到炸弹人collision是一个碰撞算法类，具有通用性，因此将其提取到引擎中。
引擎collision
```js
namespace("YE").collision = (function () {
    return {
        //获得精灵的碰撞区域,
        getCollideRect: function (obj) {
            return {
                x1: obj.x,
                y1: obj.y,
                x2: obj.x + obj.width,
                y2: obj.y + obj.height
            }
        },
        //矩形和矩形间的碰撞
        col_Between_Rects: function (obj1, obj2) {
            var rect1 = this.getCollideRect(obj1);
            var rect2 = this.getCollideRect(obj2);

            if (rect1 && rect2 && !(rect1.x1 >= rect2.x2 || rect1.y1 >= rect2.y2 || rect1.x2 <= rect2.x1 || rect1.y2 <= rect2.y1)) {
                return true;
            }
            return false;
        }
    };
}());
```
对应修改引擎Sprite，依赖引擎collision
```js
            getCollideRect: function () {
…
                return YE.collision.getCollideRect(obj);
            },
``` 
##炸弹人使用提炼的引擎类
###炸弹人精灵类改为继承引擎Sprite
由于引擎Sprite的使用方式为继承重写，所以修改炸弹人的具体精灵类BombSprite、FireSprite、MapElementSprite、MoveSprite，继承引擎Sprite类
```js
var BombSprite= YYC.Class(YE.Sprite, {
…

var FireSprite = YYC.Class(YE.Sprite, {
…

var MapElementSprite = YYC.Class(YE.Sprite, {
…

var MoveSprite = YYC.Class(YE.Sprite, {
…
```
 
###炸弹人改为依赖引擎collision
因为炸弹人collision提取到引擎中了，因此炸弹人改为依赖引擎的collision。
炸弹人BombSprite
```js
collideFireWithCharacter: function (sprite) {
…
    if (YE.collision.col_Between_Rects(fire, obj2)) {
        return true;
    }
```
炸弹人EnemySprite
```js
collideWithPlayer: function (sprite2) {
…
    if (YE.collision.col_Between_Rects(obj1, obj2)) {
        throw new Error();
    }
```


##领域模型
![](http://images.cnitblog.com/blog/419321/201412/112128052596686.jpg)

 
 
 
<a name="Factory"></a>  
#提出Factory
现在提炼Factory类。
##思考
有两个问题需要思考：
1、哪些引擎类需要工厂。
2、用哪种方式实现工厂。

对于第1个问题，目前我认为抽象类不需要工厂（第二次迭代中抽象类Scene、Layer、Sprite也会加上工厂方法create，使得用户可直接使用这些引擎类），其它非单例的类都统一用工厂创建实例。
 
对于第2个问题，有以下两个选择：
1、与炸弹人代码一样，提出工厂类LayerFactory、SpriteFactory，分别负责创建引擎Layer、Sprite的实例
2、直接在类中提出create静态方法，负责创建自身的实例
 
考虑到工厂只需要负责创建实例，没有复杂的逻辑，因此采用第二个选择，引擎所有的非单例类都提出create静态方法。 
##修改引擎类
目前只有引擎ImgLoader需要增加create方法
引擎ImgLoader 
```js
    Static: {
        create: function(){
            return new this();
        }
    }
``` 
对应修改引擎Main，使用引擎ImgLoader的create方法创建它的实例
```js
            getInstance: function () {
                if (_instance === null) {
                    _instance = new this();
                    _instance.imgLoader = YE.ImgLoader.create();
                }
                return _instance;
            },
```  



<a name="Animation"></a> 
#提出Animation
提炼Animation类，使引擎Sprite依赖引擎Animation。
##提炼引擎类
领域类Animation负责控制帧动画的播放,对应炸弹人Animation类。
该类负责帧动画的控制，具有通用性，因此将其提取到引擎中 
引擎Animation
```js 
 (function () {
    namespace("YE").Animation = YYC.Class({
        Init: function (config) {
            this._frames = YE.Tool.array.clone(config);
            this._init();
        },
        Private: {
            //帧数据
            _frames: null,
            _frameCount: -1,
            _img: null,
            _currentFrame: null,
            _currentFrameIndex: -1,
            _currentFramePlayed: -1,

            _init: function () {
                this._frameCount = this._frames.length;

                this.setCurrentFrame(0);
            }
        },
        Public: {
            setCurrentFrame: function (index) {
                this._currentFrameIndex = index;
                this._currentFrame = this._frames[index];
                this._currentFramePlayed = 0;
            },
            /**
             * 更新当前帧
             * @param deltaTime 主循环的持续时间
             */
            update: function (deltaTime) {
                //如果没有duration属性（表示动画只有一帧），则返回（因为不需要更新当前帧）
                if (this._currentFrame.duration === undefined) {
                    return;
                }

                //判断当前帧是否播放完成
                if (this._currentFramePlayed >= this._currentFrame.duration) {
                    //播放下一帧

                    if (this._currentFrameIndex >= this._frameCount - 1) {
                        //当前是最后一帧,则播放第0帧
                        this._currentFrameIndex = 0;
                    } else {
                        //播放下一帧
                        this._currentFrameIndex++;
                    }
                    //设置当前帧
                    this.setCurrentFrame(this._currentFrameIndex);

                } else {
                    //增加当前帧的已播放时间.
                    this._currentFramePlayed += deltaTime;
                }
            },
            getCurrentFrame: function () {
                return this._currentFrame;
            }
        },

        Static: {
            create: function(config){
                return new this(config);
            }
        }

    });
}());
``` 

##炸弹人使用提炼的引擎类
###炸弹人改为创建引擎Animation实例
修改炸弹人SpriteData，改为创建引擎Animation实例
炸弹人SpriteData
```js
anims: {
    "stand_right": YE.Animation.create(getFrames("player", "stand_right")),
…
```

##重构引擎
引擎Animation改为依赖引擎Tool的clone方法
引擎Animation
```js
        Init: function (config) {
            this._frames = YE.Tool.array.clone(config);
…
        },
``` 


##领域模型
![](http://images.cnitblog.com/blog/419321/201412/112126430874282.jpg)

 
 
<a name="AI"></a>  
#提出AI
现在提炼AI类。
##提炼引擎类
领域类AI负责实现人工智能算法，对应炸弹人使用的碰撞算法和寻路算法。碰撞算法已经提炼到引擎中了（提炼为引擎collision），寻路算法对应炸弹人FindPath类，它实现了A*寻路算法，属于通用的算法，应该将其提取到引擎中。
然而“FindPath”这个名字范围太大了，应该重命名为实际采用的寻路算法的名字，因此将其重命名为AStar。 
引擎AStar
```js
(function () {
…
    function aCompute(mapData, begin, end) {
…
	//8方向寻路
        if (bomberConfig.algorithm.DIRECTION == 8) {
…
	//4方向寻路
        if (bomberConfig.algorithm.DIRECTION == 4) {
…
}
…


    namespace("YE").AStar = {
        aCompute: function (terrainData, begin, end) {
…
            return aCompute(terrainData, begin, end);
        }
    };
}());
```

##重构提炼的引擎类
###用户能够设置寻路方向数为4或者为8
现在引擎AStar直接读取炸弹人Config中配置的寻路方向数algorithm.Director，导致引擎AStar依赖用户类，违反了引擎设计原则。
因此，引擎AStar增加setDirection方法，由用户调用该方法来设置寻路方向数，并删除炸弹人Config的algorithm属性。


引擎AStar
```js
…
        DIRECTION = 4;  //默认为4方向寻路
…
if (DIRECTION == 8) {
…
if (DIRECTION == 4) {
…
    namespace("YE").AStar = {
…
        /**
         * 设置寻路方向
         * @param direction 4或者8
         */
        setDirection: function (direction) {
            DIRECTION = direction;
        }
}
```

##炸弹人使用提炼的引擎类
修改炸弹人EnemySprite，在构造函数中设置寻路的方向数为4，并改为调用引擎AStar的aCompute方法来寻路。
炸弹人EnemySprite
```js
        Init: function (data, bitmap) {
…
            YE.AStar.setDirection(4);
…
        },
        Private: {
            ___findPath: function () {
                return YE.AStar.aCompute(window.terrainData, this.___computeCurrentCoordinate(), this.___computePlayerCoordinate()).path
            },
``` 
 
##领域模型 
![](http://images.cnitblog.com/blog/419321/201412/112126544627990.jpg)
 
 
 
 
 
 
<a name="EventManager"></a> 
#提出EventManager和Event
现在提炼EventManager类。
##提炼引擎类
领域类EventManager负责事件的监听和移除，与炸弹人KeyCodeMap、KeyState以及KeyEventManager对应。

炸弹人KeyCodeMap、KeyState以及KeyEventManager都在KeyEventManager.js文件中，先来看下这个文件：
KeyEventManager.js
```js
 (function () {
    //枚举值
    var keyCodeMap = {
        LEFT: 65, // A键
        RIGHT: 68, // D键
        DOWN: 83, // S键
        UP: 87, // W键
        SPACE: 32   //空格键
    };
    //按键状态
    var keyState = {
    };

    keyState[keyCodeMap.LEFT] = false;
    keyState[keyCodeMap.RIGHT] = false;
    keyState[keyCodeMap.UP] = false;
    keyState[keyCodeMap.DOWN] = false;
    keyState[keyCodeMap.SPACE] = false;

    //键盘事件管理类
    var KeyEventManager = YYC.Class({
        Private: {
            _keyDown: function () {
            },
            _keyUp: function () {
            }
        },
        Public: {
            addKeyDown: function () {
                this._keyDown = YYC.Tool.event.bindEvent(this, function (e) {
                    keyState[e.keyCode] = true;

                    e.preventDefault();
                });

                YYC.Tool.event.addEvent(document, "keydown", this._keyDown);
            },
            removeKeyDown: function () {
                YYC.Tool.event.removeEvent(document, "keydown", this._keyDown);
            },
            addKeyUp: function () {
                this._keyUp = YYC.Tool.event.bindEvent(this, function (e) {
                    keyState[e.keyCode] = false;
                });

                YYC.Tool.event.addEvent(document, "keyup", this._keyUp);
            },
            removeKeyUp: function () {
                YYC.Tool.event.removeEvent(document, "keyup", this._keyUp);
            }
        }
    });

    window.keyCodeMap = keyCodeMap;
    window.keyState = keyState;
    window.keyEventManager = new KeyEventManager();
}());
```

###提出KeyCodeMap
KeyCodeMap是键盘按键的枚举值，因为所有浏览器中的键盘按键值都一样，因此具有通用性，可以将其提取到引擎中。
###不提出KeyState
炸弹人KeyState是存储当前按键状态的容器类，与用户逻辑相关，因此不提取到引擎中。
###从KeyEventManager中提出EventManager
炸弹人KeyEventManager负责键盘事件的监听和移除，可以从中提出一个通用的、负责所有事件的监听和移除的引擎类EventManager。
另外，将事件类型（如"keydown"、"keyup"）提取为枚举值EventType，从而对用户隔离具体的事件类型的变化。

###提出事件枚举类Event
引擎增加Event类，放置KeyCodeMap和EventType枚举值。

引擎EventManager
```js
(function () {
    var _keyListeners = {};

    namespace("YE").EventManager = {
        _getEventType: function (event) {
            var eventType = "",
                e = YE.Event;

            switch (event) {
                case e.KEY_DOWN:
                    eventType = "keydown";
                    break;
                case e.KEY_UP:
                    eventType = "keyup";
                    break;
                case e.KEY_PRESS:
                    eventType = "keypress";
                    break;
                default:
                    throw new Error("事件类型错误");
            }

            return eventType;
        },
        addListener: function (event, handler) {
            var eventType = "";

            eventType = this._getEventType(event);

            YYC.Tool.event.addEvent(window, eventType, handler);
            this._registerEvent(eventType, handler);
        },
        _registerEvent: function (eventType, handler) {
            if (_keyListeners[eventType] === undefined) {
                _keyListeners[eventType] = [handler];
            }
            else {
                _keyListeners[eventType].push(handler);
            }
        },
        removeListener: function (event) {
            var eventType = "";

            eventType = this._getEventType(event);

            if (_keyListeners[eventType]) {
                _keyListeners[eventType].forEach(function (e, i) {
                    YYC.Tool.event.removeEvent(window, eventType, e);
                })
            }

        }
    };
}());
```
引擎Event
```js
namespace("YE").Event = {
    //事件枚举值
    KEY_DOWN: 0,
    KEY_UP: 1,
    KEY_PRESS: 2,

    //按键枚举值
    KeyCodeMap: {
        LEFT: 65, // A键
        RIGHT: 68, // D键
        DOWN: 83, // S键
        UP: 87, // W键
        SPACE: 32   //空格键
    }
};
```
###待重构点
目前引擎只支持键盘事件，以后可以通过“增加Event事件枚举值，并对应修改EventManager的_getEventType方法”的方式来增加更多的事件支持。


##重构提炼的引擎类
###将依赖的YTool方法移到Tool
引擎类依赖了YTool事件操作方法addEvent和removeEvent，考虑到YTool的event中的事件操作方法都具有通用性，因此将其提取到引擎Tool类中
又因为YTool的event对象依赖YTool的judge对象的方法，所以将judge对象的相关的方法提取到引擎Tool中。
引擎Tool
```js
namespace("YE.Tool").judge = {
…
    /**
     * 判断是否为jQuery对象
     */
    isjQuery: function (ob) {
        …
    },
    /**
     * 检查宿主对象是否可调用
     *
     * 任何对象，如果其语义在ECMAScript规范中被定义过，那么它被称为原生对象；
     环境所提供的，而在ECMAScript规范中没有被描述的对象，我们称之为宿主对象。

     该方法用于特性检测，判断对象是否可用。用法如下：

     MyEngine addEvent():
     if (Tool.judge.isHostMethod(dom, "addEventListener")) {    //判断dom是否具有addEventListener方法
            dom.addEventListener(sEventType, fnHandler, false);
            }
     */
    isHostMethod: (function () {
        …
    }())
};
namespace("YE.Tool").event = (function () {
    return {
        bindEvent: function (object, fun) {
            …
        },
        /* oTarget既可以是单个dom元素，也可以是jquery集合。
         如：
         Tool.event.addEvent(document.getElementById("test_div"), "mousedown", _Handle);
         Tool.event.addEvent($("div"), "mousedown", _Handle);
         */
        addEvent: function (oTarget, sEventType, fnHandler) {
            …
        },
        removeEvent: function (oTarget, sEventType, fnHandler) {
            …
        },
        wrapEvent: function (oEvent) {
            …
        },
        getEvent: function () {
            …
        }
    }
}()); 
```


###提炼通用的KeyCodeMap
现在引擎KeyCodeMap的枚举变量与用户逻辑有关，定死了上下左右移动对应的按键keyCode值（如左对应A键，右对应D键）：
引擎Event
```js
    KeyCodeMap: {
        LEFT: 65, // A键
        RIGHT: 68, // D键
        DOWN: 83, // S键
        UP: 87, // W键
        SPACE: 32   //空格键
    }
```
然而对于不同的游戏，它的上下左右对应的按键可能不同。
因此KeyCodeMap应该只定义按键对应的keyCode值，由用户来决定上下左右移动对应的按键。
引擎Event
```js
    KeyCodeMap: {
        A: 65,
        D: 68,
        S: 83,
        W: 87,
        SPACE: 32 
    }
```

##炸弹人使用提炼的引擎类
###修改炸弹人Game的初始化事件逻辑
**修改前**
炸弹人实现了监听事件的逻辑：
炸弹人Game
```js
            _initEvent: function () {
                //监听整个document的keydown,keyup事件
                keyEventManager.addKeyDown();
                keyEventManager.addKeyUp();
            },
```
炸弹人KeyEventManager
```js
    addKeyDown: function () {
                this._keyDown = YYC.Tool.event.bindEvent(this, function (e) {
                    keyState[e.keyCode] = true;

                    e.preventDefault();
                });

                YYC.Tool.event.addEvent(document, "keydown", this._keyDown);
            },
            addKeyUp: function () {
                this._keyUp = YYC.Tool.event.bindEvent(this, function (e) {
                    keyState[e.keyCode] = false;
                });

                YYC.Tool.event.addEvent(document, "keyup", this._keyUp);
            },
```


**修改后**
炸弹人调用引擎EventManager API和传入键盘事件的枚举值来监听键盘事件：
炸弹人Game
```js
            _initEvent: function () {
                //调用引擎EventManager的addListener绑定事件，传入引擎Event定义的事件类型枚举值，并定义事件处理方法
                YE.EventManager.addListener(YE.Event.KEY_DOWN, function (e) {
                    window.keyState[e.keyCode] = true;

                    e.preventDefault();
                });
                YE.EventManager.addListener(YE.Event.KEY_UP, function (e) {
                    window.keyState[e.keyCode] = false;
                });
            }
```

###删除炸弹人KeyEventManager.js文件中的KeyCodeMap和KeyEventManager，并将该文件重命名为KeyState
因为炸弹人KeyEventManager.js中的KeyCodeMap和KeyEventManager已经移到引擎中了，所以删除它们，只保留keyState，并重命名文件为KeyState.js。

炸弹人KeyState
```js
(function () {
    //按键状态
    var keyState = {
    };

    keyState[keyCodeMap.LEFT] = false;
    keyState[keyCodeMap.RIGHT] = false;
    keyState[keyCodeMap.UP] = false;
    keyState[keyCodeMap.DOWN] = false;
    keyState[keyCodeMap.SPACE] = false;

    window.keyState = keyState;
}());
```

###炸弹人改为使用引擎Event的KeyCodeMap
如对应修改炸弹人KeyState和PlayerLayer
炸弹人KeyState
```js
    keyState[YE.Event.KeyCodeMap.A] = false;
    keyState[YE.Event.KeyCodeMap.D] = false;
    keyState[YE.Event.KeyCodeMap.W] = false;
    keyState[YE.Event.KeyCodeMap.S] = false;
    keyState[YE.Event.KeyCodeMap.SPACE] = false;
```
炸弹人PlayerLayer
```js
            ___keyDown: function () {
                if (keyState[YE.Event.KeyCodeMap.A] === true || keyState[YE.Event.KeyCodeMap.D] === true
                    || keyState[YE.Event.KeyCodeMap.W] === true || keyState[YE.Event.KeyCodeMap.S] === true) {
                    return true;
                }
                else {
                    return false;
                }
            },
```



##领域模型
![](http://images.cnitblog.com/blog/419321/201412/112127209004769.jpg)




<a name="DataOperator"></a>  
#提出DataOperator
 
现在提炼DataOperator类。

##提炼引擎类
领域类DataOperator负责对数据进行读、写操作，对应炸弹人数据操作层的类，具体为MapDataOperate、GetPath、TerrainDataOperate、GetSpriteData、GetFrames。
这些数据操作类都与具体的业务逻辑相关，没有可提炼的。
 
 

<a name="Data"></a> 
#提出Data
现在提炼Data类。
##提炼引擎类 
领域类Data负责保存游戏数据，对应炸弹人的数据层的类，具体为MapData、Bitmap、ImgPathData、TerrainData、SpriteData、FrameData。
其中Bitmap是图片的包装类，包含与图片本身密切相关的属性和方法，但不包含与游戏相关的具体图片，因此具有通用性，可提取到引擎中。
 
引擎Bitmap
```js
(function () {
    namespace("YE").Bitmap = YYC.Class({
        Init: function (data) {
            this.img = data.img;
            this.width = data.width;
            this.height = data.height;
        },
        Private: {
        },
        Public: {
            img: null,
            width: 0,
            height: 0
        }
    });
}()); 
``` 
 
 
##炸弹人使用提炼的引擎类
修改炸弹人BitmapFactory，改为创建引擎的Bitmap实例
炸弹人BitmapFactory 
```js
(function () {
    var bitmapFactory = {
        createBitmap: function (data) {
…
            return new YE.Bitmap(bitmapData);
        }
    }

    window.bitmapFactory = bitmapFactory;
}());
``` 
##领域模型
![](http://images.cnitblog.com/blog/419321/201412/112127036503299.jpg)
 
 
 
<a name="model"></a> 
#本文最终领域模型
![](http://images.cnitblog.com/blog/419321/201412/112126334319131.jpg)

此处炸弹人省略了与引擎类无关的类。


<a name="module"></a> 
#高层划分
##包图
![](http://images.cnitblog.com/blog/419321/201412/112128203375526.jpg) 


 
##对应领域模型

 - 核心包
放置引擎的核心类。
    - Main
    - Director
    - Scene
    - Layer
    - Sprite
 - 算法包
放置通用的算法类。
    - AStar
    - collision
 - 动画包
放置游戏动画的相关类。
    - Animation
 - 加载包
负责游戏资源的加载和管理。
    - ImgLoader
 - 数据结构包
放置引擎的基础结构类。
    - Bitmap
 - 集合包
放置引擎集合类。
    - Collection
    - Hash
 - 通用工具包
放置引擎通用的方法类。
    - Tool
 - 配置包
放置引擎配置类。
    - Config
 - 事件管理包
负责事件的管理。
    - Event
    - EventManager


**引擎集合类也属于数据结构，为什么不放在数据结构包中，而是放在单独的集合包中？**
因为引擎集合类的使用方式为继承，而数据结构包中的引擎Bitmap的使用方式为委托，两者使用方式不同，因此不能放到一个包中。


<a name="summary"></a> 
#总结
本文将炸弹人通用的类提炼到了引擎中，搭建了引擎的整体框架。但是现在引擎还很粗糙，包含了很多炸弹人逻辑，不具备通用性。因此，在下文中，我会进行第二次迭代，对引擎进行进一步的抽象和提炼。


<a name="code"></a> 
#本文源码下载
[GitHub](https://github.com/yyc-git-show/extractEngine_code/tree/master/3)

<a name="reference"></a> 
#参考资料
[炸弹人游戏系列](http://www.cnblogs.com/chaogex/tag/%E7%82%B8%E5%BC%B9%E4%BA%BA%E6%B8%B8%E6%88%8F/)

#上一篇博文
[提炼游戏引擎系列：初步设计引擎](http://www.cnblogs.com/chaogex/p/4152381.html )

#下一篇博文
[提炼游戏引擎系列：第二次迭代（上）](http://www.cnblogs.com/chaogex/p/4164074.html )]]></description></item><item><title>提炼游戏引擎系列：初步设计引擎</title><link>http://www.cnblogs.com/chaogex/archive/2014/12/09/4152381.html</link><dc:creator>yyc元超</dc:creator><author>yyc元超</author><pubDate>Tue, 09 Dec 2014 00:18:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/12/09/4152381.html</guid><description><![CDATA[#前言
本文为后续引擎提炼定下了一个大致的方向，没有给出完整的引擎架构。这就够了！让我们在具体开发过程中再来从底向上设计吧！
 
 
#本文目的
1、进行引擎提炼的前期规划，明确引擎提炼的整体流程和引擎的非功能性需求。
2、从炸弹人领域模型中提炼出精简的领域模型，作为炸弹人的参考模型。
3、从炸弹人参考模型中提炼出抽象的领域模型，作为引擎的初步领域模型。
 
 
#本文主要内容
<ul>
    <li><a href="#plan">前期规划</a></li>
    <li><a href="#review">回顾炸弹人设计</a></li>
    <li><a href="#design">初步设计引擎</a></li>
</ul>

<a name="plan"></a>
#前期规划
##开发流程
引擎提炼的整个流程如下图所示：
![](http://images.cnitblog.com/blog/419321/201412/090709426182507.jpg)
###说明
•	回顾炸弹人游戏
介绍炸弹人游戏的基本情况，回顾炸弹人游戏的设计

•	初步设计引擎
给出引擎的初步设计，从炸弹人领域模型中提炼出一个精简的领域模型，作为炸弹人的参考模型，再从中提炼出一个抽象的领域模型，作为引擎的初步领域模型

•	第一次迭代
参考引擎的初步领域模型，从炸弹人参考模型中提炼出对应的通用类和基础的引擎框架，使引擎具备游戏入口、预加载、主循环、层、精灵、动画、事件管理等基本功能，并将炸弹人游戏改造为基于引擎实现，通过测试。
•	第二次迭代
进一步提炼炸弹人类和引擎类，提炼通用模式，消除引擎中的用户逻辑，进行引擎的整体梳理和修改，对应修改炸弹人游戏，通过测试。

本文进行“回顾炸弹人游戏”和“初步设计引擎”这两个步骤。


##引擎非功能性需求
1、可测试性
引擎是一个可复用的组件，应该保证正确和可测试。
方案：编写全覆盖引擎的单元测试。
炸弹人游戏有完整的单元测试，可以将其修改为引擎的单元测试。

注：本系列不会讨论测试。
2、可扩展性
本系列提炼的引擎还不完善，后续会加入更多的功能，因此引擎需要具有灵活的架构，满足开闭原则，方便以后的扩展。
引擎应该支持插件化开发，独立功能的模块可以作为通用插件从引擎中独立出去，由用户选择是否引入到引擎中。
方案：基于高内聚低耦合的总体思想，使用面向对象思想，复用炸弹人游戏中可扩展性的模块，从中提炼引擎，保持良好的引擎架构。

3、可读性
引擎应该具备良好的可读性，易于后续开发时理解之前的设计，方便他人理解引擎的实现。
方案：
（1）保持代码整洁
（2）只保留必要的注释
（3）编写必要的文档
（4）通过良好的命名和测试用例来辅助读者理解代码
（5）代码风格应该统一


<a name="review"></a> 
#回顾炸弹人设计
本节会介绍炸弹人游戏的基本情况，让大家有个整体印象。
##炸弹人系列博文
[炸弹人游戏开发系列](http://www.cnblogs.com/chaogex/tag/%E7%82%B8%E5%BC%B9%E4%BA%BA%E6%B8%B8%E6%88%8F/)
##炸弹人源码下载
[炸弹人源码下载](https://github.com/yyc-git/Bomber)
 
##炸弹人外部依赖
在炸弹人游戏中，我使用了以下的库：
第三方库
•	jQuery
使用它的选择器，进行dom操作。
•	progressBar
这是一个jQuery的进度条插件，我用它来显示预加载图片的进度。
•	jasmine
这是一个测试框架，使用它可以进行Javascript单元测试。
我的库
•	YOOP（命名空间：YYC.Class、YYC.AClass、YYC.Interface）
这是我的Javascript的oop框架。具体可参见[发布我的Javascript OOP框架YOOP](http://www.cnblogs.com/chaogex/archive/2013/06/07/3123999.html)。
•	图片预加载控件PreLoadImg（命名空间：YYC.Control）
•	工具库YTool（命名空间：YYC.Tool）
我的工具方法库。
•	jsExtend
Javascript原生对象扩展，对js的String和Array对象进行了扩展。
•	模式库（命名空间：YYC.Pattern）
包括创建对象模式的命名空间方法namespace和观察者模式的Observer.js



##炸弹人的概念层次结构

![](http://images.cnitblog.com/blog/419321/201412/090648320257280.jpg)
 
##炸弹人领域模型 
炸弹人游戏的领域模型如下图所示：
![](http://images.cnitblog.com/blog/419321/201412/090648377598262.jpg) 
<a target="_blank" href="http://images.cnitblog.com/blog/419321/201412/090648377598262.jpg">查看大图</a>
 
<a name="design"></a> 
#初步设计引擎
本节提出了我在实践过程中总结的引擎设计原则，以及炸弹人的参考模型和引擎的初步领域模型，为后面的引擎提炼打下了基础。
##引擎设计原则
1、引擎不应该依赖用户，用户应该依赖引擎
![](http://images.cnitblog.com/blog/419321/201412/090648261039055.jpg)

引擎应该保持通用性，不应该包含用户逻辑。


2、尽量减少引擎依赖的外部文件
因为：
（1）增加引擎的不稳定性
依赖的外部文件变化时，引擎也需要对应修改。
（2）外部文件不一定完全适合引擎
外部文件不是基于引擎开发的，可能需要对其进行改造，从而适合引擎的需要。但是由于外部文件不稳定或者对外部文件实现不了解等原因，想要针对引擎的具体情况进行改造比较困难。
（3）加大用户负担
引擎可能只需要使用外部文件的一小部分，但是却需要引入整个外部文件，这会增加引擎的整个文件大小，加大用户负担。

所以：
（1）如果必须要依赖，也尽量依赖自己开发的库，而不要依赖第三库。
（2）第三方库可以作为插件引入到引擎中，由用户自行选择。
（3）可考虑将第三方库改造为引擎的内部库。
a.如果引擎依赖的是自己开发的、没有发布的库，则可以直接引入，作为引擎的内部库
因为自己开发的、独立发布的库需要独立变化，不应该与引擎绑到一起。
b.如果引擎只依赖第三方库的部分内容，则可将依赖的第三方库的最小集提取为引擎的内部库。


3、引擎应该具有很好的可扩展性
这里可扩展性包括两个方面：引擎可扩展性和用户可扩展性。
（1）引擎可扩展性
在前面的非功能性需求中已经说过了，引擎应该具有灵活的架构，方便以后的扩展。
（2）用户可扩展性
用户可扩展性指用户可以插入自己的逻辑到引擎中，实现引擎的变化点。


4、尽量减少用户负担
引擎应该实现底层逻辑，用户只负责实现业务逻辑。
引擎应该尽量封装高层API，提供给用户使用，减少用户的工作量。


##代码组织方式
文件组织方式一般有两种：
1、使用js模块加载器（如sea.js）。在沙箱环境中，将需要引用的文件加载进来，然后通过局部变量名来使用。
2、使用命名空间。

因为：
（1）引擎文件数量不是很多，还不需要用模块加载器。
（2）如果使用模块加载器，则引擎必须依赖模块加载器，用户使用引擎时也必须按照模块加载器的方式来引用引擎文件，这样会增加复杂度，加大用户负担。

所以引擎采用命名空间的方式来组织文件，引擎的顶级命名空间为YE。
 
##引擎名
 
该引擎命名为YEngine2D。
 
 




##代码结构
 
炸弹人和引擎代码结构如下图所示：
![](http://images.cnitblog.com/blog/419321/201412/090653593848638.jpg)
 

 - Content
炸弹人游戏的资源文件
    - Image
图片资源文件
 - Scripts
js文件
    - bomber
炸弹人js文件
    - myTool
工具
        - frame
框架文件
        - pattern
模式文件
        - tool
工具文件
    - plugin	
外部插件
    - yEngine2D
引擎文件
 - Views
页面





##思考
1、炸弹人改造为基于引擎实现后，是否需要通过炸弹人的单元测试？
因为：
（1）在提炼引擎的过程中，引擎变动频繁，引擎变动会导致使用引擎的炸弹人变动，对应的炸弹人单元测试也会可能跟着变动。这样就需要经常修改单元测试，工作量太大。
（2）我不会二次开发炸弹人游戏，不需要维护炸弹人的单元测试。
（3）本系列的重点是提炼引擎，应该把精力都集中在引擎上。
综上所述，只对引擎进行单元测试，而不再维护炸弹人的单元测试，改为直接通过浏览器运行炸弹人游戏来进行运行测试。


2、引擎应该是通用的，还是只针对“炸弹人游戏”所属的RPG类型？
因为提炼引擎的目的是为了更快地开发游戏，不仅仅只有RPG类型，也包括其它类型的游戏，所以应该提出一个通用的引擎。
然而本系列并不能提出一个完全通用的引擎，因为我是从炸弹人游戏中提炼引擎的，该引擎只能保证适应炸弹人这种RPG类型的游戏。提炼通用引擎是一个长期任务，目前我只能在提炼引擎时尽可能地消除炸弹人游戏的用户逻辑，提高通用性。在以后的实践中，需要将该引擎尽可能多地应用到不同类型的游戏中，这样才能最终得到一个通用的游戏引擎。
##领域模型分析

###炸弹人参考模型
对炸弹人的领域模型进行精简，去掉具体的实现类，只保留必要的、能体现整个概念层次结构的和游戏框架的类：
![](http://images.cnitblog.com/blog/419321/201412/090658305718221.jpg)

精简后的领域模型即为本系列的炸弹人参考模型。
###引擎初步领域模型
对炸弹人参考模型进行抽象，提出抽象角色类（一个角色类可代表多个具体类，如DataOperate类，在炸弹人游戏中代表了MapDataOperate、GetPath等类），作为引擎的初步领域模型。
![](http://images.cnitblog.com/blog/419321/201412/120708044156625.jpg)







 - Config
全局配置类，存放游戏中的常量、枚举值、配置信息。

 - LoadResource
加载资源的类，负责加载各种资源 

 - Main
入口类，是整个系统的入口，负责启动游戏，页面只与该类耦合，该类是整个系统的入口。
 
 - Director
游戏主逻辑类，负责游戏的统一调度。

为什么命名不沿用炸弹人的“Game”？
因为“Game”这个名字范围太大，不能突出“统一调度”的职责，因此命名为“Director”更为合适


 - Scene
场景类，为集合类，从炸弹人的LayerManager抽象而来，负责管理场景。

在炸弹人游戏开发中，我从“如何统一调度各个层”的逻辑出发，提出了层管理类LayerManager。
现在可以进一步抽象，提出“场景”这个概念，游戏中可能包含多个场景（至少一个），场景类Scene与“场景”是1对1的关系，Scene不仅负责统一调度场景内各个层，还应该包含与场景的相关的属性和方法。


 - Hash 
具有哈希结构的集合类。

 - Layer
层类，为集合类，负责层内精灵的统一管理。

该类对应“[分层渲染](http://www.cnblogs.com/chaogex/p/3163357.html#layerDraw)”的概念，一个Layer对应一个画布canvas。 



 - Collection
具有线性结构的集合类。

 - Sprite
精灵类。
每一个单独的个体都是一个精灵类。如玩家、敌人、炸弹等，与该个体密切相关的属性和方法都放到该类中。
 
 - AI
人工智能类，负责实现人工智能算法，具体可以包括寻路算法、敌人的移动模式和行为设置等。

 - Factory
工厂类，负责创建类的实例，封装类的创建逻辑。
 
 - Animation
帧动画控制类，负责控制帧动画的播放。
 
 - DataOperator
数据操作类，负责对数据进行读、写操作。
 
 - Data
数据类，保存游戏数据

 - EventManager
事件管理类，负责事件的监听和移除。

#最新的引擎版本
有兴趣的话您可以看下最新的引擎版本（这个不是本系列博文提出的引擎版本，而是最新修改后的引擎版本）：
[发布HTML5 2D游戏引擎YEngine2D](http://www.cnblogs.com/chaogex/p/4088630.html)

#参考资料
[炸弹人游戏系列](http://www.cnblogs.com/chaogex/tag/%E7%82%B8%E5%BC%B9%E4%BA%BA%E6%B8%B8%E6%88%8F/)

#上一篇博文
[提炼游戏引擎系列：开篇介绍](http://www.cnblogs.com/chaogex/p/4149904.html)
#下一篇博文
[提炼游戏引擎系列：第一次迭代](http://www.cnblogs.com/chaogex/p/4158580.html)]]></description></item><item><title>提炼游戏引擎系列：开篇介绍</title><link>http://www.cnblogs.com/chaogex/archive/2014/12/07/4149904.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sun, 07 Dec 2014 13:43:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/12/07/4149904.html</guid><description><![CDATA[#前言
大家好！本系列记录了从[炸弹人游戏](http://www.cnblogs.com/chaogex/p/3151033.html)中提炼2D游戏引擎YEngine2D雏形的实战过程，您可以通过本系列了解到引擎提炼的思想、引擎的设计以及引擎是如何从游戏中提炼的，学习引擎开发的知识。希望对您能有所帮助！
为了突出重点，本系列对于炸弹人游戏的业务逻辑的变化和单元测试不会深入讨论。
值得注意的是本系列提出的游戏引擎还不够完善，需要在具体的游戏开发中继续打磨。


#系列目的
1、从炸弹人游戏中提炼一个2D游戏引擎
2、将炸弹人游戏改造为基于引擎实现。


#关键词
2D游戏引擎、YEngine2D、面向对象、提炼引擎
#系列博文目录
[提炼游戏引擎系列：开篇介绍](http://www.cnblogs.com/chaogex/p/4149904.html )
[提炼游戏引擎系列：初步设计引擎](http://www.cnblogs.com/chaogex/p/4152381.html)
[提炼游戏引擎系列：第一次迭代](http://www.cnblogs.com/chaogex/p/4158580.html)
[提炼游戏引擎系列：第二次迭代（上）](http://www.cnblogs.com/chaogex/p/4164074.html )
[提炼游戏引擎系列：第二次迭代（下）](http://www.cnblogs.com/chaogex/p/4175837.html)

##游戏引擎是什么？有什么用？
引擎就是用于控制所有游戏功能的主程序，负责计算碰撞，物体的相对位置，接受玩家的输入，以及按照正确的音量输出声音等工作，扮演着中场发动机的角色，把游戏中的所有元素捆绑在一起，在后台指挥它们有序地工作。
##为什么需要游戏引擎？
引擎封装底层实现，提供给用户高层API，使用户可以将精力放到游戏的逻辑、玩法、创意上，而不用关心游戏的底层实现。 
##为什么要自己开发引擎，而不是直接使用现有的引擎？
现在已经有了很多成熟的2D游戏引擎，为什么还要费时费力地开发一个自己的游戏引擎呢？
1、开发引擎是一种极大的乐趣，在开发的过程中可以体验创造的快乐和激情。
2、可以完全按照自己的想法打造引擎，具备完全的自主性和控制性，是研发一系列游戏的基础。
3、引擎是游戏开发的核心技术，自己开发引擎可以掌握这些技术，学习框架设计的思想，把自己的技术推向一个新的层次。

#开发引擎的流程
1、首先要具备一定的游戏开发经验。
您应该有不借助任何的游戏引擎，原生开发游戏的经验，并且掌握了2D游戏的相关概念、技术和设计经验。
如果您没有任何游戏开发的基础，可以先使用面向过程的方法开发一两个小游戏，学习游戏开发的技术，然后运用面向对象的思想，采用测试驱动的方式，重点打造一个设计良好的小游戏，从而具备从中提炼游戏引擎的基础。
2、然后学习游戏引擎的相关知识。
推荐大家可以看下《HTML5 Canvas核心技术：图形、动画与游戏开发》一书，它介绍了绘图canvas技术、动画和精灵等游戏的基本概念和实现。其中“第9章 游戏开发”还开发了一个游戏引擎，并应用到了游戏中，这章的内容对于我们学习引擎开发很有帮助。
另外，大家还可以学习下现有的Html5 2D游戏引擎，比如cocod2d-html5引擎就很不错，它具有很好的设计，是个成熟开源的引擎。我们可以先学习它的使用方法，了解它的API是如何设计的，然后在开发引擎的过程中，对应参考它的源代码，学习它的设计理念和思想。
3、接着从游戏中提炼引擎。
当我们有了一定的游戏开发经验，学习了引擎的相关知识后，就可以从我们的设计良好的游戏中提炼出游戏引擎，这个提炼过程会在本系列博文中展示。
4、最后持续地改进和优化引擎
有了初步的引擎后，还需要将它应用到更多的游戏中，在应用的过程中不断地改进引擎。
另外，光有引擎是不够的，我们还需要开发与引擎配套的游戏工具（比如动画编辑器、关卡编辑器等），打造游戏开发的闭环。


#最新的引擎版本
有兴趣的话您可以看下最新的引擎版本（这个不是本系列博文提出的引擎版本，而是最新修改后的引擎版本）：
[发布HTML5 2D游戏引擎YEngine2D](http://www.cnblogs.com/chaogex/p/4088630.html)

#最终成果
下面是本系列博文的最终成果

**[最终引擎和炸弹人Github源码](https://github.com/yyc-git-show/extractEngine_code/tree/master/4)**

#最终的领域模型
![](http://images.cnitblog.com/blog/419321/201412/202101481578290.jpg)


此处省略了炸弹人中与引擎类无关的类。 
#最终引擎的高层划分
##包图
![](http://images.cnitblog.com/blog/419321/201412/072020397642584.jpg)
##对应的领域模型

 - 核心包
放置引擎的核心类。
    - Main
    - Director
    - Scene
    - Layer
    - Sprite
 - 算法包
放置通用的算法类。
    - AStar
    - collision
 - 动画包
放置游戏动画的相关类。
    - AnimationFrame
    - Animation
    - Animate
    - Frame
 - 加载包
负责游戏资源的加载和管理。
    - ImgLoader
 - 数据结构包
放置引擎的基础结构类。
    - Collection
    - Hash
    - Bitmap
    - Geometry
 - 通用工具包
放置引擎通用的方法类。
    - Tool
 - 事件管理包
负责事件的管理。
    - Event
    - EventManager
 - 内部库包
放置引擎引入的库。
    - jsExtend

#最终引擎介绍
这里给出本系列提炼的引擎的一些简要介绍。
##引擎外部依赖
引擎依赖了Javascript的oop框架YOOP，具体可参见发布[我的Javascript OOP框架YOOP](http://www.cnblogs.com/chaogex/archive/2013/06/07/3123999.html) 


##引擎使用方式
用户可以通过以下三种方法使用引擎类：
（1）直接使用引擎类提供的API。
如用户可直接调用引擎EventManager类的 addListener方法监听事件。
（2）继承重写
用户类可继承引擎类，重写它的钩子方法和虚方法、抽象成员，插入自己的用户逻辑。
如引擎Scene、Layer、Sprite类均采用这种方式。
（3）实例重写
用户可重写引擎类实例的钩子方法，插入自己的用户逻辑。
第一次迭代提炼的引擎Main类提供了loadResouce等钩子方法，炸弹人Main可重写引擎Main的钩子，然后在页面中执行引擎Main实例的init方法，从而在开始游戏时执行炸弹人Main插入的用户逻辑。
不过在第二次迭代后，引擎Main的使用方式又改为继承重写了，因此本系列提炼的最终引擎只有1、2两种使用方式。

##用户创建动画的方式
```js
                var width = bomberConfig.player.WIDTH,
                    height = bomberConfig.player.HEIGHT,
                    offset = {
                        x: bomberConfig.player.offset.X,
                        y: bomberConfig.player.offset.Y
                    },
                    sw = bomberConfig.player.SW,
                    sh = bomberConfig.player.SH;

                //创建帧，传入精灵图片对象和帧图片区域大小数据
                var frame1 = YE.Frame.create(this.bitmap.img, YE.rect(offset.x, offset.y, sw, sh));  
                var frame2 = YE.Frame.create(this.getImg(), YE.rect(offset.x + width, offset.y, sw, sh));
…

                //创建动画帧数组，加入动画的帧
                var animFrames1 = [];

                animFrames1.push(frame1);
                animFrames1.push(frame2);
…

                //创建动画，设置动画的duration
                var animation1 = YE.Animation.create(animFrames1, 100);
…

                //将动画加入到精灵的AnimationFrame容器中
                var animationFrame = this.getAnimationFrame();

                animationFrame.addAnim("walk_down", YE.Animate.create(animation1));
…

                //设置当前播放的动画
                this.setAnim("walk_down");

```


#参考资料
[炸弹人游戏系列](http://www.cnblogs.com/chaogex/tag/%E7%82%B8%E5%BC%B9%E4%BA%BA%E6%B8%B8%E6%88%8F/)
cocos2d-html5引擎
[Lufy博客](http://blog.csdn.net/lufy_legend)
《HTML5 Canvas核心技术：图形、动画与游戏开发》


#下一篇博文
[提炼游戏引擎系列：初步设计引擎](http://www.cnblogs.com/chaogex/p/4152381.html )]]></description></item><item><title>发布HTML5 2D游戏引擎YEngine2D</title><link>http://www.cnblogs.com/chaogex/archive/2014/11/11/4088630.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Mon, 10 Nov 2014 23:26:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/11/11/4088630.html</guid><description><![CDATA[##关于YEngine2D
YEngine2D是一个开源的、采用HTML5技术和Javscript语言创建的2D游戏框架，用来构建web二维游戏。
###[GitHub地址](https://github.com/yyc-git/YEngine2D)
##最新版本
v0.1.2
##浏览器支持
Chrome
Firefox
IE9+
##外部依赖
您需要先下载[YOOP框架](https://github.com/yyc-git/YOOP)
##相关游戏
[发布HTML5 RTS游戏-古代战争](http://www.cnblogs.com/chaogex/p/4086142.html)
##特点

 - 开源免费


引擎遵循MIT协议，用户可完全自由使用。

 - 良好的设计

引擎从敏捷开发的游戏中提炼而出，具有良好的代码和模块结构，有比较好的可维护性和可扩展性。

 - 良好的可测试性


引擎非常重视单元测试，基本实现了单元测试全覆盖。

 - 使用HTML5技术，面向Web游戏开发

引擎采用最新的HTML5技术和Javascript语言开发，前端开发的同学能很快上手。

##领域模型
![](http://images.cnitblog.com/blog/419321/201411/230826475933421.jpg)


##包图
![](http://images.cnitblog.com/blog/419321/201411/162103416815705.jpg)



 - 入口

引擎YE.main提供了引擎入口，可进行游戏配置，加载用户类。

 - 基础

放置通用抽象基类。

 - 核心

包括入口类、导演类、场景类、层类、精灵类，搭建游戏开发的基本框架。

 - 动作

参考cocos2d，提出了立即动作和持续动作类，用户可创建自定义动作类。

 - 动画

提供多种方式创建动画和管理动画。

 - 算法

提供了通用的算法实现，如A*寻路算法。

 - 内部库

集成了多个库，包括：
1、jsExtend
Javascript扩展库，扩展了String和Array对象。
2、YEQuery
仿jquery的Dom操作和ajax封装库。
3、YSound
优先使用Web Audio，可回退到Html5 Audio的声音库。


 - 加载

支持图片、声音、json文件的加载。

 - 数据结构

提出了线性集合类、哈希集合类、图片数据类等。

 - UI

目前只有Canvas通用绘制封装类，后面会加入常用的UI组件。

 - 事件管理

目前支持PC的键盘和鼠标事件，后面会加入移动端事件的支持。

 - 声音管理

封装底层声音库YSound，提供游戏使用的高层api。




##升级计划
 - 建立开源社区，丰富文档
 - 优化内存
 - 改进声音加载
 - 支持移动端游戏开发
 - 加入UI组件
 - 优化性能]]></description></item><item><title>发布HTML5 RTS游戏-古代战争</title><link>http://www.cnblogs.com/chaogex/archive/2014/11/10/4086142.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Sun, 09 Nov 2014 16:34:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/11/10/4086142.html</guid><description><![CDATA[#古代战争

##游戏介绍
“古代战争”是一个2.5D即时战略游戏，使用了帝国时代2的素材，并参考了它的游戏设计和玩法。
游戏基于[YEngine2D](http://www.cnblogs.com/chaogex/p/4088630.html)引擎开发，具备生产、建造、资源采集、战斗、地图迷雾等RTS核心要素。
[GitHub地址](https://github.com/yyc-git/AncientWar)
##最新版本
v0.2
##游戏演示

[在线演示](https://yyc-git.github.io/ancientWar/index.html)

![游戏截图](http://images.cnitblog.com/blog/419321/201411/092254360815863.png)


##功能介绍
![](http://images.cnitblog.com/blog/419321/201411/100801223813251.jpg)


1、地图
a）背景地图
背景地图大小为90×90，地形方块有草原、沙漠、河流、道路四种类型，其中精灵不能通过河流方块，可以通过其它三种方块。
游戏中通过拼接菱形方块，来即时生成菱形背景地图。
b）小地图
游戏右下方有小地图，玩家可直接在小地图上移动视口、下达框选单位的移动和移动攻击的命令。
c）视口移动
玩家可以通过鼠标移动来使当前视口移动，从而显示背景地图的不同区域，即进行地图滚动。
因为背景地图为菱形，为了防止玩家滚动到地图外，当玩家在地图边缘滚动时，视口会与菱形地图平行移动。
2、加入实体
游戏中精灵实体分为地形、资源、建筑和单位这四种类型。其中“山”为地形类型，“肉”为资源类型，“基地”、“射击场”和“箭塔”为建筑类型，“农民”和“弓箭手”为单位类型。
a）显示
地图上可以显示实体和实体的精灵动画。选中建筑或单位实体时，会在地图上显示它们的血条和菱形方框，并在游戏面板上显示实体信息。
b）操作
可以对资源、建筑和单位实体进行操作。操作分为单个实体操作和多个实体操作。
玩家通过鼠标可以对单个建筑或单位实体下达命令，从而实现实体操作。如玩家可以选中单个建筑，进行生产操作；也可以选中单个单位，然后使用鼠标右击地图，使单位移动到该处；还可以选中己方单位，然后右击一个敌方单位，使其攻击敌方单位。
玩家可以通过拖动鼠标来框选多个单位，进行移动、攻击操作；还可以使用shift键，来选中或取消建筑或单位实体。
3、关卡
游戏有1个关卡，关卡有通关条件和失败条件，关卡通过或失败都直接结束游戏。
a）关卡设计
可在levelData.js脚本中编辑关卡有哪些精灵实体、关卡加载的资源、调用的触发器等，可在trigger.js中编辑关卡的触发器。
b）资源加载与管理
在开始每个关卡时，游戏会首先加载当前关卡所需的资源，并将加载的资源保存在引擎容器中。
c）触发器
触发器是通过游戏事件的机制来实现在特定时间或特定条件下，触发特定的动作。游戏通过触发器机制实现基本的关卡AI。
4、移动
单位实体可以在地图中移动，其采用A Star算法来静态寻路，采用Steer算法和A Star算法来动态寻路
5、采集资源
玩家需要通过农民采集资源树并运送到基地来增加“肉”这个资源。每个资源树总数有限，农民一次只能采集有限的资源，运送到基地后玩家才能获得资源。建造和生产实体都需要花费资源。
6、建造
农民可以建造建筑，玩家选中农民建造时会有建造框提示，不能建造在不可通过的地形上或迷雾中。
多个农民可以建造同一个建筑，这会使建造速度加快。建造时游戏面板中会显示建造进度信息，并且不同的建造进度会在地图上显示不同的建造效果图片。
7、生产
基地可以生产农民，射击场可以生产弓箭手。
玩家可以点击建筑生产多个单位。同一时间建筑只能生产一个单位，其余单位会排队等待生产。
生产时会在游戏面板中显示进度信息。
8、战斗
游戏中实体分为蓝色实体和红色实体，其中蓝色实体属于玩家所在的阵营，红色实体属于敌方阵营。玩家可控制己方单位攻击敌方单位。
攻击类型分为远程攻击和近战攻击，其中弓箭手为远程攻击，农民为近战攻击。
弓箭手发出的弓箭轨迹为抛物线，游戏会根据目标的前进方向和速度计算弓箭的目的地。
9、迷雾
游戏中玩家己方单位和建筑有一定的视线范围，在视线范围内是可见的，可以看到所有的实体；而在视线范围外，则只能看到背景地图，不能看到敌方实体。
游戏地图区域分为可视区域、已探索区域、未探索区域，其中位于玩家单位和建筑视线范围内的区域为可视区域，可以看到玩家和敌人的单位和建筑；玩家单位探索过的地图区域为已探索区域，可以看到地形、敌人建筑；其余地图区域为未探索区域，为一片黑色，什么都看不到。
10、声音
开始关卡前会加载单位和建筑的音效。
这里值得说明的是有些音效是局部的，只有当发出该音效的单位或建筑位于视口中时才会播放；有些音效是全局的，会直接播放。 

##关卡介绍
目前只有一关，玩家需要消灭地图上所有的敌人。
##升级计划
 - 修复游戏bug
 - 改进游戏功能、用户体验，优化游戏性能
 - 增加游戏可玩性，增加更多的单位、建筑和关卡
 - 优化地形，增加每种地形的方块种类，实现相邻地形的自动拼接
 - 实现多人联网
 - 开发移动版，可在安卓和ios上运行
 - 重构代码，优化性能]]></description></item><item><title>深入理解requestAnimationFrame</title><link>http://www.cnblogs.com/chaogex/archive/2014/09/07/3960175.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sun, 07 Sep 2014 02:25:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/09/07/3960175.html</guid><description><![CDATA[#前言
本文主要参考w3c资料，从底层实现原理的角度介绍了requestAnimationFrame、cancelAnimationFrame，给出了相关的示例代码以及我对实现原理的理解和讨论。
#本文介绍
浏览器中动画有两种实现形式：通过申明元素实现（如SVG中的<animate>元素）和脚本实现。
可以通过setTimeout和setInterval方法来在脚本中实现动画，但是这样效果可能不够流畅，且会占用额外的资源。可参考《Html5 Canvas核心技术》中的论述：
> 它们有如下的特征：
> 1、即使向其传递毫秒为单位的参数，它们也不能达到ms的准确性。这是因为javascript是单线程的，可能会发生阻塞。
> 2、没有对调用动画的循环机制进行优化。 
> 3、没有考虑到绘制动画的最佳时机，只是一味地以某个大致的事件间隔来调用循环。
> 其实，使用setInterval或setTimeout来实现主循环，根本错误就在于它们抽象等级不符合要求。我们想让浏览器执行的是一套可以控制各种细节的api，实现如“最优帧速率”、“选择绘制下一帧的最佳时机”等功能。但是如果使用它们的话，这些具体的细节就必须由开发者自己来完成。

requestAnimationFrame不需要使用者指定循环间隔时间，浏览器会基于当前页面是否可见、CPU的负荷情况等来自行决定最佳的帧速率，从而更合理地使用CPU。

#本文主要内容
<ul>
    <li><a href="#explain">名词说明</a></li>
    <li><a href="#api">API接口</a></li>
    <li><a href="#processModel">处理模型</a> <br>
    <li><a href="#question">已解决的问题</a></li>
    <li><a href="#note">注意事项</a></li>
    <li><a href="#reference">参考资料</a></li>
</ul>

<a name="explain"></a>
#名词说明

 - 动画帧请求回调函数列表


每个Document都有一个动画帧请求回调函数列表，该列表可以看成是由< handle, callback>元组组成的集合。其中handle是一个整数，唯一地标识了元组在列表中的位置；callback是一个无返回值的、形参为一个时间值的函数（该时间值为由浏览器传入的从1970年1月1日到当前所经过的毫秒数）。
刚开始该列表为空。

 - Document 

Dom模型中定义的Document节点。
 

 - Active document

浏览器上下文browsingContext中的Document被指定为active document。

 - browsingContext

    浏览器上下文。
    
浏览器上下文是呈现document对象给用户的环境。
浏览器中的1个tab或一个窗口包含一个顶级浏览器上下文，如果该页面有iframe，则iframe中也会有自己的浏览器上下文，称为嵌套的浏览器上下文。

 - DOM模型

详见我的[理解DOM](http://www.cnblogs.com/chaogex/p/3959723.html)。

 - document对象

当html文档加载完成后，浏览器会创建一个document对象。它对应于Document节点，实现了HTML的Document接口。
通过该对象可获得整个html文档的信息，从而对HTML页面中的所有元素进行访问和操作。

 - HTML的Document接口

该接口对DOM定义的Document接口进行了扩展，定义了 HTML 专用的属性和方法。
详见[The Document object](http://www.w3.org/TR/html5/dom.html#document)

 - 页面可见

当页面被最小化或者被切换成后台标签页时，页面为不可见，浏览器会触发一个 visibilitychange事件,并设置document.hidden属性为true；切换到显示状态时，页面为可见，也同样触发一个 visibilitychange事件，设置document.hidden属性为false。
详见[Page Visibility](http://www.w3.org/TR/page-visibility/)、[Page Visibility(页面可见性) API介绍、微拓展](http://www.zhangxinxu.com/wordpress/2012/11/page-visibility-api-introduction-extend/) 

 - 队列

浏览器让一个单线程共用于执行javascrip和更新用户界面。这个线程通常被称为“浏览器UI线程”。
浏览器UI线程的工作基于一个简单的队列系统，任务会被保存到队列中直到进程空闲。一旦空闲，队列中的下一个任务就被重新提取出来并运行。这些任务要么是运行javascript代码，要么执行UI更新，包括重绘和重排。

<a name="api"></a>
#API接口

Window对象定义了以下两个接口：
```js
partial interface Window {
  long requestAnimationFrame(FrameRequestCallback callback);
  void cancelAnimationFrame(long handle);
};
```

##requestAnimationFrame
requestAnimationFrame方法用于通知浏览器重采样动画。
当requestAnimationFrame(callback)被调用时不会执行callback，而是会将元组< handle,callback>插入到动画帧请求回调函数列表末尾（其中元组的callback就是传入requestAnimationFrame的回调函数），并且返回handle值，该值为浏览器定义的、大于0的整数，唯一标识了该回调函数在列表中位置。
每个回调函数都有一个布尔标识cancelled，该标识初始值为false，并且对外不可见。
在后面的[“处理模型”](#processModel)中我们会看到，浏览器在执行“采样所有动画”的任务时会遍历动画帧请求回调函数列表，判断每个元组的callback的cancelled，如果为false，则执行callback。



##cancelAnimationFrame 
cancelAnimationFrame 方法用于取消先前安排的一个动画帧更新的请求。
当调用cancelAnimationFrame(handle)时，浏览器会设置该handle指向的回调函数的cancelled为true。
无论该回调函数是否在动画帧请求回调函数列表中，它的cancelled都会被设置为true。
如果该handle没有指向任何回调函数，则调用cancelAnimationFrame 不会发生任何事情。

<a name="processModel"></a>
#处理模型
当页面可见并且动画帧请求回调函数列表不为空时，浏览器会定期地加入一个“采样所有动画”的任务到UI线程的队列中。

此处使用伪代码来说明“采样所有动画”任务的执行步骤：
```js
var list = {};

var browsingContexts = 浏览器顶级上下文及其下属的浏览器上下文;

for (var browsingContext in browsingContexts) {
/*!将时间值从 DOMTimeStamp 更改为 DOMHighResTimeStamp 是 W3C 针对基于脚本动画计时控制规范的最新编辑草案中的最新更改，并且某些供应商仍将其作为 DOMTimeStamp 实现。较早版本的 W3C 规范使用 DOMTimeStamp，允许你将 Date.now 用于当前时间。
如上所述，某些浏览器供应商可能仍实现 DOMTimeStamp 参数，或者尚未实现 window.performance.now 计时函数。因此需要用户进行polyfill
*/
    //var time = 从1970年1月1日到当前所经过的毫秒数;
    var time = DOMHighResTimeStamp   //从页面导航开始时测量的高精确度时间。DOMHighResTimeStamp 以毫秒为单位，精确到千分之一毫秒。此时间值不直接与 Date.now() 进行比较，后者测量自 1970 年 1 月 1 日至今以毫秒为单位的时间。如果你希望将 time 参数与当前时间进行比较，请使用当前时间的 window.performance.now。



   var d = browsingContext的active document;   //即当前浏览器上下文中的Document节点
    //如果该active document可见
    if (d.hidden !== true) { 
        //拷贝active document的动画帧请求回调函数列表到list中，并清空该列表
        var doclist = d的动画帧请求回调函数列表
        doclist.appendTo(list);
        clear(doclist);
    }

    //遍历动画帧请求回调函数列表的元组中的回调函数
    for (var callback in list) {
        if (callback.cancelled !== true) {
            try {
                //每个browsingContext都有一个对应的WindowProxy对象，WindowProxy对象会将callback指向active document关联的window对象。
                //传入时间值time
                callback.call(window, time);
            }
            //忽略异常
            catch (e) {    
            }
        }
    }
}
```

<a name="question"></a>
#已解决的问题

 - 为什么在callback内部执行cancelAnimationFrame不能取消动画？

**问题描述**
如下面的代码会一直执行a：
```js
    var id = null;

    function a(time) {
        console.log("animation");
        window.cancelAnimationFrame(id);    //不起作用
        id = window.requestAnimationFrame(a);
    }

    a();
```

**原因分析**
我们来分析下这段代码是如何执行的：
1、执行a
（1）执行“a();”，执行函数a；
（2）执行“console.log("animation");”，打印“animation”；
（3）执行“window.cancelAnimationFrame(id);”，因为id为null，浏览器在动画帧请求回调函数列表中找不到对应的callback，所以不发生任何事情；
（4）执行“id = window.requestAnimationFrame(a);”，浏览器会将一个元组< handle, a>插入到Document的动画帧请求回调函数列表末尾，将id赋值为该元组的handle值；


2、a执行完毕后，执行第一个“采样所有动画”的任务
假设当前页面一直可见，因为动画帧请求回调函数列表不为空，所以浏览器会定期地加入一个“采样所有动画”的任务到线程队列中。
a执行完毕后的第一个“采样所有动画”的任务执行时会进行以下步骤：
（1）拷贝Document的动画帧请求回调函数列表到list变量中，清空Document的动画帧请求回调函数列表；
（2）遍历list的列表，列表有1个元组，该元组的callback为a；
（3）判断a的cancelled，为默认值false，所以执行a；
（4）执行“console.log("animation");”，打印“animation”；
（5）执行“window.cancelAnimationFrame(id);”，此时id指向当前元组的a（即当前正在执行的a），浏览器将<span style="color:red;">当前元组</span>的a的cancelled设为true。
（6）执行“id = window.requestAnimationFrame(a);”，浏览器会将<span style="color:red;">新的元组< handle, a></span>插入到Document的动画帧请求回调函数列表末尾（新元组的a的cancelled为默认值false），将id赋值为该元组的handle值。

3、执行下一个“采样所有动画”的任务
当下一个“采样所有动画”的任务执行时，会判断动画帧请求回调函数列表的元组的a的cancelled，因为该元组为新插入的元组，所以值为默认值false，因此会继续执行a。
如此类推，浏览器会一直循环执行a。

**解决方案**
有下面两个方案：
1、执行requestAnimationFrame之后再执行cancelAnimationFrame。
下面代码只会执行一次a：
```js
    var id = null;

    function a(time) {
        console.log("animation");
        id = window.requestAnimationFrame(a);
        window.cancelAnimationFrame(id);
    }

    a();
```
2、在callback外部执行cancelAnimationFrame。
下面代码只会执行一次a：
```js
    function a(time) {
        console.log("animation");
        id = window.requestAnimationFrame(a);
    }

    a();
    window.cancelAnimationFrame(id);
```

因为执行“window.cancelAnimationFrame(id);”时，id指向了新插入到动画帧请求回调函数列表中的元组的a，所以 “采样所有动画”任务判断元组的a的cancelled时，该值为true，从而不再执行a。

<a name="note"></a>
#注意事项
1、在[处理模型](#processModel)中我们已经看到，在遍历执行拷贝的动画帧请求回调函数列表中的回调函数之前，Document的动画帧请求回调函数列表已经被清空了。因此如果要多次执行回调函数，需要在回调函数中再次调用requestAnimationFrame将包含回调函数的元组加入到Document的动画帧请求回调函数列表中,从而浏览器才会再次定期加入“采样所有动画”的任务（当页面可见并且动画帧请求回调函数列表不为空时，浏览器才会加入该任务），执行回调函数。

例如下面代码只执行1次animate函数：
```js
             var id = null;
             
             function animate(time) {
                 console.log("animation");
             }

              window.requestAnimationFrame(animate);
```
下面代码会一直执行animate函数：
```js
    var id = null;

    function animate(time) {
        console.log("animation");
        window.requestAnimationFrame(animate);
    }
    animate();
```
2、如果在执行回调函数或者Document的动画帧请求回调函数列表被清空之前多次调用requestAnimationFrame插入同一个回调函数，那么列表中会有多个元组指向该回调函数（它们的handle不同，但callback都为该回调函数），“采集所有动画”任务会执行多次该回调函数。

例如下面的代码在执行“id1 = window.requestAnimationFrame(animate);”和“id2 = window.requestAnimationFrame(animate);”时会将两个元组（handle分别为id1、id2，回调函数callback都为animate）插入到Document的动画帧请求回调函数列表末尾。
因为“采样所有动画”任务会遍历执行动画帧请求回调函数列表的每个回调函数，所以在“采样所有动画”任务中会执行两次animate。
```js
    //下面代码会打印两次"animation"
    
    var id1 = null,
        id2 = null;
    function animate(time) {
        console.log("animation");
    }
    
    id1 = window.requestAnimationFrame(animate);
    id2 = window.requestAnimationFrame(animate);   //id1和id2值不同，指向列表中不同的元组，这两个元组中的callback都为同一个animate
```
<a name="compatible"></a>
#兼容性方法
下面为《HTML5 Canvas 核心技术》给出的兼容主流浏览器的requestNextAnimationFrame 和cancelNextRequestAnimationFrame方法，大家可直接拿去用：
```js
window.requestNextAnimationFrame = (function () {
    var originalRequestAnimationFrame = undefined,
        wrapper = undefined,
        callback = undefined,
        geckoVersion = null,
        userAgent = navigator.userAgent,
        index = 0,
        self = this;

    wrapper = function (time) {
        time = performance.now();
        self.callback(time);
    };

    /*!
     bug!
     below code:
     when invoke b after 1s, will only invoke b, not invoke a!

     function a(time){
     console.log("a", time);
     webkitRequestAnimationFrame(a);
     }

     function b(time){
     console.log("b", time);
     webkitRequestAnimationFrame(b);
     }

     a();

     setTimeout(b, 1000);



     so use requestAnimationFrame priority!
     */
    if(window.requestAnimationFrame) {
        return requestAnimationFrame;
    }


    // Workaround for Chrome 10 bug where Chrome
    // does not pass the time to the animation function

    if (window.webkitRequestAnimationFrame) {
        // Define the wrapper

        // Make the switch

        originalRequestAnimationFrame = window.webkitRequestAnimationFrame;

        window.webkitRequestAnimationFrame = function (callback, element) {
            self.callback = callback;

            // Browser calls the wrapper and wrapper calls the callback

            return originalRequestAnimationFrame(wrapper, element);
        }
    }

    //修改time参数
    if (window.msRequestAnimationFrame) {
        originalRequestAnimationFrame = window.msRequestAnimationFrame;

        window.msRequestAnimationFrame = function (callback) {
            self.callback = callback;

            return originalRequestAnimationFrame(wrapper);
        }
    }

    // Workaround for Gecko 2.0, which has a bug in
    // mozRequestAnimationFrame() that restricts animations
    // to 30-40 fps.

    if (window.mozRequestAnimationFrame) {
        // Check the Gecko version. Gecko is used by browsers
        // other than Firefox. Gecko 2.0 corresponds to
        // Firefox 4.0.

        index = userAgent.indexOf('rv:');

        if (userAgent.indexOf('Gecko') != -1) {
            geckoVersion = userAgent.substr(index + 3, 3);

            if (geckoVersion === '2.0') {
                // Forces the return statement to fall through
                // to the setTimeout() function.

                window.mozRequestAnimationFrame = undefined;
            }
        }
    }

    return window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||

        function (callback, element) {
            var start,
                finish;

            window.setTimeout(function () {
                start = performance.now();
                callback(start);
                finish = performance.now();

                self.timeout = 1000 / 60 - (finish - start);

            }, self.timeout);
        };
})();


    window.cancelNextRequestAnimationFrame = window.cancelRequestAnimationFrame
        || window.webkitCancelAnimationFrame
        || window.webkitCancelRequestAnimationFrame
        || window.mozCancelRequestAnimationFrame
        || window.oCancelRequestAnimationFrame
        || window.msCancelRequestAnimationFrame
        || clearTimeout;
```


<a name="reference"></a>
#参考资料
[Timing control for script-based animations](http://www.w3.org/TR/animation-timing/)
[Browsing contexts](http://www.w3.org/TR/html5/browsers.html#windows)
[The Document object](http://www.w3.org/TR/html5/dom.html#document)
《HTML5 Canvas核心技术》
[理解DOM](http://www.cnblogs.com/chaogex/p/3959723.html)
[Page Visibility](http://www.w3.org/TR/page-visibility/)
[Page Visibility(页面可见性) API介绍、微拓展](http://www.zhangxinxu.com/wordpress/2012/11/page-visibility-api-introduction-extend/) 
[HOW BROWSERS WORK: BEHIND THE SCENES OF MODERN WEB BROWSERS](http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)]]></description></item><item><title>理解DOM</title><link>http://www.cnblogs.com/chaogex/archive/2014/09/06/3959723.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sat, 06 Sep 2014 11:46:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/09/06/3959723.html</guid><description><![CDATA[#前言
本文试图弄清楚DOM到底是什么，不会讨论具体DOM节点的操作。

#DOM是什么
DOM全称为The Document Object Model，应该理解为是一个规范，定义了HTML和XML文档的逻辑结构和文档操作的编程接口。

##文档逻辑结构
DOM实际上是以面向对象方式描述的对象模型，它将文档建模为一个个对象，以树状的结构组织（本文称之为“文档树”，树中的对象称为“节点”）。
每个文档包含1个document节点，0个或1个doctype节点以及0个或多个元素节点等。document节点是文档树的根节点。
如对于HTML文档，DOM 是这样规定的：

 - 整个文档是一个文档节点
 - 每个 HTML 标签是一个元素节点
 - 包含在 HTML 元素中的文本是文本节点
 - 每一个 HTML 属性是一个属性节点
 - 注释属于注释节点

节点与文档内容是一一对应的关系，节点之间有层次关系。

例如下面的hmlt文档：
```html
<!DOCTYPE html>
<html>
<head>
    <title>文档标题</title>
</head>
<body>
<a href="">我的链接</a>
<h1>我的标题</h1>
</body>
</html>
```
会被建模为下面的文档树：
![_1](http://img2.tbcdn.cn/L1/461/1/8ee8be23856d5b187a8b433b88cbcc03f0c53def)

又如下面的html文档：
```html
<!DOCTYPE html>
<html class=e>
 <head><title>Aliens?</title></head>
 <body>Why yes.</body>
</html>
```
会被建模为下面的文档树：
![_2](http://img1.tbcdn.cn/L1/461/1/20227de567513876af94136badef35f8af4008ef) 

##文档操作
程序员可以使用DOM定义的接口来获得对文档中所有元素进行访问的入口，创建文档，浏览文档结构，添加、修改或删除文档元素和内容。
HTML或XML文档中的所有的内容都可以通过使用DOM定义的接口来操作。

##DOM到底是对象模型还是编程接口？
总的来说，DOM应该理解为是1个规范。
站在实现（如浏览器）和使用者（如程序员）的角度来看，DOM就是一套文档节点的编程接口，只要实现了接口，就可以使用接口成员来操作文档；站在设计和制定的角度来看，DOM是一个对象模型，它将文档内容建模为对象并组织为树状结构，定义了这些对象的行为和属性以及这些对象之间的关系。


#DOM不是什么

 - DOM不是一个数据结构集，并没有定义数据结构。
 - DOM没有定义文档中什么信息是相关的或者文档中的信息是如何组织的。

如对于XML，这些是在[XML Information Set](http://www.w3.org/TR/2004/REC-xml-infoset-20040204/)中指定的。DOM只是这些信息集的API。

**鉴于水平有限，w3c资料中我没有理解的部分此处没有给出**，详细内容可参考[What is the Document Object Model -> What the Document Object Model is not](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/introduction.html#ID-E7C30822)

#DOM的分级
上面讨论的DOM是1级DOM，具体就是  DOM CORE和DOM HTML，它将HTML和XML文档映射为对由层次对象（节点）组成的树。
根据W3C DOM规范，DOM有1级、2级、3级以及最新的4级，本文只讨论前3级DOM。
##1级DOM
1级DOM在1998年10月份成为W3C的提议，由DOM CORE与DOM HTML两个模块组成。DOM CORE能映射以XML为基础的文档结构，允许获取和操作文档的任意部分。DOM HTML通过添加HTML专用的对象与函数对DOM核心进行了扩展。
##2级DOM
![2_DOM](http://img1.tbcdn.cn/L1/461/1/9c71bd26356e6884475a93eace7fbd54865221d9) 

鉴于1级DOM仅以映射文档结构为目标，DOM 2级面向更为宽广。通过对原有DOM的扩展，2级DOM通过对象接口增加了对鼠标和用户界面事件（DHTML长期支持鼠标与用户界面事件）、范围、遍历（重复执行DOM文档）和层叠样式表（CSS）的支持。同时也对DOM 1的核心进行了扩展，从而可支持XML命名空间。
2级DOM引进了几个新DOM模块来处理新的接口类型：
DOM视图：描述跟踪一个文档的各种视图（使用CSS样式设计文档前后）的接口；
DOM事件：描述事件接口；
DOM样式：描述处理基于CSS样式的接口；
DOM遍历与范围：描述遍历和操作文档树的接口；
##3级DOM
3级DOM通过引入统一方式载入和保存文档和文档验证方法对DOM进行进一步扩展，DOM3包含一个名为“DOM载入与保存”的新模块，DOM核心扩展后可支持XML1.0的所有内容，包扩XML Infoset、 XPath、和XML Base。
##"0级"DOM
当阅读与DOM有关的材料时，可能会遇到参考0级DOM的情况。需要注意的是并没有标准被称为0级DOM，它仅是DOM历史上一个参考点（0级DOM被认为是在Internet Explorer 4.0 与Netscape Navigator4.0支持的最早的DHTML）。


#参考资料
[DOM百度百科](http://baike.baidu.com/subview/14806/8904138.htm)
[What is the Document Object Model](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/introduction.html)
[W3C DOM4](http://www.w3.org/TR/domcore/)]]></description></item><item><title>前端的架构设计与演化实例</title><link>http://www.cnblogs.com/chaogex/archive/2014/08/27/3938657.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Wed, 27 Aug 2014 08:36:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/08/27/3938657.html</guid><description><![CDATA[#前言
本文介绍我在实际的前端项目中的架构设计，展示因为需求变化而导致架构变化的过程。
全文分为三个阶段，分别对应三次需求的变化，给出了对应的架构设计。
在第一个阶段中，我使用面向过程设计；在第二个阶段和在第三个阶段中，我使用面向对象设计。
#本文内容
<ul>
    <li><a href="#stragety">策略</a></li>
    <li><a href="#dependence">依赖项</a></li>
    <li><a href="#first">第一个阶段</a> <br>
        <ul><li><a href="#first_request">需求</a></li>
            <li><a href="#first_design">架构设计</a></li>
            <li><a href="#first_code">项目示例代码</a></li>
            <li><a href="#first_sequence">序列图</a></li>
            <li><a href="#first_refactor">重构</a></li>
            <li><a href="#first_model">领域模型</a></li>
            <li><a href="#first_analysis">分析当前设计</a></li></ul></li>
    <li><a href="#second">第二个阶段</a> <br>
        <ul><li><a href="#second_request">需求</a></li>
            <li><a href="#second_design">架构设计</a></li>
            <li><a href="#second_analysis1">分析当前设计</a></li>
            <li><a href="#second_refactor1">重构</a></li>
            <li><a href="#second_code">项目示例代码</a></li>
            <li><a href="#second_sequence">序列图</a></li>
            <li><a href="#second_analysis2">分析具体实现</a></li>
            <li><a href="#second_refactor2">重构</a></li>
            <li><a href="#second_model">领域模型</a></li>
            <li><a href="#second_think">思考：是否需要使用观察者模式重构</a></li>
            <li><a href="#second_analysis3">分析当前设计</a></li></ul></li>
    <li><a href="#third">第三个阶段</a> <br>
        <ul><li><a href="#third_request">需求</a></li>
            <li><a href="#third_design">架构设计</a></li>
            <li><a href="#third_code1">项目示例代码</a></li>
            <li><a href="#third_analysis1">分析当前设计</a></li>
            <li><a href="#third_refactor">重构</a></li>
            <li><a href="#third_model">领域模型和分层</a></li>
            <li><a href="#third_code2">项目示例代码</a></li>
            <li><a href="#third_analysis2">分析当前设计</a></li></ul></li>
    <li><a href="#summary">总结</a></li>
    <li><a href="#reference">参考资料</a></li>
</ul>

<p><a name="stragety"></a></p>
#策略
为了方便讨论，本文的涉及的项目是经过简化的示例项目。
本文重点展现领域模型和架构的变化，对于具体的方法/属性级别的重构不进行详细讨论。
本文会给出核心的实现代码，但不会讨论单元测试。
本文会在具体的上下文中讨论架构的设计。详见下面的讨论：

 - 本文应该给出一个具体的上下文环境，还是构造一个抽象的上下文？

    **具体的上下文示例**
    这是一个贴子后台管理的数据统计平台，用户可在该平台中查看“发贴审核”选项的“贴子审核量”数据项的数据。
    **优点**
    便于读者理解讨论的上下文，从而能够更好地理解本文讨论的架构的设计和演变。
    **缺点**
    不能为了演示架构演变而随意构造用户的需求，需求必须约束在具体的上下文中
    **抽象的上下文示例**
    这是一个数据统计平台，用户可在该平台中查看tabA选项的item1数据项的数据。
    **优点**
    可以围绕架构设计和演变最大限度地构造用户的需求，可以充分在各种假设需求下讨论架构的演变。
    **缺点**
    由于没有具体的上下文，读者很难理解本文的架构设计和演变与需求的关系。
    **结论**
    为了让读者更好地理解架构的设计和演变，本文会在具体的上下文中讨论，但也会将需求最简化，从而让读者把精力集中到关注架构设计上。
    
<p><a name="dependence"></a></p>    
#依赖项
[Javascript OOP框架YOOP](http://www.cnblogs.com/chaogex/archive/2013/06/07/3123999.html)
#正文
<p><a name="first"></a></p>
##第一个阶段
<p><a name="first_request"></a></p>
###需求
这是一个后台管理系统的数据统计平台，其中后台管理系统可以对网站的贴子进行审核，平台则记录并显示后台管理系统操作的数据。
现后台接口已开发完成，我负责前端逻辑实现。
现在用户可在该平台中查看“发贴审核”选项的“贴子审核量”数据项的数据。
有以下两个要求：
用户可以选择日期，查看指定日期的贴子审核量数据。
用户可点击“趋势”，查看指定日期范围（指定日期前7天）内的贴子审核量数据，以图表形式显示。


![1_](http://img4.tbcdn.cn/L1/461/1/09f3b9b7a98b52d45bf90b3fe1d98f7f4d877006)
用户可在页面右上角选择日期，“贴子审核量”下面会显示对应日期的审核量数据

![1_](http://img3.tbcdn.cn/L1/461/1/3b1dbae2794699d7f070e311770cf54119ca20dc)
用户点击趋势后，会弹出一个二级页面，显示日期范围（指定日期前7天）内的贴子审核量数据图表



###需求分析
“审核量”数据项对应后台接口“/postCheck/get_check_data“，可从该接口获得指定日期范围的审核量数据：
如接口“/postCheck/get_check_data? begin_date=20140525&end_date=20140724“可获得2014年5月25日到2014年7月24日的json数组，“/postCheck/get_check_data? begin_date=20140724&end_date=20140724”可获得2014年7月24日的json数组（只有1条数据）。
需要从接口返回的json数据中提取出date和num字段的数据，其中date字段对应日期，num字段对应该日期的贴子审核量。
<p><a name="first_design"></a></p>
###架构设计
####技术选型
使用datepicker插件实现日历功能
使用highchart插件实现绘制图表功能
####技术方案
使用模块化设计，一个模块负责一个功能。

 - main
    
    入口模块，负责封装内部逻辑，提供一个外观方法给页面
 - showData
   
    负责显示数据项指定日期的数据
 - qushi
    
    负责显示数据项指定日期范围的趋势图表
 - chartHelper
    
    负责构建highchart的配置项，与highcharts插件交互
 - controlDatePicker
    
    负责管理日期选择，与datepicker插件交互

####领域模型


![_1_](http://img4.tbcdn.cn/L1/461/1/952d2d030489dd61edb71e083404b28a32a97369)


<p><a name="first_code"></a></p>
###项目示例代码
[详见GitHub地址](https://github.com/yyc-git-show/frontEndArchitecture_code/tree/master/1)


<p><a name="first_sequence"></a></p>
###序列图
选择日期


![_1_](http://img2.tbcdn.cn/L1/461/1/08dc57bc3aeef168ed1f8218f0fc9b7d991f348f)


查看趋势


![_1_](http://img4.tbcdn.cn/L1/461/1/3d9d1c04d45ec5df2f856190315917505c7018a1)


<p><a name="first_refactor"></a></p>
###进一步重构
1、重构qushi与controlDatePicker的关联方向
**问题说明**
qushi负责显示审核量日期范围的数据图表，其中日期范围的截止日期应该为用户选择的日期。然而在当前模型中，用户点击“趋势”后，qushi才会去访问保存在controlDatePicker中的日期，该日期值可能在用户选择日期与用户点击“趋势”的间隔时间中发生了变化，因而可能与用户实际选择的日期不同
**原因分析**
这是由于用户选择日期和qushi访问日期数据是异步进行的。
**解决方案**
将两者改为同步进行。
具体为：
qushi增加_selectDate属性，
用户选择日期后，触发controlDatePicker的onchange函数，该函数通知qushi，更新它的_selectDate。用户查看趋势时，qushi调用自己的getAndShowChart方法访问属性_selectDate，从而获得用户选择的日期。
**重构后的选择日期和查看趋势序列图**

![_1_selectDate_](http://img2.tbcdn.cn/L1/461/1/a282869dc10d766cae6ae498adcc5335d4b58b4d)


**重构后的领域模型**


![_1_selectDate_](http://img2.tbcdn.cn/L1/461/1/cef3a88d8c40a5f2005d712c4ed12f6743b9dabe)


2、重构showData、qushi
现在showData和qushi中的ajaxData接口数据都一样，因此需要去掉重复数据。
**有两个方案：**
1）showData和qushi改为委托关系，使用同一个接口数据
那么关联方向应该如何确定呢？
引用自《重构：改善既有代码的设计》：

> 1.如果两者都是引用对象，而期间的关联是“一对多”关系，那么就由“拥有单一引用”的那一方承担“控制者”角色。
> 2.如果某个对象是组成另一对象的部件，那么由后者负责控制关联关系。
> 3.如果两者都是引用对象，而期间关联是“多对多”关系，那么随便其中哪个对象来控制关联关系，都无所谓。

此处showData和qushi在概念上相互独立，两者没有映射关系，因此没办法确定关联方向。
2）提出一个数据模块data，将接口数据移到其中，showData、qushi通过访问data来获得接口数据。
**结论**
虽然第2个方案可以将数据与业务逻辑分离，但是考虑到当前数据与业务逻辑还不是很复杂，而且将接口数据直接写到模块中的话修改数据比较方便（如要修改showData数据，则直接可以修改showData的_ajaxData，而不用去data中先查找showData的数据，然后再修改），因此采用第1个方案。
至于关联方向，此处直接设置qushi关联showData。

**重构后的领域模型**


![_1_showData_qushi_](http://img2.tbcdn.cn/L1/461/1/48f0f6be9c8c9d577969a1ee88ccf6b8b41fb9a5)


<p><a name="first_model"></a></p>
####重构后总的领域模型


![_1_](http://img4.tbcdn.cn/L1/461/1/b693f9f27a9d36c7a7b3a7510b27218ed015475e)


<p><a name="first_analysis"></a></p>
###分析当前设计
**优点**
1、每个模块的职责没有重复，对需求变化具有良好的封闭性
一个需求的变化只会影响负责该需求的模块的变化，其它模块不会受到影响。
2、能较好地适应功能点的增加
如果需要增加新的功能，则增加对应的模块，并对应修改入口模块main即可，其余模块不用修改。
**缺点**
1、数据与业务逻辑耦合
当前场景下还不是什么问题，可先保留当前设计，到需要分离数据时再分离。


<p><a name="second"></a></p>
##第二个阶段
<p><a name="second_request"></a></p>
###需求变更
现在“发贴审核”选项增加一个“贴子删除量”数据项，该数据项的功能与“贴子审核量”一样，要显示用户指定日期的数据和日期范围的数据趋势图。
另外增加“评论审核”选项，它有“评论审核量”和“评论删除量”两个数据项，与“发贴审核”数据项的功能一样。
用户可以切换选项，分别查看“发贴审核”或“评论审核”的数据
可显示选项趋势图：每个选项可显示选项页面中所有数据项的指定日期范围（指定日期前7天）的数据趋势图。



![2_](http://img1.tbcdn.cn/L1/461/1/df9b11fd055fa427b27a280d91d632525df126e6)
“发贴审核”增加“贴子删除量”，页面下方显示两个数据项的趋势图


![2_](http://img3.tbcdn.cn/L1/461/1/d479feae6254519d2d4807452582dbc623d0cf25)
增加“评论审核”选项，该选项有“评论审核量”和“评论删除量”两个数据项，页面下方显示两个数据项的趋势图



###需求分析
每个数据项的功能都一样，只是对应的后台接口不同或从接口数据中取出的字段不同
如“发贴审核”的“贴子审核量”需要从/postCheck/get_check_data接口取出date、num字段，“贴子删除量”需要从/postCheck/get_delete_data接口取出date、delete字段；“评论审核”的“评论审核量”需要从/commentCheck/get_check_data接口取出date、num字段，“贴子删除量”需要从/ commentCheck /get_delete_data接口取出date、delete字段。
<p><a name="second_design"></a></p>
###架构设计
经过上面的需求分析后，可以给出下面的架构设计：

 - 1个main模块

    负责封装内部逻辑，提供一个外观方法给页面
 - 1个选项控制模块controlTab

    负责管理选项的切换

 - 2个showChart模块

    对应两个选项，负责显示选项趋势图。

 - 2个showData模块

    对应两个选项，负责显示数据项的指定日期数据

 - 2个qushi模块

    对应两个选项，负责显示数据项的指定日期范围的趋势图

 - 1个chartHelper和1个controlDatePicker模块

    因为两个选项的图表的配置和日期管理逻辑都一样，因此两个选项共用1个chartHelper和1个controlDatePicker模块。

####为什么分别需要2个而不是1个showChart、showData、qushi模块？
因为用户可切换选项，显示不同的选项页面，所以两个选项应该相互独立，各自的模块和数据也应该相互独立。
<p><a name="second_analysis1"></a></p>
###分析当前设计
1、模块之间有共同模式
showChart与qushi之间都要负责绘制图表，有共同的模式可以提出。
另外2个showChart/showData/qushi模块之间也有很多共同模式。
2、模块数量太多
每增加一个功能需求，就要增加一个模块，这样会导致模块太多难以管理。

**因此，需要使用面向对象思维来重新设计。**
<p><a name="second_refactor1"></a></p>
###重构
####提出“一级页面”和“二级页面”
让我们来重新分析下需求：
“用户指定日期的数据项数据”和“选项趋势图”都是显示在选项页面中，而“显示数据项指定日期范围的趋势图”则显示在弹出层页面中，因此可以提出“一级页面”， 对应选项页面，逻辑由模块firstLevelPage负责；可以提出“二级页面”，对应选项的弹出层页面，逻辑由模块secondLevelPage负责。
因为“显示数据项指定日期数据”和“显示选项趋势图”属于选项页面的职责，“显示指定日期范围的趋势图”属于弹出层页面的职责，所以将对应的模块showChart和showData合并为firstLevelPage，将qushi重命名为secondLevelPage。
#####领域模型

![_2_FirstLevelPage_SecondLevelPage_](http://img1.tbcdn.cn/L1/461/1/1f1b71507b8a36d9ac84f6e84517ef169fb1fc8f)


####升级为类，提出基类
现在firstLevelPage与secondLevelPage有共同的模式，并且它们概念相近，都属于“页面”这个概念，因此将firstLevelPage与secondLevelPage模块升级为类FirstLevelPage和SecondLevelPage，并提出基类Page，将两者的共同模式提到基类中。
本文使用我的[YOOP库](http://www.cnblogs.com/chaogex/archive/2013/06/07/3123999.html)来实现javascript的OOP编程。

####增加FirstLevelPage的子类
因为两个选项的后台接口数据不同，所以增加FirstLevelPage的子类PostFirstLevelPage、CommentFirstLevelPage，放置各自选项的接口数据。
因为两个选项的二级页面逻辑都相同，并且SecondLevelPage从FirstLevelPage中获得接口数据，本身并没有数据，因此SecondLevelPage不需要提出子类。
####新的领域模型


![_2_](http://img1.tbcdn.cn/L1/461/1/657a7e7bcc9b83e96d63c17029fe2b7c43623695)
没有画出main模块，因为它与几乎所有的类都有关联，如果画出来模型就看不清楚了。后面的领域模型中也不会画出main。

<p><a name="second_code"></a></p>
###项目示例代码
[详见GitHub地址](https://github.com/yyc-git-show/frontEndArchitecture_code/tree/master/2)

<p><a name="second_sequence"></a></p>

###序列图
切换选项
 

![_2_](http://img1.tbcdn.cn/L1/461/1/ea391a21d8749660bf4d1f311a3b63e6d6ffac0f)


选择日期
 

![_2_](http://img1.tbcdn.cn/L1/461/1/a7512de664cd099f76217403a73f55184e3a881f)


查看趋势


![_2_](http://img4.tbcdn.cn/L1/461/1/6f8ed3294500b17d2d41d33c1a657794b051580b)

<p><a name="second_analysis2"></a></p>

###分析具体实现
为了便于读者理解设计，此处对具体实现中重要的内容作一些说明和分析。

####dom的id与类的对应关系
**dom的id前缀**
“发贴审核”和“评论审核”的id前缀分别为“post”、“comment”， “审核量”和“删除量”的id前缀分别为“check”、“delete”，一级页面和二级页面的id前缀分别为“firstLevelPage”、“secondLevelPage”。
dom的id前缀为：选项id前缀+“_”+（数据项id前缀）+“_”+（页面id前缀）。
如果dom属于选项，则加上选项id前缀；如果dom属于数据项，则加上数据项id前缀；如果dom属于一级页面（选项页面）或二级页面（弹出层页面），则加上对应的页面id前缀
**dom的id前缀与类对应**
dom的id前缀与Page类族对应，id前缀由对应的Page类注入。
如选项id前缀在PostFirstLevelPage和CommentFirstLevelPage类的构造函数中注入；页面id前缀在FirstLevelPage、SecondLevelPage类的构造函数中注入。
相关代码
index.html
```html
<div class="container">
   …
    <section id="post">
       …
                        <span id="post_check_firstLevelPage_num"></span>
                            …
                        <span id="post_delete_firstLevelPage_num"></span>
       …
	</section>
        <section id="post_secondLevelPage_chartBody" class="secondLevelChartBody qushiBody">
            …
                        <div id="post_secondLevelPage_chart"></div>
            …
        <section id="post_firstLevelPage_chartBody" class="chartContainer">
            …
                <div id="post_firstLevelPage_chart"></div>
            …
        </section>
</section>

    <section id="comment">
       …
                        <span id="comment_check_firstLevelPage_num"></span>
                            …
                        <span id="comment_delete_firstLevelPage_num"></span>
       …
	</section>
        <section id="comment_secondLevelPage_chartBody" class="secondLevelChartBody qushiBody">
            …
                        <div id="comment_secondLevelPage_chart"></div>
            …
        <section id="comment_firstLevelPage_chartBody" class="chartContainer">
            …
                <div id="comment_firstLevelPage_chart"></div>
            …
        </section>
</section>
```
Page
```js
Init: function (tab, level) {
    this._tab = tab;    //选项id前缀
    this._level = level;    //页面id前缀
},
```
FirstLevelPage
```js
Init: function (tab) {
    this.base(tab, "firstLevelPage"); //传入页面id前缀
},
```
PostFirstLevelPage
```js
Init: function () {
    this.base("post");  //传入选项前缀
```
CommentFirstLevelPage
```js
Init: function () {
    this.base("comment");  //传入选项前缀
```
SecondLevelPage
```js
Init: function (tab, firstLevelPage) {
    this.base(tab, "secondLevelPage");  //传入页面id前缀

    this._firstLevelPage = firstLevelPage;
},
```
main
```js
init: function () {
    …
    //在创建SecondLevelPage实例时传入二级页面的选项id前缀和firstLevelPage实例
    window.postSecondLevelPage = new SecondLevelPage("post", window.postFirstLevelPage);
    window.commentSecondLevelPage = new SecondLevelPage("comment",window.commentFirstLevelPage);
```
**为什么要这样设计**
Page类族可通过注入的id前缀访问对应的dom。
相关代码为：
Page
```js
Protected: {
    …
//根据子类传入的id前缀，构造dom的id的前缀
    P_getPrefixId: function () {
        return this._tab + "_" + this._level + "_";
    },
    …
},
Public: {
    getChartDom:function(){
        return $(this.P_getPrefixId() + "chartBody");
    },
```
main
```js
window.main = {
        init: function () {
            window.postFirstLevelPage = new PostFirstLevelPage();
            window.commentFirstLevelPage = new CommentFirstLevelPage();

            window.postSecondLevelPage = new SecondLevelPage("post", window.postFirstLevelPage);
            window.commentSecondLevelPage = new SecondLevelPage("comment",window.commentFirstLevelPage);
```
调用main.init()后，调用window.postFirstLevelPage.getChartDom()可获得“发贴审核”的选项趋势图的dom（id为post_firstLevelPage_chartBody），而调用window. postSecondLevelPage.getChartDom()则可获得“发贴审核”的二级页面的dom（id为post_secondLevelPage_chartBody）。
####共享二级页面dom 
上面的代码中可以看到，不同的选项、不同选项的选项趋势图、数据项指定日期的数据显示的dom相互独立，而同一个选项的“审核量”和“删除量”的二级页面则共享同一个容器dom（如选项post只有一个post_secondLevelPage_chartBody，选项comment只有一个comment_secondLevelPage_chartBody）。
这是因为：
1、“共享dom”虽然会造成相互干扰，但可以减少dom的数量，而且目前相互之间只有很轻微的干扰。
2、如果同一个选项的“审核量”和“删除量”的二级页面相互独立，那么它们的dom的id就要加上数据项id前缀。但是现在的Page类族无法访问包含数据项id前缀的dom（见“解决Page类族无法访问有数据项id前缀的dom的问题”），在SecondLevelPage中访问对应数据项的二级页面dom比较麻烦！
####解决“Page类族无法访问有数据项id前缀的dom”的问题
在前面的“dom的id与类的对应关系”讨论中，我们看到选项id前缀和页面id前缀都可以注入到类中，而数据项id前缀现在却没有注入，因此Page类族无法访问包含数据项id前缀的dom！
**有两个方案解决该问题：**
1、FirstLevelPage子类的P_ajaxData中直接指定包含数据项id前缀的dom的id，从而Page类族可通过访问P_ajaxData的dom id来获得对应的包含数据项id前缀的dom。
相关代码
PostFirstLevelPage
```js
Init: function () {
    this.base("post");  //传入选项前缀

    this.P_ajaxData = {
        "发贴审核贴子审核量": {
            url: "/postCheck/get_check_data",
            name: "贴子审核量",
            field: "num",
            domId: {
                num: "#post_check_firstLevelPage_num" //“发贴审核”的“审核量”的指定日期数据显示对应的domId
            }
        },
        "发贴审核贴子删除量": {
            url: "/postCheck/get_delete_data",
            name: "贴子删除",
            field: "delete" ,
            domId: {
                num: "#post_delete_firstLevelPage_num"  //“发贴审核”的“删除量”的指定日期数据显示对应的domId
            }
        }
    };
}
```
CommentFirstLevelPage
```js
Init: function () {
    this.base("comment");  //传入选项前缀

    this.P_ajaxData = {
        "评论审核贴子审核量": {
            url: "/commentCheck/get_check_data",
            name: "评论审核量",
            field: "num",
            domId: {
                num: "#comment_firstLevel_check_num" //“评论审核”的“审核量”的指定日期数据显示对应的domId
            }
        },
        "评论审核贴子删除量": {
            url: "/commentCheck/get_delete_data",
            name: "评论删除",
            field: "delete" ,
            domId: {
                num: "#comment_firstLevel_delete_num"  //“评论审核”的“删除量”的指定日期数据显示对应的domId
            }
        }
    };
}
```
2、增加PostFirstLevelPage的子类PostCheckFirstLevelPage、PostDeleteFirstLevelPage，分别对应数据项“审核量”和“删除量”，然后在构造函数中注入数据项id前缀。
还可以将PostFirstLevelPage中的选项接口数据分解为各个数据项的接口数据，放到对应的子类。
（CommentFirstLevelPage也要进行类似的修改，此处省略）

相关代码
PostCheckFirstLevelPage
```js
(function () {
    var PostCheckFirstLevelPage = YYC.Class(PostFirstLevelPage, {
        Init: function () {
            this.base("check");  //传入数据项id前缀

            this.P_ajaxData = {
                url: "/postCheck/get_check_data",
                name: "贴子审核量",
                field: "num"
            };
        }
    });

    window.PostCheckFirstLevelPage = PostCheckFirstLevelPage;
}());
```
PostDeleteFirstLevelPage
```js
(function () {
    var PostDeleteFirstLevelPage = YYC.Class(PostFirstLevelPage, {
        Init: function () {
            this.base("delete ");  //传入数据项id前缀

            this.P_ajaxData = {
                url: "/postCheck/get_delete_data",
                name: "贴子删除量",
                field: "delete"
            };
        }
    });

    window.PostDeleteFirstLevelPage = PostDeleteFirstLevelPage;
}());
```
然后再对应修改它的父类PostFirstLevelPage、FirstLevelPage、Page以及main和controlDatePicker模块。
PostFirstLevelPage
```js
Init: function (item) {
    this.base("post", item);  //传入选项前缀
}
```
FirstLevelPage
```js
Init: function (tab, item) {
    this.base(tab, "firstLevelPage", item); //传入页面id前缀
},
```
Page
```js
Init: function (tab, level, item) {
    this._tab = tab;
    this._level = level;
    this._item = item;
},
```
main
```js
window.main = {
    init: function () {
//        window.postFirstLevelPage = new PostFirstLevelPage();
        window.postCheckFirstLevelPage = new PostCheckFirstLevelPage();
        window.postDeleteFirstLevelPage = new PostDeleteFirstLevelPage();

        window.postCheckFirstLevelPage.init();
        window.postDeleteFirstLevelPage.init();
```
controlDatePicker
```js
        function _onchange() {
//            window.postFirstLevelPage.refreshData(_selectDate); //更新一级页面
            window.postCheckFirstLevelPage.refreshData(_selectDate);
            window.postDeleteFirstLevelPage.refreshData(_selectDate);
            …
        }
```

考虑到：
1、采用方案2代价比较大。
2、当前场景下 “审核量”和“删除量”只有id前缀和接口数据不同，其余都一样，因此仅仅为了实现不同的id前缀和接口数据而大费周折地提出PostCheckFirstLevelPage、PostDeleteFirstLevelPage子类是没有必要的。

因此，此处选择方案1，满足当前需求即可。以后如果数据项要变化，再考虑采用方案2来解决。





<p><a name="second_refactor2"></a></p>
###继续重构，提出ui模块
增加ui模块，放置表现层逻辑，负责与dom的交互。
优点：
1、分离职责
表现层的逻辑与业务逻辑是正交的，应该将其分离出来
2、方便测试
测试业务逻辑时不用再受到表现层逻辑的干扰，可直接对ui模块stub。
<p><a name="second_model"></a></p>
###领域模型


![_2_ui_](http://img2.tbcdn.cn/L1/461/1/927d4793a5779b613299d9e5501821923db082f0)


<p><a name="second_think"></a></p>
###思考：是否需要使用观察者模式重构
我们看到controlDatePicker与Page的子类都有关联，这是因为用户更改日期后，controlDatePicker需要通知页面更新数据显示。
或许应该使用观察者模式重构？
####使用观察者重构后的领域模型


![_2_](http://img2.tbcdn.cn/L1/461/1/57cd78b0edf55772cedebd7ba573064d22e1e2cf)


我们来看下观察者模式的应用场景：

 - 当一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变。
 - 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之,你不希望这些对象是紧密耦合的。
 - 对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。

对于第1和2个观察者模式应用场景，当前场景controlDatePicker需要通知的对象是已知且固定的，因此不符合。
对于第3个场景，controlDatePicker确实需要知道通知对象的细节（需要在_onchange中调用通知对象的方法），但是考虑到通知的对象不是很多，而且_onchange中调用通知对象的逻辑也不是很复杂，因此也不需要使用观察者模式。
**综上所述，不需要使用观察者模式重构。**

<p><a name="second_analysis3"></a></p>
###分析当前设计
第1阶段为面向过程设计（实现各自的功能点），当前架构则为面向对象设计（识别对象，划分职责）：
**优点**
1、消除了重复代码
由于将子类共同模式提取到父类中，子类通过实现父类的抽象成员或扩展父类的虚成员等方式来实现自己的不同点，从而消除继承树中的重复代码。
2、封闭变换点
适应“一级页面”和“二级页面”逻辑的变化：
如要修改一级和二级页面的逻辑，则修改Page即可；如要修改一级页面的逻辑，则修改FirstLevelPage及其父类即可；如要修改“发贴审核”的一级页面的逻辑，则修改PostFirstLevelPage及其父类即可；如要修改“发贴审核”的“审核量”数据的一级页面的逻辑，则可以增加PostFirstLevelPage的子类PostCheckFirstLevelPage，修改该类及其父类即可。
**缺点**
1、实现较复杂 
需要划分各个类的职责和相互之间的交互关系，因此实现相对要复杂点。

<p><a name="third"></a></p>
##第三个阶段
<p><a name="third_request"></a></p>
###需求变化
现在一级页面的数据项的逻辑发生了变化：
“发贴审核”和“评论审核”的“审核量”在一级页面中增加“审核量增加百分比”（当天审核量相对于前一天增加的百分比)。
计算公式：
百分比 = （指定日期的审核量 – 前一天的审核量） /前一天的审核量


![3_](http://img4.tbcdn.cn/L1/461/1/cd4d9cdcb24b1aad5e642a0fbc329274da0c6c7d)
“发贴审核”的“审核量”增加百分比

![3_](http://img4.tbcdn.cn/L1/461/1/3353dd276142d92bb00238c78a5eec5974944fda)
“评论审核”的“审核量”增加百分比


<p><a name="third_design"></a></p>
###架构设计
提出PostFirstLevelPage的子类PostCheckFirstLevelPage、PostDeleteFirstLevelPage，分别对应“发贴审核”的“审核量”和“删除量”；提出CommentFirstLevelPage的子类CommentCheckFirstLevelPage、CommentDeleteFirstLevelPage，分别对应“评论审核”的“审核量”和“删除量”。
然后由PostCheckFirstLevelPage、CommentCheckFirstLevelPage分别实现增加百分比数据显示的逻辑，并将共同模式提到它们的基类FirstLevelPage中。
####领域模型


![_3_](http://img1.tbcdn.cn/L1/461/1/12d6cb151cfee7e2af2d12b4946d3c8b734661b1)


<p><a name="third_code1"></a></p>
###项目示例代码
[详见GitHub地址](https://github.com/yyc-git-show/frontEndArchitecture_code/tree/master/3_%E8%80%81%E6%9E%B6%E6%9E%84%E5%A4%84%E7%90%86%E6%96%B0%E5%A2%9E%E9%9C%80%E6%B1%82)

<p><a name="third_analysis1"></a></p>
###分析当前设计
1、层次太多
现在Page继承树有4层，层次过多，一个变化点可能会导致多层的类的修改，复杂性增加。
引用自《Java面向对象编程》：

> （1）对象模型的结构太复杂，难以理解，增加了设计和开发的难度。在继承树最底层的子类会继承上层所有直接父类或间接父类的方法和属性，假如子类和父类之间还有频繁的方法覆盖和属性被屏蔽的现象，那么会增加运用多态机制的难度，难以预计在运行时方法和属性到底和哪个类绑定。
> （2）影响系统的可扩展性。继承树的层次越多，在继承树上增加一个新的继承分支需要创建的类越多。

因此，需要对Page继承树进行重构，减少层次数量。
2、多余代码
FirstLevelPage的P_showPercent对于PostDeleteFirstLevelPage和CommentDeleteFirstLevelPage来说是多余的。
多余代码在继承中是一个常见的问题。继承层次越多，问题越严重。
<p><a name="third_refactor"></a></p>
###重构
####提出“选项”和“数据项”
可以从现有设计中找到提示。
Page继承树的对应关系：



![_3_](http://img1.tbcdn.cn/L1/461/1/24159f8691d4b45a1968701ac02bb292ac346813)



可以看到，第三层对应选项，第四层对应数据项，因此可以提取出“选项”和“数据项”，Page继承树中只保留“一级页面”和“二级页面”。
####确定交互关系
现在要考虑“选项”、“数据项”、“一级页面”、“二级页面”之间的关系。
**首先分析“选项”和“数据项”的关系**
“选项”对应整个选项页面，“数据项”对应页面的数据项。页面中每个选项包含两个数据项“审核量”和“删除量”，因此它们应该为包含关系。
现在每个选项中有两个数据项（“审核量”和“删除量”），因此目前1个选项包含两个数据项。
**领域模型**
 
 
![_3_](http://img2.tbcdn.cn/L1/461/1/22eb255b07c9986f5cdc3e3d9cb45d81fe110e05)



**分析“数据项”和“一级页面”、“二级页面”的关系**
现在缩小了Page对应的页面范围，“一级页面”现在只对应选项页面中属于所属“数据项”的部分（之前对应整个选项页面），“二级页面”对应弹出层页面中属于所属“数据项”的部分（之前对应整个弹出层页面）。
“数据项”应该与“一级页面”、“二级页面”是包含关系。
**领域模型**


![_3_](http://img3.tbcdn.cn/L1/461/1/f8d62ea01e22d453ad9e7346c8b74b9da22312e6)



####确定职责
“选项”对应选项页面，负责“数据项”的管理和与选项有关的逻辑。
“数据项”对应选项页面的数据项，负责数据项的“一级页面”和“二级页面”的管理。
“一级页面”对应选项页面中属于所属“数据项”的部分，负责所属“数据项”的一级页面的逻辑。
“二级页面”对应弹出层页面中属于所属“数据项”的部分，负责所属“数据项”的二级页面的逻辑。
####删除controlTab模块，提出Controller类
将controlTab升级为单例容器类Controller，它包含两个选项，负责选项的管理。
**领域模型**


![_3_Controller_](http://img3.tbcdn.cn/L1/461/1/07e880650ff5cb8309a0a56a7e80e2aa40da06f1)



####删除main
我们来看下main的代码：
```js
window.main = {
    init: function () {
        window.postCheckFirstLevelPage = new PostCheckFirstLevelPage();
        window.postDeleteFirstLevelPage = new PostDeleteFirstLevelPage();
        window.commentCheckFirstLevelPage = new CommentCheckFirstLevelPage();
        window.commentDeleteFirstLevelPage = new CommentFirstLevelPage();
		//初始化一级页面
        window.postCheckFirstLevelPage.init();
        window.postDeleteFirstLevelPage.init();
        window.commentCheckFirstLevelPage.init();
        window.commentDeleteFirstLevelPage.init();

        window.postSecondLevelPage = new SecondLevelPage("post", window.postFirstLevelPage);
        window.commentSecondLevelPage = new SecondLevelPage("comment",window.commentFirstLevelPage);
		//初始化二级页面
        postSecondLevelPage.init();
        commentSecondLevelPage.init();

		//初始化tab
        controlTab.initTabEvent();

		//初始化日历
        controlDatepicker.initDatePicker();
        controlDatepicker.initScroll();
   }
};
```
main中的“初始化一级页面和二级页面”属于页面管理的职责，应该放到Item中；现在Controller替代了controlTab，负责选项管理，因此“初始化tab”应该放到Controller中；“初始化日历”也属于“选项管理”的职责，因此也应该放到Controller中。
经过重构后，main现在是多余的了，应该将其删除，让页面直接调用Controller。

**领域模型**


![_3_main_](http://img1.tbcdn.cn/L1/461/1/414441913ea0fa6c842adb0efb214ad28686bb18)


####提出接口数据itemData
现在回头来审视Page中的接口数据：
1、后台接口数据分散在PostFirstLevelPage、CommentFirstLevelPage中，不方便管理。
2、因为FirstLevelPage、SecondLevelPage需要共享itemData数据，所以两者之间有关联关系。
因此将接口数据提出，放到itemData中。
因为接口数据属于数据项Item，所以应该由数据项负责操作itemData。
提出itemData后，一级页面、二级页面通过对应的数据项来获得对应的接口数据，它们之间不再有关联关系。

**领域模型**


![_3_ItemData_](http://img1.tbcdn.cn/L1/461/1/d4da2418404b4d578f3b1f5acf1d1b48407709f4)


####“选项”Tab提出子类PostTab、CommentTab
因为两个选项“发贴审核”和“评论审核”相互独立，因此提出Tab的子类PostTab、CommentTab，分别对应这两个选项。
**领域模型**


![_3_Tab_](http://img3.tbcdn.cn/L1/461/1/29d0ac2081c51d76ecd952adc3742d56f255e727)



####“数据项”Item提出子类CheckItem、DeleteItem
两个选项的“审核量”和“删除量”数据项虽然相互独立，但是它们对“一级页面”和“二级页面”管理的逻辑分别相同，只有后台接口的不同，其它模式都一样因此只需提出CheckItem类，对应两个选项的“审核量”；提出DeleteItem类，对应两个选项的 “删除量”。
**领域模型**


![_3_Item_](http://img2.tbcdn.cn/L1/461/1/6a12914afd7e883c83e84a9c84b6874c29beb53a)



####重构一级页面FirstLevelPage
**分解职责**
分解FirstLevelPage的“绘制选项趋势图”的职责，将“选项趋势图绘制”的逻辑移到“选项”Tab的getAndShowFirstLevelChart方法中（因为“选项中绘制所有数据项的趋势图”并不应该由某个具体的“数据项”来负责，而应该由“选项”直接负责），留下与一级页面的职责相关的“获得所属数据项的趋势图数据”逻辑。
重构后相关代码如下：
Tab
```js
getAndShowFirstLevelChart: function (selectDate) {
    var seriesDataArr = [],
        data = null;

    //Item负责获得图表数据
    this._items.forEach(function (item) {
        data = item.getFirstLevelChartData(selectDate);
        if (data) {
            seriesDataArr.push(data);
        }
    });

    //Tab负责绘制图表
    this.P_draw(seriesDataArr);
},
```
Item
```js
getFirstLevelChartData: function (selectDate) {
    return this.P_firstLevelPage.getChartData(selectDate);
},
```
FirstLevelPage
```js
getChartData: function (selectDate) {
    var seriesDataArr = [],
        ajaxData = null,
        self = this;

    ajaxData = this.P_ajaxData;

    $.ajax({
        url: ajaxData.url,
        data: {
            begin_date: _getStartDate(selectDate),		//获得selectDate-7的日期
            end_date: selectDate
        },
        dataType: "json",
        async: false,  //同步
        success: function (dataArr) {
            seriesData = self.P_getSeriesData(dataArr, self._item.getTitleName());
        }
    });

    return seriesDataArr;
},
```
对应的dom的id也要修改：
```html
<!--删除一级页面的id前缀，因为"绘制选项趋势图"与选项Tab有关而与FirstLevelPage无关，因此该dom不再与FirstLevelPage对应-->
	<section id="post">
        …
        <!--<section id="post_firstLevelPage_chartBody" class="chartContainer">-->
        <section id="post_chartBody" class="chartContainer">
```


**使用策略模式，提出FirstLevelPage的子类CommonFirstLevelPage和PercentFirstLevelPage**
CommonFirstLevelPage负责“删除量”数据项的一级页面逻辑；PercentFirstLevelPage负责“审核量”数据项的一级页面逻辑，加入了显示百分比数据的逻辑。

**重构后的领域模型**


![_3_FirstLevelPage_](http://img4.tbcdn.cn/L1/461/1/bba3f11d2d1d0333d61ce8d982e8ec7488635432)


####id前缀注入的修改
第二个阶段是在Page类族的构造函数中注入id前缀，而现在已经提出了“选项”、“数据项”、“一级页面”、“二级页面”这四个实体，因此可以增加id属性作为实体的标识符，保存对应的id前缀，而不用再注入id前缀了。
####关于“tab与item、item与Page之间双向关联”的分析
因为Item需要访问所属选项Tab的id、name、getSelectDate等成员，Page需要访问所属数据项Item的id、itemData等成员，因此tab与item、item与Page之间为双向关联的关系。
另外Page还需要访问所属选项的id（用于构造id前缀，访问对应的dom），所以Item提供getTabId方法，使Page通过所属Item就可以获得选项的id，避免了Page依赖Tab造成的循环依赖的问题。
####二级页面dom改为相互独立
第二个阶段中的“共享二级页面dom”的设计现在不合适了！
这是因为：
1、在上面的“确定交互关系”讨论中，确定了“数据项”与“二级页面”是1对1的包含关系，因此数据项的二级页面从逻辑上来看已经是相互独立的了，所以为了避免数据项操作各自的二级页面dom时相互干扰，应该将二级页面dom改为相互独立。
2、SecondLevelPage可以通过访问所属的Item来获得Item的数据项id前缀，因此能够访问包含数据项id前缀的dom。
所以应该将每个选项的二级页面dom改为与数据项相关的、相互独立的dom（dom id包含数据项id前缀），然而这样又会造成二级页面dom冗余（html结构都一样，只是id不一样）。
考虑到当前dom冗余还不是很严重，并且它们都在一个页面中，管理起来也比较容易，因此以适当的dom冗余来换取灵活性是值得的。
如果后期dom冗余过于严重，则可以考虑使用js模板来生成重复的html代码。
相关代码：
```html
 <!--发贴审核选项-->
  <section id="post">
    …

        <!--数据项的secondLevelPage容器现在相互独立了-->

        <section id="post_check_secondLevelPage_chartBody" class="secondLevelChartBody qushiBody">
           …
        </section>

        <section id="post_delete_secondLevelPage_chartBody" class="secondLevelChartBody qushiBody">
            …
        </section>
    …
</section>

 <!--评论审核选项-->
  <section id="comment">
    …

        <!--数据项的secondLevelPage容器现在相互独立了-->

        <section id="comment_check_secondLevelPage_chartBody" class="secondLevelChartBody qushiBody">
            …
        </section>

        <section id="comment_delete_secondLevelPage_chartBody" class="secondLevelChartBody qushiBody">
            …
        </section>
    …
</section>
```

<p><a name="third_model"></a></p>
###领域模型和分层
现在可以对系统进行分层，如下所示：

 - 系统交互层

    负责与页面交互

 - 业务逻辑层

    负责系统的业务逻辑

 - 数据层

    放置接口数据

 - 辅助层

    放置通用类

**领域模型**

![_3_](http://img1.tbcdn.cn/L1/461/1/4ebe8bffef5397ae6c4d6e629591382b1b72756c)


<p><a name="third_code2"></a></p>
###项目示例代码
[详见GitHub地址](https://github.com/yyc-git-show/frontEndArchitecture_code/tree/master/3_%E6%96%B0%E6%9E%B6%E6%9E%84)

<p><a name="third_analysis2"></a></p>
###分析当前设计
**优点**
1、相对于第二阶段的架构，新架构分离出了“选项”和“数据项”，这样能够适应“选项”、“数据项”、“一级页面”、“二级页面”各自独立的变化，因而更加灵活了。

 - 例如“一级页面”或“二级页面”发生了变化：

1）“发贴审核”和“评论审核”的“审核量”在一级页面中增加“星期审核量总和增加百分比”（当前星期审核量总和相对于前一个星期增加的百分比）。

那么只需要对应修改“审核量”数据项CheckItem使用的PercentFirstLevelPage类即可。

2）“发贴审核”和“评论审核”的“审核量”增加二级页面的数据下载功能。

那么可以增加一个下载类Download，负责二级页面数据下载。
因为它属于二级页面的逻辑，所以由“二级页面”SecnondLevelPage组合Download。

领域模型
![_Download](http://img4.tbcdn.cn/L1/461/1/59e525f6b894e5279feb7bf15b6acaf818a3c9b5)


 - 又比如现在“数据项”发生了变化：

1）“发贴审核”和“评论审核”的“删除量”增加最近二个月范围的“审核量增加百分比”数据的图表，该图表显示在二级页面中。

因为该图表也显示在二级页面中，因此现在“删除量”这个数据项应该包含二个“二级页面”，一个“二级页面”负责日期范围删除量的图表，另一个“二级页面”负责最近二个月范围审核量增加百分比的图表。

因此可以增加“二级页面”SecondLevelPage的子类QuShiSecondLevelPage和PercentSecondLevelPage。QuShiSecondLevelPage负责显示日期范围删除量的图表，PercentSecondLevelPage负责显示二个月范围审核量增加百分比的图表。


领域模型
![_](http://img2.tbcdn.cn/L1/461/1/3fa9c3c09ab63e58e2762ea7efa4bb1714619a9e)


**缺点**
1、如果选项所有数据项的一级页面或二级页面统一发生变化，则修改起来没有第二阶段架构方便。

 - 如现在“发贴审核”的所有数据项的一级页面的逻辑发生了变化。

如果是第二阶段的架构，则只需修改PostFirstLevelPage及其父类即可。

如果是当前的架构，则需要增加Item的子类PostCheckItem、PostDeleteItem、CommentCheckItem、CommentDeleteItem，分别对应两个选项的四个数据项。然后修改属于“发贴审核”的数据项类PostCheckItem、PostDeleteItem。

####对比第二阶段架构和第三阶段架构
<table>
<thead>
<tr class="header">
<th align="left">比较</th>
<th align="left">第二阶段架构</th>
<th align="left">第三阶段架构</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">适应的变化点</td>
<td align="left">“一级页面”、“二级页面”</td>
<td align="left">“选项”、“数据项”、“一级页面”、“二级页面”</td>
</tr>
<tr class="even">
<td align="left">层次结构</td>
<td align="left" valign="top">纵向层次结构 <img src="http://img2.tbcdn.cn/L1/461/1/24159f8691d4b45a1968701ac02bb292ac346813" alt="3" style="width: 400px;display:block;"></td>
<td align="left" valign="top">横向层次结构 <img src="http://img2.tbcdn.cn/L1/461/1/606405283ec01041d093dc59032f9fd8998d303c" alt="3" style="width: 400px;display:block;"></td>
</tr>
</tbody>
</table>

<p><a name="summary"></a></p>
#总结
在本文中可以看到，我并没有一开始就给出一个完善的架构设计，这也是不可能的。随着需求的不断变化和我对需求理解的不断深入，对应的架构也在不断的演化。
在第一个阶段中，我从功能点的实现出发，将需求分割为一个个模块，负责实现对应的功能。因为当时需求比较简单，因此直接用面向过程的思维来设计是适合当时场景的，也是最简单的方式。
在第二个阶段中，我通过重构进行了由下而上的分析，采用面向对象思维对需求进行了初步建模，提取出了“一级页面”和“二级页面”的模型。
在第三个阶段中，由于需求的进一步变化，导致原有设计中出现了坏味道。因此我及时重构，提取出了“选项”和“数据项”的概念，分解了Page继承树，减少了复杂度，适应了更多的变化点。
在实际的工程中，应该根据需求来设计架构。对于容易变化的需求，常常采用敏捷设计，先给出初步的设计，然后在坚实的测试保证下不断地迭代、重构、集成。
<p><a name="reference"></a></p>
#参考资料
《Java面向对象编程》
《重构：改善既有代码的设计》
[演化架构与紧急设计系列](http://www.ibm.com/developerworks/cn/java/j-eaed/)]]></description></item><item><title>YOOP备份</title><link>http://www.cnblogs.com/chaogex/archive/2014/08/26/3936518.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Tue, 26 Aug 2014 01:37:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/08/26/3936518.html</guid><description><![CDATA[<p>YOOP的注释中加入：</p>
<p>&nbsp;</p>
<p>保护前缀</p>
<p>c#中测试结果：</p>
<p>class Program<br />    {<br />        class A<br />        {<br />            protected virtual int a()<br />            {<br />                return 100;<br />            }<br />            public int b()<br />            {<br />                return this.a();<br />            }<br />        }<br />        class B : A<br />        {<br />            protected override int a()<br />            {<br />                return 200;<br />            }<br />            public int b()<br />            {<br />                return base.b();<br />            }<br />        }<br />        static void Main(string[] args)<br />        {<br />            var b = new B();<br />            var t = b.b();<br />            Console.WriteLine(t);   //200<br />        }<br />    }</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>大家好！今天我正式发布我的OOP框架<span style="color: #000000; font-size: 18px;">YOOP</span>！该框架将帮助开发者更好地进行面向对象编程。</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">介绍</span></strong></p>
<p>该框架包含接口、抽象类、类。</p>
<p>接口Interface可以继承多个接口，可以定义方法、属性。</p>
<p>抽象类AClass可以继承多个接口、一个抽象类，可以定义构造函数、公有成员、私有成员、保护成员、静态成员、虚<span style="color: #ff0000;">方法</span>、抽象成员。</p>
<p>类Class可以继承多个接口、一个抽象类或类，可以定义构造函数、公有成员、私有成员、保护成员、静态成员、虚<span style="color: #ff0000;">方法</span>。&nbsp;</p>
<h1><span style="background-color: #ffffff; color: #000000;">子类调用父类成员</span></h1>
<p>在子类中，可以使用this.base()来调用父类同名方法。也可以使用this.baseClass来访问父类的原型。</p>
<h1><span style="background-color: #ffffff; color: #000000;">主要的语法规则</span></h1>
<p><span style="color: #ff0000;">如果企图声明虚属性，会抛出异常。</span></p>
<h2>类Class：</h2>
<ol>
<li>创建实例时调用构造函数。</li>
<li>验证是否实现了接口的方法、属性，如果没有实现会抛出异常。</li>
<li>验证是否实现了父类的抽象成员，如果没有实现会抛出异常。</li>
<li>只能继承一个类（AClass或Class），否则抛出异常.</li>
<li>不能定义抽象成员，否则抛出异常。</li>

</ol>
<h2>抽象类AClass：</h2>
<ol>
<li>可以声明构造函数，供子类Class调用。</li>
<li>抽象类如果继承类Class，会抛出异常。</li>
<li>不用实现接口，可以交给子类Class实现。</li>
<li>不用实现父类抽象成员，可以交给子类Class实现。</li>
<li>只能继承一个抽象类AClass，否则抛出异常。</li>

</ol>
<h2>接口Interface：</h2>
<ol>
<li>接口只能继承接口，否则抛出异常。</li>

</ol>
<p style="width: 100%; background-color: #c0c0c0;"><span style="font-family: 幼圆;"><strong><span style="color: #ffffff; font-size: 18pt;">用法</span></strong></span></p>
<h1>接口</h1>
<h2>定义接口</h2>
<p>只有方法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">method1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">method2</span><span style="color: #800000;">"</span>);</pre>
</div>
<p>只有属性：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface([], [<span style="color: #800000;">"</span><span style="color: #800000;">attribute1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">attribute2</span><span style="color: #800000;">"</span>]);</pre>
</div>
<p>既有方法又有属性：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface([<span style="color: #800000;">"</span><span style="color: #800000;">method1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">method2</span><span style="color: #800000;">"</span>], [<span style="color: #800000;">"</span><span style="color: #800000;">attribute1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">attribute2</span><span style="color: #800000;">"</span>]);</pre>
</div>
<h2>继承接口</h2>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface([<span style="color: #800000;">"</span><span style="color: #800000;">method1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">method2</span><span style="color: #800000;">"</span>],[<span style="color: #800000;">"</span><span style="color: #800000;">attribute1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">attribute2</span><span style="color: #800000;">"</span><span style="color: #000000;">]);
</span><span style="color: #0000ff;">var</span> B = YYC.Interface(A, <span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> C = YYC.Interface([A], [<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span>], [<span style="color: #800000;">"</span><span style="color: #800000;">a1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">a2</span><span style="color: #800000;">"</span><span style="color: #000000;">]);
</span><span style="color: #0000ff;">var</span> D = YYC.Interface([A, B], [<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span>], [<span style="color: #800000;">"</span><span style="color: #800000;">a1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">a2</span><span style="color: #800000;">"</span>]);</pre>
</div>
<h1>抽象类</h1>
<h2>定义抽象类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('74d2895c-4a23-4e35-9396-13051e6c6202')"><img id="code_img_closed_74d2895c-4a23-4e35-9396-13051e6c6202" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_74d2895c-4a23-4e35-9396-13051e6c6202" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('74d2895c-4a23-4e35-9396-13051e6c6202',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_74d2895c-4a23-4e35-9396-13051e6c6202" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
    Init: </span><span style="color: #0000ff;">function</span> () { <span style="color: #008000;">//</span><span style="color: #008000;">构造函数</span>
<span style="color: #000000;">    },
    Protected: {    </span><span style="color: #008000;">//</span><span style="color: #008000;">保护成员</span>
        Abstract: { <span style="color: #008000;">//</span><span style="color: #008000;">保护抽象成员</span>
<span style="color: #000000;">        },
        Virtual: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">保护虚方法</span>
<span style="color: #000000;">        },
        P_proA: </span><span style="color: #0000ff;">true</span>,   <span style="color: #008000;">//</span><span style="color: #008000;">保护属性</span>
       P_proM: <span style="color: #0000ff;">function</span> () { }    <span style="color: #008000;">//</span><span style="color: #008000;">保护方法</span>
<span style="color: #000000;">    },
    Public: {   </span><span style="color: #008000;">//</span><span style="color: #008000;">公有成员</span>
        Abstract: { <span style="color: #008000;">//</span><span style="color: #008000;">公有抽象成员</span>
<span style="color: #000000;">        },
        Virtual: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">公有虚方法</span>
<span style="color: #000000;">        },
        pubM: </span><span style="color: #0000ff;">function</span> () { },  <span style="color: #008000;">//</span><span style="color: #008000;">公有方法</span>
      pubA: 0    <span style="color: #008000;">//</span><span style="color: #008000;">公有属性</span>
<span style="color: #000000;">    },
    Private: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">私有成员</span>
        _priA: "",   <span style="color: #008000;">//</span><span style="color: #008000;">私有属性</span>
        _priM: <span style="color: #0000ff;">function</span> () { } <span style="color: #008000;">//</span><span style="color: #008000;">私有方法</span>
<span style="color: #000000;">    },
    Abstract: { </span><span style="color: #008000;">//</span><span style="color: #008000;">公有抽象成员</span>
<span style="color: #000000;">    },
    Virtual: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">公有虚方法</span>
<span style="color: #000000;">    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承抽象类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('86502fa7-140a-46a9-9ca3-cc15a69312c9')"><img id="code_img_closed_86502fa7-140a-46a9-9ca3-cc15a69312c9" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_86502fa7-140a-46a9-9ca3-cc15a69312c9" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('86502fa7-140a-46a9-9ca3-cc15a69312c9',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_86502fa7-140a-46a9-9ca3-cc15a69312c9" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({});
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.AClass(A, {});
</span><span style="color: #0000ff;">var</span> C = YYC.AClass({Class: A}, {}); </pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承接口</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('9e2698d9-dc7f-4d21-ac3c-9365f4b1430c')"><img id="code_img_closed_9e2698d9-dc7f-4d21-ac3c-9365f4b1430c" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9e2698d9-dc7f-4d21-ac3c-9365f4b1430c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9e2698d9-dc7f-4d21-ac3c-9365f4b1430c',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9e2698d9-dc7f-4d21-ac3c-9365f4b1430c" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> B = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.AClass({ Interface: A }, {
    Public: {
        m1: function () { }
    }
});
</span><span style="color: #0000ff;">var</span> D =<span style="color: #000000;"> YYC.AClass({ Interface: [A, B] }, {
    Public: {
        m1: function () { },
        m2: function () { }
    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承接口和抽象类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('4a15c29d-3313-4198-a7e9-79a429b0deb0')"><img id="code_img_closed_4a15c29d-3313-4198-a7e9-79a429b0deb0" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_4a15c29d-3313-4198-a7e9-79a429b0deb0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4a15c29d-3313-4198-a7e9-79a429b0deb0',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_4a15c29d-3313-4198-a7e9-79a429b0deb0" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> B = YYC.Interface([<span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span>], [<span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span><span style="color: #000000;">]);
</span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.AClass({});
</span><span style="color: #0000ff;">var</span> D =<span style="color: #000000;"> YYC.AClass({ Interface: [A, B], Class: C }, {
    Public: {
        m1: function () { },
        a: </span><span style="color: #800080;">0</span><span style="color: #000000;">
    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>类</h1>
<h2>定义类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('9e441a77-56a3-4ab3-84c3-75f649488695')"><img id="code_img_closed_9e441a77-56a3-4ab3-84c3-75f649488695" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9e441a77-56a3-4ab3-84c3-75f649488695" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9e441a77-56a3-4ab3-84c3-75f649488695',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9e441a77-56a3-4ab3-84c3-75f649488695" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({
                Init: function () { </span><span style="color: #008000;">//</span><span style="color: #008000;">构造函数</span>
<span style="color: #000000;">                },
                Protected: {    </span><span style="color: #008000;">//</span><span style="color: #008000;">保护成员</span>
                    Virtual: {  <span style="color: #008000;">//</span><span style="color: #008000;">保护虚方法</span>
<span style="color: #000000;">                    },
                    P_proA: </span><span style="color: #0000ff;">true</span>,   <span style="color: #008000;">//</span><span style="color: #008000;">保护属性</span>
                    P_proM: function () { }    <span style="color: #008000;">//</span><span style="color: #008000;">保护方法</span>
<span style="color: #000000;">                },
                Public: {   </span><span style="color: #008000;">//</span><span style="color: #008000;">公有成员</span>
                    Virtual: {  <span style="color: #008000;">//</span><span style="color: #008000;">公有虚方法</span>
<span style="color: #000000;">                    },
                    pubM: function () { },  </span><span style="color: #008000;">//</span><span style="color: #008000;">公有方法</span>
                    pubA: <span style="color: #800080;">0</span>    <span style="color: #008000;">//</span><span style="color: #008000;">公有属性</span>
<span style="color: #000000;">                },
                Private: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">私有成员</span>
                    _priA: <span style="color: #800000;">""</span>,   <span style="color: #008000;">//</span><span style="color: #008000;">私有属性</span>
                    _priM: function () { } <span style="color: #008000;">//</span><span style="color: #008000;">私有方法</span>
<span style="color: #000000;">                },
                Virtual: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">公有虚方法</span>
<span style="color: #000000;">                }
            });</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承抽象类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('9384a505-35bc-44d2-aa46-b5e0deed39f9')"><img id="code_img_closed_9384a505-35bc-44d2-aa46-b5e0deed39f9" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9384a505-35bc-44d2-aa46-b5e0deed39f9" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9384a505-35bc-44d2-aa46-b5e0deed39f9',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9384a505-35bc-44d2-aa46-b5e0deed39f9" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({});
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.AClass(A, {});
</span><span style="color: #0000ff;">var</span> C = YYC.AClass({ Class: A }, {});</pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('976ac329-56ac-4f09-811f-66706040d12f')"><img id="code_img_closed_976ac329-56ac-4f09-811f-66706040d12f" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_976ac329-56ac-4f09-811f-66706040d12f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('976ac329-56ac-4f09-811f-66706040d12f',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_976ac329-56ac-4f09-811f-66706040d12f" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({});
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {});
</span><span style="color: #0000ff;">var</span> C = YYC.Class({ Class: A }, {});</pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承接口</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('30e4055d-da03-44ae-85cc-0501a94069a4')"><img id="code_img_closed_30e4055d-da03-44ae-85cc-0501a94069a4" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_30e4055d-da03-44ae-85cc-0501a94069a4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('30e4055d-da03-44ae-85cc-0501a94069a4',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_30e4055d-da03-44ae-85cc-0501a94069a4" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> B = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.Class({ Interface: A }, {
    Public: {
        m1: function () { }
    }
});
</span><span style="color: #0000ff;">var</span> D =<span style="color: #000000;"> YYC.Class({ Interface: [A, B] }, {
    Public: {
        m1: function () { },
        m2: function () { }
    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承接口和抽象类/类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('8dc18103-1f27-4cb1-8bab-d06523bedfcc')"><img id="code_img_closed_8dc18103-1f27-4cb1-8bab-d06523bedfcc" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_8dc18103-1f27-4cb1-8bab-d06523bedfcc" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8dc18103-1f27-4cb1-8bab-d06523bedfcc',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_8dc18103-1f27-4cb1-8bab-d06523bedfcc" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> B = YYC.Interface([<span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span>], [<span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span><span style="color: #000000;">]);
</span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.AClass({});
</span><span style="color: #0000ff;">var</span> D =<span style="color: #000000;"> YYC.Class({});
</span><span style="color: #0000ff;">var</span> E =<span style="color: #000000;"> YYC.AClass({ Interface: [A, B], Class: C }, {
    Public: {
        m1: function () { },
        a: </span><span style="color: #800080;">0</span><span style="color: #000000;">
    }
});
</span><span style="color: #0000ff;">var</span> F =<span style="color: #000000;"> YYC.AClass({ Interface: [A, B], Class: D }, {
    Public: {
        m1: function () { },
        a: </span><span style="color: #800080;">0</span><span style="color: #000000;">
    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>构造函数</h1>
<div class="cnblogs_code" onclick="cnblogs_code_show('1f31e68a-88be-4e95-85a9-35fcd59c1d1c')"><img id="code_img_closed_1f31e68a-88be-4e95-85a9-35fcd59c1d1c" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1f31e68a-88be-4e95-85a9-35fcd59c1d1c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1f31e68a-88be-4e95-85a9-35fcd59c1d1c',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1f31e68a-88be-4e95-85a9-35fcd59c1d1c" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({
　　Init: function(t){
　　　　</span><span style="color: #0000ff;">this</span>.value =<span style="color: #000000;"> t;
　　}
});
</span><span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span> A(<span style="color: #800080;">100</span><span style="color: #000000;">);
console.log(a.value);　　</span><span style="color: #008000;">//</span><span style="color: #008000;">100</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>静态成员</h1>
<p>使用&ldquo;类.静态成员&rdquo;的形式来调用静态成员。这里静态成员实质是类（function，function也是对象）的成员。</p>
<p>注意！静态方法中的this指向类，不是指向类的实例！</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5b868112-991a-4f5f-8bce-cabd0c7c48aa')"><img id="code_img_closed_5b868112-991a-4f5f-8bce-cabd0c7c48aa" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_5b868112-991a-4f5f-8bce-cabd0c7c48aa" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5b868112-991a-4f5f-8bce-cabd0c7c48aa',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_5b868112-991a-4f5f-8bce-cabd0c7c48aa" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({
    Static: {
        a: </span>100<span style="color: #000000;">,
        method1: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">return</span> 200<span style="color: #000000;">;
        },
        method2: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
             </span><span style="color: #0000ff;">this</span>.k = 300<span style="color: #000000;">;
        }
    }
});

A.method2();

console.log(A.a);   </span><span style="color: #008000;">//</span><span style="color: #008000;">100</span>
console.log(A.method1());    <span style="color: #008000;">//</span><span style="color: #008000;">200</span>
console.log(A.k);   <span style="color: #008000;">//</span><span style="color: #008000;">300</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>类的成员互相调用</h1>
<p>使用this来调用。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('2fa57eb4-faee-463b-b0f3-ed5329d090c0')"><img id="code_img_closed_2fa57eb4-faee-463b-b0f3-ed5329d090c0" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_2fa57eb4-faee-463b-b0f3-ed5329d090c0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2fa57eb4-faee-463b-b0f3-ed5329d090c0',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_2fa57eb4-faee-463b-b0f3-ed5329d090c0" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({
    Private: {
        _a: </span><span style="color: #800080;">100</span><span style="color: #000000;">
    },
    Public: {
        method: function (t) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._a;
        }
    }
});
</span><span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> A();
console.log(a.method);  </span><span style="color: #008000;">//</span><span style="color: #008000;">100</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>子类调用父类</h1>
<p>使用this.base()可调用父类同名函数。</p>
<p>使用this.baseClass.xx.call(this, xx)可调用父类的成员。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('1f442ed7-4339-49f7-abb1-7f1f1563cca6')"><img id="code_img_closed_1f442ed7-4339-49f7-abb1-7f1f1563cca6" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1f442ed7-4339-49f7-abb1-7f1f1563cca6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1f442ed7-4339-49f7-abb1-7f1f1563cca6',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1f442ed7-4339-49f7-abb1-7f1f1563cca6" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
                    Init: function () {
                        </span><span style="color: #0000ff;">this</span>.p = <span style="color: #800080;">100</span><span style="color: #000000;">;
                    },
                    Public: {
                        method1: function () {
                            </span><span style="color: #0000ff;">this</span>.m = <span style="color: #800080;">300</span><span style="color: #000000;">;
                        },
                        method2: function () {
                            </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">100</span><span style="color: #000000;">;
                        }
                    }
                });
                </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
                    Init: function () {
                        </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
                    },
                    Private: {
                        _a: </span><span style="color: #800080;">100</span><span style="color: #000000;">
                    },
                    Public: {
                        method1: function (t) {
                            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
                            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.baseClass.method2.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span>) + <span style="color: #0000ff;">this</span><span style="color: #000000;">._a;
                        }
                    }
                });
                </span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
                console.log(b.method1());  </span><span style="color: #008000;">//</span><span style="color: #008000;">200</span>
                console.log(b.p);  <span style="color: #008000;">//</span><span style="color: #008000;">100</span>
                console.log(b.m);  <span style="color: #008000;">//</span><span style="color: #008000;">300</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>父类调用子类（模板模式）</h1>
<div class="cnblogs_code" onclick="cnblogs_code_show('e3a2be67-7d0e-4470-83c8-ba38c13853f4')"><img id="code_img_closed_e3a2be67-7d0e-4470-83c8-ba38c13853f4" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_e3a2be67-7d0e-4470-83c8-ba38c13853f4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e3a2be67-7d0e-4470-83c8-ba38c13853f4',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_e3a2be67-7d0e-4470-83c8-ba38c13853f4" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
    Public: {
        method: function () {
            console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.value);
        }
    }
});
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
    Public: {
        value: </span><span style="color: #800080;">100</span><span style="color: #000000;">
    }
});
</span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
b.method(); </span><span style="color: #008000;">//</span><span style="color: #008000;">100</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>覆盖父类方法，实现接口成员、抽象成员</h1>
<div class="cnblogs_code" onclick="cnblogs_code_show('97fdfde9-9bae-4c6a-9edf-8f0c0e468bbd')"><img id="code_img_closed_97fdfde9-9bae-4c6a-9edf-8f0c0e468bbd" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_97fdfde9-9bae-4c6a-9edf-8f0c0e468bbd" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('97fdfde9-9bae-4c6a-9edf-8f0c0e468bbd',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_97fdfde9-9bae-4c6a-9edf-8f0c0e468bbd" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.AClass({ Interface: A }, {
    Protected: {
        Abstract: {
            P_method: function () { }
        }
    },
    Public: {
        method: function () { }
    }
});
</span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.Class(B, {
    Protected: {
        P_method: function () {
            console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">实现抽象方法</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        }
    },
    Public: {
        method: function () {
            console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">覆盖父类同名方法</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        },
        m1: function () {
            console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">实现接口</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        }
    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p style="width: 100%; background-color: #c0c0c0;"><span style="font-family: 幼圆;"><strong><span style="color: #ffffff; font-size: 18pt;">约定</span></strong></span></p>
<p>在该框架的实现中，类的实例可以访问类的公有成员、保护成员、私有成员，所有成员都是添加到类的原型中（如果是继承，则将父类的成员添和子类的成员都添加到子类的原型中），框架对成员的访问没有设任何限制。</p>
<p>因此，用户需要采用<span style="color: #ff0000;">命名约定</span>的方式来区分不同的成员，需要自觉遵守访问权限规则（如类的实例只能访问公有成员；不能访问其它类的私有成员；子类可以访问父类的保护成员等等）。</p>
<h1>私有成员和保护成员的参考命名约定</h1>
<p>基类的私有成员以&ldquo;_&rdquo;开头，保护成员以&ldquo;P_&rdquo;开头。</p>
<p>在继承中，第一层子类私有成员以&ldquo;__&rdquo;开头，第二层子类私有成员以&ldquo;___&rdquo;开头，以此类推。。。。。。（因为接口都是公有成员，故考虑该命名约定时忽略接口。）</p>
<p>如：</p>
<p>不继承接口：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A = YYC.AClass({    <span style="color: #008000;">//</span><span style="color: #008000;">A为基类</span>
<span style="color: #000000;">    Private: {
        _value: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        _method: function () { }
    },
    Protected: {
        P_value: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        P_method: function () { }
    }
});
</span><span style="color: #0000ff;">var</span> B = YYC.Class(A, {  <span style="color: #008000;">//</span><span style="color: #008000;">B为第一层子类</span>
<span style="color: #000000;">    Private: {
        __value: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        __method: function () { }
    }</span><span style="color: #000000;">
});</span></pre>
</div>
<p>继承接口：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> I = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">method</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> A = YYC.AClass({ Interface: I }, {
<span style="color: #000000;">    Private: {
        _value: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        _method: function () { }
    },
    Protected: {
        P_method: function () { }
    }
});
</span><span style="color: #0000ff;">var</span> B = YYC.Class(A, {  <span style="color: #008000;">//</span><span style="color: #008000;">B为第一层子类</span>
<span style="color: #000000;">    Private: {
        __value: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        __method: function () { }
    },
    Public: {
        method: function () { }
    }
});</span></pre>
</div>
<h2>为什么每层子类的私有成员前缀不一样？</h2>
<p>因为如果子类与父类有同名的私有成员时，当子类调用父类成员时，可能会出现以下情形的问题：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({
    Private: {
        _val: </span><span style="color: #800080;">100</span><span style="color: #000000;">
    },
    Public: {
        getVal: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._val;
        }
    }
});

</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
    Private: {
        _val: </span><span style="color: #800080;">200</span><span style="color: #000000;">
    },
    Public: {
        getVal: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
        }
    }
});

</span><span style="color: #008000;">//</span><span style="color: #008000;">无法通过测试！实际值为200
</span><span style="color: #008000;">//</span><span style="color: #008000;">这是因为通过&ldquo;this.base()&rdquo;调用父类A的getVal时，返回的是B覆写的_val！</span>
expect(<span style="color: #0000ff;">new</span> B().getVal()).toEqual(<span style="color: #800080;">100</span>);</pre>
</div>
<p>用户也可以将第一层子类的私有成员前缀设为&ldquo;_1_&rdquo;，第二层子类的私有成员设为&ldquo;_2_&rdquo;。。。。。。</p>
<p>前缀设置规则用户可自订，<span style="color: #ff0000;"><span style="color: #000000;">只要能</span>在继承中使不同层级的类的私有和保护成员不同名即可</span>。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>/*</p>
<p>&nbsp;</p>
<h1>私有成员和保护成员的建议命名约定</h1>
<p>建议的命名约定</p>
<p>基类的私有成员以&ldquo;_&rdquo;开头，保护成员以&ldquo;P_&rdquo;开头。</p>
<p>在继承树中，第一层类私有成员以&ldquo;_&rdquo;开头，保护成员以&ldquo;P_&rdquo;，第二层类私有成员以&ldquo;__&rdquo;开头，保护成员以&ldquo;P__&rdquo;，以此类推。。。。。。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>保护成员前缀都为&ldquo;P_&rdquo;，不需要根据继承层级的不同，设置为&ldquo;P__&rdquo;、&ldquo;P___&rdquo;了！<br />（因为我现在认为保护成员是可以被子类重写的，如果是不希望被子类重写（如引擎类的保护成员不希望被继承该类的用户类的保护成员重写），则可以加上特有前缀（如引擎类中加上&ldquo;ye_&rdquo;））</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>如：</p>
<p>不继承接口：</p>
<div class="cnblogs_code">
<pre>var A = YYC.AClass({    //私有成员以&ldquo;_&rdquo;开头，保护成员以&ldquo;P_&rdquo;
<span>    Private: {
        _value: 0<span>,
        _method: function () { }
    },
    Protected: {
        P_value: 0<span>,
        P_method: function () { }
    }
});
var B = YYC.Class(A, {  //私有成员以&ldquo;__&rdquo;开头，保护成员以&ldquo;P__&rdquo;
<span>    Private: {
        __value: 0<span>,
        __method: function () { }
    }<span>
});</span></span></span></span></span></span></pre>
</div>
<p>继承接口：</p>
<div class="cnblogs_code">
<pre>var I = YYC.Interface("method"<span>);
var A = YYC.AClass({ Interface: I }, {   //私有成员以&ldquo;_&rdquo;开头，保护成员以&ldquo;P_&rdquo;
<span>    Private: {
        _value: 0<span>,
        _method: function () {
        }
    },
    Protected: {
        P_method: function () {
        }
    }
});
var B = YYC.Class(A, {  //私有成员以&ldquo;__&rdquo;开头，保护成员以&ldquo;P__&rdquo;
<span>    Private: {
        __value: 0<span>,
        __method: function () {
        }
    },
    Public: {
        method: function () {
        }
    }
});</span></span></span></span></span></pre>
</div>
<h2>为什么每层子类的私有和保护成员前缀最好不一样？</h2>
<p>如果子类与父类有同名的私有或保护成员时，当子类调用父类成员时，可能会出现父类成员调用了子类的私有或保护成员：</p>
<div class="cnblogs_code">
<pre>var A =<span> YYC.Class({
    Private: {
        _val: 100<span>
    },
    Protected: {
        P_num: 100<span>
    },
    Public: {
        getVal: function<span> () {
            return this<span>._val;
        }  ,
        getNum:function<span>(){
            return this<span>.P_num;
        }
    }
});

var B =<span> YYC.Class(A, {
    Private: {
        _val: 200<span>
    },
    Protected: {
        P_num: 300<span>
    },
    Public: {
        getVal: function<span> () {
            return this<span>.base();
        }  ,
        getNum:function<span>(){
            return this<span>.base();
        }
    }
});

expect(new B().getVal()).toEqual(100);　　//失败！实际为200
expect(new B().getNum()).toEqual(100);　　//失败！实际为300</span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>用户也可以将第一层子类的私有成员前缀设为&ldquo;_1_&rdquo;，第二层子类的私有成员设为&ldquo;_2_&rdquo;。。。。。。</p>
<p>前缀设置规则用户可自订，只要在继承中使不同层级的类的私有成员不重名即可。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>*/</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>baseClass</h1>
<p>为了防止子类的prototype.baseClass覆盖父类prototype.baseClass，在子类继承父类时，先判断父类prototype.baseClass是否存在。如果存在，则加上前缀&ldquo;_&rdquo;，如&ldquo;_baseClass&rdquo;。如果加上前缀后依然存在，则再加上前缀&ldquo;_&rdquo;，如&ldquo;__baseClass&rdquo;。以此类推。</p>
<p>如：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('29395fb8-176a-49f2-92fe-3bcfbd415978')"><img id="code_img_closed_29395fb8-176a-49f2-92fe-3bcfbd415978" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_29395fb8-176a-49f2-92fe-3bcfbd415978" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('29395fb8-176a-49f2-92fe-3bcfbd415978',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_29395fb8-176a-49f2-92fe-3bcfbd415978" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A1 =<span style="color: #000000;"> YYC.AClass({
    Public: {
        arr: [],
        a: function () {
            </span><span style="color: #0000ff;">this</span>.arr.push(<span style="color: #800080;">1</span><span style="color: #000000;">);
        }
    }
});
</span><span style="color: #0000ff;">var</span> A2 =<span style="color: #000000;"> YYC.AClass(A1, {
    Public: {
        a: function () {
            </span><span style="color: #0000ff;">this</span>.arr.push(<span style="color: #800080;">2</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">this</span>.baseClass.a.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">调用A1.a</span>
<span style="color: #000000;">        }
    }
});
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A2, {
    Public: {
        a: function () {
            </span><span style="color: #0000ff;">this</span>.arr.push(<span style="color: #800080;">3</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">this</span>._baseClass.a.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span>); <span style="color: #008000;">//</span><span style="color: #008000;">调用A2.a</span>
            <span style="color: #0000ff;">this</span>._baseClass.baseClass.a.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span>);   <span style="color: #008000;">//</span><span style="color: #008000;">调用A1.a</span>

            <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.arr;
        }
    }
});
</span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();

console.log(b.a());     </span><span style="color: #008000;">//</span><span style="color: #008000;">[3, 2, 1, 1] </span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p style="width: 100%; background-color: #c0c0c0;"><span style="font-family: 幼圆;"><strong><span style="color: #ffffff; font-size: 18pt;">注意事项</span></strong></span></p>
<p><strong><span style="font-size: 18px;">子类使用this.baseClass调用父类成员时，要将父类成员的this指向子类。</span></strong></p>
<p>错误的写法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
    Public: {
        method: function () {
            </span><span style="color: #0000ff;">this</span>.p = <span style="color: #800080;">100</span><span style="color: #000000;">;
        }
    }
});
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
    Public: {
        method: function () {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.baseClass.method();
        }
    }
});
</span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
b.method();
console.log(b.p);   </span><span style="color: #008000;">//</span><span style="color: #008000;">此处为undefined，而不是100！</span></pre>
</div>
<p>正确的写法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
    Public: {
        method: function () {
            </span><span style="color: #0000ff;">this</span>.p = <span style="color: #800080;">100</span><span style="color: #000000;">;
        }
    }
});
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
    Public: {
        method: function () {
            </span><span style="color: #0000ff;">this</span>.baseClass.method.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
        }
    }
});
</span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
b.method();
console.log(b.p);   </span><span style="color: #008000;">//</span><span style="color: #008000;">100</span></pre>
</div>
<p style="width: 100%; background-color: #c0c0c0;"><span style="font-family: 幼圆;"><strong><span style="color: #ffffff; font-size: 18pt;">缺点</span></strong></span></p>
<p><strong><span style="font-size: 18px;">只是从语义上约定了访问权限，而没有从机制上限制访问权限。</span></strong></p>
<p>如可以根据命名约定区分类的公有成员、保护成员、私有成员，但是类的实例却可以访问类的所有成员。</p>
<p style="width: 100%; background-color: #c0c0c0;"><span style="font-family: 幼圆;"><strong><span style="color: #ffffff; font-size: 18pt;">下载</span></strong></span></p>
<h1><a href="http://pan.baidu.com/s/1hqFoLeO">源文件下载</a></h1>]]></description></item><item><title>深入理解Html5规范系列</title><link>http://www.cnblogs.com/chaogex/archive/2014/08/17/3918289.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sun, 17 Aug 2014 13:08:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/08/17/3918289.html</guid><description><![CDATA[每天早上看这个

参考w3c资料，从http://www.w3.org/TR/html5/introduction.html开始翻译

并不是直接翻译，而是学习整理w3c资料后，给出自己的理解（可举出实例，给出demo等）
w3c中不是很重要的内容可以省略






申明

本系列主要参考w3c的2014年7月31日版本的《Html5推荐规范》，进行了翻译、整理工作，并加入了自己的理解。鉴于本人水平有限，难免理解有些偏差，欢迎大家拍砖！此处向w3c致敬！建议大家有空也看看w3c规范，里面介绍了很多底层原理，可以深入地学习Web标准。
w3c链接：
http://www.w3.org/


参考资料
http://www.w3.org/TR/html5/]]></description></item><item><title>YOOP升级计划</title><link>http://www.cnblogs.com/chaogex/archive/2014/08/14/3912150.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Thu, 14 Aug 2014 03:26:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/08/14/3912150.html</guid><description><![CDATA[v1.0
最初版本

v1.1
现有成果

未来升级计划：
研究最新的Typescrip（v1.3+），看它的protected如何，private是否解决了成员重名的问题！
私有成员前缀的问题或许可参考typescript的Private Variables http://typescript.codeplex.com/discussions/397651

增加get、set（ecm5）
解决前缀问题
//解决“性能问题”：拷贝原型
增加Sealed，如果子类重写了父类密封的方法，会抛出异常
。。。

将属性都放在构造函数中，原型上只放方法。
这样在继承时，就只需继承原型成员（方法）即可，不用深拷贝原型了！
参考typescript的继承方法：
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];     //拷贝静态成员
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();   //继承原型
};



typescript的继承树中，子类的私有成员不能与父类私有成员名相同，否则会在编译时报错！
这样就防止了私有成员的干扰（而现在YOOP是允许同名的，只是要前缀不同）
或许YOOP也不应该允许同名！这样就没有前缀的问题了！]]></description></item><item><title>提炼初步游戏引擎系列（5）：总结</title><link>http://www.cnblogs.com/chaogex/archive/2014/08/09/3900757.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sat, 09 Aug 2014 03:28:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/08/09/3900757.html</guid><description><![CDATA[<p>总结提炼出来的初步引擎，从复用性和通用性分析炸弹人代码的前后改进之处</p>
<p>&nbsp;</p>
<p>提出若干不足之处（从复用性、通用性等方面分析），引出后面的&ldquo;古代战争开发&rdquo;系列。</p>
<p>事件管理类EventManager目前只支持键盘事件，需要加入对鼠标事件的支持</p>
<p>&nbsp;</p>]]></description></item><item><title>提炼初步游戏引擎系列（4）：第二次迭代</title><link>http://www.cnblogs.com/chaogex/archive/2014/08/03/3888803.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sun, 03 Aug 2014 12:19:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/08/03/3888803.html</guid><description><![CDATA[<p><strong>前言</strong></p>
<p><span style="color: #c0c0c0;">本文将炸弹人中通用的类提炼到了引擎中，搭建了引擎的整体框架。</span></p>
<p><span style="color: #c0c0c0;">但是现在引擎还很粗糙，跟炸弹人耦合严重，还不是一个可单独复用的组件。</span></p>
<p><span style="color: #c0c0c0;">因此，在下文中，我会进行第二次迭代，对引擎进行进一步的抽象和提炼，尽量减少引擎与炸弹人之间的耦合。</span></p>
<p>上文搭建了引擎的整体框架</p>
<p>本文会继续提炼，增强引擎通用性，减少与具体游戏逻辑的耦合。</p>
<p>&nbsp;</p>
<p><strong>说明</strong></p>
<p>&nbsp;</p>
<p><strong>本文目的</strong></p>
<p>对Core模块进一步提炼，提出共同的模式、成员，如提出Director的gameOver和gameWin方法、提出层的change状态及其管理等<br />
对炸弹人游戏进行相应修改并测试通过。</p>
<p><strong>本文主要内容</strong></p>
<p>&nbsp;</p>
<p><strong>回顾上文更新后的领域模型</strong></p>
<p>图</p>
<p>&nbsp;</p>
<p><strong>对领域模型进行思考</strong></p>
<p>&nbsp;</p>
<p><strong>开发策略</strong></p>
<p>本文会结合第一次迭代的经验，对引擎领域模型从左到右一一进行分析，从通用性和复用性角度再次进行提炼加工。<span style="color: #c0c0c0;">（需要进一步说明？）</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>正文</strong></p>
<p><strong>&nbsp;</strong></p>
<p><span style="line-height: 1.5;">&nbsp;</span></p>
<p><span style="color: #000000;">修改Main</span></p>
<p><span style="color: #000000;">&nbsp;19 53</span></p>
<p><span style="color: #ff0000;">（&ldquo;古代战争系列&rdquo;中，会删除引擎Main，以LoaderManager替代Main，负责资源加载管理，而游戏的入口则由用户提供（如LevelManager））&nbsp;</span></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">（仍然保持实例重写！）</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>修改前炸弹人Main</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">    (function(){
        </span><span style="color: #0000ff;">var</span> Main =<span style="color: #000000;"> YE.Main,
            main </span>=<span style="color: #000000;"> Main.getInstance();


        </span><span style="color: #0000ff;">var</span> _getImg =<span style="color: #000000;"> function () {
            </span><span style="color: #0000ff;">var</span> urls =<span style="color: #000000;"> [];
            </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, len = <span style="color: #800080;">0</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">var</span> map =<span style="color: #000000;"> [
                { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">) },
                { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
            ];
            </span><span style="color: #0000ff;">var</span> player =<span style="color: #000000;"> [
                { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
            ];
            </span><span style="color: #0000ff;">var</span> enemy =<span style="color: #000000;"> [
                { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
            ];
            </span><span style="color: #0000ff;">var</span> bomb =<span style="color: #000000;"> [
                { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">bomb</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">bomb</span><span style="color: #800000;">"</span><span style="color: #000000;">) },
                { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">explode</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">explode</span><span style="color: #800000;">"</span><span style="color: #000000;">) },
                { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">fire</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">fire</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
            ];

            _addImg(urls, map, player, enemy, bomb);

            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> urls;
        };

        </span><span style="color: #0000ff;">var</span> _addImg =<span style="color: #000000;"> function (urls, imgs) {
            </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span><span style="color: #000000;">),
                i </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                len1 </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                len2 </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len1 = args.length; i &lt; len1; i++<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>, len2 = args[i].length; j &lt; len2; j++<span style="color: #000000;">) {
                    urls.push({ id: args[i][j].id, url: args[i][j].url });
                }
            }
        };

        </span><span style="color: #0000ff;">var</span> _hideBar =<span style="color: #000000;"> function () {
            $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar</span><span style="color: #800000;">"</span>).css(<span style="color: #800000;">"</span><span style="color: #800000;">display</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">none</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        };

        main.loadResource </span>=<span style="color: #000000;"> function () {
            </span><span style="color: #0000ff;">var</span> loader = <span style="color: #0000ff;">this</span><span style="color: #000000;">.imgLoader;

            loader.load(_getImg());

            </span><span style="color: #008000;">//</span><span style="color: #008000;">已在ImgLoaderSpec中测试过了onloading、onload，此处不再测试</span>
            loader.onloading =<span style="color: #000000;"> function (currentLoad, imgCount) {
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar_img_show</span><span style="color: #800000;">"</span>).progressBar(parseInt(currentLoad * <span style="color: #800080;">100</span> / imgCount, <span style="color: #800080;">10</span>));     <span style="color: #008000;">//</span><span style="color: #008000;">调用进度条插件</span>
<span style="color: #000000;">            };
            loader.onload </span>=<span style="color: #000000;"> function (imgCount) {
                _hideBar();
            };


            window.imgLoader </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.imgLoader;
        };
    }());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>修改前引擎Main</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> _instance = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).Main =<span style="color: #000000;"> YYC.Class({
        Init: function () {
        },
        Public: {
            init: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._prepare();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.imgLoader.done();
            },
            _prepare: function () {
               </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.loadResource();

                </span><span style="color: #0000ff;">this</span>.imgLoader.onload_game =<span style="color: #000000;"> function () {
                    </span><span style="color: #0000ff;">var</span> director =<span style="color: #000000;"> YE.Director.getInstance();

                    director.init();
                    director.start();
                }
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">* 钩子</span>
<span style="color: #000000;">
            loadResource: function () {
            }
        },
        Static: {
            getInstance: function () {
                </span><span style="color: #0000ff;">if</span> (_instance === <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                    _instance </span>= <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">();
                    _instance.imgLoader </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> YE.ImgLoader();
                }
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> _instance;
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">*供测试使用</span>
<span style="color: #000000;">
            clearInstance: function(){
                _instance </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }
</span><span style="color: #008000;">//</span><span style="color: #008000;">            setInstance: function(ins){
</span><span style="color: #008000;">//</span><span style="color: #008000;">                _instance =  ins;
</span><span style="color: #008000;">//</span><span style="color: #008000;">            }</span>
<span style="color: #000000;">        }
    });
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>重构前领域模型&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">思考用户使用引擎的方式：</span></p>
<p><span style="color: #c0c0c0;">研究是采用钩子还是继承，找到了用户使用引擎的方法</span></p>
<p><span style="color: #c0c0c0;">10</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">用户可以通过以下三种方法使用引擎类：</span></p>
<p><span style="color: #c0c0c0;">a）直接使用引擎类提供的API。如用户可直接使用YE.EventManager. addListener来监听事件。</span></p>
<p><span style="color: #c0c0c0;">b）继承引擎类，重写钩子方法和虚方法。如用户可重写核心类Scene、Layer、Sprite中的钩子方法onenter等。</span></p>
<p><span style="color: #c0c0c0;">c）使用引擎类实例，并重写其钩子方法。如用户可使用LoaderManager的preload方法来加载资源，重写其钩子方法onloading、onload。</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #000000;">（用户可以通过继承而不是重写实例来增加逻辑，参照Cocos2D-html5中HelloHTML5World -&gt; main.js的Application类的使用）</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">为什么要改为继承重写</span></p>
<p>上文在提炼Layer后，对用户使用引擎的方式进行了思考，给出了&ldquo;目前Main、Director采用实例重写的方式，其它类（如Layer等）采用继承重写的方式&rdquo;的方案。</p>
<p><span style="color: #000000;">但是现在重新思考后，发现Main采用实例重写并不合适，因为：</span></p>
<p><span style="color: #000000;">1、用户Main与引擎Main都属于&ldquo;入口&rdquo;概念，都负责资源加载的管理</span></p>
<p><span style="color: #000000;">所以，用户Main与引擎Main应该为继承关系，引擎Main需要被改造为可被继承的类，用户的main也要被改造为继承于引擎Main的类</span></p>
<p><span style="color: #000000;">引擎Main</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).Main =<span style="color: #000000;"> YYC.AClass({
        Init: function () {
            </span><span style="color: #0000ff;">this</span>.imgLoader = <span style="color: #0000ff;">new</span><span style="color: #000000;"> YE.ImgLoader();
        },
        Private: {
            _prepare: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.loadResource();

</span><span style="color: #008000;">//</span><span style="color: #008000;">                this.imgLoader.onload_game = this.onload;</span>
<span style="color: #000000;">            }
        },
        Public: {
            imgLoader: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            init: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._prepare();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.imgLoader.done();
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">* 钩子</span>

            <span style="color: #008000;">/*</span><span style="color: #008000;">*
             * 加载资源
             </span><span style="color: #008000;">*/</span><span style="color: #000000;">
            loadResource: function () {
            }
</span><span style="color: #008000;">//</span><span style="color: #008000;">            /**
</span><span style="color: #008000;">//</span><span style="color: #008000;">             * 资源加载完成后调用
</span><span style="color: #008000;">//</span><span style="color: #008000;">             */
</span><span style="color: #008000;">//</span><span style="color: #008000;">            onload: function () {
</span><span style="color: #008000;">//</span><span style="color: #008000;">            }</span>
<span style="color: #000000;">        }
    });
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>用户MyMain</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> MyMain =<span style="color: #000000;"> YYC.Class(YE.Main, {
        Private: {
            _getImg: function () {
                </span><span style="color: #0000ff;">var</span> urls =<span style="color: #000000;"> [];
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, len = <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">var</span> map =<span style="color: #000000;"> [
                    { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">) },
                    { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
                ];
                </span><span style="color: #0000ff;">var</span> player =<span style="color: #000000;"> [
                    { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
                ];
                </span><span style="color: #0000ff;">var</span> enemy =<span style="color: #000000;"> [
                    { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
                ];
                </span><span style="color: #0000ff;">var</span> bomb =<span style="color: #000000;"> [
                    { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">bomb</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">bomb</span><span style="color: #800000;">"</span><span style="color: #000000;">) },
                    { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">explode</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">explode</span><span style="color: #800000;">"</span><span style="color: #000000;">) },
                    { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">fire</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">fire</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
                ];

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._addImg(urls, map, player, enemy, bomb);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> urls;
            },

            _addImg: function (urls, imgs) {
                </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span><span style="color: #000000;">),
                    i </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len1 </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len2 </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len1 = args.length; i &lt; len1; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>, len2 = args[i].length; j &lt; len2; j++<span style="color: #000000;">) {
                        urls.push({ id: args[i][j].id, url: args[i][j].url });
                    }
                }
            },

            _hideBar: function () {
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar</span><span style="color: #800000;">"</span>).css(<span style="color: #800000;">"</span><span style="color: #800000;">display</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">none</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        },
        Public: {
            loadResource: function () {
                </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();

                </span><span style="color: #0000ff;">var</span> loader = <span style="color: #0000ff;">this</span><span style="color: #000000;">.imgLoader,
                    self </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">;

                loader.load(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">._getImg());

                </span><span style="color: #008000;">//</span><span style="color: #008000;">已在ImgLoaderSpec中测试过了onloading、onload，此处不再测试</span>
                loader.onloading =<span style="color: #000000;"> function (currentLoad, imgCount) {
                    $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar_img_show</span><span style="color: #800000;">"</span>).progressBar(parseInt(currentLoad * <span style="color: #800080;">100</span> / imgCount, <span style="color: #800080;">10</span>));     <span style="color: #008000;">//</span><span style="color: #008000;">调用进度条插件</span>
<span style="color: #000000;">                };
                loader.onload </span>=<span style="color: #000000;"> function (imgCount) {
                    self._hideBar();
                    YE.Director.getInstance().init();
                    YE.Director.getInstance().start();
                };

                window.imgLoader </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.imgLoader;
            }
        }
    });

    window.MyMain </span>=<span style="color: #000000;"> MyMain;
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>分析&nbsp;</p>
<p><span style="color: #c0c0c0;">提出onload钩子</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #000000;">Main不再为单例了，Main改为AClass&nbsp;<span style="color: #c0c0c0;">onload设为抽象方法</span></span></p>
<p><span style="color: #000000;">由于引擎Main现在改为了可被继承的类，因此其不能再为单例类了，而应该改为抽象类AClass</span></p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">用户类名为MyMain，main.js文件要重命名为MyMain.js</span></p>
<p>用户类改名为MyMain，并将文件名重命名为MyMain.js。&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">修改后的Main</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">修改炸弹人main.js</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">分析</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">文件要重命名为Main</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #000000;">重构后领域模型</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #000000;">修改Director</span></p>
<p><span style="color: #000000;">20-24</span></p>
<p>&nbsp;</p>
<p>重构前领域模型</p>
<p>&nbsp;</p>
<p>/*</p>
<p>n&nbsp; 用户不需要重写该类（这样就可以不重写实例或继承该类后重写方法了！因为Director是单例，采用继承重写的方式不好实现；而采用重写实例的方式，又与Layer等采用的继承重写方式不一致！），该类作为封装的类，用户不能重写。即去掉init、onenter、onexit等钩子方法，把这些职责分配到Scene和Layer等类中（如用户重写Scene和Layer等类的init方法）</p>
<p>n&nbsp; gameState提到其中？<br />
Director增加内部游戏状态_gameState，bomber的gameState保留</p>
<p>n&nbsp;
stop增加&ldquo;停止所有计时器&rdquo;</p>
<p>n&nbsp;
&ldquo;game.sleep = 1000 / 60&rdquo;应改成基于时间的运动（对应修改Layer的___deltaTime）</p>
<p><span style="color: #c0c0c0;">n&nbsp; 去掉与config.js的耦合。如去掉访问&ldquo;window.bomberConfig.game.state&rdquo;</span></p>
<p>n&nbsp;
addElement应该放到Layer中？</p>
<p>n&nbsp;
应该改名gameOver、gameWin为overGame、winGame，另外这两个方法应该放到Scene中，Director只提供停止主循环的方法</p>
<p>*/</p>
<p>&nbsp;</p>
<p>n&nbsp; 用户不需要重写该类（这样就可以不重写实例或继承该类后重写方法了！因为Director是单例，采用继承重写的方式不好实现；而采用重写实例的方式，又与Layer等采用的继承重写方式不一致！），该类作为封装的类，用户不能重写。即去掉init、onenter、onexit等钩子方法，把这些职责分配到Scene和Layer等类中（如用户重写Scene和Layer等类的init方法）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;　　提出Scene</p>
<p>21</p>
<p>（引擎Scene不能重写，修改为可重写，提出MyScene）</p>
<p>&nbsp;</p>
<p>将bomber-&gt;Game.js中的init移到engine-&gt;Scene中<br />Director-&gt;runWithScene中进行场景初始化<br />修改Director调用Scene的方式：<br />增加用户自定义的bomber-&gt;Scene.js(MyScene类)，在bomber-&gt;main.js-&gt;onload中将MyScene传入Director实例中</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>start重命名为runWithScene，并做对应修改</p>
<p>&nbsp;</p>
<p>　　Main提出onload钩子</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>将引擎类的钩子方法都设成Virtual（Layer类未修改）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>n&nbsp; gameState提到其中？<br />Director增加内部游戏状态_gameState，bomber的gameState保留</p>
<p>n&nbsp; stop增加&ldquo;停止所有计时器&rdquo;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>重构后领域模型</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">　　修改Game</span></p>
<p><span style="color: #000000;">&nbsp;21-22 &nbsp;27&nbsp;</span></p>
<p>（第二次迭代会删除Game）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>分析现在的领域模型（Director与Game的关系，Game明显多余了！）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>重构后领域模型</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">修改Scene</span></p>
<p><span style="color: #000000;">23 27-28 53</span></p>
<p>（第二次迭代提出MyScene时，根据需要再提出onenter、onexit钩子函数</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">修改Layer</span></p>
<p><span style="color: #000000;">28-33 35-36 39-41 49 52 54 62</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">修改Sprite</span></p>
<p><span style="color: #000000;">38-40 54 58-62 64</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">修改动画</span></p>
<p><span style="color: #000000;">41-44 52 54 60 62</span></p>
<p>&nbsp;</p>
<p>（不提出Action类）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">&nbsp;　　增加Geometry</span></p>
<p><span style="color: #000000;">　　42</span></p>
<p><span style="color: #000000;">　　增加Frame</span></p>
<p>&nbsp;</p>
<p><span style="color: #000000;">　　Animation改为Animate</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">修改集合类</span></p>
<p><span style="color: #000000;">45-46 49-50 54</span></p>
<p><span style="color: #000000;">&nbsp;</span></p>
<p>&nbsp;</p>
<p><span style="color: #000000;">修改Config</span></p>
<p><span style="color: #000000;">63</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">修改collision</span></p>
<p><span style="color: #000000;">64</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">&nbsp;</span></p>
<p><strong>本文最终完整的领域模型</strong></p>
<p>&nbsp;</p>
<p><strong>高层划分</strong></p>
<p>&nbsp;</p>
<p><strong>本文源码下载</strong></p>
<p>&nbsp;</p>
<p><strong>演示地址</strong></p>
<p>&nbsp;</p>
<p><strong>本文参考资料</strong></p>
<p>&nbsp;</p>
<p><strong>欢迎浏览下一篇博文：</strong></p>
<p>&nbsp;</p>
<p>版本1-18</p>]]></description></item><item><title>提炼初步游戏引擎系列（3）：第一次迭代</title><link>http://www.cnblogs.com/chaogex/archive/2014/08/03/3888802.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sun, 03 Aug 2014 12:18:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/08/03/3888802.html</guid><description><![CDATA[<p><strong>前言</strong></p>
<p>&nbsp;</p>
<p><strong>说明</strong></p>
<p>&nbsp;</p>
<p>名词说明</p>
<ul>
<li>用户</li>
</ul>
<p>指引擎使用方</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>本文目的</strong></p>
<p>提出Core模块，提炼出类和主要的成员，将component、algorithm、event中的组件提出，包括游戏入口、预加载、主循环、层、精灵、动画、事件管理、Canvas渲染库等<br />对炸弹人游戏进行相应修改并测试通过。</p>
<p><span style="color: #ff0000;">待修改&nbsp;</span></p>
<p>&nbsp;</p>
<p><strong>本文主要内容</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>引擎初步领域模型</p>
<p>图</p>
<p>&nbsp;</p>
<p><strong>炸弹人的参考模型</strong></p>
<p style="text-align: left;">图</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;"><strong style="font-size: 14px; line-height: 1.5;">对领域模型进行思考</strong></p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><strong>开发策略</strong></p>
<p><span style="color: #c0c0c0;">引擎提炼顺序&nbsp;</span></p>
<p><span style="color: #c0c0c0;">本文会按照&ldquo;引擎参考设计模型&rdquo;从左往右的顺序进行提炼</span></p>
<p>&nbsp;</p>
<p>引擎提炼的步骤</p>
<p>1、确定引擎要提炼的类</p>
<p>按照&ldquo;引擎初步领域模型&rdquo;从左往右的顺序进行提炼，每次只提炼出1个领域类。如果领域类之间有依赖关系，则优先提出依赖关系最少的领域类，然后再提出与其相关的领域类</p>
<p>2、分析炸弹人参考模型中对应的类，找出可复用的、通用的部分，将其提炼到引擎类中</p>
<p>&nbsp;</p>
<p>3、对应修改炸弹人的类，令其使用提炼出的引擎类</p>
<p>&nbsp;</p>
<p>4、炸弹人进行运行测试</p>
<p>&nbsp;</p>
<p>5、编写引擎单元测试</p>
<p>&nbsp;</p>
<p>本文的每次提炼会重点说明1、2、3步骤。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>本文及后面的文章不会讲解单元测试的过程，不过在每篇文章最后的源码下载中，包括了单元测试</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>正文</strong></p>
<p><span style="color: #ff0000;">加入开发时的思考，并给出相应的答案</span></p>
<p><span style="color: #ff0000;">可给出不同步骤的开发策略</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">加入Main、ImgLoader</span></p>
<p><span style="color: #c0c0c0;">1-2</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>修改namespace方法，提出Tool</p>
<p>在提炼引擎类时，首先需要定义引擎的命名空间YE。</p>
<p>在炸弹人中，我使用YTool的namespace方法来定义命名空间。</p>
<p>分析namespace方法 ：</p>
<div class="cnblogs_code">
<pre></pre>
<p>var YToolConfig = {<br />        topNamespace: "YYC",<br />        toolNamespace: "Tool"<br />    };</p>
<p>...</p>
<pre><span style="color: #0000ff;"><br />namespace</span><span style="color: #000000;">: function (str) {
                </span><span style="color: #0000ff;">var</span> parent =<span style="color: #000000;"> window[YToolConfig.topNamespace],　　//YYC
                    parts </span>= str.split(<span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">),
                    i </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (str.length == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">命名空间不能为空</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
                </span><span style="color: #0000ff;">if</span> (parts[<span style="color: #800080;">0</span>] ===<span style="color: #000000;"> YToolConfig.topNamespace) {
                    parts </span>= parts.slice(<span style="color: #800080;">1</span><span style="color: #000000;">);
                }

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = parts.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> parent[parts[i]] === <span style="color: #800000;">"</span><span style="color: #800000;">undefined</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                        parent[parts[i]] </span>=<span style="color: #000000;"> {};
                    }
                    parent </span>= parent[parts[i]];  <span style="color: #008000;">//</span><span style="color: #008000;">递归增加命名空间</span>
<span style="color: #000000;">                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> parent;
            },</span></pre>
</div>
<p>该方法默认设置顶级命名空间为YYC，并且不能修改，这显然不符合引擎的&ldquo;顶级命名空间为YE&rdquo;的需求。</p>
<p><span style="color: #c0c0c0;">另外，我希望namespace为全局方法，</span></p>
<p>&nbsp;</p>
<p>因此，对其进行修改：</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> extend =<span style="color: #000000;"> function (destination, source) {
        </span><span style="color: #0000ff;">var</span> property = <span style="color: #800000;">""</span><span style="color: #000000;">;

        </span><span style="color: #0000ff;">for</span> (property <span style="color: #0000ff;">in</span><span style="color: #000000;"> source) {
            destination[property] </span>=<span style="color: #000000;"> source[property];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> destination;
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;">*全局方法</span>
<span style="color: #000000;">    (function () {
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
         * 创建命名空间。
         示例：
         namespace("YYC.Tool.Button");
         </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">var</span> <span style="color: #0000ff;">global</span> =<span style="color: #000000;"> {
            </span><span style="color: #0000ff;">namespace</span><span style="color: #000000;">: function (str) {
                </span><span style="color: #0000ff;">var</span> parent =<span style="color: #000000;"> window,
                    parts </span>= str.split(<span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">),
                    i </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (str.length == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">命名空间不能为空</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = parts.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> parent[parts[i]] === <span style="color: #800000;">"</span><span style="color: #800000;">undefined</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                        parent[parts[i]] </span>=<span style="color: #000000;"> {};
                    }
                    parent </span>= parent[parts[i]];  <span style="color: #008000;">//</span><span style="color: #008000;">递归增加命名空间</span>
<span style="color: #000000;">                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> parent;
            }
        };

        extend(window, </span><span style="color: #0000ff;">global</span><span style="color: #000000;">);
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>提出Tool类</p>
<p>考虑到引擎的Tool类用于放置通用方法，因此引擎应该增加Tool类，并将namespace方法放进来。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>提出ImgLoader</p>
<p>按照从左到右的提炼顺序，提炼出LoaderResource领域类。</p>
<p>&nbsp;</p>
<p><br />分析炸弹人参考模型中对应的类，找出可复用的、通用的部分，将其提炼到引擎类中</p>
<p>LoaderResource对应炸弹人的PreLoadImg类，该类本身就是一个独立的图片预加载组件（参考<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3203061.html">发布我的图片预加载控件YPreLoadImg v1.0</a>），因此可直接提炼到引擎中。</p>
<p>我将其重命名为ImgLoader，加入到YE命名空间中，代码如下：</p>
<p>ImgLoader</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">namespace("YE").ImgLoader = YYC.Class({
    Init: function (images, onstep, onload) {
        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._checkImages(images);

        </span><span style="color: #0000ff;">this</span>.config =<span style="color: #000000;"> {
            images: images </span>||<span style="color: #000000;"> [],
            onstep: onstep </span>||<span style="color: #000000;"> function () {
            },
            onload: onload </span>||<span style="color: #000000;"> function () {
            }
        };
        </span><span style="color: #0000ff;">this</span>._imgs =<span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">this</span>.imgCount = <span style="color: #0000ff;">this</span><span style="color: #000000;">.config.images.length;
        </span><span style="color: #0000ff;">this</span>.currentLoad = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">this</span>.timerID = <span style="color: #800080;">0</span><span style="color: #000000;">;

        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.loadImg();
    },
    Private: {
        _imgs: {},

        _checkImages: function (images) {
            </span><span style="color: #0000ff;">var</span> i = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> images) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (images.hasOwnProperty(i)) {
                    </span><span style="color: #0000ff;">if</span> (images[i].id === undefined || images[i].url ===<span style="color: #000000;"> undefined) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"应该包含id和url属性</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                }
            }
        }
    },
    Public: {
        imgCount: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        currentLoad: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        timerID: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

        </span><span style="color: #0000ff;">get</span><span style="color: #000000;">: function (id) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._imgs[id];
        },
        loadImg: function () {
            </span><span style="color: #0000ff;">var</span> c = <span style="color: #0000ff;">this</span><span style="color: #000000;">.config,
                img </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                i,
                self </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">,
                image </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; c.images.length; i++<span style="color: #000000;">) {
                img </span>=<span style="color: #000000;"> c.images[i];
                image </span>= <span style="color: #0000ff;">this</span>._imgs[img.id] = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Image();
                
                image.onload </span>=<span style="color: #000000;"> function () {
                    </span><span style="color: #0000ff;">this</span>.onload = <span style="color: #0000ff;">null</span><span style="color: #000000;">;   
                    YYC.Tool.func.bind(self, self.onload)();
                };
                image.src </span>=<span style="color: #000000;"> img.url;

                </span><span style="color: #0000ff;">this</span>.timerID =<span style="color: #000000;"> (function (i) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> setTimeout(function () {
                        </span><span style="color: #0000ff;">if</span> (i ==<span style="color: #000000;"> self.currentLoad) {
                            image.src </span>=<span style="color: #000000;"> img.url;
                        }
                    }, </span><span style="color: #800080;">500</span><span style="color: #000000;">);
                })(i);
            }
        },
        onload: function (i) {
            clearTimeout(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.timerID);
            </span><span style="color: #0000ff;">this</span>.currentLoad++<span style="color: #000000;">;
            </span><span style="color: #0000ff;">this</span>.config.onstep(<span style="color: #0000ff;">this</span>.currentLoad, <span style="color: #0000ff;">this</span><span style="color: #000000;">.imgCount);
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.currentLoad === <span style="color: #0000ff;">this</span><span style="color: #000000;">.imgCount) {
                </span><span style="color: #0000ff;">this</span>.config.onload(<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentLoad);
            }
        },
        dispose: function () {
            </span><span style="color: #0000ff;">var</span> i, _imgs = <span style="color: #0000ff;">this</span><span style="color: #000000;">._imgs;
            </span><span style="color: #0000ff;">for</span> (i <span style="color: #0000ff;">in</span><span style="color: #000000;"> _imgs) {
                _imgs[i].onload </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                _imgs[i] </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">this</span>.config = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
    }
});</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>对应修改炸弹人的类，令其使用提炼出的引擎类</p>
<p>需要对应修改炸弹人的main.js：</p>
<p>修改前</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        init: function () {
            window.imgLoader </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> YYC.Control.PreLoadImg(_getImg(), function (currentLoad, imgCount) {
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar_img_show</span><span style="color: #800000;">"</span>).progressBar(parseInt(currentLoad * <span style="color: #800080;">100</span> / imgCount, <span style="color: #800080;">10</span>));     <span style="color: #008000;">//</span><span style="color: #008000;">调用进度条插件</span>
            }, YYC.Tool.func.bind(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.onload));
        },</span></pre>
</div>
<p>&nbsp;</p>
<p>修改后</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        init: function () {
            window.imgLoader </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> YE.ImgLoader(_getImg(), function (currentLoad, imgCount) {
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar_img_show</span><span style="color: #800000;">"</span>).progressBar(parseInt(currentLoad * <span style="color: #800080;">100</span> / imgCount, <span style="color: #800080;">10</span>));     <span style="color: #008000;">//</span><span style="color: #008000;">调用进度条插件</span>
            }, YYC.Tool.func.bind(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.onload));
        },</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><br /><span style="color: #c0c0c0;">炸弹人进行运行测试</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">编写引擎单元测试</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #888888;">&nbsp;</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>提出Main</p>
<p><span style="color: #ff0000;">（Main这里是通过重写loadResource方法</span></p>
<p><span style="color: #ff0000;">第二次迭代时会改成通过继承的方式）</span></p>
<p><span style="color: #c0c0c0;">现在首先提炼出Main</span></p>
<p>接着就是提炼与LoadResource依赖的Main领域类</p>
<p>&nbsp;</p>
<p>分析炸弹人参考模型中对应的类，找出可复用的、通用的部分，将其提炼到引擎类中</p>
<p>Main对应炸弹人的Main类（main.js）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">修改前炸弹人的</span>main.js</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> main =<span style="color: #000000;"> (function () {
    </span><span style="color: #0000ff;">var</span> _getImg =<span style="color: #000000;"> function () {
        </span><span style="color: #0000ff;">var</span> urls =<span style="color: #000000;"> [];
        </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, len = <span style="color: #800080;">0</span><span style="color: #000000;">;

        </span><span style="color: #0000ff;">var</span> map =<span style="color: #000000;"> [
            { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">) },
            { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
        ];
        </span><span style="color: #0000ff;">var</span> player =<span style="color: #000000;"> [
            { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
        ];
        </span><span style="color: #0000ff;">var</span> enemy =<span style="color: #000000;"> [
            { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
        ];
        </span><span style="color: #0000ff;">var</span> bomb =<span style="color: #000000;"> [
            { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">bomb</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">bomb</span><span style="color: #800000;">"</span><span style="color: #000000;">) },
            { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">explode</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">explode</span><span style="color: #800000;">"</span><span style="color: #000000;">) },
            { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">fire</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">fire</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
        ];

        _addImg(urls, map, player, enemy, bomb);

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> urls;
    };
    </span><span style="color: #0000ff;">var</span> _addImg =<span style="color: #000000;"> function (urls, imgs) {
        </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span><span style="color: #000000;">),
            i </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
            j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
            len1 </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
            len2 </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

        </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len1 = args.length; i &lt; len1; i++<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>, len2 = args[i].length; j &lt; len2; j++<span style="color: #000000;">) {
                urls.push({ id: args[i][j].id, url: args[i][j].url });
            }
        }
    };

    </span><span style="color: #0000ff;">var</span> _hideBar =<span style="color: #000000;"> function () {
        $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar</span><span style="color: #800000;">"</span>).css(<span style="color: #800000;">"</span><span style="color: #800000;">display</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">none</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    };

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
        init: function () {
            window.imgLoader </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> YE.ImgLoader(_getImg(), function (currentLoad, imgCount) {
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar_img_show</span><span style="color: #800000;">"</span>).progressBar(parseInt(currentLoad * <span style="color: #800080;">100</span> / imgCount, <span style="color: #800080;">10</span>));     <span style="color: #008000;">//</span><span style="color: #008000;">调用进度条插件</span>
            }, YYC.Tool.func.bind(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.onload));
        },
        onload: function () {
            _hideBar();

            </span><span style="color: #0000ff;">var</span> game = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Game();
            game.init();
            game.start();
        },
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
         * 用于测试时预加载图片
         </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        initTest: function () {
            window.imgLoader </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> YYC.Control.PreLoadImg(_getImg(), function (currentLoad, imgCount) {
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar_img_show</span><span style="color: #800000;">"</span>).progressBar(parseInt(currentLoad * <span style="color: #800080;">100</span> / imgCount, <span style="color: #800080;">10</span>));     <span style="color: #008000;">//</span><span style="color: #008000;">调用进度条插件</span>
            }, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
        }
    };

    window.main </span>=<span style="color: #000000;"> main;
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>分析提炼引擎的思路（重用的角度分析），提出重写loadResource的方法，设计示例</p>
<p>main.js中&ldquo;加载资源&rdquo;这个逻辑为通用逻辑，可以将其提出到引擎Main中：</p>
<p>引擎Main内部负责创建ImgLoader，提供imgLoader公有属性供用户访问；</p>
<p>引擎的Main提供一个loadResource钩子方法，由用户重写，负责加载资源并启动游戏；</p>
<p>&nbsp;</p>
<p>另外可将main.js的init方法提到引擎Main中，从而由引擎负责启动游戏。</p>
<p>对应修改Index.html中的游戏启动：</p>
<p>Index.html修改前</p>
<div class="cnblogs_code">
<pre>&lt;script type=<span style="color: #800000;">"</span><span style="color: #800000;">text/javascript</span><span style="color: #800000;">"</span>&gt;<span style="color: #000000;">
    (function () {
        main.init();
    })();
</span>&lt;/script&gt;</pre>
</div>
<p>&nbsp;</p>
<p>Index.html修改后</p>
<div class="cnblogs_code">
<pre>&lt;script type=<span style="color: #800000;">"</span><span style="color: #800000;">text/javascript</span><span style="color: #800000;">"</span>&gt;<span style="color: #000000;">
    (function () {
        YE.Main.getInstance().init();
    })();
</span>&lt;/script&gt;</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span class="webkit-whitespace"> <span class="webkit-javascript-ident"><br /></span></span></p>
<p>提炼出的引擎Main：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> _instance = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).Main =<span style="color: #000000;"> YYC.Class({
        Init: function () {
        },
        Public: {
            init: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._prepare();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.imgLoader.done();
            },
            _prepare: function () {
               </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.loadResource();

</span><span style="color: #008000;">//</span><span style="color: #008000;">                this.imgLoader.onload_game = function () {</span>
<span style="color: #808080;">///</span><span style="color: #008000;">/                    var director = YE.Director.getInstance();
</span><span style="color: #808080;">///</span><span style="color: #008000;">/
</span><span style="color: #808080;">///</span><span style="color: #008000;">/                    director.init();
</span><span style="color: #808080;">///</span><span style="color: #008000;">/                    director.start();</span>
<span style="color: #008000;">//</span><span style="color: #008000;">                    var game = new Game();
</span><span style="color: #008000;">//</span><span style="color: #008000;">                    game.init();
</span><span style="color: #008000;">//</span><span style="color: #008000;">                    game.start();
</span><span style="color: #008000;">//</span><span style="color: #008000;">                }</span>
<span style="color: #000000;">            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">* 钩子</span>
<span style="color: #000000;">
            loadResource: function () {
            }
        },
        Static: {
            getInstance: function () {
                </span><span style="color: #0000ff;">if</span> (_instance === <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                    _instance </span>= <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">();
                    _instance.imgLoader </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> YE.ImgLoader();
                }
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> _instance;
            }
        }
    });
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>修改后的main.js</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"> (function(){
        </span><span style="color: #0000ff;">var</span> Main =<span style="color: #000000;"> YE.Main,
            main </span>=<span style="color: #000000;"> Main.getInstance();


        </span><span style="color: #0000ff;">var</span> _getImg =<span style="color: #000000;"> function () {
           ...</span><span style="color: #000000;">
        };

        </span><span style="color: #0000ff;">var</span> _addImg =<span style="color: #000000;"> function (urls, imgs) {
            </span><span><span style="color: #0000ff;">...</span></span><span style="color: #000000;">
        };

        </span><span style="color: #0000ff;">var</span> _hideBar =<span style="color: #000000;"> function () {
           ...</span><span style="color: #000000;">
        };

        main.loadResource </span>=<span style="color: #000000;"> function () {
            </span><span style="color: #0000ff;">var</span> loader = <span style="color: #0000ff;">this</span><span style="color: #000000;">.imgLoader;

            loader.load(_getImg());
</span>
            loader.onloading =<span style="color: #000000;"> function (currentLoad, imgCount) {
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar_img_show</span><span style="color: #800000;">"</span>).progressBar(parseInt(currentLoad * <span style="color: #800080;">100</span> / imgCount, <span style="color: #800080;">10</span>)); 
<span style="color: #000000;">            };
            loader.onload </span>=<span style="color: #000000;"> function (imgCount) {
                _hideBar();

                </span><span style="color: #0000ff;">var</span> game = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Game();
                game.init();
                game.start();
            };


            window.imgLoader </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.imgLoader;　　//将imgLoader设为全局属性
        };
    }());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>修改ImgLoader</p>
<p>修改构造函数</p>
<p>这里对ImgLoader进行了修改，构造函数不再进行onload、onloading的注入，而是将其提出为外部钩子方法，由用户在引擎Main的loadResource中重写。</p>
<p>增加load方法，用于传入图片数据。</p>
<p>&nbsp;</p>
<p>提出done方法&nbsp;</p>
<p>另外，分离出了负责进行图片加载的done方法，在引擎Main的init方法中调用。</p>
<p>相对于以前的创建ImgLoader时即进行图片预加载，这样可更灵活地控制图片加载的时机。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>修改后的ImgLoader</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).ImgLoader =<span style="color: #000000;"> YYC.Class({
    Init: function () {
    },
    Private: {
        _images: [],
        _imgs: {},

        _checkImages: function (images) {
            </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (YYC.Tool.judge.isArray(images)) {
                </span><span style="color: #0000ff;">for</span> (len = images.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (images[i].id === undefined || images[i].url ===<span style="color: #000000;"> undefined) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">应该包含id和url属性</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                }
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (images.id === undefined || images.url ===<span style="color: #000000;"> undefined) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">应该包含id和url属性</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            }
        },
        _onload: function (i) {
            clearTimeout(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.timerID);

            </span><span style="color: #0000ff;">this</span>.currentLoad++<span style="color: #000000;">;
            </span><span style="color: #0000ff;">this</span>.onloading(<span style="color: #0000ff;">this</span>.currentLoad, <span style="color: #0000ff;">this</span><span style="color: #000000;">.imgCount);

            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.currentLoad === <span style="color: #0000ff;">this</span><span style="color: #000000;">.imgCount) {
                </span><span style="color: #0000ff;">this</span>.onload(<span style="color: #0000ff;">this</span><span style="color: #000000;">.imgCount);
</span><span style="color: #008000;">//</span><span style="color: #008000;">                this.onload_game();</span>
<span style="color: #000000;">            }
        },
        _loadImg: function () {
            </span><span style="color: #0000ff;">var</span> img = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                i </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                len </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._images.length,</span>
                self = <span style="color: #0000ff;">this</span><span style="color: #000000;">,
                image </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>;i &lt; len; i++<span style="color: #000000;">) {
                img </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._images[i];
                image </span>= <span style="color: #0000ff;">this</span>._imgs[img.id] = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Image();
</span><span style="color: #000000;">
                image.onload </span>=<span style="color: #000000;"> function () {
                    </span><span style="color: #0000ff;">this</span>.onload = <span style="color: #0000ff;">null</span>;     <span style="color: #008000;">//</span><span style="color: #008000;">解决ie内存泄露  此处this指代_imgs[i]</span>
<span style="color: #000000;">
                    YTool.Tool.func.bind(self, self._onload)();
                };
                </span><span style="color: #008000;">//</span><span style="color: #008000;">_imgs[i].src = c.images[i];</span>
                image.src =<span style="color: #000000;"> img.url;

                </span><span style="color: #0000ff;">this</span>.timerID =<span style="color: #000000;"> (function (i) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> setTimeout(function () {
                        </span><span style="color: #0000ff;">if</span> (i ==<span style="color: #000000;"> self.currentLoad) {
                            </span><span style="color: #008000;">//</span><span style="color: #008000;">_imgs[i].src = c.images[i];</span>
                            image.src =<span style="color: #000000;"> img.url;
                        }
                    }, </span><span style="color: #800080;">500</span><span style="color: #000000;">);
                })(i);
            }
        }
    },
    Public: {
        imgCount: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        currentLoad: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        timerID: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

        </span><span style="color: #0000ff;">get</span><span style="color: #000000;">: function (id) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._imgs[id];
        },

        done: function () {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._loadImg();

        },
        load: function (images) {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._checkImages(images);

            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (YE.Tool.judge.isArray(images)) {
                </span><span style="color: #0000ff;">this</span>._images = <span style="color: #0000ff;">this</span><span style="color: #000000;">._images.concat(images);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._images.push(images);
            }
            </span><span style="color: #0000ff;">this</span>.imgCount = <span style="color: #0000ff;">this</span><span style="color: #000000;">._images.length;
        },

        dispose: function () {
            </span><span style="color: #0000ff;">var</span> i, _imgs = <span style="color: #0000ff;">this</span><span style="color: #000000;">._imgs;
            </span><span style="color: #008000;">//</span><span style="color: #008000;">for (i = 0; i &lt; _imgs.length; i++) {</span>
            <span style="color: #0000ff;">for</span> (i <span style="color: #0000ff;">in</span><span style="color: #000000;"> _imgs) {
                _imgs[i].onload </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                _imgs[i] </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">_imgs.length = 0;</span>
            <span style="color: #0000ff;">this</span>.config = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        },

</span><span style="color: #008000;">//</span>        <span style="color: #008000;">//</span><span style="color: #008000;">*内部钩子
</span><span style="color: #008000;">//</span>
<span style="color: #008000;">//</span><span style="color: #008000;">        onload_game: function () {
</span><span style="color: #008000;">//</span><span style="color: #008000;">        },

        </span><span style="color: #008000;">//</span><span style="color: #008000;">*外部钩子</span>
<span style="color: #000000;">
        onloading: function (currentLoad, imgCount) {
        },
        onload: function (imgCount) {
        }
    }
});</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>将依赖的YTool方法移到Tool</p>
<p>ImgLoader中需要调用YTool的isArray方法，将其移到Tool中。</p>
<p>Tool</p>
<div class="cnblogs_code">
<pre>    <span style="color: #008000;">//</span><span style="color: #008000;">*工具类</span>

    <span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE.Tool</span><span style="color: #800000;">"</span>).func =<span style="color: #000000;"> {
        bind: function (</span><span style="color: #0000ff;">object</span><span style="color: #000000;">, fun) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> function () {
                </span><span style="color: #0000ff;">return</span> fun.apply(<span style="color: #0000ff;">object</span><span style="color: #000000;">, arguments);
            };
        }
    };

    </span><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE.Tool</span><span style="color: #800000;">"</span>).judge =<span style="color: #000000;"> {
        isArray: function (val) {
            </span><span style="color: #0000ff;">return</span> Object.prototype.toString.call(val) === <span style="color: #800000;">"</span><span style="color: #800000;">[object Array]</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        }
    };</span></pre>
</div>
<p>&nbsp;</p>
<p>对应修改ImgLoader，将YYC.Tool调用改为YE.Tool</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">...
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (YE.Tool.judge.isArray(images)) {
                </span><span style="color: #0000ff;">for</span> (len = images.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (images[i].id === undefined || images[i].url ===<span style="color: #000000;"> undefined) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">应该包含id和url属性</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                }
            }
...
                image.onload </span>=<span style="color: #000000;"> function () {
                    </span><span style="color: #0000ff;">this</span>.onload = <span style="color: #0000ff;">null</span>;     <span style="color: #008000;">//</span><span style="color: #008000;">解决ie内存泄露  此处this指代_imgs[i]</span>
<span style="color: #000000;">
                    YE.Tool.func.bind(self, self._onload)();
                };
 ...</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">提出的引擎Main代码</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">对应修改炸弹人的类，令其使用提炼出的引擎类</span></p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">修改后的炸弹人main.js代码</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>领域模型</p>
<p style="text-align: center;">图</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">加入Global</span></p>
<p><span style="color: #c0c0c0;">5</span></p>
<p>&nbsp;</p>
<p>加入Director</p>
<p>4,6</p>
<p><span style="color: #ff0000;">（第二次迭代会删除Game）</span></p>
<p>&nbsp;</p>
<p>提炼Director<span style="color: #c0c0c0;">（scene暂为layerManager）</span></p>
<p>确定引擎要提炼的类</p>
<p>分析领域模型，现在引擎Main依赖于用户的Game，这违背了引擎的设计原则，所以应该提炼出引擎的Director类，使得引擎Main依赖于引擎Director，从而解决引擎对用户的依赖</p>
<p>（本文后面的提炼中也会遇到类似的问题，不再进行解释）</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">继续往右提炼，现在该提炼Director领域类了。</span></p>
<p>该类为游戏主逻辑类，负责游戏的统一调度。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><br />分析炸弹人参考模型中对应的类，找出可复用的、通用的部分，将其提炼到引擎类中</p>
<p>该类对应炸弹人的Game类</p>
<p>Game</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">观察者全局实例</span>
    window.subject = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">游戏全局状态</span>
    window.gameState =<span style="color: #000000;"> window.bomberConfig.game.state.NORMAL;

    </span><span style="color: #0000ff;">var</span> Game =<span style="color: #000000;"> YYC.Class({
        Init: function () {
            window.subject </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> YYC.Pattern.Subject();
        },
        Private: {
            _pattern: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            _ground: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            _createLayerManager: function () {
                </span><span style="color: #0000ff;">this</span>.layerManager = <span style="color: #0000ff;">new</span><span style="color: #000000;"> LayerManager();
                </span><span style="color: #0000ff;">this</span>.layerManager.addLayer(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, layerFactory.createMap());
                </span><span style="color: #0000ff;">this</span>.layerManager.addLayer(<span style="color: #800000;">"</span><span style="color: #800000;">enemyLayer</span><span style="color: #800000;">"</span>, layerFactory.createEnemy(<span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep));
                </span><span style="color: #0000ff;">this</span>.layerManager.addLayer(<span style="color: #800000;">"</span><span style="color: #800000;">playerLayer</span><span style="color: #800000;">"</span>, layerFactory.createPlayer(<span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep));
                </span><span style="color: #0000ff;">this</span>.layerManager.addLayer(<span style="color: #800000;">"</span><span style="color: #800000;">bombLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, layerFactory.createBomb());
                </span><span style="color: #0000ff;">this</span>.layerManager.addLayer(<span style="color: #800000;">"</span><span style="color: #800000;">fireLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, layerFactory.createFire());
            },
            _addElements: function () {
                </span><span style="color: #0000ff;">var</span> mapLayerElements = <span style="color: #0000ff;">this</span><span style="color: #000000;">._createMapLayerElement(),
                    playerLayerElements </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._createPlayerLayerElement(),
                    enemyLayerElements </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._createEnemyLayerElement();

                </span><span style="color: #0000ff;">this</span>.layerManager.addSprites(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, mapLayerElements);
                </span><span style="color: #0000ff;">this</span>.layerManager.addSprites(<span style="color: #800000;">"</span><span style="color: #800000;">playerLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, playerLayerElements);
                </span><span style="color: #0000ff;">this</span>.layerManager.addSprites(<span style="color: #800000;">"</span><span style="color: #800000;">enemyLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, enemyLayerElements);
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">创建并设置每个地图方格精灵，加入到元素数组中并返回。</span>
<span style="color: #000000;">            _createMapLayerElement: function () {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    x </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    y </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    row </span>=<span style="color: #000000;"> bomberConfig.map.ROW,
                    col </span>=<span style="color: #000000;"> bomberConfig.map.COL,
                    element </span>=<span style="color: #000000;"> [],
                    mapData </span>=<span style="color: #000000;"> mapDataOperate.getMapData(),
                    img </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; row; i++<span style="color: #000000;">) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">注意！
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">y为纵向height，x为横向width</span>
                    y = i *<span style="color: #000000;"> bomberConfig.HEIGHT;

                    </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; col; j++<span style="color: #000000;">) {
                        x </span>= j *<span style="color: #000000;"> bomberConfig.WIDTH;
                        img </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._getMapImg(i, j, mapData);
                        element.push(spriteFactory.createMapElement({ x: x, y: y }, bitmapFactory.createBitmap({ img: img, width: bomberConfig.WIDTH, height: bomberConfig.HEIGHT })));
                    }
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
            },
            _getMapImg: function (i, j, mapData) {
                </span><span style="color: #0000ff;">var</span> img = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (mapData[i][j]) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">1</span><span style="color: #000000;">:
                        img </span>= window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">2</span><span style="color: #000000;">:
                        img </span>= window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> img;
            },
            _createPlayerLayerElement: function () {
                </span><span style="color: #0000ff;">var</span> element =<span style="color: #000000;"> [],
                    player </span>=<span style="color: #000000;"> spriteFactory.createPlayer();

                player.init();
                element.push(player);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
            },
            _createEnemyLayerElement: function () {
                </span><span style="color: #0000ff;">var</span> element =<span style="color: #000000;"> [],
                    enemy </span>=<span style="color: #000000;"> spriteFactory.createEnemy(),
                    enemy2 </span>=<span style="color: #000000;"> spriteFactory.createEnemy2();

                enemy.init();
                enemy2.init();
                element.push(enemy);
                element.push(enemy2);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
            },
            _initLayer: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layerManager.initLayer();
            },
            _initEvent: function () {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">监听整个document的keydown,keyup事件</span>
<span style="color: #000000;">                keyEventManager.addKeyDown();
                keyEventManager.addKeyUp();
            },
            _judgeGameState: function () {
                </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (window.gameState) {
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> window.bomberConfig.game.state.NORMAL:
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> window.bomberConfig.game.state.OVER:
                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.gameOver();
                        </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">over</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> window.bomberConfig.game.state.WIN:
                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.gameWin();
                        </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">over</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">未知的游戏状态</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        },
        Public: {
            sleep: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            x: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            layerManager: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            mainLoop: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            init: function () {
                </span><span style="color: #0000ff;">this</span>.sleep = Math.floor(<span style="color: #800080;">1000</span> /<span style="color: #000000;"> bomberConfig.FPS);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._createLayerManager();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._addElements();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._initLayer();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._initEvent();

                window.subject.subscribe(</span><span style="color: #0000ff;">this</span>.layerManager.getLayer(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span>), <span style="color: #0000ff;">this</span>.layerManager.getLayer(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">).changeSpriteImg);
            },
            start: function () {
                </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span>.mainLoop =<span style="color: #000000;"> window.setInterval(function () {
                    self.run();
                }, </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep);
            },
            run: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._judgeGameState() === <span style="color: #800000;">"</span><span style="color: #800000;">over</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layerManager.run();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layerManager.change();
            },
            gameOver: function () {
                YYC.Tool.asyn.clearAllTimer(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.mainLoop);
                alert(</span><span style="color: #800000;">"</span><span style="color: #800000;">Game Over！</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            },
            gameWin: function () {
                YYC.Tool.asyn.clearAllTimer(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.mainLoop);
                alert(</span><span style="color: #800000;">"</span><span style="color: #800000;">You Win！</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        }
    });

    window.Game </span>=<span style="color: #000000;"> Game;
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>其中主循环、 layerManager的调度和fps的计算可以提取到Director中</p>
<p>Director</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> _instance = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).Director =<span style="color: #000000;"> YYC.Class({
        Private: {
            _STARTING_FPS: </span><span style="color: #800080;">60</span><span style="color: #000000;">,

            _startTime: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            _lastTime: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            _fps: </span><span style="color: #800080;">60</span><span style="color: #000000;">,

            _layerManager: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            _loop: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,


            _getTimeNow: function () {
                </span><span style="color: #0000ff;">return</span> +<span style="color: #0000ff;">new</span><span style="color: #000000;"> Date();
            },
            _run: function (time) {
                </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._loopBody(time);

                </span><span style="color: #0000ff;">this</span>._loop =<span style="color: #000000;"> window.requestNextAnimationFrame(function (time) {
                    self._run.call(self, time);
                });
            },
            _loopBody: function (time) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._tick(time);

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.onenter();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._layerManager.run();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._layerManager.change();

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.onexit();
            },
            _tick: function (time) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._updateFps(time);
                </span><span style="color: #0000ff;">this</span>.gameTime = <span style="color: #0000ff;">this</span>._getTimeNow() - <span style="color: #0000ff;">this</span><span style="color: #000000;">._startTime;
                </span><span style="color: #0000ff;">this</span>._lastTime =<span style="color: #000000;"> time;
            },
            _updateFps: function (time) {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._lastTime === <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>._fps = <span style="color: #0000ff;">this</span><span style="color: #000000;">._STARTING_FPS;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span>._fps = <span style="color: #800080;">1000</span> / (time - <span style="color: #0000ff;">this</span><span style="color: #000000;">._lastTime);
                }
            }
        },
        Public: {
            gameTime: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,


            start: function () {
                </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span>._startTime = <span style="color: #0000ff;">this</span><span style="color: #000000;">._getTimeNow();

                window.requestNextAnimationFrame(function (time) {
                    self._run.call(self, time);
                });
            },
            setLayerManager: function (layerManager) {
                </span><span style="color: #0000ff;">this</span>._layerManager =<span style="color: #000000;"> layerManager;
            },
            getFps: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._fps;
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> getPixPerFrame: function (speed) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">     return speed / this._fps;
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> },</span>
<span style="color: #000000;">            stop: function () {
                window.cancelNextRequestAnimationFrame(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">._loop);
            },


            </span><span style="color: #008000;">//</span><span style="color: #008000;">*钩子</span>
<span style="color: #000000;">
            init: function () {
            },
            onenter: function () {
            },
            onexit: function () {
            }

        },


        Static: {
            getInstance: function () {
                </span><span style="color: #0000ff;">if</span> (_instance === <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                    _instance </span>= <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">();
                }
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> _instance;
            }
        }
    });
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>分析Director</p>
<p>&nbsp;</p>
<ul>
<li>主循环的实现，选择requestAnimationFrame</li>
</ul>
<p><span style="line-height: 1.5;">炸弹人Game中使用setInterval，而Director使用</span><span style="line-height: 1.5;">requestAnimationFrame实现主循环</span></p>
<p>&nbsp;</p>
<p>（引用自《HTML5 Canvas 核心技术》）</p>
<blockquote>
<p>每一个游戏都是由获得用户输入，更新游戏状态，处理AI，播放音乐和音效，还有画面显示这些行为组成。游戏主循环就是用来处理这个行为序列。</p>
<p>可以使用setInterval（或setTimeout）和requestAnimationFrame两种方法来实现游戏主循环。</p>
<p class="a">比较setInterval（setTimeout）和requestNextAnimationFrame</p>
<p>如果使用setInterval或setTimeout来实现循环，则效果可能不够流畅，且会占用额外的资源。它们有如下的特征：</p>
<ol>
<li>它们都是通用的方法，不是为制作游戏而设计的。</li>
<li>即使向其传递毫秒为单位的参数，它们也不能达到ms的准确性。这是因为javascript是单线程的，可能会发生阻塞。</li>
<li>没有对调用动画的循环机制进行优化。</li>
<li>没有考虑到绘制动画的最佳时机，只是一味地以某个大致的事件间隔来调用循环。</li>
</ol>
<p>其实，使用setInterval或setTimeout来实现主循环，根本错误就在于它们抽象等级不符合要求。我们想让浏览器执行的是一套可以控制各种细节的api，实现如&ldquo;最优帧速率&rdquo;、&ldquo;选择绘制下一帧的最佳时机&rdquo;等功能。但是如果使用它们的话，这些具体的细节就必须由开发者自己来完成。</p>
</blockquote>
<p>因此，我选用requestAnimationFrame方法来实现主循环。该方法不需要调用者指定循环间隔时间，而是由浏览器自行决定最佳的帧速率。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>提出兼容的requestNextAnimationFrame、cancelNextRequestAnimationFrame方法，放到Tool中</p>
<p>需要注意的时，不同的浏览器对于requestAnimationFrame、cancelNextRequestAnimationFrame的实现不一样，因此需要定义一个通用的方法，该方法放到引擎Tool类中。</p>
<p>Tool</p>
<div class="cnblogs_code">
<p> /**<br />         * 来自《HTML5 Canvas 核心技术》<br />         * 不能写到global中，否则会报错&ldquo;illegal invocation&rdquo;！<br />         */</p>
<pre><em> window.requestNextAnimationFrame =<span style="color: #000000;"> (function () {
            </span><span style="color: #0000ff;">var</span> originalWebkitRequestAnimationFrame =<span style="color: #000000;"> undefined,
                wrapper </span>=<span style="color: #000000;"> undefined,
                callback </span>=<span style="color: #000000;"> undefined,
                geckoVersion </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                userAgent </span>=<span style="color: #000000;"> navigator.userAgent,
                index </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                self </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">;

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Workaround for Chrome 10 bug where Chrome
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> does not pass the time to the animation function</span>

            <span style="color: #0000ff;">if</span><span style="color: #000000;"> (window.webkitRequestAnimationFrame) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Define the wrapper</span>
<span style="color: #000000;">
                wrapper </span>=<span style="color: #000000;"> function (time) {
                    </span><span style="color: #0000ff;">if</span> (time ===<span style="color: #000000;"> undefined) {
                        time </span>= +<span style="color: #0000ff;">new</span><span style="color: #000000;"> Date();
                    }
                    self.callback(time);
                };

                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Make the switch</span>
<span style="color: #000000;">
                originalWebkitRequestAnimationFrame </span>=<span style="color: #000000;"> window.webkitRequestAnimationFrame;

                window.webkitRequestAnimationFrame </span>=<span style="color: #000000;"> function (callback, element) {
                    self.callback </span>=<span style="color: #000000;"> callback;

                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Browser calls the wrapper and wrapper calls the callback</span>
<span style="color: #000000;">
                    originalWebkitRequestAnimationFrame(wrapper, element);
                }
            }

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Workaround for Gecko 2.0, which has a bug in
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> mozRequestAnimationFrame() that restricts animations
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> to 30-40 fps.</span>

            <span style="color: #0000ff;">if</span><span style="color: #000000;"> (window.mozRequestAnimationFrame) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Check the Gecko version. Gecko is used by browsers
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> other than Firefox. Gecko 2.0 corresponds to
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Firefox 4.0.</span>
<span style="color: #000000;">
                index </span>= userAgent.indexOf(<span style="color: #800000;">'</span><span style="color: #800000;">rv:</span><span style="color: #800000;">'</span><span style="color: #000000;">);

                </span><span style="color: #0000ff;">if</span> (userAgent.indexOf(<span style="color: #800000;">'</span><span style="color: #800000;">Gecko</span><span style="color: #800000;">'</span>) != -<span style="color: #800080;">1</span><span style="color: #000000;">) {
                    geckoVersion </span>= userAgent.substr(index + <span style="color: #800080;">3</span>, <span style="color: #800080;">3</span><span style="color: #000000;">);

                    </span><span style="color: #0000ff;">if</span> (geckoVersion === <span style="color: #800000;">'</span><span style="color: #800000;">2.0</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Forces the return statement to fall through
                        </span><span style="color: #008000;">//</span><span style="color: #008000;"> to the setTimeout() function.</span>
<span style="color: #000000;">
                        window.mozRequestAnimationFrame </span>=<span style="color: #000000;"> undefined;
                    }
                }
            }

            </span><span style="color: #0000ff;">return</span>  window.requestAnimationFrame ||<span style="color: #000000;">
                window.webkitRequestAnimationFrame </span>||<span style="color: #000000;">
                window.mozRequestAnimationFrame </span>||<span style="color: #000000;">
                window.oRequestAnimationFrame </span>||<span style="color: #000000;">
                window.msRequestAnimationFrame </span>||<span style="color: #000000;">

                function (callback, element) {
                    </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> start,
                        finish;

                    window.setTimeout(function () {
                        start </span>= +<span style="color: #0000ff;">new</span><span style="color: #000000;"> Date();
                        callback(start);
                        finish </span>= +<span style="color: #0000ff;">new</span><span style="color: #000000;"> Date();

                        self.timeout </span>= <span style="color: #800080;">1000</span> / <span style="color: #800080;">60</span> - (finish -<span style="color: #000000;"> start);

                    }, self.timeout);
                };
        }());<br /><br /></span></em></pre>
<p> window.cancelNextRequestAnimationFrame = window.cancelRequestAnimationFrame<br />            || window.webkitCancelAnimationFrame<br />            || window.webkitCancelRequestAnimationFrame<br />            || window.mozCancelRequestAnimationFrame<br />            || window.oCancelRequestAnimationFrame<br />            || window.msCancelRequestAnimationFrame<br />        || clearTimeout;</p>
<pre><span style="color: #000000;">&nbsp;</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<ul>
<li>提出fps</li>
</ul>
<p>Director定义了初始的fps属性_STARTING_FPS</p>
<p>并且可计算当前主循环的fps</p>
<ul>
<li><span style="color: #c0c0c0;">结束主循环提到Director中</span></li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<ul>
<li>Director提出init、onenter、onexit钩子函数，<span style="color: #c0c0c0;">LayerManager也提出onenter、onexit钩子函数，</span>用户可重写</li>
</ul>
<p>Director定义了init、onenter、onexit钩子函数，其中init会在引擎Main中加载完资源后调用，onenter、onexit会在主循环中调用layerManager的前、后分别调用。</p>
<p>&nbsp;</p>
<ul>
<li>单例</li>
</ul>
<p>因为全局只会有一个Director，因此其设为单例。</p>
<p>&nbsp;</p>
<ul>
<li>&nbsp;LayerManager-&gt;change的调用应该放在哪里？</li>
</ul>
<p>有两个选择：</p>
<p>1、由用户调用</p>
<p>重写director-&gt;onexit，调用LayerManager-&gt;change</p>
<p>2、由引擎调用</p>
<p>在Director主循环调用layerManager-&gt;run后调用LayerManager-&gt;change</p>
<p>&nbsp;</p>
<p>炸弹人的change机制属于通用的部分，因此应该由引擎调用。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>对应修改炸弹人的类和引擎类</p>
<p>&nbsp;</p>
<p>修改炸弹人Game&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Director =<span style="color: #000000;"> YE.Director,
        director </span>=<span style="color: #000000;"> Director.getInstance();

</span><span style="color: #008000;">//</span>    <span style="color: #008000;">//</span><span style="color: #008000;">观察者全局实例
</span><span style="color: #008000;">//</span><span style="color: #008000;">    window.subject = new YYC.Pattern.Subject();</span>


    <span style="color: #0000ff;">var</span> Game =<span style="color: #000000;"> YYC.Class({
        Init: function () {
</span><span style="color: #008000;">//</span><span style="color: #008000;">            window.subject = new YYC.Pattern.Subject();</span>
<span style="color: #000000;">        },
        Private: {
        ...</span><span style="color: #000000;">
        },
        Public: {
            sleep: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            x: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            layerManager: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            mainLoop: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

</span><span style="color: #008000;">//</span><span style="color: #008000;">            init: function () {
</span><span style="color: #008000;">//</span><span style="color: #008000;">                this.sleep = Math.floor(1000 / bomberConfig.FPS);
</span><span style="color: #008000;">//</span><span style="color: #008000;">                this._createLayerManager();
</span><span style="color: #008000;">//</span><span style="color: #008000;">                this._addElements();
</span><span style="color: #008000;">//</span><span style="color: #008000;">                this._initLayer();
</span><span style="color: #008000;">//</span><span style="color: #008000;">                this._initEvent();
</span><span style="color: #008000;">//</span>
<span style="color: #008000;">//</span><span style="color: #008000;">                window.subject.subscribe(this.layerManager.getLayer("mapLayer"), this.layerManager.getLayer("mapLayer").changeSpriteImg);
</span><span style="color: #008000;">//</span><span style="color: #008000;">            },
</span><span style="color: #008000;">//</span><span style="color: #008000;">            start: function () {
</span><span style="color: #008000;">//</span><span style="color: #008000;">                var self = this;
</span><span style="color: #008000;">//</span>
<span style="color: #008000;">//</span><span style="color: #008000;">                this.mainLoop = window.setInterval(function () {
</span><span style="color: #008000;">//</span><span style="color: #008000;">                    self.run();
</span><span style="color: #008000;">//</span><span style="color: #008000;">                }, this.sleep);
</span><span style="color: #008000;">//</span><span style="color: #008000;">            },
</span><span style="color: #008000;">//</span><span style="color: #008000;">            run: function () {
</span><span style="color: #008000;">//</span><span style="color: #008000;">                if (this._judgeGameState() === "over") {
</span><span style="color: #008000;">//</span><span style="color: #008000;">                    return;
</span><span style="color: #008000;">//</span><span style="color: #008000;">                }
</span><span style="color: #008000;">//</span>
<span style="color: #008000;">//</span><span style="color: #008000;">                this.layerManager.run();
</span><span style="color: #008000;">//</span><span style="color: #008000;">                this.layerManager.change();
</span><span style="color: #008000;">//</span><span style="color: #008000;">            },</span>
<span style="color: #000000;">            gameOver: function () {
                director.stop();
                alert(</span><span style="color: #800000;">"</span><span style="color: #800000;">Game Over！</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            },
            gameWin: function () {
                director.stop();
                alert(</span><span style="color: #800000;">"</span><span style="color: #800000;">You Win！</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        }
    });


    </span><span style="color: #0000ff;">var</span> game = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Game();

    director.init </span>=<span style="color: #000000;"> function () {<br />game.sleep = 1000 / director.getFps();　　<span style="color: #ff0000;">//加入该行代码</span><br />
        </span><span style="color: #008000;">//</span><span style="color: #008000;">游戏全局状态</span>
        window.gameState =<span style="color: #000000;"> window.bomberConfig.game.state.NORAML;

        window.subject </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> YYC.Pattern.Subject();


        game._createLayerManager();
        game._addElements();
        game._initLayer();
        game._initEvent();

        window.subject.subscribe(game.layerManager.getLayer(</span><span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span>), game.layerManager.getLayer(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">).changeSpriteImg);


        </span><span style="color: #008000;">//</span><span style="color: #008000;">设置场景</span>

        <span style="color: #0000ff;">this</span><span style="color: #000000;">.setScene(game.layerManager);
    };

    director.onenter </span>=<span style="color: #000000;"> function () {
        </span><span style="color: #0000ff;">if</span> (game._judgeGameState() === <span style="color: #800000;">"</span><span style="color: #800000;">over</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
            YE.Global.returnFunc();
        }
    };
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>分析</p>
<p>Game不需要start方法实现主循环了，该机制已经提到了Director中</p>
<p>通过重写Director-&gt;init，将Game中的初始化逻辑移到其中，并且设置Director管理的layerManager</p>
<p>重写Director-&gt;onenter，将Game-&gt;run的判断逻辑移到其中</p>
<p>修改Game-&gt;gameOver、gameWin，调用director.stop来终止主循环</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">第一步：4</span></p>
<p><span style="color: #000000;">修改Main和ImgLoader</span></p>
<p><span style="color: #c0c0c0;">Director封闭到Main中</span></p>
<p>分析loadResource钩子方法，分离出&ldquo;启动游戏&rdquo;的逻辑到引擎中</p>
<p>&nbsp;</p>
<p>修改炸弹人main.js-&gt;loadResource，改为调用director的init和start方法启动游戏</p>
<div class="cnblogs_code">
<pre> main.loadResource =<span style="color: #000000;"> function () {
...
            loader.onload </span>=<span style="color: #000000;"> function (imgCount) {
                _hideBar();

                </span><span style="color: #0000ff;">var</span> director =<span style="color: #000000;"> YE.Director.getInstance();

                director.init();
                director.start();
            };


...
        };</span></pre>
</div>
<p>　　进一步分析</p>
<p>从onload分离出onload_game钩子</p>
<p>&ldquo;调用director的init和start方法启动游戏&rdquo;不应该由用户负责，而应该由引擎负责。</p>
<p>因此，修改ImgLoader，从onload分离出onload_game钩子：</p>
<p>ImgLoader</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        _onload: function (i) {
</span><span style="color: #000000;">...

            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.currentLoad === <span style="color: #0000ff;">this</span><span style="color: #000000;">.imgCount) {
                </span><span style="color: #0000ff;">this</span>.onload(<span style="color: #0000ff;">this</span><span style="color: #000000;">.imgCount);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.onload_game();
            }
        },
...

        </span><span style="color: #008000;">//</span><span style="color: #008000;">*内部钩子</span>
<span style="color: #000000;">
        onload_game: function () {
        },
...
    }</span></pre>
</div>
<p>然后在Main中定义ImgLoader-&gt;onload_game，定义游戏启动：</p>
<p>Main</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">_prepare: function () {
</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.loadResource();

</span><span style="color: #0000ff;">this</span>.imgLoader.onload_game =<span style="color: #000000;"> function () {
</span><span style="color: #0000ff;">var</span> director =<span style="color: #000000;"> YE.Director.getInstance();

director.init();
director.start();
}
},</span></pre>
</div>
<p>修改main.js，现在用户不再负责游戏启动了<span style="color: #c0c0c0;">，不用知道Director的存在</span></p>
<div class="cnblogs_code">
<pre>        main.loadResource =<span style="color: #000000;"> function () {
...
            loader.onload </span>=<span style="color: #000000;"> function (imgCount) {
                _hideBar();
            };
...
        };</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">修改ImgLoader</span></p>
<p><span style="color: #c0c0c0;">提出onload_game内部钩子</span></p>
<p><span style="color: #c0c0c0;">（分析内部钩子和外部钩子的区别）</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">进一步提炼</span></p>
<p><span style="color: #c0c0c0;">修改Game</span></p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">结束主循环提到Director中</span></p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">状态初始化放到init中&nbsp;</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>&nbsp;</p>
<p>领域模型</p>
<p style="text-align: center;">图</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>加入Scene和Hash</p>
<p>7-8</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>确定引擎要提炼的类</p>
<p><span style="color: #c0c0c0;">分析领域模型，现在Director依赖于用户的LayerManager！</span></p>
<p><span style="color: #c0c0c0;">现在引擎的Director依赖于用户的LayerManager，这违背了引擎的设计原则。</span></p>
<p>因此，参考引擎的初步领域模型，应该提出引擎的Scene类，使得引擎Director依赖于引擎的Scene。</p>
<p>由于Scene继承于Hash类，因此将Hash也一并提出。</p>
<p><span style="color: #c0c0c0;">现在要提出引擎的LayerManager类&nbsp;</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>分析炸弹人参考模型中对应的类，找出可复用的、通用的部分，将其提炼到引擎类中</p>
<p>引擎的Scene对应炸弹人的LayerManager，引擎Hash对应炸弹人的Hash。</p>
<p>炸弹人Hash是一个独立的类，可直接移到引擎中</p>
<p>炸弹人LayerManager是一个Hash容器类，负责容器元素的管理，没有具体的、跟游戏相关的业务逻辑，因此也是可复用的，可直接移到引擎中。</p>
<p>&nbsp;</p>
<p>引擎Hash</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).Hash =<span style="color: #000000;"> YYC.Class({
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">容器</span>
<span style="color: #000000;">            _childs: {}
        },
        Public: {
            getChilds: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._childs;
            },
            getValue: function (key) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._childs[key];
            },
            add: function (key, value) {
                </span><span style="color: #0000ff;">this</span>._childs[key] =<span style="color: #000000;"> value;
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">;
            }
        }
    });
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>引擎Scene</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {

    </span><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).Scene =<span style="color: #000000;"> YYC.Class(YE.Hash, {
        Private: {
            __iterator: function (handler, args) {
                </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span><span style="color: #000000;">),
                    i </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                    layers </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.getChilds();

                </span><span style="color: #0000ff;">for</span> (i <span style="color: #0000ff;">in</span><span style="color: #000000;"> layers) {
                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (layers.hasOwnProperty(i)) {
                        layers[i][handler].apply(layers[i], args);
                    }
                }
            },
            __getLayers: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.getChilds();
            }
        },
        Public: {
            addLayer: function (name, layer) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.add(name, layer);
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">;
            },
            getLayer: function (name) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.getValue(name);
            },
            addSprites: function (name, elements) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.getLayer(name).addSprites(elements);
            },
            initLayer: function () {
                </span><span style="color: #0000ff;">this</span>.__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">setCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">this</span>.__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">init</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.__getLayers());
            },
            run: function () {
                </span><span style="color: #0000ff;">this</span>.__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">run</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            },
            change: function () {
                </span><span style="color: #0000ff;">this</span>.__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">change</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        }
    });
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>修改引擎类</p>
<p>现在Director依赖于 Scene了，因此应该将layerManager重命名为scene</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">...
            _scene: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

...
            _loopBody: function (time) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._tick(time);

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.onenter();
</span><span style="color: #0000ff;">this</span><span style="color: #000000;">._scene.run();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._scene.change();

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.onexit();
            },
...
            setScene: function (scene) {
                </span><span style="color: #0000ff;">this</span>._scene =<span style="color: #000000;"> scene;
            },
...</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>对应修改炸弹人的类，令其使用提炼出的引擎类</p>
<p>修改Game</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Director =<span style="color: #000000;"> YE.Director,
        director </span>=<span style="color: #000000;"> Director.getInstance();


    </span><span style="color: #0000ff;">var</span> game =<span style="color: #000000;"> {
        scene: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

        sleep: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

        _initScene: function () {
            </span><span style="color: #0000ff;">this</span>.scene = <span style="color: #0000ff;">new</span><span style="color: #000000;"> YE.Scene();
            </span><span style="color: #0000ff;">this</span>.scene.onenter =<span style="color: #000000;"> function () {
            };
            </span><span style="color: #0000ff;">this</span>.scene.onexit =<span style="color: #000000;"> function () {
            };

            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._addLayer();
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._addElements();
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._initLayer();
        },
        _addLayer: function () {
            </span><span style="color: #0000ff;">this</span>.scene.addLayer(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, layerFactory.createMap());
            </span><span style="color: #0000ff;">this</span>.scene.addLayer(<span style="color: #800000;">"</span><span style="color: #800000;">enemyLayer</span><span style="color: #800000;">"</span>, layerFactory.createEnemy(<span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep));
            </span><span style="color: #0000ff;">this</span>.scene.addLayer(<span style="color: #800000;">"</span><span style="color: #800000;">playerLayer</span><span style="color: #800000;">"</span>, layerFactory.createPlayer(<span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep));
            </span><span style="color: #0000ff;">this</span>.scene.addLayer(<span style="color: #800000;">"</span><span style="color: #800000;">bombLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, layerFactory.createBomb());
            </span><span style="color: #0000ff;">this</span>.scene.addLayer(<span style="color: #800000;">"</span><span style="color: #800000;">fireLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, layerFactory.createFire());
        },
        _addElements: function () {
            </span><span style="color: #0000ff;">var</span> mapLayerElements = <span style="color: #0000ff;">this</span><span style="color: #000000;">._createMapLayerElement(),
                playerLayerElements </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._createPlayerLayerElement(),
                enemyLayerElements </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._createEnemyLayerElement();

            </span><span style="color: #0000ff;">this</span>.scene.addSprites(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, mapLayerElements);
            </span><span style="color: #0000ff;">this</span>.scene.addSprites(<span style="color: #800000;">"</span><span style="color: #800000;">playerLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, playerLayerElements);
            </span><span style="color: #0000ff;">this</span>.scene.addSprites(<span style="color: #800000;">"</span><span style="color: #800000;">enemyLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, enemyLayerElements);
        },
<span style="color: #ff0000;">/*</span><br />        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建并设置每个地图方格精灵，加入到元素数组中并返回。</span>
<span style="color: #000000;">        _createMapLayerElement: function () {
            </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                x </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                y </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                row </span>=<span style="color: #000000;"> bomberConfig.map.ROW,
                col </span>=<span style="color: #000000;"> bomberConfig.map.COL,
                element </span>=<span style="color: #000000;"> [],
                mapData </span>=<span style="color: #000000;"> mapDataOperate.getMapData(),
                img </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; row; i++<span style="color: #000000;">) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">注意！
                </span><span style="color: #008000;">//</span><span style="color: #008000;">y为纵向height，x为横向width</span>
                y = i *<span style="color: #000000;"> bomberConfig.HEIGHT;

                </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; col; j++<span style="color: #000000;">) {
                    x </span>= j *<span style="color: #000000;"> bomberConfig.WIDTH;
                    img </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._getMapImg(i, j, mapData);
                    element.push(spriteFactory.createMapElement({ x: x, y: y }, bitmapFactory.createBitmap({ img: img, width: bomberConfig.WIDTH, height: bomberConfig.HEIGHT })));
                }
            }

            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
        },
        _getMapImg: function (i, j, mapData) {
            </span><span style="color: #0000ff;">var</span> img = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (mapData[i][j]) {
                </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">1</span><span style="color: #000000;">:
                    img </span>= window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">2</span><span style="color: #000000;">:
                    img </span>= window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">
            }

            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> img;
        },
        _createPlayerLayerElement: function () {
            </span><span style="color: #0000ff;">var</span> element =<span style="color: #000000;"> [],
                player </span>=<span style="color: #000000;"> spriteFactory.createPlayer();

            player.init();
            element.push(player);

            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
        },
        _createEnemyLayerElement: function () {
            </span><span style="color: #0000ff;">var</span> element =<span style="color: #000000;"> [],
                enemy </span>=<span style="color: #000000;"> spriteFactory.createEnemy(),
                enemy2 </span>=<span style="color: #000000;"> spriteFactory.createEnemy2();

            enemy.init();
            enemy2.init();
            element.push(enemy);
            element.push(enemy2);

            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
        },<br /><span style="color: #ff0000;">*/</span>
        _initLayer: function () {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.scene.initLayer();<br />        },<br /><span style="color: #ff0000;">/*</span>
        _initEvent: function () {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">监听整个document的keydown,keyup事件</span>
<span style="color: #000000;">            keyEventManager.addKeyDown();
            keyEventManager.addKeyUp();
        },
        _judgeGameState: function () {
            </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (window.gameState) {
                </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> window.bomberConfig.game.state.NORAML:
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> window.bomberConfig.game.state.OVER:
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._gameOver();
                    </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">over</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> window.bomberConfig.game.state.WIN:
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._gameWin();
                    </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">over</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">未知的游戏状态</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        },
</span><span style="color: #008000;">//</span><span style="color: #008000;">        _setScene: function () {</span>
<span style="color: #808080;">///</span><span style="color: #008000;">/            window.scene.onexit = function () {
</span><span style="color: #808080;">///</span><span style="color: #008000;">/                this.__iterator("change");
</span><span style="color: #808080;">///</span><span style="color: #008000;">/            }</span>
<span style="color: #008000;">//</span><span style="color: #008000;">        },</span>
<span style="color: #000000;">        _gameOver: function () {
            director.stop();
            alert(</span><span style="color: #800000;">"</span><span style="color: #800000;">Game Over！</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        },
        _gameWin: function () {
            director.stop();
            alert(</span><span style="color: #800000;">"</span><span style="color: #800000;">You Win！</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        }<br /><span style="color: #ff0000;">*/</span>
    };


    director.init </span>=<span style="color: #000000;"> function () {
  <span style="color: #ff0000;">  /*    </span></span><span style="color: #008000;">//</span><span style="color: #008000;">设置间隔时间
        </span><span style="color: #008000;">//</span><span style="color: #008000;">要改成基于时间的运动！</span>
        game.sleep = <span style="color: #800080;">1000</span> / director.getFps();<span style="color: #008000;">//</span><span style="color: #008000;">director.getFps()此时为0!


        </span><span style="color: #008000;">//</span><span style="color: #008000;">游戏全局状态</span>
        window.gameState =<span style="color: #000000;"> window.bomberConfig.game.state.NORAML;

        window.subject </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> YYC.Pattern.Subject();
<span style="color: #ff0000;">*/</span>

        game._initScene();
</span><span style="color: #008000;">//</span><span style="color: #008000;">        game._addElements();
</span><span style="color: #008000;">//</span><span style="color: #008000;">        game._initLayer();</span>
<span style="color: #000000;">        game._initEvent();

        window.subject.subscribe(game.scene.getLayer(</span><span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span>), game.scene.getLayer(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">).changeSpriteImg);


        </span><span style="color: #008000;">//</span><span style="color: #008000;">设置场景</span>
        <span style="color: #0000ff;">this</span><span style="color: #000000;">.setScene(game.scene);
    };
<span style="color: #ff0000;">/*</span>
    director.onenter </span>=<span style="color: #000000;"> function () {
        </span><span style="color: #0000ff;">if</span> (game._judgeGameState() === <span style="color: #800000;">"</span><span style="color: #800000;">over</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
            YE.Global.returnFunc();
        }
    };<span style="color: #ff0000;">*/</span>
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>分析</p>
<p>删除炸弹人LayerManager类，Game改为调用Scene</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">重构&nbsp;</span></p>
<p><span style="color: #c0c0c0;">Scene提出onenter、onexit钩子函数</span></p>
<p><span style="color: #ff0000;">（第二次迭代提出MyScene时，根据需要再提出onenter、onexit钩子函数<span style="color: #c0c0c0;">，同时需要讨论需不需要用户在onexit中调用change，还是引擎Scene在run中调用change</span>）</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">修改LayerManager</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>领域模型</p>
<p>图</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">加入Hash　　?</span></p>
<p><span style="color: #c0c0c0;">7</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>加入Layer和Collection</p>
<p>9-11</p>
<p>&nbsp;</p>
<p>确定引擎要提炼的类</p>
<p>现在就要提炼Layer类。</p>
<p>由于Layer继承于Collection类，因此将Collection也一并提出。</p>
<p>&nbsp;</p>
<p><br />分析炸弹人参考模型中对应的类，找出可复用的、通用的部分，将其提炼到引擎类中</p>
<p>引擎Layer对应炸弹人的Layer，引擎Collection对应炸弹人Collection</p>
<p>炸弹人Collection是一个独立的类，可直接移到引擎中</p>
<p>炸弹人Layer是一个Collection容器类，负责容器元素的管理，没有具体的、跟游戏相关的业务逻辑，因此也是可复用的，可直接移到引擎中。</p>
<p>引擎Layer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">
(function () {
    </span><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).Layer =<span style="color: #000000;"> YYC.AClass(Collection, {
        Init: function () {
        },
        Private: {
            __state: bomberConfig.layer.state.CHANGE,   </span><span style="color: #008000;">//</span><span style="color: #008000;">默认为change</span>
<span style="color: #000000;">
            __getContext: function () {
                </span><span style="color: #0000ff;">this</span>.P__context = <span style="color: #0000ff;">this</span>.P__canvas.getContext(<span style="color: #800000;">"</span><span style="color: #800000;">2d</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        },
        Protected: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">*共用的变量（可读、写）</span>
<span style="color: #000000;">
            P__canvas: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            P__context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">*共用的方法（可读）</span>
<span style="color: #000000;">
            P__isChange: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.__state ===<span style="color: #000000;"> bomberConfig.layer.state.CHANGE;
            },
            P__isNormal: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.__state ===<span style="color: #000000;"> bomberConfig.layer.state.NORMAL;
            },
            P__iterator: function (handler) {
                </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span><span style="color: #000000;">),
                    nextElement </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasNext()) {
                    nextElement </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.next();
                    nextElement[handler].apply(nextElement, args);  </span><span style="color: #008000;">//</span><span style="color: #008000;">要指向nextElement</span>
<span style="color: #000000;">                }
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.resetCursor();
            },
            P__render: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__isChange()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.clear();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.draw();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.setStateNormal();
                }
            }
        },
        Public: {
            remove: function (sprite) {
                </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">(function (e, obj) {
                    </span><span style="color: #0000ff;">if</span> (e.x === obj.x &amp;&amp; e.y ===<span style="color: #000000;"> obj.y) {
                        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }, sprite);
            },
            addSprites: function (elements) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.appendChilds(elements);
            },
            setStateNormal: function () {
                </span><span style="color: #0000ff;">this</span>.__state =<span style="color: #000000;"> bomberConfig.layer.state.NORMAL;
            },
            setStateChange: function () {
                </span><span style="color: #0000ff;">this</span>.__state =<span style="color: #000000;"> bomberConfig.layer.state.CHANGE;
            },
            Virtual: {
                init: function () {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__getContext();
                },
                clear: function (sprite) {
                    </span><span style="color: #0000ff;">if</span> (arguments.length === <span style="color: #800080;">0</span><span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">clear</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
                    }
                    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (arguments.length === <span style="color: #800080;">1</span><span style="color: #000000;">) {
                        sprite.clear(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
                    }
                }
            }
        },
        Abstract: {
            setCanvas: function () {
            },
            change: function () {
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">统一绘制</span>
<span style="color: #000000;">            draw: function () {
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">游戏主线程调用的函数</span>
<span style="color: #000000;">            run: function () {
            }
        }
    });
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>引擎Collecton</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">*使用迭代器模式</span>

    <span style="color: #0000ff;">var</span> IIterator = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">hasNext</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">next</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">resetCursor</span><span style="color: #800000;">"</span><span style="color: #000000;">);


    </span><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).Collection =<span style="color: #000000;"> YYC.AClass({Interface: IIterator}, {
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">当前游标</span>
            _cursor: <span style="color: #800080;">0</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">容器</span>
<span style="color: #000000;">            _childs: []
        },
        Public: {
            getChilds: function () {
                </span><span style="color: #0000ff;">return</span> YE.Tool.array.clone(<span style="color: #0000ff;">this</span><span style="color: #000000;">._childs);
            },
            getChildAt: function (index) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._childs[index];
            },
            appendChild: function (child) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._childs.push(child);

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">;
            },
            appendChilds: function (childs) {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = childs.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.addChild(childs[i]);
                }
            },
            removeAll: function () {
                </span><span style="color: #0000ff;">this</span>._childs =<span style="color: #000000;"> [];
            },
            hasNext: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._cursor === <span style="color: #0000ff;">this</span><span style="color: #000000;">._childs.length) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            },
            next: function () {
                </span><span style="color: #0000ff;">var</span> result = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasNext()) {
                    result </span>= <span style="color: #0000ff;">this</span>._childs[<span style="color: #0000ff;">this</span><span style="color: #000000;">._cursor];
                    </span><span style="color: #0000ff;">this</span>._cursor += <span style="color: #800080;">1</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    result </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
            },
            resetCursor: function () {
                </span><span style="color: #0000ff;">this</span>._cursor = <span style="color: #800080;">0</span><span style="color: #000000;">;
            },
            Virtual: {
                remove: function (func, child) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._childs.remove(func, child);
                }
            }
        },
        Abstract: {
        }
    });
}());</span></pre>
</div>
<p>分析</p>
<p>YE.Tool.array.clone提到Tool中</p>
<p>&nbsp;</p>
<p>Tool</p>
<div class="cnblogs_code">
<pre> <span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE.Tool</span><span style="color: #800000;">"</span>).array =<span style="color: #000000;"> {
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">返回一个新的数组，元素与array相同（地址不同）</span><span style="color: #008000;">*/</span><span style="color: #000000;">
        clone: function (array) {
            </span><span style="color: #0000ff;">var</span> new_array = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Array(array.length);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, _length = array.length; i &lt; _length; i++<span style="color: #000000;">) {
                new_array[i] </span>=<span style="color: #000000;"> array[i];
            }
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> new_array;
        }
    };</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>重构</p>
<p>Collection</p>
<p>Collection重命名appendChild、appendChilds为addChild、addChilds，并对应修改Layer</p>
<p>&nbsp;</p>
<p>Collection</p>
<p> addChild: function (child) {<br />                this._childs.push(child);</p>
<p>                return this;<br />            },<br />            addChilds: function (childs) {<br />                var i = 0,<br />                    len = 0;</p>
<p>                for (i = 0, len = childs.length; i &lt; len; i++) {<br />                    this.addChild(childs[i]);<br />                }<br />            },</p>
<p>&nbsp;</p>
<p>Layer</p>
<p> addSprites: function (elements) {<br />                this.addChilds(elements);<br />            },</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Layer</p>
<p>现在引擎Layer依赖于炸弹人Config的layer.state，因此将state提出来放到引擎Layer中，从而可解除引擎Layer对炸弹人Config的依赖</p>
<p>Layer</p>
<div class="cnblogs_code">
<pre>    <span style="color: #0000ff;">var</span> State =<span style="color: #000000;"> {
        NORMAL: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        CHANGE: </span><span style="color: #800080;">1</span><span style="color: #000000;">
    };

    </span><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).Layer =<span style="color: #000000;"> YYC.AClass(YE.Collection, {
        Init: function () {
        },
        Private: {
            __state: State.CHANGE, </span>
<span style="color: #000000;">...
        Protected: {
... 
            P__isChange: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.__state ===<span style="color: #000000;"> State.CHANGE;
            },
            P__isNormal: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.__state ===<span style="color: #000000;"> State.NORMAL;
            },
...<br /></span></pre>
<p> Public: {<br />...<br />            setStateNormal: function () {<br />                this.__state = State.NORMAL;<br />            },<br />            setStateChange: function () {<br />                this.__state = State.CHANGE;<br />            },</p>
<p><span>...</span></p>









</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">重构后代码</span></p>
<p><span style="color: #c0c0c0;">引擎Collection</span></p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">引擎Layer</span></p>
<p><br /><br /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>对应修改炸弹人的类，令其使用提炼出的引擎类</p>
<p>&nbsp;</p>
<p>思考用户使用引擎的方式：</p>
<p>研究是采用钩子还是继承，找到了用户使用引擎的方法</p>
<p>10</p>
<p>（重点说明什么时候用实例重写，什么时候用继承重写。</p>
<p>至于两者的对比，因为关于委托和继承的讨论已经够多了，因此此处只简要说明跟引擎上下文相关的内容即可）</p>
<p><span style="color: #c0c0c0;">用户可以通过以下三种方法使用引擎类：</span></p>
<p><span style="color: #c0c0c0;">a）直接使用引擎类提供的API。如用户可直接使用YE.EventManager. addListener来监听事件。</span></p>
<p><span style="color: #c0c0c0;">b）继承引擎类，重写钩子方法和虚方法。如用户可重写核心类Scene、Layer、Sprite中的钩子方法onenter等。</span></p>
<p><span style="color: #c0c0c0;">c）使用引擎类实例，并重写其钩子方法。如用户可使用LoaderManager的preload方法来加载资源，重写其钩子方法onloading、onload。</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">我研究了Cocos2D-html5、lufylegend、EaselJS以及《Html5 Canvas核心技术》中的游戏引擎，Cocos2D-html5、lufylegend采用继承重写，EaselJS、《Html5 Canvas核心技术》采用实例重写。</span></p>
<p>因此，有两种方式：</p>
<p>实例重写</p>
<p>继承重写</p>
<p>&nbsp;</p>
<p>实例重写：</p>
<p>使用引擎类实例，重写其钩子方法，引擎内部调用钩子，从而插入用户的实现的逻辑</p>
<p>&nbsp;</p>
<p>继承重写：</p>
<p>将被重写的引擎类的钩子成员设成Abstract，可被扩展的方法设成Virtual</p>
<p>被重写的引擎类提供基本框架（使用模板模式）、基本方法和属性</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>实例重写和继承重写的比较：</p>
<p>实质就是比较委托和继承</p>
<p>&nbsp;</p>
<p>共同点</p>
<p>1、都是单向关联，用户类依赖于引擎类。用户类的变化不会影响到引擎类</p>
<p>图（用户类依赖于引擎类）</p>
<p>2、都提供了供用户重写的钩子方法，可插入用户的逻辑</p>
<p>&nbsp;</p>
<p>实例重写优点：</p>
<p>用户类与引擎类的关联性较弱，用户类只使用引擎的钩子，不会受到引擎整体结构变化的影响</p>
<p>&nbsp;</p>
<p>继承重写的优点：</p>
<p>父类和子类代码共享，提高代码的重用性。&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;/*</p>
<p><span style="color: #ff0000;">参考下面资料修改！</span></p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="234">
<p>合 关 系</p>




</td>
<td valign="top" width="244">
<p>继 承 关 系</p>




</td>




</tr>
<tr>
<td valign="top" width="234">
<p>优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立</p>




</td>
<td valign="top" width="244">
<p>缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性</p>




</td>




</tr>
<tr>
<td valign="top" width="234">
<p>优点：具有较好的可扩展性</p>




</td>
<td valign="top" width="244">
<p>缺点：支持扩展，但是往往以增加系统结构的复杂度为代价</p>




</td>




</tr>
<tr>
<td valign="top" width="234">
<p>优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象</p>




</td>
<td valign="top" width="244">
<p>缺点：不支持动态继承。在运行时，子类无法选择不同的父类</p>




</td>




</tr>
<tr>
<td valign="top" width="234">
<p>优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口</p>




</td>
<td valign="top" width="244">
<p>缺点：子类不能改变父类的接口</p>




</td>




</tr>
<tr>
<td valign="top" width="234">
<p>缺点：整体类不能自动获得和局部类同样的接口</p>




</td>
<td valign="top" width="244">
<p>优点：子类能自动继承父类的接口</p>




</td>




</tr>
<tr>
<td valign="top" width="234">
<p>缺点：创建整体类的对象时，需要创建所有局部类的对象</p>




</td>
<td valign="top" width="244">
<p>优点：创建子类的对象时，无须创建父类的对象</p>




</td>




</tr>




</tbody>




</table>
<p>&nbsp;</p>
<p>三、如何使用继承</p>
<p>&nbsp;</p>
<p>1、精心设计专门用于被继承的类，继承树的抽象层应该比较稳定，一般不要多于三层。</p>
<p>2、对于不是专门用于被继承的类，禁止其被继承。</p>
<p>3、优先考虑用组合关系来提高代码的可重用性。</p>
<p>4、子类是一种特殊的类型，而不只是父类的一个角色</p>
<p>5、子类扩展，而不是覆盖或者使父类的功能失效</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>四、组合的缺点：</p>
<p>1、整体类不能自动获得和局部类同样的接口</p>
<p>如果父类的方法子类中几乎都要暴露出去，这时可能会觉得使用组合很不方便，使用继承似乎更简单方便。但从另一个角度讲，实际上也许子类中并不需要暴露这些方法，客户端组合应用就可以了。所以上边推荐不要继承那些不是为了继承而设计的类，一般为了继承而设计的类都是抽象类。</p>
<p>2、创建整体类的对象时，需要创建所有局部类的对象</p>
<p>这个可能没什么更好的办法，但在实际应用中并没有多出多少代码。</p>
<p>&nbsp;*/</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>什么时候用实例重写</p>
<p>use a关系，即用户类只需要使用引擎类部分功能时，可以用实例重写。</p>
<p>什么时候用继承重写</p>
<p>is a关系，即用户类与引擎类同属于一个概念时，可以用继承重写。</p>
<p>引擎类是精心设计专门用于被继承的类时，可以用继承重写</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">对Main和Director分析：</span></p>
<p><span style="color: #c0c0c0;">Main&nbsp;</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>本文选用的方式：</p>
<p>因为Main和Director是从炸弹人Main、Game中提出来的，炸弹人Main、Game本身为单例，并不是设计为可被继承的类，</p>
<p>所以Main、Director采用实例重写的方式，</p>
<p>&nbsp;</p>
<p>（引擎Scene不能重写）</p>
<p>&nbsp;</p>
<p>Layer和后面的Sprite是从炸弹人Layer、Sprite中提出来的，炸弹人Layer、Sprite都是抽象基类，本身就是可被继承的类，</p>
<p>所以Layer和Sprite采用继承重写的方式。</p>
<p>&nbsp;</p>
<p>其它引擎类不能被重写，引擎或用户直接使用。</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">在第二次迭代中我会再来修改Main和Director的重写方式。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>此处Layer应该采用继承重写，因此修改炸弹人具体Layer类，使其继承于引擎Layer</p>
<p>炸弹人BombLayer、CharacterLayer、FireLayer、MapLayer、PlayerLayer修改</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> BombLayer =<span style="color: #000000;"> YYC.Class(YE.Layer, {
...

</span><span style="color: #0000ff;">var</span> CharacterLayer =<span style="color: #000000;"> YYC.Class(YE.Layer, {
...

</span><span style="color: #0000ff;">var</span> FireLayer =<span style="color: #000000;"> YYC.Class(YE.Layer, {
...

</span><span style="color: #0000ff;">var</span> MapLayer =<span style="color: #000000;"> YYC.Class(YE.Layer, {
...

</span><span style="color: #0000ff;">var</span> PlayerLayer =<span style="color: #000000;"> YYC.Class(YE.Layer, {
...</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">修改Game</span></p>
<p><br /><br /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>领域模型</p>
<p>图&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">加入Collection</span></p>
<p><span style="color: #c0c0c0;">9</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">加入jsExtend.js　　修改</span></p>
<p><span style="color: #c0c0c0;">9</span></p>
<p><span style="color: #c0c0c0;"><span style="color: #ff0000;">不加入jsExtend，将其作为依赖库</span>&nbsp;</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">重构Layer</span></p>
<p><span style="color: #c0c0c0;">11</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>加入Sprite、Config、collision.js</p>
<p>12-13</p>
<p>&nbsp;</p>
<p>确定引擎要提炼的类</p>
<p>现在提炼Sprite类</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><br />分析炸弹人参考模型中对应的类，找出可复用的、通用的部分，将其提炼到引擎类中</p>
<p>引擎Sprite对应炸弹人的Sprite基类</p>
<p>炸弹人Sprite作为精灵类的基类，放置了炸弹人具体精灵类的共性，因此具备通用性，将其直接移到引擎中。</p>
<p>引擎Sprite</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Sprite =<span style="color: #000000;"> YYC.AClass({
        Init: function (data, bitmap) {
            </span><span style="color: #0000ff;">this</span>.bitmap =<span style="color: #000000;"> bitmap;

            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (data) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">初始坐标</span>
                <span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
                </span><span style="color: #0000ff;">this</span>.y =<span style="color: #000000;"> data.y;

                </span><span style="color: #0000ff;">this</span>.defaultAnimId =<span style="color: #000000;"> data.defaultAnimId;
                </span><span style="color: #0000ff;">this</span>.anims =<span style="color: #000000;"> data.anims;
            }
        },
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">更新帧动画</span>
<span style="color: #000000;">            _updateFrame: function (deltaTime) {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.update(deltaTime);
                }
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">bitmap实例</span>
            bitmap: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标</span>
            x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵包含的所有 Animation 集合. Object类型, 数据存放方式为" id : animation ".</span>
            anims: <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">默认的Animation的Id , string类型</span>
            defaultAnimId: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">当前的Animation.</span>
            currentAnim: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation, 参数为Animation的id, String类型</span>
<span style="color: #000000;">            setAnim: function (animId) {
                </span><span style="color: #0000ff;">this</span>.currentAnim = <span style="color: #0000ff;">this</span><span style="color: #000000;">.anims[animId];
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">重置当前帧</span>
<span style="color: #000000;">            resetCurrentFrame: function (index) {
                </span><span style="color: #0000ff;">this</span>.currentAnim &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.setCurrentFrame(index);
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">取得精灵的碰撞区域,</span>
<span style="color: #000000;">            getCollideRect: function () {
                </span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
                    x: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.x,
                    y: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.y,
                    width: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.width,
                    height: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.height
                };

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> YYC.Tool.collision.getCollideRect(obj);
            },
            Virtual: {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">初始化方法</span>
<span style="color: #000000;">                init: function () {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation</span>
                    <span style="color: #0000ff;">this</span>.setAnim(<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId);
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新精灵当前状态.</span>
<span style="color: #000000;">                update: function (deltaTime) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._updateFrame(deltaTime);
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">获得坐标对应的方格坐标（向下取值）</span>
<span style="color: #000000;">                getCellPosition: function (x, y) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                        x: Math.floor(x </span>/<span style="color: #000000;"> bomberConfig.WIDTH),
                        y: Math.floor(y </span>/<span style="color: #000000;"> bomberConfig.HEIGHT)
                    }
                },
                draw: function (context) {
                    context.drawImage(</span><span style="color: #0000ff;">this</span>.bitmap.img, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span>.y, <span style="color: #0000ff;">this</span>.bitmap.width, <span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.height);
                },
                clear: function (context) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">直接清空画布区域</span>
                    context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
                }
            }
        }
    });

    window.Sprite </span>=<span style="color: #000000;"> Sprite;
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>分析</p>
<p>提出Config&nbsp;</p>
<p>1、引擎Sprite引用了炸弹人Config的方格大小和画布大小</p>
<p>2、方格大小和画布大小具有通用性，不应该放在Sprite中</p>
<p>因此，引擎提出Config配置类，将方格大小和画布大小放在其中。</p>
<p>Config</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).Config =<span style="color: #000000;"> {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">方格宽度</span>
    WIDTH: <span style="color: #800080;">30</span><span style="color: #000000;">,
    </span><span style="color: #008000;">//</span><span style="color: #008000;">方格高度</span>
    HEIGHT: <span style="color: #800080;">30</span><span style="color: #000000;">,

    </span><span style="color: #008000;">//</span><span style="color: #008000;">画布</span>
<span style="color: #000000;">    canvas: {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">画布宽度</span>
        WIDTH: <span style="color: #800080;">600</span><span style="color: #000000;">,
        </span><span style="color: #008000;">//</span><span style="color: #008000;">画布高度</span>
        HEIGHT: <span style="color: #800080;">600</span><span style="color: #000000;">,
        </span><span style="color: #008000;">//</span><span style="color: #008000;">定位坐标</span>
        TOP: <span style="color: #800000;">"</span><span style="color: #800000;">0px</span><span style="color: #800000;">"</span><span style="color: #000000;">,
        LEFT: </span><span style="color: #800000;">"</span><span style="color: #800000;">0px</span><span style="color: #800000;">"</span><span style="color: #000000;">
    }</span></pre>
</div>
<p>&nbsp;</p>
<p>对应修改引擎Sprite</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">getCellPosition: function (x, y) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                        x: Math.floor(x </span>/<span style="color: #000000;"> YE.Config.WIDTH),
                        y: Math.floor(y </span>/<span style="color: #000000;"> YE.Config.HEIGHT)
                    }
                },
...
                clear: function (context) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">直接清空画布区域</span>
                    context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, YE.Config.canvas.WIDTH, YE.Config.canvas.HEIGHT);
                }</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>提出collision.js</p>
<p>12</p>
<p>Sprite还使用了YTool的collision-&gt;getCollideRect来获得碰撞区域</p>
<p>考虑到碰撞的相关算法具有通用性，因此也将其提到引擎中，形成collision.js</p>
<p>collision：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).collision =<span style="color: #000000;"> (function () {
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获得精灵的碰撞区域,</span>
<span style="color: #000000;">        getCollideRect: function (obj) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                x1: obj.x,
                y1: obj.y,
                x2: obj.x </span>+<span style="color: #000000;"> obj.width,
                y2: obj.y </span>+<span style="color: #000000;"> obj.height
            }
        },
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
         *矩形和矩形间的碰撞
         *</span><span style="color: #008000;">*/</span><span style="color: #000000;">
        col_Between_Rects: function (obj1, obj2) {
            </span><span style="color: #0000ff;">var</span> rect1 = <span style="color: #0000ff;">this</span><span style="color: #000000;">.getCollideRect(obj1);
            </span><span style="color: #0000ff;">var</span> rect2 = <span style="color: #0000ff;">this</span><span style="color: #000000;">.getCollideRect(obj2);

            </span><span style="color: #008000;">//</span><span style="color: #008000;">如果碰撞，则返回true</span>
            <span style="color: #0000ff;">if</span> (rect1 &amp;&amp; rect2 &amp;&amp; !(rect1.x1 &gt;= rect2.x2 || rect1.y1 &gt;= rect2.y2 || rect1.x2 &lt;= rect2.x1 || rect1.y2 &lt;=<span style="color: #000000;"> rect2.y1)) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
    };
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>对应修改炸弹人的类，令其使用提炼出的引擎类</p>
<p>Sprite也采用继承重写的方式复用，对应修改炸弹人的具体精灵类BombSprite、FireSprite、MapElementSprite、MoveSprite，使其继承YE.Sprite</p>
<p>代码略</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>炸弹人仍然保留Config类</p>
<p>只将引擎依赖的炸弹人Config的成员移到引擎Config类中，炸弹人的类仍然依赖于炸弹人的Config，而不是依赖于引擎的Config</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>炸弹人修改为依赖于引擎的collision</p>
<p>15</p>
<p><span style="color: #c0c0c0;">BombSprite</span></p>
<p><span style="color: #c0c0c0;">if (YE.collision.col_Between_Rects(fire, obj2)) {</span><br /><span style="color: #c0c0c0;">                        return true;</span><br /><span style="color: #c0c0c0;">                    }</span></p>
<p><span style="color: #c0c0c0;">EnemySprite</span></p>
<p><span style="color: #c0c0c0;"> if (YE.collision.col_Between_Rects(obj1, obj2)) {</span><br /><span style="color: #c0c0c0;">                    throw new Error();</span><br /><span style="color: #c0c0c0;">                }</span></p>
<p>&nbsp;</p>
<p>领域模型</p>
<p>图</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>提出Factory（提出create方法，与提出工厂类进行比较）</p>
<p>55</p>
<p>按照&ldquo;引擎初步的领域模型&rdquo;，在提炼完Sprite后，就要提炼Factory工厂类了。</p>
<p>有两个问题需要分析：</p>
<p>1、范围</p>
<p>哪些引擎类需要工厂。</p>
<p>2、实现</p>
<p>如何实现工厂。</p>
<p>&nbsp;</p>
<p>对于第1个问题，我认为抽象类不需要工厂，其它的普通类Class都统一用工厂。</p>
<p>&nbsp;</p>
<p>对于第2个问题，有以下两个选择：</p>
<p>1、与炸弹人一样，提出LayerFactory、SpriteFactory，负责创建Layer、Sprite的实例</p>
<p>2、直接在Class中提出create静态方法，负责创建自身的实例</p>
<p>&nbsp;</p>
<p>考虑到工厂只需要负责创建实例，不会有太多复杂的逻辑，因此采用第2个选择。&nbsp;</p>
<p>&nbsp;</p>
<p>修改引擎类</p>
<p>ImgLoader增加create方法</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">    Static: {
        create: function(){
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> this();
        }
    }</span></pre>
</div>
<p>&nbsp;</p>
<p>对应修改引擎Main</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">            getInstance: function () {
                </span><span style="color: #0000ff;">if</span> (_instance === <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                    _instance </span>= <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">();
                    _instance.imgLoader </span>=<span style="color: #000000;"> YE.ImgLoader.create();
                }
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> _instance;
            },</span></pre>
</div>
<p>&nbsp;</p>
<p>提出Animation</p>
<p>12-13</p>
<p>确定引擎要提炼的类</p>
<p>提炼Animation</p>
<p><br />分析炸弹人参考模型中对应的类，找出可复用的、通用的部分，将其提炼到引擎类中</p>
<p>对应炸弹人Animation类，该类负责帧动画的控制，具有通用性，因此将其移到引擎中&nbsp;</p>
<p>Animation</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).Animation =<span style="color: #000000;"> YYC.Class({
        Init: function (config) {
            </span><span style="color: #0000ff;">this</span>._frames =<span style="color: #000000;"> YE.Tool.array.clone(config);
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._init();
        },
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Animation 包含的Frame, 类型:数组</span>
            _frames: <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 包含的Frame数目</span>
            _frameCount: -<span style="color: #800080;">1</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 所使用的图片id(在ImgCache中存放的Key), 字符串类型. </span>
            _img: <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            _currentFrame: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            _currentFrameIndex: </span>-<span style="color: #800080;">1</span><span style="color: #000000;">,
            _currentFramePlayed: </span>-<span style="color: #800080;">1</span><span style="color: #000000;">,

            _init: function () {
                </span><span style="color: #0000ff;">this</span>._frameCount = <span style="color: #0000ff;">this</span><span style="color: #000000;">._frames.length;

                </span><span style="color: #0000ff;">this</span>.setCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
            }
        },
        Public: {
            setCurrentFrame: function (index) {
                </span><span style="color: #0000ff;">this</span>._currentFrameIndex =<span style="color: #000000;"> index;
                </span><span style="color: #0000ff;">this</span>._currentFrame = <span style="color: #0000ff;">this</span><span style="color: #000000;">._frames[index];
                </span><span style="color: #0000ff;">this</span>._currentFramePlayed = <span style="color: #800080;">0</span><span style="color: #000000;">;
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新Animation状态. deltaTime表示时间的变化量.</span>
<span style="color: #000000;">            update: function (deltaTime) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">如果没有duration属性（表示只有一帧），则返回</span>
                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._currentFrame.duration ===<span style="color: #000000;"> undefined) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #008000;">//</span><span style="color: #008000;">判断当前Frame是否已经播放完成, </span>
                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._currentFramePlayed &gt;= <span style="color: #0000ff;">this</span><span style="color: #000000;">._currentFrame.duration) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">播放下一帧</span>

                    <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._currentFrameIndex &gt;= <span style="color: #0000ff;">this</span>._frameCount - <span style="color: #800080;">1</span><span style="color: #000000;">) {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">当前是最后一帧,则播放第0帧</span>
                        <span style="color: #0000ff;">this</span>._currentFrameIndex = <span style="color: #800080;">0</span><span style="color: #000000;">;
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">播放下一帧</span>
                        <span style="color: #0000ff;">this</span>._currentFrameIndex++<span style="color: #000000;">;
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前帧信息</span>
                    <span style="color: #0000ff;">this</span>.setCurrentFrame(<span style="color: #0000ff;">this</span><span style="color: #000000;">._currentFrameIndex);

                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">增加当前帧的已播放时间.</span>
                    <span style="color: #0000ff;">this</span>._currentFramePlayed +=<span style="color: #000000;"> deltaTime;
                }
            },
            getCurrentFrame: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._currentFrame;
            }
        },<br /></span></pre>
<p> Static: {<br />        create: function(){<br />            return new this();<br />        }<br />    }</p>
<pre><span style="color: #000000;">
    });
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>分析</p>
<p>&nbsp;</p>
<p>重构</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>对应修改炸弹人的类，令其使用提炼出的引擎类</p>
<p>修改炸弹人SpriteData</p>
<p>删除炸弹人的Animation类，直接使用引擎的Animation</p>
<p>需要对应修改炸弹人SpriteData</p>
<p>sprite-&gt;data.js</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">                    anims: {
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span>: YE.Animation.create(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span>: YE.Animation.create(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span>: YE.Animation.create(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span>: YE.Animation.create(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span>: YE.Animation.create(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span>: YE.Animation.create(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span>: YE.Animation.create(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span>: YE.Animation.create(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">))
                    }</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>领域模型</p>
<p>图</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>加入AStar</p>
<p>15</p>
<p>确定引擎要提炼的类</p>
<p>现在该提炼AI类了</p>
<p>&nbsp;</p>
<p><br />分析炸弹人参考模型中对应的类，找出可复用的、通用的部分，将其提炼到引擎类中</p>
<p>炸弹人中由FindPath类负责实现A*寻路算法，A*寻找算法属于通用的人工智能，因此应该将炸弹人的FindPath提到引擎中，并重命名为更为通用的名字AStar</p>
<p>引擎AStar<span style="color: #888888;"><br /></span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> pass = <span style="color: #800080;">0</span><span style="color: #000000;">,
        stop </span>= <span style="color: #800080;">1</span><span style="color: #000000;">,
        DIRECTION </span>= <span style="color: #800080;">4</span>;  <span style="color: #008000;">//</span><span style="color: #008000;">默认为4方向寻路</span>

    <span style="color: #0000ff;">var</span> arr_map =<span style="color: #000000;"> [],
        open_list </span>= [], <span style="color: #008000;">//</span><span style="color: #008000;">创建OpenList</span>
        close_list = [], <span style="color: #008000;">//</span><span style="color: #008000;">创建CloseList</span>
        map_w = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    function aCompute(mapData, begin, end) {
        </span><span style="color: #0000ff;">var</span> startTime = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            endTime </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            d </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Date(),
            time </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            beginx </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            beginy </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            endx </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            endy </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            arr_path_out </span>=<span style="color: #000000;"> [],
            arr_path </span>=<span style="color: #000000;"> [],
            stopn </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
            tmp </span>=<span style="color: #000000;"> [],

            startTime </span>=<span style="color: #000000;"> d.getTime();


        </span><span style="color: #008000;">/*</span><span style="color: #008000;">*******************函数主体部分************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
        map_w </span>=<span style="color: #000000;"> mapData.length;
        arr_map </span>=<span style="color: #000000;"> setMap(mapData);
        beginx </span>= begin[<span style="color: #800080;">0</span><span style="color: #000000;">];
        beginy </span>= map_w - <span style="color: #800080;">1</span> - begin[<span style="color: #800080;">1</span><span style="color: #000000;">];
        endx </span>= end[<span style="color: #800080;">0</span><span style="color: #000000;">];
        endy </span>= map_w - <span style="color: #800080;">1</span> - end[<span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">var</span> startNodeNum =<span style="color: #000000;"> tile_num(beginx, beginy);
        </span><span style="color: #0000ff;">var</span> targetNodeNum =<span style="color: #000000;"> tile_num(endx, endy);

        </span><span style="color: #0000ff;">if</span> (arr_map[targetNodeNum] &amp;&amp; arr_map[targetNodeNum][<span style="color: #800080;">0</span>] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
</span><span style="color: #008000;">//</span><span style="color: #008000;">            showError("目的地无法到达");</span>
            time =<span style="color: #000000;"> getTime(startTime);
            </span><span style="color: #0000ff;">return</span> { path: [], time: time, info: <span style="color: #800000;">"</span><span style="color: #800000;">目的地无法到达</span><span style="color: #800000;">"</span><span style="color: #000000;"> };
        }
        </span><span style="color: #0000ff;">if</span> (arr_map[startNodeNum][<span style="color: #800080;">0</span>] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
</span><span style="color: #008000;">//</span><span style="color: #008000;">            showError("起始点不可用");</span>
            time =<span style="color: #000000;"> getTime(startTime);
            </span><span style="color: #0000ff;">return</span> { path: [], time: time, info: <span style="color: #800000;">"</span><span style="color: #800000;">起始点不可用</span><span style="color: #800000;">"</span><span style="color: #000000;"> };
        }

        </span><span style="color: #0000ff;">if</span> (arr_map[targetNodeNum] &amp;&amp; arr_map[targetNodeNum][<span style="color: #800080;">0</span>] * arr_map[startNodeNum][<span style="color: #800080;">0</span>] == <span style="color: #800080;">1</span><span style="color: #000000;">) {
            arr_map[startNodeNum] </span>= [arr_map[startNodeNum][<span style="color: #800080;">0</span>], startNodeNum, arr_map[startNodeNum][<span style="color: #800080;">2</span>], arr_map[startNodeNum][<span style="color: #800080;">3</span>], arr_map[startNodeNum][<span style="color: #800080;">4</span>]];<span style="color: #008000;">//</span><span style="color: #008000;">起始点的父节点为自己</span>
<span style="color: #000000;">            setH(targetNodeNum);
            setOpenList(startNodeNum); </span><span style="color: #008000;">//</span><span style="color: #008000;">把开始节点加入到openlist中
            </span><span style="color: #008000;">//</span><span style="color: #008000;">就要开始那个令人发指的循环了，==！！A*算法主体</span>

            <span style="color: #0000ff;">while</span> (open_list.length != <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">var</span> bestNodeNum =<span style="color: #000000;"> selectFmin(open_list);
                stopn </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                open_list.shift();
                setCloseList(bestNodeNum);

                </span><span style="color: #0000ff;">if</span> (bestNodeNum ==<span style="color: #000000;"> targetNodeNum) {
                    showPath(close_list, arr_path, arr_path_out);
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #008000;">//</span><span style="color: #008000;">当目标为孤岛时的判断</span>
                <span style="color: #0000ff;">var</span> tmp0 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Array();
                </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> k;
                tmp0 </span>=<span style="color: #000000;"> setSuccessorNode(targetNodeNum, map_w);
                </span><span style="color: #0000ff;">for</span> (j; j &lt; <span style="color: #800080;">9</span>; j++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (j == <span style="color: #800080;">8</span><span style="color: #000000;">) {
                        k </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #0000ff;">if</span> (tmp0[j][<span style="color: #800080;">0</span>] == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                        k </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    }
                }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">当目标为孤岛时的判断语句结束</span>
                <span style="color: #0000ff;">if</span> (k == <span style="color: #800080;">0</span><span style="color: #000000;">) {
</span><span style="color: #008000;">//</span><span style="color: #008000;">                    showError("目标成孤岛!");</span>
                    time =<span style="color: #000000;"> getTime(startTime);
                    </span><span style="color: #0000ff;">return</span> { path: [], time: time, info: <span style="color: #800000;">"</span><span style="color: #800000;">目标成孤岛</span><span style="color: #800000;">"</span><span style="color: #000000;">  };
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    tmp </span>=<span style="color: #000000;"> setSuccessorNode(bestNodeNum, map_w);
                    </span><span style="color: #0000ff;">for</span> (i; i &lt; <span style="color: #800080;">8</span>; i++<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">if</span> ((tmp[i][<span style="color: #800080;">0</span>] == <span style="color: #800080;">0</span>) || (findInCloseList(tmp[i][<span style="color: #800080;">4</span>]))) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;

                        </span><span style="color: #0000ff;">if</span> (findInOpenList(tmp[i][<span style="color: #800080;">4</span>]) == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                            </span><span style="color: #0000ff;">if</span> (tmp[i][<span style="color: #800080;">2</span>] &gt;= (arr_map[bestNodeNum][<span style="color: #800080;">2</span>] +<span style="color: #000000;"> cost(tmp[i], bestNodeNum))) {
                                setG(tmp[i][</span><span style="color: #800080;">4</span>], bestNodeNum); <span style="color: #008000;">//</span><span style="color: #008000;">算g值，修改arr_map中[2]的值</span>
                                arr_map[tmp[i][<span style="color: #800080;">4</span>]] = tmp[i] = [arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">0</span>], bestNodeNum, arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">2</span>], arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">3</span>], arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">4</span>]]; <span style="color: #008000;">//</span><span style="color: #008000;">修改tmp和arr_map中父节点的值，并修改tmp中g值，是之和arr_map中对应节点的值统一</span>
<span style="color: #000000;">                            }
                        }
                        </span><span style="color: #0000ff;">if</span> (findInOpenList(tmp[i][<span style="color: #800080;">4</span>]) == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                            setG(tmp[i][</span><span style="color: #800080;">4</span>], bestNodeNum); <span style="color: #008000;">//</span><span style="color: #008000;">算g值，修改arr_map中[2]的值</span>
                            arr_map[tmp[i][<span style="color: #800080;">4</span>]] = tmp[i] = [arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">0</span>], bestNodeNum, arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">2</span>], arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">3</span>], arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">4</span>]]; <span style="color: #008000;">//</span><span style="color: #008000;">修改tmp和arr_map中父节点的值，并修改tmp中g值，是之和arr_map中对应节点的值统一</span>
                            setOpenList(tmp[i][<span style="color: #800080;">4</span>]); <span style="color: #008000;">//</span><span style="color: #008000;">存进openlist中</span>
<span style="color: #000000;">
                        }
                    }
                }

                stopn</span>++<span style="color: #000000;">;
                </span><span style="color: #008000;">//</span><span style="color: #008000;">if (stopn == map_w * map_w - 1) {     </span><span style="color: #008000;">//</span><span style="color: #008000;">2013.5.27修改</span>
                <span style="color: #0000ff;">if</span> (stopn == map_w * map_w * <span style="color: #800080;">1000</span><span style="color: #000000;">) {
</span><span style="color: #008000;">//</span><span style="color: #008000;">                    showError("找不到路径!");</span>
                    time =<span style="color: #000000;"> getTime(startTime);
                    </span><span style="color: #0000ff;">return</span> { path: [], time: time, info: <span style="color: #800000;">"</span><span style="color: #800000;">找不到路径</span><span style="color: #800000;">"</span><span style="color: #000000;">  };

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">                break;</span>
<span style="color: #000000;">                }
            }


            </span><span style="color: #0000ff;">if</span> (open_list.length == <span style="color: #800080;">0</span> &amp;&amp; bestNodeNum !=<span style="color: #000000;"> targetNodeNum) {
</span><span style="color: #008000;">//</span><span style="color: #008000;">                showError("没有找到路径！！");   </span><span style="color: #008000;">//</span><span style="color: #008000;">对于那种找不到路径的点的处理</span>
                time =<span style="color: #000000;"> getTime(startTime);
                </span><span style="color: #0000ff;">return</span> { path: [], time: time, info: <span style="color: #800000;">"</span><span style="color: #800000;">找不到路径</span><span style="color: #800000;">"</span><span style="color: #000000;"> };
            }
        }

        time </span>=<span style="color: #000000;"> getTime(startTime);

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> { path: arr_path_out, time: time };

    }

    function getTime(startTime) {
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">**显示运行时间*******</span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">var</span> endTime = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Date().getTime();
        </span><span style="color: #0000ff;">return</span> (endTime - startTime) / <span style="color: #800080;">1000</span><span style="color: #000000;">;
    };


    function showError(error) {
        console.log(error);
    };


    </span><span style="color: #008000;">/*</span><span style="color: #008000;">*********************************************************************
     *function setMap(n)
     *功能：把外部的地图数据抽象成该算法中可操作数组的形式来输入算法
     *参数：n为地图的宽度，生成方阵地图
     ***********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function setMap(mapData) {
</span><span style="color: #008000;">//</span><span style="color: #008000;">        var map_w = mapData.length;</span>
        <span style="color: #0000ff;">var</span> m = map_w *<span style="color: #000000;"> map_w;

        </span><span style="color: #0000ff;">var</span> arr_map0 = <span style="color: #0000ff;">new</span> Array(); <span style="color: #008000;">//</span><span style="color: #008000;">该函数对地图数据转换的操作数组</span>
        <span style="color: #0000ff;">var</span> a = m - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (a; a &gt;= <span style="color: #800080;">0</span>; a--<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">var</span> xTmp = tile_x(a); <span style="color: #008000;">//</span><span style="color: #008000;">把ID 编号值转换为x坐标值，用来对应读入地图数据</span>
            <span style="color: #0000ff;">var</span> yTmp = map_w - <span style="color: #800080;">1</span> - tile_y(a); <span style="color: #008000;">//</span><span style="color: #008000;">把ID 编号值转换为y坐标值，用来对应读入地图数据,对应数组标号和我自定义xoy坐标位置

            </span><span style="color: #008000;">//</span><span style="color: #008000;">[cost,parent,g,h,id]</span>
            <span style="color: #0000ff;">if</span> (mapData[yTmp][xTmp] ==<span style="color: #000000;"> pass)
                arr_map0[a] </span>= [<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, a];
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
                arr_map0[a] </span>= [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, a];


        }

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> arr_map0;
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">********************************************************************
     *以下三个函数是地图上的编号与数组索引转换
     *function tile_num(x,y)
     *功能：将 x,y 坐标转换为地图上块的编号
     *function tile_x(n)
     *功能：由块编号得出 x 坐标
     *function tile_y(n)
     *功能：由块编号得出 y 坐标
     *****************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function tile_num(x, y) {
        </span><span style="color: #0000ff;">return</span> ((y) * map_w +<span style="color: #000000;"> (x));
    }

    function tile_x(n) {
        </span><span style="color: #0000ff;">return</span> (parseInt((n) %<span style="color: #000000;"> map_w));
    }

    function tile_y(n) {
        </span><span style="color: #0000ff;">return</span> (parseInt((n) /<span style="color: #000000;"> map_w));
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">********************************************************************
     *function setH(targetNode)
     *功能：初始化所有点H的值
     *参数：targetNode目标节点
     *********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function setH(targetNode) {

        </span><span style="color: #0000ff;">var</span> x0 =<span style="color: #000000;"> tile_x(targetNode);
        </span><span style="color: #0000ff;">var</span> y0 =<span style="color: #000000;"> tile_y(targetNode);
        </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (i; i &lt; arr_map.length; i++<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">var</span> x1 =<span style="color: #000000;"> tile_x(i);
            </span><span style="color: #0000ff;">var</span> y1 =<span style="color: #000000;"> tile_y(i);
            </span><span style="color: #008000;">/*</span><span style="color: #008000;">****欧几里德距离*******************************</span><span style="color: #008000;">*/</span>
            <span style="color: #008000;">//</span><span style="color: #008000;"> var h = (Math.sqrt((parseInt(x0) - parseInt(x1)) * (parseInt(x0) - parseInt(x1))) + Math.sqrt((parseInt(y0) - parseInt(y1)) * (parseInt(y0) - parseInt(y1))));</span>
            <span style="color: #008000;">/*</span><span style="color: #008000;">****对角线距离*******************************</span><span style="color: #008000;">*/</span>
            <span style="color: #0000ff;">var</span> h = Math.max(Math.abs(parseInt(x0) - parseInt(x1)), Math.abs(parseInt(y0) -<span style="color: #000000;"> parseInt(y1)));
            </span><span style="color: #008000;">/*</span><span style="color: #008000;">****曼哈顿距离*******************************</span><span style="color: #008000;">*/</span>
                <span style="color: #008000;">//</span><span style="color: #008000;"> var h=Math.abs(parseInt(x0) - parseInt(x1))+Math.abs(parseInt(y0) - parseInt(y1));</span>
            arr_map[i][<span style="color: #800080;">3</span>] = h * parseInt(<span style="color: #800080;">10</span><span style="color: #000000;">);
        }
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">********************************************************************
     *function setG(nowNode,bestNode)
     *功能：计算现节点G的值
     *参数：nowNode现节点，bestNode其父节点
     *********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function setG(nowNode, bestNode) {
        </span><span style="color: #0000ff;">var</span> x0 =<span style="color: #000000;"> tile_x(bestNode);
        </span><span style="color: #0000ff;">var</span> y0 =<span style="color: #000000;"> tile_y(bestNode);
        </span><span style="color: #0000ff;">var</span> x1 =<span style="color: #000000;"> tile_x(nowNode);
        </span><span style="color: #0000ff;">var</span> y1 =<span style="color: #000000;"> tile_y(nowNode);
        </span><span style="color: #0000ff;">if</span> (((x0 - x1) == <span style="color: #800080;">0</span>) || ((y0 - y1) == <span style="color: #800080;">0</span><span style="color: #000000;">)) {
            arr_map[nowNode] </span>= [arr_map[nowNode][<span style="color: #800080;">0</span>], arr_map[nowNode][<span style="color: #800080;">1</span>], arr_map[nowNode][<span style="color: #800080;">2</span>] + parseInt(<span style="color: #800080;">10</span>), arr_map[nowNode][<span style="color: #800080;">3</span>], arr_map[nowNode][<span style="color: #800080;">4</span><span style="color: #000000;">]];

        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {

            arr_map[nowNode] </span>= [arr_map[nowNode][<span style="color: #800080;">0</span>], arr_map[nowNode][<span style="color: #800080;">1</span>], arr_map[nowNode][<span style="color: #800080;">2</span>] + parseInt(<span style="color: #800080;">14</span>), arr_map[nowNode][<span style="color: #800080;">3</span>], arr_map[nowNode][<span style="color: #800080;">4</span><span style="color: #000000;">]];
        }
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">********************************************************************
     *function selectFmin(open_list)
     *功能：在openlist中对f值进行排序(冒泡排序)，并选择一个f值最小的节点返回
     *参数：openlist
     **********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function selectFmin(open_list) {
        </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> i, j, min, temp;
        </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; open_list.length; i++<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (j = i + <span style="color: #800080;">1</span>; j &lt; open_list.length; j++<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> ((open_list[i][<span style="color: #800080;">2</span>] + open_list[i][<span style="color: #800080;">3</span>]) &gt; (open_list[j][<span style="color: #800080;">2</span>] + open_list[j][<span style="color: #800080;">3</span><span style="color: #000000;">])) {
                    temp </span>=<span style="color: #000000;"> open_list[i];
                    open_list[i] </span>=<span style="color: #000000;"> open_list[j];
                    open_list[j] </span>=<span style="color: #000000;"> temp;
                }
            }
        }
        </span><span style="color: #0000ff;">var</span> min = open_list[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">return</span> min[<span style="color: #800080;">4</span><span style="color: #000000;">];
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">**********************************************************************
     *function setOpenList(NodeNum)
     *功能：把节点加入open表中
     *参数：待加入openlist的节点的编号
     ***********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function setOpenList(NodeNum) {
        </span><span style="color: #0000ff;">var</span> n =<span style="color: #000000;"> open_list.length;
        open_list[n] </span>= [arr_map[NodeNum][<span style="color: #800080;">0</span>], arr_map[NodeNum][<span style="color: #800080;">1</span>], arr_map[NodeNum][<span style="color: #800080;">2</span>], arr_map[NodeNum][<span style="color: #800080;">3</span>], arr_map[NodeNum][<span style="color: #800080;">4</span><span style="color: #000000;">]];
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">**********************************************************************
     *function setCloseList(NodeNum)
     *功能：把节点加入close表中
     *参数：待加入closelist的节点的编号
     ***********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function setCloseList(NodeNum) {
        </span><span style="color: #0000ff;">var</span> n =<span style="color: #000000;"> close_list.length;
        close_list[n] </span>= [arr_map[NodeNum][<span style="color: #800080;">0</span>], arr_map[NodeNum][<span style="color: #800080;">1</span>], arr_map[NodeNum][<span style="color: #800080;">2</span>], arr_map[NodeNum][<span style="color: #800080;">3</span>], arr_map[NodeNum][<span style="color: #800080;">4</span><span style="color: #000000;">]];
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">**********************************************************************
     *function findInOpenList(nowNodeNum)
     *功能：查询当前节点是否在openlist中，找到返回1，找不到返回0
     *参数：待查询的节点的编号
     ***********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function findInOpenList(nowNodeNum) {
        </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; open_list.length; i++<span style="color: #000000;">) {

            </span><span style="color: #0000ff;">if</span> (open_list[i][<span style="color: #800080;">4</span>] ==<span style="color: #000000;"> nowNodeNum)
                </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">**********************************************************************
     *function findInCloseList(nowNodeNum)
     *功能：查询当前节点是否在closelist中，找到返回1，找不到返回0
     *参数：待查询的节点的编号
     ***********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function findInCloseList(nowNodeNum) {
        </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; close_list.length; i++<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (close_list[i][<span style="color: #800080;">4</span>] ==<span style="color: #000000;"> nowNodeNum)
                </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">**********************************************************************
     *function cost(SuccessorNodeNum,bestNodeNum)
     *功能：现节点到达周围节点的代价
     *参数：SuccessorNodeNum周围节点编号，bestNodeNum现节点
     ***********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function cost(SuccessorNodeNum, bestNodeNum) {
        </span><span style="color: #0000ff;">var</span> x0 =<span style="color: #000000;"> tile_x(bestNodeNum);
        </span><span style="color: #0000ff;">var</span> y0 =<span style="color: #000000;"> tile_y(bestNodeNum);
        </span><span style="color: #0000ff;">var</span> x1 =<span style="color: #000000;"> tile_x(SuccessorNodeNum);
        </span><span style="color: #0000ff;">var</span> y1 =<span style="color: #000000;"> tile_y(SuccessorNodeNum);
        </span><span style="color: #0000ff;">if</span> (((x0 - x1) == <span style="color: #800080;">0</span>) || ((y0 - y1) == <span style="color: #800080;">0</span><span style="color: #000000;">)) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">else</span>
            <span style="color: #0000ff;">return</span> <span style="color: #800080;">14</span><span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">*********************************************************************
     *function setSuccessorNode(bestNodeNum,map_w)
     *功能：把现节点的周围8个节点放入预先准备好的临时arr中以备检察
     *参数：现节点的编号
     035
     1 6
     247
     周围八个点的排序
     **********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function setSuccessorNode(bestNodeNum, n) {
        </span><span style="color: #0000ff;">var</span> x0 =<span style="color: #000000;"> tile_x(bestNodeNum);
        </span><span style="color: #0000ff;">var</span> y0 =<span style="color: #000000;"> tile_y(bestNodeNum);
        </span><span style="color: #0000ff;">var</span> m = n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">var</span> tmp =<span style="color: #000000;"> [];

        </span><span style="color: #0000ff;">if</span> ((x0 - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0 - <span style="color: #800080;">1</span>) &lt;= m &amp;&amp; (y0) &lt;= m) tmp[<span style="color: #800080;">1</span>] = [arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            tmp[</span><span style="color: #800080;">1</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">if</span> ((x0) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0 + <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0) &lt;= m &amp;&amp; (y0 + <span style="color: #800080;">1</span>) &lt;= m) tmp[<span style="color: #800080;">3</span>] = [arr_map[tile_num(x0, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            tmp[</span><span style="color: #800080;">3</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">if</span> ((x0) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0 - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0) &lt;= m &amp;&amp; (y0 - <span style="color: #800080;">1</span>) &lt;= m) tmp[<span style="color: #800080;">4</span>] = [arr_map[tile_num(x0, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            tmp[</span><span style="color: #800080;">4</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">if</span> ((x0 + <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0 + <span style="color: #800080;">1</span>) &lt;= m &amp;&amp; (y0) &lt;= m) tmp[<span style="color: #800080;">6</span>] = [arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            tmp[</span><span style="color: #800080;">6</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">if</span> (DIRECTION == <span style="color: #800080;">8</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> ((x0 - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0 + <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0 - <span style="color: #800080;">1</span>) &lt;= m &amp;&amp; (y0 + <span style="color: #800080;">1</span>) &lt;= m) tmp[<span style="color: #800080;">0</span>] = [arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                tmp[</span><span style="color: #800080;">0</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            }

            </span><span style="color: #0000ff;">if</span> ((x0 - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0 - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0 - <span style="color: #800080;">1</span>) &lt;= m &amp;&amp; (y0 - <span style="color: #800080;">1</span>) &lt;= m) tmp[<span style="color: #800080;">2</span>] = [arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                tmp[</span><span style="color: #800080;">2</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            }

            </span><span style="color: #0000ff;">if</span> ((x0 + <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0 + <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0 + <span style="color: #800080;">1</span>) &lt;= m &amp;&amp; (y0 + <span style="color: #800080;">1</span>) &lt;= m) tmp[<span style="color: #800080;">5</span>] = [arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                tmp[</span><span style="color: #800080;">5</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            }

            </span><span style="color: #0000ff;">if</span> ((x0 + <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0 - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0 + <span style="color: #800080;">1</span>) &lt;= m &amp;&amp; (y0 - <span style="color: #800080;">1</span>) &lt;= m) tmp[<span style="color: #800080;">7</span>] = [arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                tmp[</span><span style="color: #800080;">7</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            }

        }
        </span><span style="color: #0000ff;">if</span> (DIRECTION == <span style="color: #800080;">4</span><span style="color: #000000;">) {
            tmp[</span><span style="color: #800080;">0</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            tmp[</span><span style="color: #800080;">2</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            tmp[</span><span style="color: #800080;">5</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            tmp[</span><span style="color: #800080;">7</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
        }

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> tmp;
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">******************************************************************
     *function showPath(close_list)
     *功能：把结果路径存入arr_path输出
     *参数：close_list
     *******************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function showPath(close_list, arr_path, arr_path_out) {
        </span><span style="color: #0000ff;">var</span> n =<span style="color: #000000;"> close_list.length;
        </span><span style="color: #0000ff;">var</span> i = n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">var</span> ii = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">var</span> nn = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">var</span> mm = <span style="color: #800080;">0</span><span style="color: #000000;">;


        </span><span style="color: #0000ff;">var</span> arr_path_tmp = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Array();
        </span><span style="color: #0000ff;">var</span> target = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        </span><span style="color: #008000;">/*</span><span style="color: #008000;">*********把close_list中有用的点存入arr_path_tmp中************</span><span style="color: #008000;">*/</span>

        <span style="color: #0000ff;">for</span> (ii; ; ii++<span style="color: #000000;">) {
            arr_path_tmp[ii] </span>= close_list[n - <span style="color: #800080;">1</span>][<span style="color: #800080;">4</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (close_list[n - <span style="color: #800080;">1</span>][<span style="color: #800080;">1</span>] == close_list[i][<span style="color: #800080;">4</span><span style="color: #000000;">]) {
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">for</span> (i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; i--<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (close_list[i][<span style="color: #800080;">4</span>] == close_list[n - <span style="color: #800080;">1</span>][<span style="color: #800080;">1</span><span style="color: #000000;">]) {
                    n </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
        }

        </span><span style="color: #0000ff;">var</span> w = arr_path_tmp.length - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">var</span> j = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = w; i &gt;= <span style="color: #800080;">0</span>; i--<span style="color: #000000;">) {
            arr_path[j] </span>=<span style="color: #000000;"> arr_path_tmp[i];
            j</span>++<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> k = <span style="color: #800080;">0</span>; k &lt;= w; k++<span style="color: #000000;">) {
            target </span>=<span style="color: #000000;"> [
                tile_x(arr_path[k]),
                map_w </span>- <span style="color: #800080;">1</span> -<span style="color: #000000;"> tile_y(arr_path[k])
            ];
            arr_path_out.push(target);
        }
        arr_path_out.shift();
    }

    function _reset() {
</span><span style="color: #008000;">//</span><span style="color: #008000;">        arr_path_out = [];</span>
        arr_map =<span style="color: #000000;"> [];
</span><span style="color: #008000;">//</span><span style="color: #008000;">        arr_map_tmp = window.mapData;
</span><span style="color: #008000;">//</span><span style="color: #008000;">        map_w = arr_map_tmp.length;</span>
        map_w = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        open_list </span>= []; <span style="color: #008000;">//</span><span style="color: #008000;">创建OpenList</span>
        close_list = []; <span style="color: #008000;">//</span><span style="color: #008000;">创建CloseList
</span><span style="color: #008000;">//</span><span style="color: #008000;">        tmp = []; </span><span style="color: #008000;">//</span><span style="color: #008000;">存放当前节点的八个方向的节点</span>
<span style="color: #000000;">    };


    </span><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).AStar =<span style="color: #000000;"> {
        aCompute: function (terrainData, begin, end) {
            _reset();
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> aCompute(terrainData, begin, end);
        },
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
         * 设置寻路方向
         * @param direction 4或者8
         </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        setDirection: function (direction) {
            DIRECTION </span>=<span style="color: #000000;"> direction;
        }
    };
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><br />	分析</p>
<p>用户自己调用setDirection设置寻路方向数</p>
<p>现在并不在Config中设置A*算法寻路的方向数，而是由用户自己调用setDirection来设置寻路方向数，这样更为灵活通用。</p>
<p><br />	<span style="color: #c0c0c0;">重构</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>对应修改炸弹人的类，令其使用提炼出的引擎类</p>
<p>修改炸弹人EnemySprite，初始化时设置A*算法寻路的方向数为4，并改为调用引擎AStar来寻路</p>
<p>EnemySprite</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        Init: function (data, bitmap) {
...
            YE.AStar.setDirection(</span><span style="color: #800080;">4</span><span style="color: #000000;">);
...
        },
        Private: {
            ___findPath: function () {
                </span><span style="color: #0000ff;">return</span> YE.AStar.aCompute(<span style="color: #0000ff;">this</span>.___computeCurrentCoordinate(), <span style="color: #0000ff;">this</span><span style="color: #000000;">.___computePlayerCoordinate()).path
            },</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>删除引擎Config中关于&nbsp;A*算法寻路的方向数的设置</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>领域模型&nbsp;</p>
<p>图</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>加入键盘事件管理EventManager，提出事件枚举类Event。</p>
<p>16</p>
<p>确定引擎要提炼的类</p>
<p>接着提炼引擎KeyState和事件管理类KeyEventManager</p>
<p><br />分析炸弹人参考模型中对应的类，找出可复用的、通用的部分，将其提炼到引擎类中</p>
<p>引擎事件管理类对应炸弹人的KeyState和KeyEventManager</p>
<p>&nbsp;</p>
<p>炸弹人KeyEventManager和KeyState写到了同一个文件中</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">键盘事件管理类</span>
<span style="color: #000000;">(function () {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">枚举值</span>
    <span style="color: #0000ff;">var</span> keyCodeMap =<span style="color: #000000;"> {
        Left: </span><span style="color: #800080;">65</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> A键</span>
        Right: <span style="color: #800080;">68</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> D键</span>
        Down: <span style="color: #800080;">83</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> S键</span>
        Up: <span style="color: #800080;">87</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> W键</span>
        Space: <span style="color: #800080;">32</span>   <span style="color: #008000;">//</span><span style="color: #008000;">空格键</span>
<span style="color: #000000;">    };
    </span><span style="color: #008000;">//</span><span style="color: #008000;">按键状态</span>
    <span style="color: #0000ff;">var</span> keyState =<span style="color: #000000;"> {
    };

    keyState[keyCodeMap.Left] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    keyState[keyCodeMap.Right] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    keyState[keyCodeMap.Up] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    keyState[keyCodeMap.Down] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    keyState[keyCodeMap.Space] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">var</span> KeyEventManager =<span style="color: #000000;"> YYC.Class({
        Private: {
            _keyDown: function () {
            },
            _keyUp: function () {
            }
        },
        Public: {
            addKeyDown: function () {
                </span><span style="color: #0000ff;">this</span>._keyDown = YYC.Tool.<span style="color: #0000ff;">event</span>.bindEvent(<span style="color: #0000ff;">this</span><span style="color: #000000;">, function (e) {
                    keyState[e.keyCode] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;

                    e.preventDefault();
                });

                YYC.Tool.</span><span style="color: #0000ff;">event</span>.addEvent(document, <span style="color: #800000;">"</span><span style="color: #800000;">keydown</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">._keyDown);
            },
            removeKeyDown: function () {
                YYC.Tool.</span><span style="color: #0000ff;">event</span>.removeEvent(document, <span style="color: #800000;">"</span><span style="color: #800000;">keydown</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">._keyDown);
            },
            addKeyUp: function () {
                </span><span style="color: #0000ff;">this</span>._keyUp = YYC.Tool.<span style="color: #0000ff;">event</span>.bindEvent(<span style="color: #0000ff;">this</span><span style="color: #000000;">, function (e) {
                    keyState[e.keyCode] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                });

                YYC.Tool.</span><span style="color: #0000ff;">event</span>.addEvent(document, <span style="color: #800000;">"</span><span style="color: #800000;">keyup</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">._keyUp);
            },
            removeKeyUp: function () {
                YYC.Tool.</span><span style="color: #0000ff;">event</span>.removeEvent(document, <span style="color: #800000;">"</span><span style="color: #800000;">keyup</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">._keyUp);
            }
        }
    });

    window.keyCodeMap </span>=<span style="color: #000000;"> keyCodeMap;
    window.keyState </span>=<span style="color: #000000;"> keyState;
    window.keyEventManager </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> KeyEventManager();
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>分析</p>
<p>&nbsp;</p>
<p>不提出KeyState</p>
<p>KeyState是存储当前的按键状态的容器类，与用户的业务逻辑相关，因此不提出。</p>
<p>KeyEventManager中的&ldquo;管理事件的监听与移除&rdquo;属于通用机制，可以将其提出。</p>
<p>&nbsp;</p>
<p>重命名为EventManager</p>
<p>EventManager这个名字更具有通用性，泛指所有的事件管理，因此将引擎的KeyEventManager重命名为EventManager。</p>
<p>&nbsp;</p>
<p>将依赖的YTool方法移到Tool中</p>
<p>通用机制调用了YTool-&gt;event的方法，可将其移到引擎Tool中</p>
<p>&nbsp;</p>
<p>提出EventManager和事件枚举类Event</p>
<p>另外，可以将具体的事件值（如"keydown"、"keyup"）提取为枚举值，并提取到新增的引擎Event中</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>提出的引擎类</p>
<p>&nbsp;</p>
<p>引擎EventManager</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> _keyListeners =<span style="color: #000000;"> {};

    </span><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).EventManager =<span style="color: #000000;"> {
        _getEventType: function (</span><span style="color: #0000ff;">event</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">var</span> eventType = <span style="color: #800000;">""</span><span style="color: #000000;">,
                e </span>=<span style="color: #000000;"> YE.Event;

            </span><span style="color: #0000ff;">switch</span> (<span style="color: #0000ff;">event</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> e.KEY_DOWN:
                    eventType </span>= <span style="color: #800000;">"</span><span style="color: #800000;">keydown</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> e.KEY_UP:
                    eventType </span>= <span style="color: #800000;">"</span><span style="color: #800000;">keyup</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> e.KEY_PRESS:
                    eventType </span>= <span style="color: #800000;">"</span><span style="color: #800000;">keypress</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">事件类型错误</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }

            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> eventType;
        },
        addKeyListener: function (</span><span style="color: #0000ff;">event</span><span style="color: #000000;">, handler) {
            </span><span style="color: #0000ff;">var</span> eventType = <span style="color: #800000;">""</span><span style="color: #000000;">;

            eventType </span>= <span style="color: #0000ff;">this</span>._getEventType(<span style="color: #0000ff;">event</span><span style="color: #000000;">);

            YE.Tool.</span><span style="color: #0000ff;">event</span><span style="color: #000000;">.addEvent(window, eventType, handler);
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._registerEvent(eventType, handler);
        },
        _registerEvent: function (eventType, handler) {
            </span><span style="color: #0000ff;">if</span> (_keyListeners[eventType] ===<span style="color: #000000;"> undefined) {
                _keyListeners[eventType] </span>=<span style="color: #000000;"> [handler];
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                _keyListeners[eventType].push(handler);
            }
        },
        removeKeyListener: function (</span><span style="color: #0000ff;">event</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">var</span> eventType = <span style="color: #800000;">""</span><span style="color: #000000;">;

            eventType </span>= <span style="color: #0000ff;">this</span>._getEventType(<span style="color: #0000ff;">event</span><span style="color: #000000;">);

            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (_keyListeners[eventType]) {
                _keyListeners[eventType].forEach(function(e, i){
                    YE.Tool.</span><span style="color: #0000ff;">event</span><span style="color: #000000;">.removeEvent(window, eventType, e);
                })
            }

        }
    };
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>引擎Event</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE</span><span style="color: #800000;">"</span>).Event =<span style="color: #000000;"> {
    KEY_DOWN: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
    KEY_UP: </span><span style="color: #800080;">1</span><span style="color: #000000;">,
    KEY_PRESS: </span><span style="color: #800080;">2</span>

    <span style="color: #008000;">//</span><span style="color: #008000;">可增加鼠标事件枚举类型</span>
};</pre>
</div>
<p>&nbsp;</p>
<p>引擎Tool</p>
<div class="cnblogs_code">
<pre>    <span style="color: #0000ff;">namespace</span>(<span style="color: #800000;">"</span><span style="color: #800000;">YE.Tool</span><span style="color: #800000;">"</span>).<span style="color: #0000ff;">event</span> =<span style="color: #000000;"> (function () {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">注意！bindEvent传的参数与BindWithArguments类似，只是第一个参数为event！</span>
            bindEvent: function (<span style="color: #0000ff;">object</span><span style="color: #000000;">, fun) {
                </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">2</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">return</span> function (<span style="color: #0000ff;">event</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span> fun.apply(<span style="color: #0000ff;">object</span>, [self.wrapEvent(<span style="color: #0000ff;">event</span>)].concat(args)); <span style="color: #008000;">//</span><span style="color: #008000;">对事件对象进行包装</span>
<span style="color: #000000;">                }
            },
            </span><span style="color: #008000;">/*</span><span style="color: #008000;"> oTarget既可以是单个dom元素，也可以使jquery集合。
             如：
             Tool.event.addEvent(document.getElementById("test_div"), "mousedown", _Handle);
             Tool.event.addEvent($("div"), "mousedown", _Handle);
             </span><span style="color: #008000;">*/</span><span style="color: #000000;">
            addEvent: function (oTarget, sEventType, fnHandler) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">            var oTarget = $(oTarget)[0];    </span><span style="color: #008000;">//</span><span style="color: #008000;">转换为dom对象</span>
                <span style="color: #0000ff;">var</span> dom = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                    i </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    temp </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (Tool.judge.isjQuery(oTarget)) {
                    oTarget.each(function () {
                        dom </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">;

                        </span><span style="color: #0000ff;">if</span> (Tool.judge.isHostMethod(dom, <span style="color: #800000;">"</span><span style="color: #800000;">addEventListener</span><span style="color: #800000;">"</span><span style="color: #000000;">)) {
                            dom.addEventListener(sEventType, fnHandler, </span><span style="color: #0000ff;">false</span><span style="color: #000000;">);
                        }
                        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (Tool.judge.isHostMethod(dom, <span style="color: #800000;">"</span><span style="color: #800000;">attachEvent</span><span style="color: #800000;">"</span><span style="color: #000000;">)) {
                            dom.attachEvent(</span><span style="color: #800000;">"</span><span style="color: #800000;">on</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> sEventType, fnHandler);
                        }
                        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            dom[</span><span style="color: #800000;">"</span><span style="color: #800000;">on</span><span style="color: #800000;">"</span> + sEventType] =<span style="color: #000000;"> fnHandler;
                        }
                    });
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    dom </span>=<span style="color: #000000;"> oTarget;

                    </span><span style="color: #0000ff;">if</span> (Tool.judge.isHostMethod(dom, <span style="color: #800000;">"</span><span style="color: #800000;">addEventListener</span><span style="color: #800000;">"</span><span style="color: #000000;">)) {
                        dom.addEventListener(sEventType, fnHandler, </span><span style="color: #0000ff;">false</span><span style="color: #000000;">);
                    }
                    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (Tool.judge.isHostMethod(dom, <span style="color: #800000;">"</span><span style="color: #800000;">attachEvent</span><span style="color: #800000;">"</span><span style="color: #000000;">)) {
                        dom.attachEvent(</span><span style="color: #800000;">"</span><span style="color: #800000;">on</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> sEventType, fnHandler);
                    }
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        dom[</span><span style="color: #800000;">"</span><span style="color: #800000;">on</span><span style="color: #800000;">"</span> + sEventType] =<span style="color: #000000;"> fnHandler;
                    }
                }
            },
            removeEvent: function (oTarget, sEventType, fnHandler) {
                </span><span style="color: #0000ff;">var</span> dom = <span style="color: #0000ff;">null</span><span style="color: #000000;">;


                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (Tool.judge.isjQuery(oTarget)) {
                    oTarget.each(function () {
                        dom </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">if</span> (Tool.judge.isHostMethod(dom, <span style="color: #800000;">"</span><span style="color: #800000;">removeEventListener</span><span style="color: #800000;">"</span><span style="color: #000000;">)) {
                            dom.removeEventListener(sEventType, fnHandler, </span><span style="color: #0000ff;">false</span><span style="color: #000000;">);
                        }
                        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (Tool.judge.isHostMethod(dom, <span style="color: #800000;">"</span><span style="color: #800000;">detachEvent</span><span style="color: #800000;">"</span><span style="color: #000000;">)) {
                            dom.detachEvent(</span><span style="color: #800000;">"</span><span style="color: #800000;">on</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> sEventType, fnHandler);
                        }
                        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            dom[</span><span style="color: #800000;">"</span><span style="color: #800000;">on</span><span style="color: #800000;">"</span> + sEventType] = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                        }
                    });
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    dom </span>=<span style="color: #000000;"> oTarget;
                    </span><span style="color: #0000ff;">if</span> (Tool.judge.isHostMethod(dom, <span style="color: #800000;">"</span><span style="color: #800000;">removeEventListener</span><span style="color: #800000;">"</span><span style="color: #000000;">)) {
                        dom.removeEventListener(sEventType, fnHandler, </span><span style="color: #0000ff;">false</span><span style="color: #000000;">);
                    }
                    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (Tool.judge.isHostMethod(dom, <span style="color: #800000;">"</span><span style="color: #800000;">detachEvent</span><span style="color: #800000;">"</span><span style="color: #000000;">)) {
                        dom.detachEvent(</span><span style="color: #800000;">"</span><span style="color: #800000;">on</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> sEventType, fnHandler);
                    }
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        dom[</span><span style="color: #800000;">"</span><span style="color: #800000;">on</span><span style="color: #800000;">"</span> + sEventType] = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    }
                }
            },
            </span><span style="color: #008000;">/*</span><span style="color: #008000;">
             包装event对象   -待补充

             event.type:返回事件名。返回没有&ldquo;on&rdquo;作为前缀的事件名，比如，onclick事件返回的type是click
             event.target: 返回事件源，就是发生事件的元素
             event.preventDefault: 阻止默认事件动作
             event.stopBubble: 阻止冒泡
             //event.offsetLeft:为匹配的元素集合中获取第一个元素的当前坐标的left，相对于文档（document）。
             //event.offsetTop:为匹配的元素集合中获取第一个元素的当前坐标的top，相对于文档（document）。
             //event.positionLeft:获取匹配元素中第一个元素的当前坐标的left，相对于offset parent的坐标。( offset parent指离该元素最近的而且被定位过的祖先元素 )
             //event.positionTop:获取匹配元素中第一个元素的当前坐标的top，相对于offset parent的坐标。( offset parent指离该元素最近的而且被定位过的祖先元素 )
             event.pageX: 鼠标相对于文档的左边缘的位置。
             event.pageY: 鼠标相对于文档的上边缘的位置。
             event.relatedTarget: 发生mouseover和mouseout事件时，相关的dom元素。
             （mouseover：鼠标来之前的元素；mouseout：鼠标将要去的那个元素）
             event.mouseButton: 鼠标按键。
             左键： 0
             右键： 1
             中键： 2

             </span><span style="color: #008000;">*/</span><span style="color: #000000;">
            wrapEvent: function (oEvent) {
                </span><span style="color: #0000ff;">var</span> e = oEvent ? oEvent : <span style="color: #0000ff;">global</span>.<span style="color: #0000ff;">event</span><span style="color: #000000;">,
                    target </span>= e.srcElement ||<span style="color: #000000;"> e.target;

                </span><span style="color: #008000;">//</span><span style="color: #008000;">ie</span>
                <span style="color: #0000ff;">if</span><span style="color: #000000;"> (Tool.judge.browser.isIE()) {
                    e.pageX </span>= e.clientX + document.body.scrollLeft ||<span style="color: #000000;"> document.documentElement.scrollLeft;
                    e.pageY </span>= e.clientY + document.body.scrollTop ||<span style="color: #000000;"> document.documentElement.scrollTop;

                    e.stopBubble </span>=<span style="color: #000000;"> function () {
                        e.cancelBubble </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    };

                    </span><span style="color: #0000ff;">if</span> (Tool.judge.browser.isIE7() ||<span style="color: #000000;"> Tool.judge.browser.isIE8()) {
                        e.preventDefault </span>=<span style="color: #000000;"> function () {
                            e.returnValue </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                        };

                        </span><span style="color: #0000ff;">if</span> (e.type == <span style="color: #800000;">"</span><span style="color: #800000;">mouseout</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                            e.relatedTarget </span>=<span style="color: #000000;"> e.toElement;
                        }
                        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (e.type == <span style="color: #800000;">"</span><span style="color: #800000;">mouseover</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                            e.relatedTarget </span>=<span style="color: #000000;"> e.fromElement;
                        }

                        </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (e.button) {
                            </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">1</span><span style="color: #000000;">:
                                e.mouseButton </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                            </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">4</span><span style="color: #000000;">:
                                e.mouseButton </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                            </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">2</span><span style="color: #000000;">:
                                e.mouseButton </span>= <span style="color: #800080;">2</span><span style="color: #000000;">;
                                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                            </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                                e.mouseButton </span>=<span style="color: #000000;"> e.button;
                                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                        }
                    }
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        e.mouseButton </span>=<span style="color: #000000;"> e.button;
                    }
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    e.stopBubble </span>=<span style="color: #000000;"> e.stopPropagation;

                    e.keyCode </span>=<span style="color: #000000;"> e.which;
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">注意：firefox没有多个键一起按的事件</span>
                    e.mouseButton =<span style="color: #000000;"> e.button;
                }
                e.target </span>=<span style="color: #000000;"> target;


</span><span style="color: #008000;">//</span><span style="color: #008000;">                e.offsetLeft = $(target).offset().left;   </span><span style="color: #008000;">//</span><span style="color: #008000;">使用jquery的方法
</span><span style="color: #008000;">//</span><span style="color: #008000;">                e.offsetTop = $(target).offset().top;     </span><span style="color: #008000;">//</span><span style="color: #008000;">使用jquery的方法
</span><span style="color: #008000;">//</span>
<span style="color: #008000;">//</span><span style="color: #008000;">                e.positionLeft = $(target).position().left;   </span><span style="color: #008000;">//</span><span style="color: #008000;">使用jquery的方法
</span><span style="color: #008000;">//</span><span style="color: #008000;">                e.positionTop = $(target).position().top;   </span><span style="color: #008000;">//</span><span style="color: #008000;">使用jquery的方法</span>

                <span style="color: #0000ff;">return</span><span style="color: #000000;"> e;
            },
            getEvent: function () {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">this.getEvent.caller为调用了getEvent方法的函数的引用</span>
                <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.getEvent.caller.arguments[<span style="color: #800080;">0</span><span style="color: #000000;">];
            }
        }
    }());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>对应修改炸弹人的类，令其使用提炼出的引擎类</p>
<p>修改炸弹人KeyEventManager，调用引擎EventManager：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">  addKeyDown: function () {
                YE.EventManager.addKeyListener(YE.Event.KEY_DOWN, function (e) {
                    keyState[e.keyCode] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;

                    e.preventDefault();
                })

            },
            removeKeyDown: function () {
                YE.EventManager.removeKeyListener(YE.Event.KEY_DOWN);

            },
            addKeyUp: function () {
                YE.EventManager.addKeyListener(YE.Event.KEY_UP, function (e) {
                    keyState[e.keyCode] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                })
            },
            removeKeyUp: function () {
                YE.EventManager.removeKeyListener(YE.Event.KEY_UP);
            }</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>领域模型</p>
<p>图</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">Global.js进一步明确职责为外部辅助成员、全局成员类</span></p>
<p><span style="color: #c0c0c0;">17</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>提出DataOperate</p>
<p>&nbsp;</p>
<p>确定引擎要提炼的类</p>
<p>提炼DataOperate</p>
<p><br />分析炸弹人参考模型中对应的类，找出可复用的、通用的部分，将其提炼到引擎类中</p>
<p>DataOperate对应炸弹人数据操作层的类，具体包括MapDataOperate、GetPath、TerrainDataOperate、GetSpriteData、GetFrames类。所有的炸弹人数据操作类都与具体的业务逻辑相关，因此没有可提炼的。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>加入Bitmap</p>
<p>14</p>
<p>&nbsp;</p>
<p><br />确定引擎要提炼的类</p>
<p>提炼Data</p>
<p><br />分析炸弹人参考模型中对应的类，找出可复用的、通用的部分，将其提炼到引擎类中</p>
<p>&nbsp;</p>
<p>Data对应炸弹人的数据层的类，具体包括MapData、Bitmap、ImgPathData、TerrainData、SpriteData、FrameData类。其中Bitmap类是图片的包装类，包含与图片本身密切相关的属性和方法，但不包括具体的图片数据，因此其具有通用性，可直接提出来。</p>
<p>&nbsp;</p>
<p>引擎Bitmap</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {


    </span><span style="color: #0000ff;">var</span> Bitmap =<span style="color: #000000;"> YYC.Class({
        Init: function (data) {
            </span><span style="color: #0000ff;">this</span>.img =<span style="color: #000000;"> data.img;
            </span><span style="color: #0000ff;">this</span>.width =<span style="color: #000000;"> data.width;
            </span><span style="color: #0000ff;">this</span>.height =<span style="color: #000000;"> data.height;
        },
        Private: {
        },
        Public: {
            img: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            width: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            height: </span><span style="color: #800080;">0</span><span style="color: #000000;">
        }
    });

    window.Bitmap </span>=<span style="color: #000000;"> Bitmap;
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>对应修改炸弹人的类，令其使用提炼出的引擎类</p>
<p>修改炸弹人BitmapFactory，改为创建引擎的Bitmap实例</p>
<p>BitmapFactory&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {


    </span><span style="color: #0000ff;">var</span> bitmapFactory =<span style="color: #000000;"> {
        createBitmap: function (data) {
</span><span style="color: #000000;">...
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> YE.Bitmap(bitmapData);
        }
    }

    window.bitmapFactory </span>=<span style="color: #000000;"> bitmapFactory;
}());</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>领域模型</p>
<p>图</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>本文最终完整的领域模型</strong></p>
<p>&nbsp;</p>
<p><strong>高层划分</strong></p>
<p><span style="color: #888888;">分层</span></p>
<p>分模块</p>
<p>图</p>
<p>&nbsp;</p>
<p>对应领域模型</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>分析改进点，指出第二次迭代的任务</strong></p>
<p><span style="color: #c0c0c0;">（宏观上说一下，不要说得太细）&nbsp;</span></p>
<p>&nbsp;&nbsp;</p>
<p>本文将炸弹人中通用的类提炼到了引擎中，搭建了引擎的整体框架。</p>
<p>但是现在引擎还很粗糙，跟炸弹人耦合严重，还不是一个可单独复用的组件。</p>
<p>因此，在下文中，我会进行第二次迭代，对引擎进行进一步的抽象和提炼，尽量减少引擎与炸弹人之间的耦合。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>本文源码下载</strong></p>
<p>修改源码后再给出</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;"><strong>演示地址</strong></span></p>
<p>&nbsp;</p>
<p><strong>本文参考资料</strong></p>
<p>&nbsp;</p>
<p><strong>欢迎浏览下一篇博文：</strong></p>
<p>&nbsp;</p>
<p>版本1-18</p>]]></description></item><item><title>提炼初步游戏引擎系列（1）：开篇</title><link>http://www.cnblogs.com/chaogex/archive/2014/08/03/3888759.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sun, 03 Aug 2014 11:39:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/08/03/3888759.html</guid><description><![CDATA[<p><strong>前言</strong></p>
<p><span style="font-size: 14px; line-height: 1.5;">大家好久不见了！在</span><a style="font-size: 14px; line-height: 1.5;" href="http://www.cnblogs.com/chaogex/category/491727.html">&ldquo;炸弹人游戏系列&rdquo;</a><span style="font-size: 14px; line-height: 1.5;">中，我运用面向对象思想开发了一个炸弹人游戏，现在我准备基于该游戏的制作经验，开发一个新的即时战略游戏（就是后面的&ldquo;xxxx系列&rdquo;）。</span></p>
<p><span style="color: #000000;">考虑到：</span></p>
<p><span style="color: #000000;">1、炸弹人游戏代码组织良好，已经提出了一些通用的类（如Sprite、Layer类等），而且类的层次清晰，具有良好的模块化，因此具备从中提炼引擎的条件。</span></p>
<p><span style="color: #000000;">2、炸弹人游戏有完整的单元测试，因此在此基础上修改为引擎的单元测试。</span></p>
<p><span style="color: #000000;">3、已经有一些成熟的开源2D游戏引擎，因此可以参考它们的设计。</span></p>
<p><span style="color: #000000;">基于以上三点分析，我确定了一个基本方案：从炸弹人游戏中提炼一个初步的游戏引擎，然后基于该引擎迭代开发即时战略游戏，最后进行扩展优化。</span></p>
<p>&nbsp;</p>
<p>系列重点</p>
<p><span>本系列负责说明&ldquo;从炸弹人游戏中提炼一个初步的游戏引擎&rdquo;，重点</span>介绍引擎提炼的思想、模块设计和迭代过程，并对炸弹人游戏改造为基于该引擎来实现后的<span style="font-size: 14px; line-height: 1.5;">设计结构上的变化和优缺点进行分析，对于炸弹人游戏的业务逻辑的变化、单元测试的编写不会深入讨论。</span></p>
<p>&nbsp;</p>
<p><span style="color: #000000;">游戏引擎是什么？有什么用？</span></p>
<p><span style="color: #000000;">引擎就是用于控制所有游戏功能的主程序，负责从计算碰撞、物体的相对位置，到接受玩家的输入，以及按照正确的音量输出声音等工作，扮演着<a href="http://baike.baidu.com/view/34054.htm" target="_blank">中场发动机</a>的角色，把游戏中的所有元素捆绑在一起，在<a href="http://baike.baidu.com/view/179243.htm" target="_blank">后台</a>指挥它们同时、有序地工作。</span></p>
<p><span style="color: #000000;">&nbsp;</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 14px; line-height: 1.5;">为什么需要游戏引擎？</span></p>
<p>引擎封装底层实现，呈现给用户以高层API，使用户可以将精力放到游戏的逻辑、玩法创意上，而不用关心游戏的具体实现。&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>系列目的</h1>
<p>1、从炸弹人游戏中提炼一个初步的通用的2D游戏引擎</p>
<p>将炸弹人游戏代码中的游戏框架、通用代码、通用模式提出出来，并进行抽象、精炼，形成一个初步的2D游戏引擎。</p>
<p>2、炸弹人游戏改造为基于该引擎来实现。</p>
<p>在提炼引擎的过程中 ，炸弹人游戏也改为使用引擎来实现，这样一方面可以从用户使用的角度得到反馈，并迭代修改引擎；另一方面也能进行客户测试，结合单元测试来保证引擎的正确性。</p>
<p>&nbsp;</p>
<h1>关键词</h1>
<p><span style="font-size: 14px; line-height: 1.5;">2D游戏引擎、面向对象、迭代、提炼</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 14px; line-height: 1.5;">前期准备</span></p>
<p><span style="font-size: 14px; line-height: 1.5;">建议您先阅读我的炸弹人系列，至少了解下炸弹人领域模型的设计</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>系列博文目录</strong></p>
<ul>
<li><a id="homepage1_HomePageDays_ctl04_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3151033.html">&nbsp;</a></li>
</ul>
<p><strong>最终成果</strong></p>
<p>下面是完成整个游戏开发后的成果，大家可以先预览一下。</p>
<p>&nbsp;</p>
<h1>项目GitHub地址（包含引擎、游戏、单元测试）<a href="http://pan.baidu.com/s/1kmcM5" target="_blank"><br /></a></h1>
<p>&nbsp;</p>
<h1><span style="color: #c0c0c0;">游戏截图（已测试通过的浏览器：chrome、ff）</span></h1>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<h1><span style="color: #c0c0c0;"><a href="http://yang222.s2.jutuo.net/Bomber"><span style="color: #c0c0c0;">演示地址</span></a></span></h1>
<h1><a id="conceptLayer"></a><span style="color: #c0c0c0;">概念层次结构</span></h1>
<p>&nbsp;</p>
<h1><span>&nbsp;</span></h1>
<h1><span>最终引擎的领域模型（炸弹人和引擎领域模型）</span></h1>
<p>&nbsp;炸弹人使用精简的领域模型</p>
<h1><span style="color: #c0c0c0;">最终使用了引擎的炸弹人游戏的领域模型</span></h1>
<p>（简略版，不用全部画出来，重点突出使用引擎的部分）</p>
<p>&nbsp;</p>
<p>引擎序列图分析</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1><span>最终引擎的高层划分</span></h1>
<h2>　　层、包</h2>
<p>&nbsp;</p>
<h2>　　对应的领域模型</h2>
<p>&nbsp;</p>
<p>参考资料</p>
<p><a href="http://www.cnblogs.com/chaogex/category/491727.html">&ldquo;炸弹人游戏系列&rdquo;</a></p>
<p>Lufugend引擎源码</p>
<p>cocos2d-html5引擎</p>
<p>《HTML5 Canvas核心技术：图形、动画与游戏开发》</p>
<p>&nbsp;</p>]]></description></item><item><title>提炼初步游戏引擎系列（2）：回顾与前期规划</title><link>http://www.cnblogs.com/chaogex/archive/2014/08/03/3888760.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sun, 03 Aug 2014 11:39:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/08/03/3888760.html</guid><description><![CDATA[<h1>前言</h1>
<p>本文并没有设计出一个比较完整的引擎架构（类图、包图），而只是对后续开发定下了一个大致的方向。这就够了！让我们在具体开发中再来从底向上设计吧！</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>本文目的</p>
<p>进行引擎的前期规划</p>
<p>回顾炸弹人设计，提炼出一个精简的领域模型，作为炸弹人的参考模型</p>
<p>从精简模型中提炼出一个抽象的领域模型，并将该模型的通用部分提出来，作为引擎的初步领域模型</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>本文主要内容</strong></p>
<p><span style="color: #c0c0c0;">1、从炸弹人领域模型中提炼出一个抽象的领域模型</span></p>
<p><span style="color: #c0c0c0;">2、参考该领域模型，进行初步引擎设计</span></p>
<p>&nbsp;</p>
<p><span style="color: #888888;">前期准备</span></p>
<h1><span style="color: #888888;">需要的知识</span></h1>
<h2><span style="color: #888888;">必备知识</span></h2>
<ul>
<li><span style="color: #888888;">Html+css</span><br /><span style="color: #888888;">掌握html常用的标签，掌握常用的css属性，掌握div布局、定位等知识。能够使用html和css来设计和显示页面。</span></li>
<li><span style="color: #888888;">Javascript</span><br /><span style="color: #888888;">熟悉Javascript基本语法、原型、闭包、作用域链等知识。</span></li>
<li><span style="color: #888888;">Html5 Canvas</span><br /><span style="color: #888888;">了解画布原理，掌握常用的API，掌握Canvas优化。</span></li>


















</ul>
<h2><span style="color: #888888;">进阶知识</span></h2>
<ul>
<li><span style="color: #888888;">面向对象思想</span><br /><span style="color: #888888;">熟悉oo思想，能够运用oo来分析、设计、编程。</span></li>
<li><span style="color: #888888;">设计模式</span><br /><span style="color: #888888;">了解23种设计模式。</span></li>
<li><span style="color: #888888;">领域驱动</span><br /><span style="color: #888888;">了解模型驱动开发（DDD）的思想。</span></li>
<li><span style="color: #888888;">敏捷开发</span><br /><span style="color: #888888;">了解敏捷开发流程。</span></li>
<li><span style="color: #888888;">测试驱动开发</span><br /><span style="color: #888888;">熟悉测试驱动开发流程。</span></li>


















</ul>
<h1><span style="color: #888888;">相关资源</span></h1>
<h2><span style="color: #888888;">&nbsp;</span></h2>
<h1>&nbsp;</h1>
<p>&nbsp;</p>
<h1>炸弹人回顾与分析</h1>
<p><span style="font-size: 1.5em; line-height: 1.5; color: #c0c0c0;">开始初步建模（迭代建模）</span></p>
<h3><span style="color: #c0c0c0;">分析思路（&ldquo;炸弹人游戏&rdquo;启发）</span></h3>
<p>&nbsp;</p>
<p>炸弹人源码下载（放在github上）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #000000;">回顾炸弹人设计</span></p>
<p>&nbsp;</p>
<p><span style="color: #888888;">因为我之前开发的炸弹人游戏与本游戏类似，都是2D游戏，有一些共同的领域概念（如精灵、层）和模式。</span></p>
<p><span style="color: #888888;">因此，</span></p>
<p>首先分析炸弹人游戏的领域模型，提炼出一个精简的模型；然后对该模型进行抽象，提出抽象模型。</p>
<p>然后参考该抽象模型，提出引擎的初步领域模型。<span style="color: #888888;">在原型验证阶段和具体的开发阶段中，再不断地提炼和重构领域模型。</span></p>
<p>&nbsp;</p>
<p>炸弹人游戏的概念层次结构：</p>
<p><img src="http://images.cnitblog.com/i/419321/201408/050829079126015.jpg" alt="" width="230" height="581" />&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>领域模型</h3>
<p><span style="color: #888888;">根据上面的分析思路，现在从&ldquo;炸弹人游戏&rdquo;中提出领域模型。</span></p>
<p>&nbsp;</p>
<p>炸弹人游戏的领域模型</p>
<p><img src="http://images.cnitblog.com/i/419321/201408/050830402728898.jpg" alt="" />&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>引擎初步设计</h1>
<p>&nbsp;</p>
<h2>代码组织方式</h2>
<p><span style="color: #888888;">l&nbsp; 不使用SeaJs组织</span></p>
<p><span style="color: #888888;">因为引擎文件应该不会很大</span></p>
<p><span style="color: #888888;">如果使用SeaJs组织，则文件数会过多（每个模块有多个文件），在使用引擎时会引入过多的模块文件，增加学习成本和代码复杂度</span></p>
<p><span style="color: #888888;">&nbsp;</span></p>
<p><span style="color: #888888;">l&nbsp; 通过命名空间的方式，将引擎组织为一个整体</span></p>
<p><span style="color: #888888;">每个命名空间即为一个模块。如Sprite命名空间包含了精灵模块的所有类</span></p>
<p><span style="color: #888888;">可提供压缩的min版本和简化的simple版本</span></p>
<p><span style="color: #888888;">&nbsp;</span></p>
<p><span style="color: #888888;">使用seaJs组织</span></p>
<p><span style="color: #888888;">&nbsp;</span></p>
<p>&nbsp;</p>
<p>文件组织方式一般有两种：</p>
<p>1、使用js模块加载器。在沙箱环境中，将需要引用的文件加载进来，然后通过局部变量名来使用。</p>
<p>2、使用命名空间。</p>
<p>本引擎采用命名空间的方式来组织文件，引擎的顶级命名空间为YE。这是因为引擎文件数不是很多，还不需要用模块加载器。如果使用模块加载器，在使用引擎时会引入过多的模块文件，增加学习成本和代码复杂度。</p>
<p>&nbsp;</p>
<h2><span style="color: #c0c0c0;">名词表</span></h2>
<p><span style="color: #c0c0c0;">l&nbsp; 用户</span></p>
<p><span style="color: #c0c0c0;">指引擎使用方</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">引擎组织方式</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p>&nbsp;</p>
<h2>引擎名</h2>
<p><span style="color: #c0c0c0;">YEngine2D</span></p>
<p><span style="color: #c0c0c0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 命名空间</span></p>
<p><span style="color: #c0c0c0;">YE</span></p>
<p>&nbsp;</p>
<p>该引擎命名为YEngine2D。</p>
<p>&nbsp;</p>
<h2>技术选择</h2>
<p>使用javascript语言</p>
<p>使用html5技术</p>
<p>使用了html5的canvas作为底层绘制api</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>引擎外部依赖</strong></p>
<p>引擎需要依赖YOOP和jsExtend库（jsExtend不再是引擎的文件，而是作为依赖文件</p>
<p>&nbsp;</p>
<ul>
<li>YOOP（命名空间：YYC.Class、YYC.AClass、YYC.Interface）<br />这是我的Javascript的oop框架。具体可参见<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/archive/2013/06/07/3123999.html">发布我的Javascript OOP框架YOOP v1.0</a></li>
<li>jsExtend</li>















</ul>
<p>Javascript原生对象扩展<br />位于object_extend.js文件中，包括了对String和Array对象的扩展。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a name="structure"></a></p>
<p>&nbsp;</p>
<p><strong>代码结构</strong></p>
<p>&nbsp;</p>
<p><strong>引擎放在yEngine目录下</strong></p>
<p><strong>图</strong></p>
<p>&nbsp;</p>
<ul>
<li>Content<br />炸弹人游戏的资源文件
<ul>
<li>Image<br />图片资源文件</li>















</ul>















</li>















</ul>
<p>&nbsp;</p>
<ul>
<li>Script<br />js文件View
<ul>
<li>bomber<br />炸弹人js</li>
<li>jasmine
<ul>
<li>lib<br />jasmine框架库文件</li>
<li>spec<br />游戏的测试文件</li>
<li>src<br />测试的工具方法</li>















</ul>















</li>
<li>myTool<br />我的javascript库、控件、工具箱等plugIn
<ul>
<li>control<br />控件</li>
<li>extend<br />javascript原生对象扩展</li>
<li>frame<br />YOOP框架</li>
<li>pattern<br />模式库</li>
<li>tool<br />工具箱</li>















</ul>















</li>
<li><br />外部插件</li>















</ul>















</li>
<li><br />html页面</li>















</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>引擎设计原则</p>
<p>1、引擎应该是个独立组件，不依赖用户，用户应该依赖引擎</p>
<p style="text-align: center;">图&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>引擎开发要求</p>
<p>1、可测试性</p>
<p>引擎是一个可复用的组件，必须保证其正确和可测试。</p>
<p>方案：编写引擎全覆盖的单元测试。</p>
<p>2、可扩展性</p>
<p>目前提炼出来的引擎还不完善，后续会加入更多的功能，因此需要具有灵活的架构，满足开闭原则。</p>
<p>方案：使用面向对象设计，基于高内聚低耦合的总体思想，并可复用炸弹人游戏中可扩展性的模块来提炼引擎。</p>
<p>&nbsp;</p>
<p>3、可读性</p>
<p>引擎应该具备良好的可读性，这样在后续开发时可易于理解之前的设计，也方便他人阅读理解引擎设计。</p>
<p>方案：保持代码整洁，只保留必要的注释，编写必要的文档，通过命名和测试用例来辅助读者理解代码。&nbsp;</p>
<p>&nbsp;</p>
<p>引擎提炼目标</p>
<p>得到一个初步的2D游戏引擎，该引擎具备通用性和复用性。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>（说明what什么是、how怎样具备、why为什么要具备、where&nbsp;通用性/复用性使用场景？怎样才是具备了通用性/复用性？）</p>
<p>通用性</p>
<p>&nbsp;</p>
<p>复用性</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>&nbsp;</h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>策略</h2>
<p>l&nbsp; 分成多次迭代。</p>
<p>n&nbsp; 第一次迭代<br />
提出Core模块，提炼出类和主要的成员，将component、algorithm、event中的组件提出，包括游戏入口、预加载、主循环、层、精灵、动画、事件管理等<br />
对炸弹人游戏进行相应修改并测试通过。</p>
<p>n&nbsp;
第二次迭代<br />
对Core模块进一步提炼，提出共同的模式、成员，如提出Director的gameOver和gameWin方法、提出层的change状态及其管理等<br />
对炸弹人游戏进行相应修改并测试通过。</p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">l&nbsp;
先使用命名空间方式来组织代码，然后再改成SeaJs来组织</span></p>
<p>&nbsp;</p>
<p>测试策略&nbsp;</p>
<p>引擎单元测试全覆盖，游戏运行测试能够通过即可</p>
<p>不再使用TDD开发，而是：提炼引擎-&gt;基于引擎修改炸弹人代码-&gt;对游戏进行运行测试-&gt;对引擎进行单元测试（<span style="color: #ff0000;">要画成一个循环图</span>），其中引擎的单元测试可以复用炸弹人游戏的单元测试</p>
<p>&nbsp;</p>
<h2>思考</h2>
<p><span style="color: #c0c0c0;">1、应该保留Main吗？预加载和onload在引擎中应该如何规划？</span></p>
<p><span style="color: #c0c0c0;">见Main和Loader类</span></p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">导演类的职责和其他类的关系？</span></p>
<p>&nbsp;</p>
<p>1、炸弹人游戏改用引擎时，是否需要修改已有的炸弹人游戏测试？</p>
<p>l&nbsp; 目前在学习阶段，引擎变动频繁。引擎变动也会导致使用引擎的炸弹人游戏变动。因此，修改已有测试工作量大，且维护的工作量也大。</p>
<p>l&nbsp; 我并不会继续扩展炸弹人游戏，因此也不再需要对炸弹人游戏的测试。</p>
<p>l&nbsp; 因为我会继续使用引擎开发&ldquo;古代战争&rdquo;，所以重点是引擎。所以只针对引擎进行测试。</p>
<p>综上所述，对引擎进行单元测试，不再修改已有的炸弹人游戏测试，而是直接通过浏览器运行炸弹人游戏来进行测试。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>2、是应该提出一个通用的引擎，还是具体于&ldquo;炸弹人游戏&rdquo;这个类型的引擎？</p>
<p>因为我提炼引擎的目的是为了更好地开发&ldquo;古代战争&rdquo;，而不是继续开发&ldquo;炸弹人&rdquo;，所以应该提出一个最基本的、能适用于&ldquo;炸弹人&rdquo;和&ldquo;古代战争&rdquo;的引擎。</p>
<p>&nbsp;</p>
<p>/*</p>
<p>这个放到具体迭代中遇到相应问题时，再讨论</p>
<p><span style="color: #c0c0c0;">用户是采用钩子还是继承来实现游戏逻辑？找到用户使用引擎的方法</span></p>
<p><span style="color: #c0c0c0;">我研究了Cocos2D-html5、lufylegend、EaselJS以及《Html5 Canvas核心技术》中的游戏引擎，Cocos2D-html5、lufylegend采用继承重写，EaselJS、《Html5 Canvas核心技术》采用实例重写。</span></p>
<p><span style="color: #c0c0c0;">因此，有两种方式：</span></p>
<p><span style="color: #c0c0c0;">l&nbsp; 实例重写</span></p>
<p><span style="color: #c0c0c0;">l&nbsp; 继承重写</span></p>
<p><span style="color: #c0c0c0;">能扩展已有的方法</span></p>
<p><span style="color: #c0c0c0;">能利用继承的好处（如代码复用，创建子类等）</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">继承重写：</span></p>
<p><span style="color: #c0c0c0;">将被重写的引擎类的钩子成员设成Abstract，可被扩展的方法设成Virtual</span></p>
<p><span style="color: #c0c0c0;">被重写的引擎类提供基本框架（使用模板模式）、基本方法和属性</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">当前我选用的方式：</span></p>
<p><span style="color: #c0c0c0;">目前Main、Director采用重写实例的方式，其它类（如Layer等）采用继承重写的方式。后期需要修改Main、Director（见&ldquo;待修改的地方&rdquo;）</span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><span style="color: #c0c0c0;">onxxx钩子方法（如onenter）是专门提供给用户实现的事件处理器，用户可以完全控制；而其余可供用户重写的钩子方法则需要用户先调用&ldquo;this.base()&rdquo;</span></p>
<p>*/</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>领域模型分析</h1>
<p>&nbsp;</p>
<p>精简模型</p>
<p>对炸弹人游戏的领域模型进行精简，去掉具体的实现类，只保留必要的体现整个概念层次结构的和游戏框架的类。</p>
<p align="center">图</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>抽象模型</p>
<p>对精简模型进行抽象，提出抽象角色类（一个角色类可能代表多个具体类，如DataOperate类，在炸弹人游戏的类中就代表了MapDataOperate、GetPath等类）。</p>
<p style="text-align: center;">图</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>下面的说明还要更抽象一般化点！&nbsp;</p>
<p>Config</p>
<p>全局配置类，存放游戏中的常量、枚举值、配置信息。</p>
<p>LoadResource</p>
<p>加载资源的类。</p>
<p>负责加载各种资源，具体可以是图片预加载类或者音效预加载类等</p>
<p>&nbsp;</p>
<p>Main</p>
<p>提供入口框架，负责资源加载的管理，并提供一个入口方法，作为整个游戏的入口。</p>
<p><span style="color: #c0c0c0;">该类负责游戏初始化和启动</span>，<span style="color: #c0c0c0;">Html页面只与该类耦合，该类是整个系统的入口。</span></p>
<p>&nbsp;</p>
<p>Director</p>
<p>（重命名为Director</p>
<p>分析&ldquo;Game&rdquo;这个名字，其并不能体现&ldquo;统一调度&rdquo;的职责，因此将其命名为&ldquo;Director&rdquo;更为合适。)</p>
<p>游戏主逻辑类。</p>
<p>负责游戏的统一调度。</p>
<p>&nbsp;</p>
<p>Scene</p>
<p>（重命名为Scene</p>
<p>参考业内的领域概念，将LayerManager重命名为Scene场景。 ）</p>
<p>场景类，为集合类，集合元素为Layer实例。</p>
<p>该类负责统一管理Layer。</p>
<p>&nbsp;</p>
<p>Hash&nbsp;</p>
<p>&nbsp;</p>
<p>Layer</p>
<p>层类，为集合类，集合元素为Sprite实例。</p>
<p>Layer负责本层所有精灵的绘制和初始化等操作，对层内精灵进行统一管理。</p>
<p>该类对应&ldquo;分层渲染&rdquo;的概念，每个Layer都有自己的画布canvas，一个Layer就对应界面的一层画布。</p>
<p>&nbsp;</p>
<p>Collection</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Sprite</p>
<p>精灵类。</p>
<p>每一个单独的个体都是一个精灵类。如玩家、敌人、炸弹等。</p>
<p>与该个体密切相关的属性和方法都放到该类中。</p>
<p>&nbsp;</p>
<p>AI</p>
<p>人工智能类。</p>
<p>负责电脑AI部分，具体可以包括寻路算法、电脑人物的移动模式、电脑人物的行为设置等。</p>
<p>&nbsp;</p>
<p>Factory</p>
<p>工厂类。</p>
<p>负责创建类的实例，封装类的创建逻辑，解除类之间的耦合。</p>
<p>&nbsp;</p>
<p>Animation</p>
<p><span style="color: #888888;">动画相关类。</span></p>
<p><span style="color: #000000;">帧动画控制类</span></p>
<p>负责<span style="color: #888888;">动画相关的操作读取、配置、更新帧数据，</span>控制帧动画的播放。</p>
<p>&nbsp;</p>
<p>DataOperate</p>
<p>数据操作类。</p>
<p>负责对数据进行读、写等操作。</p>
<p>&nbsp;</p>
<p>Data</p>
<p>游戏中的数据，可以是保存在内存中的数据（如数据容器类），也可以是保存在数据库的数据（如关系数据库的表数据）。</p>
<p>&nbsp;</p>
<p>EventState</p>
<p>事件状态类，是一个数据容器类。</p>
<p>用于保存事件的触发状态。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>EventManager</p>
<p>事件管理类。</p>
<p>负责监听事件，并管理事件状态类。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>给出引擎的初步领域模型</p>
<p><span style="color: #c0c0c0;">分析炸弹人的抽象模型，其中DataOperate、Data与具体的游戏逻辑相关，不属于通用的部分，应该剔除。</span></p>
<p>&nbsp;</p>
<p>增加Tool类</p>
<p>因为引擎的外部依赖设计为不依赖YTool，而炸弹人是依赖于YTool的，所以引擎增加Tool类，在提炼引擎类时将依赖的YTool的方法全部移到Tool类中，放到YE.Tool命名空间，从而将引擎对YTool的依赖变为对Tool的依赖。</p>
<p>Tool类还应该负责引擎的通用方法。</p>
<p>&nbsp;</p>
<p>因此，引擎的初步领域模型为：</p>
<p>&nbsp;</p>]]></description></item><item><title>博文模板2</title><link>http://www.cnblogs.com/chaogex/archive/2014/08/03/3888541.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sun, 03 Aug 2014 08:36:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2014/08/03/3888541.html</guid><description><![CDATA[<p><strong>前言</strong></p>
<p>&nbsp;</p>
<p><strong>说明</strong></p>
<p>&nbsp;</p>
<p><strong>本文目的</strong></p>
<p>&nbsp;</p>
<p><strong>本文主要内容</strong></p>
<p>&nbsp;</p>
<p><strong>回顾上文更新后的领域模型</strong></p>
<p>&nbsp;</p>
<p><strong>对领域模型进行思考</strong></p>
<p>&nbsp;</p>
<p><strong>开发策略</strong></p>
<p>&nbsp;</p>
<p><strong>正文</strong></p>
<p><strong>又可以分成很多个部分，如：</strong></p>
<ul>
<li><a style="font-size: 14px; line-height: 1.5;" href="http://www.cnblogs.com/chaogex/p/3327097.html#firstCheck">初步实现碰撞检测</a></li>
<li><a href="http://www.cnblogs.com/chaogex/p/3327097.html#setMoveIndex">设置移动步长</a></li>
<li><a href="http://www.cnblogs.com/chaogex/p/3327097.html#secondCheck">继续完成碰撞检测</a></li>
<li><a href="http://www.cnblogs.com/chaogex/p/3327097.html#refactor">重构</a></li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>本文最终完整的领域模型</strong></p>
<p>&nbsp;</p>
<p><strong>高层划分</strong></p>
<p>&nbsp;</p>
<p><strong>本文源码下载</strong></p>
<p>&nbsp;</p>
<p><strong>演示地址</strong></p>
<p>&nbsp;</p>
<p><strong>本文参考资料</strong></p>
<p>&nbsp;</p>
<p><strong>欢迎浏览下一篇博文：</strong></p>
<p>&nbsp;</p>
<p>版本xx-xx</p>]]></description></item><item><title>HTML5技术实验系列</title><link>http://www.cnblogs.com/chaogex/archive/2013/11/13/3422055.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Wed, 13 Nov 2013 11:50:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/11/13/3422055.html</guid><description><![CDATA[<p>待补充</p>]]></description></item><item><title>我对Stub和Mock的理解</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/25/3388386.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Fri, 25 Oct 2013 14:55:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/25/3388386.html</guid><description><![CDATA[<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">介绍</span></strong></p>
<p>使用测试驱动开发大半年了，我还是对Stub和Mock的认识比较模糊，没有进行系统整理。</p>
<p>今天查阅了相关资料，觉得写得很不错，所以我试图在博文中对资料进行整理一下，再加上一些自己的观点。</p>
<p>本文是目前我对Stub和Mock的认识，难免有偏差，欢迎大家拍砖。</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">分析</span></strong></p>
<p>Stub和Mock都是属于测试替身，对类型细分的话可以分为：</p>
<ul>
<li><span>Dummy Object</span></li>
<li><span>Fake Object</span></li>
<li>Test Stub</li>
<li>Test Spy</li>
<li>Mock Object</li>
</ul>
<p>前四项属于Stub，最后的Mock Object属于Mock。</p>
<h1>类型分析</h1>
<h2>Dummy Object（哑对象）</h2>
<p><span style="line-height: 1.5;">测试代码仅仅是需要使用它来通过编译，</span><span style="line-height: 1.5;">实际上用不到它。如测试A类的run方法，需要在创建A类的实例时需要传入B类实例，但run方法并没有用到B类实例。在测试时需要传入B类的哑对象new NullB()（如&ldquo;new A(new NullB())&rdquo;），让其通过编译。这里的NullB是一个空类，没有具体实现。</span></p>
<h2><span>Fake Object（假对象）</span></h2>
<p><span>假对象相对于哑对象来说，要对耦合的组件有一些简单的实现，实现我们在测试中要用到的方法，指定期望的行为（如返回期望的值）。假对象适用于替换产品代码中使用的全局对象，或者创建的类。这里注意的是要先对被替换的全局对象或类进行备份，然后在测试完成后进行恢复。</span></p>
<p><span>示例1（替换全局对象）：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">产品代码</span>
<span style="color: #000000;">function A(){
    </span><span style="color: #0000ff;">this</span>.num = <span style="color: #800080;">0</span><span style="color: #000000;">;
}
A.prototype.run </span>=<span style="color: #000000;"> function(){
   </span><span style="color: #0000ff;">this</span>.num =<span style="color: #000000;"> window.b.getNum();
};

</span><span style="color: #008000;">//</span><span style="color: #008000;">测试代码</span>
describe(<span style="color: #800000;">"</span><span style="color: #800000;">测试A类的run方法</span><span style="color: #800000;">"</span><span style="color: #000000;">, function(){
    </span><span style="color: #0000ff;">var</span> temp = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    function backUp(){
        window.b </span>= window.b ||<span style="color: #000000;"> {};
        temp </span>=<span style="color: #000000;"> YYC.Tool.extendDeep(window.b);
    }
    function restore(){
        window.b </span>=<span style="color: #000000;"> temp;
    }

    beforeEach(function(){
        backUp();
    });
    afterEach(function(){
        restore();
    });

    it(</span><span style="color: #800000;">"</span><span style="color: #800000;">获得数字</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        window.b </span>= {    <span style="color: #008000;">//</span><span style="color: #008000;">假对象</span>
<span style="color: #000000;">            getNum: function(){
                </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }

        </span><span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> A();
        a.run();

        expect(a.num).toEqual(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
    });
});</span></pre>
</div>
<p><span>示例2（替换类）：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">产品代码</span>
<span style="color: #000000;">function A() {
    </span><span style="color: #0000ff;">this</span>.num = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">this</span>._b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
}
A.prototype.run </span>=<span style="color: #000000;"> function () {
    </span><span style="color: #0000ff;">this</span>.num = <span style="color: #0000ff;">this</span><span style="color: #000000;">._b.getNum();
};

</span><span style="color: #008000;">//</span><span style="color: #008000;">测试代码</span>
describe(<span style="color: #800000;">"</span><span style="color: #800000;">测试A类的run方法</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
    </span><span style="color: #0000ff;">var</span> temp = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    function backUp() {
        window.B </span>= window.B ||<span style="color: #000000;"> function () {};
        temp </span>=<span style="color: #000000;"> B;
    }

    function restore() {
        window.B </span>=<span style="color: #000000;"> temp;
    }

    beforeEach(function () {
        backUp();
    });
    afterEach(function () {
        restore();
    });

    it(</span><span style="color: #800000;">"</span><span style="color: #800000;">获得数字</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        window.B </span>=<span style="color: #000000;"> function () {
        };
        window.B.prototype.getNum </span>=<span style="color: #000000;"> function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
        };

        </span><span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> A();
        a.run();

        expect(a.num).toEqual(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
    });
});</span></pre>
</div>
<h2><span>Test Stub（测试桩）</span></h2>
<p>测试桩与假对象有点类似，也要实现与产品代码耦合的组件，指定期望的行为。这里最大的不同是测试桩需要注入到产品代码中，从而在测试产品代码时替换组件，执行桩的行为。使用测试桩不需要进行备份和还原。</p>
<p>示例：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">产品代码</span>
<span style="color: #000000;">function A(b) {
    </span><span style="color: #0000ff;">this</span>.num = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">this</span>._b =<span style="color: #000000;"> b;
}
A.prototype.run </span>=<span style="color: #000000;"> function () {
    </span><span style="color: #0000ff;">this</span>.num = <span style="color: #0000ff;">this</span><span style="color: #000000;">._b.getNum();
};

</span><span style="color: #008000;">//</span><span style="color: #008000;">测试代码</span>
describe(<span style="color: #800000;">"</span><span style="color: #800000;">测试A类的run方法</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
    it(</span><span style="color: #800000;">"</span><span style="color: #800000;">获得数字</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        </span><span style="color: #0000ff;">var</span> stub_B = {  <span style="color: #008000;">//</span><span style="color: #008000;">B类的桩</span>
<span style="color: #000000;">            getNum: function(){
                </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        };

        </span><span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span> A(stub_B); <span style="color: #008000;">//</span><span style="color: #008000;">注入桩</span>
<span style="color: #000000;">        a.run();

        expect(a.num).toEqual(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
    });
});</span></pre>
</div>
<h2>Test Spy（嗅探桩）</h2>
<p><span>与测试桩类似，但是可以记录桩使用的记录，并进行验证。</span></p>
<p><span>示例：</span></p>
<p><span>可以使用jasmine的spy来举例。</span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">产品代码</span>
<span style="color: #000000;">function A(b) {
    </span><span style="color: #0000ff;">this</span>.num = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">this</span>._b =<span style="color: #000000;"> b;
}
A.prototype.run </span>=<span style="color: #000000;"> function () {
    </span><span style="color: #0000ff;">this</span>.num = <span style="color: #0000ff;">this</span><span style="color: #000000;">._b.getNum();
};

</span><span style="color: #008000;">//</span><span style="color: #008000;">测试代码</span>
describe(<span style="color: #800000;">"</span><span style="color: #800000;">测试A类的run方法</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
    it(</span><span style="color: #800000;">"</span><span style="color: #800000;">获得数字</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        </span><span style="color: #0000ff;">var</span> stub_b =<span style="color: #000000;"> {
            getNum: function(){
                </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        };
        spyOn(stub_b, </span><span style="color: #800000;">"</span><span style="color: #800000;">getNum</span><span style="color: #800000;">"</span>).andCallThrough();   <span style="color: #008000;">//</span><span style="color: #008000;">嗅探桩的getNum方法</span>

        <span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span> A(stub_b); <span style="color: #008000;">//</span><span style="color: #008000;">注入桩</span>
<span style="color: #000000;">        a.run();

        expect(a.num).toEqual(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
        expect(stub_b.getNum).toHaveBeenCalled();   </span><span style="color: #008000;">//</span><span style="color: #008000;">验证调用过桩的getNum方法</span>
<span style="color: #000000;">    });
});</span></pre>
</div>
<h2><span>Mock Object（<span>模拟对象</span>）</span></h2>
<p><span>设定产品代码中耦合的类的期望的行为，然后验证期望的行为是否发生，从而达到测试产品代码行为的目的。<span>适用于验证一些void的行为。例如：在某个条件发生时，要记录Log。这种情景，用stub就很难验证，因为对目标物件来说，沒有回传值，也沒有状态变化，就只能通过mock object來验证目标物件是否正确的与Log介面进行互动。</span></span></p>
<p><span><span>示例：</span></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">产品代码</span>
<span style="color: #000000;">function A(b) {
    </span><span style="color: #0000ff;">this</span>.num = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">this</span>._b =<span style="color: #000000;"> b;
}
A.prototype.run </span>=<span style="color: #000000;"> function () {
    </span><span style="color: #0000ff;">this</span>.num = <span style="color: #0000ff;">this</span>._b.getNum(<span style="color: #800080;">2</span>);
<span style="color: #000000;">};

</span><span style="color: #008000;">//</span><span style="color: #008000;">测试代码（Mock为伪代码）</span>
describe(<span style="color: #800000;">"</span><span style="color: #800000;">测试A类的run方法</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
    it(</span><span style="color: #800000;">"</span><span style="color: #800000;">获得数字</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        </span><span style="color: #0000ff;">var</span> mockB =<span style="color: #000000;"> Mock.createMock({
            getNum: function(){}
        }); </span><span style="color: #008000;">//</span><span style="color: #008000;">如果B类存在的话，也可以直接传入B的原型：var mockB = Mock.createMock(B.prototype);</span>
        Mock.expect(mockB.getNum, <span style="color: #800080;">2</span>).<span style="color: #0000ff;">return</span>(<span style="color: #800080;">1</span>).times(<span style="color: #800080;">1</span><span style="color: #000000;">);

        </span><span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> A(mockB);
        a.run();

        expect(a.num).toEqual(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
        Mock.verify();  </span><span style="color: #008000;">//</span><span style="color: #008000;">验证期望的行为发生：mockB的getNum传入的参数为2；调用了1次mockB.getNum</span>
<span style="color: #000000;">    });
});</span></pre>
</div>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">Mock（Mock Object）与Spy（Test Spy）的比较</span></strong></p>
<p>相同点</p>
<ul>
<li>都要注入到产品代码中。</li>
</ul>
<p>不同的</p>
<ul>
<li>Mock是替换整个被Mock的类，这个类可以存在也可以不存在。而Spy是使用一个已经存在的类，嗅探其中的部分方法。</li>
<li>从流程中来说，Mock是先设定被Mock的类的期望行为，然后验证期望的行为是否发生。Spy是记录下桩的方法的使用记录（如传入的参数，调用的次数等），然后再对记录进行验证。</li>
</ul>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">Mock退化为Stub</span></strong></p>
<div><span style="line-height: 1.5;">在现实使用中，我们经常将mock做不同程度的退化，从而使得mock对象在某些程度上如stub一样工作。</span></div>
<div><span style="line-height: 1.5;">使用Mock的示例：</span></div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">产品代码</span>
<span style="color: #000000;">function A(b) {
    </span><span style="color: #0000ff;">this</span>.num = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">this</span>._b =<span style="color: #000000;"> b;
}
A.prototype.run </span>=<span style="color: #000000;"> function () {
    </span><span style="color: #0000ff;">this</span>.num = <span style="color: #0000ff;">this</span>._b.getNum(<span style="color: #800080;">2</span><span style="color: #000000;">);
};

</span><span style="color: #008000;">//</span><span style="color: #008000;">测试代码（Mock为伪代码）</span>
describe(<span style="color: #800000;">"</span><span style="color: #800000;">测试A类的run方法</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
    it(</span><span style="color: #800000;">"</span><span style="color: #800000;">获得数字</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        </span><span style="color: #0000ff;">var</span> mockB =<span style="color: #000000;"> Mock.createMock({
            getNum: function(){}
        }); </span><span style="color: #008000;">//</span><span style="color: #008000;">如果B类存在的话，也可以直接传入B的原型：var mockB = Mock.createMock(B.prototype);</span>
        Mock.expect(mockB.getNum).<span style="color: #0000ff;">return</span>(<span style="color: #800080;">1</span>);    <span style="color: #008000;">//</span><span style="color: #008000;">只指定返回值，没有期望的参数或期望调用的次数。因此不用verify来验证了！</span>

        <span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> A(mockB);
        a.run();

        expect(a.num).toEqual(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
    });
});</span></pre>
</div>
<p>也可以用Stub来达到相同的效果：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">产品代码</span>
<span style="color: #000000;">function A(b) {
    </span><span style="color: #0000ff;">this</span>.num = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">this</span>._b =<span style="color: #000000;"> b;
}
A.prototype.run </span>=<span style="color: #000000;"> function () {
    </span><span style="color: #0000ff;">this</span>.num = <span style="color: #0000ff;">this</span>._b.getNum(<span style="color: #000000;">);
};

</span><span style="color: #008000;">//</span><span style="color: #008000;">测试代码</span>
describe(<span style="color: #800000;">"</span><span style="color: #800000;">测试A类的run方法</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
    it(</span><span style="color: #800000;">"</span><span style="color: #800000;">获得数字</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        </span><span style="color: #0000ff;">var</span> stub_B =<span style="color: #000000;"> {
            getNum: function(){
                </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        };

        </span><span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> A(stub_B);
        a.run();

        expect(a.num).toEqual(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
    });
});</span></pre>
</div>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">总结</span></strong></p>
<p>在比较简单的情况下（如需要哑对象来通过编译，或是需要测试桩来替换耦合的组件），使用Stub。</p>
<p>如果需要验证耦合组件的行为，可以使用Spy或Mock。</p>
</div>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">参考资料</span></strong></p>
<p><span class="link_title"><a href="http://blog.csdn.net/lilybear101/article/details/6938646">软件测试- 3 - Mock 和Stub的区别</a></span></p>
<p><a id="viewpost1_TitleUrl" href="http://www.blogjava.net/aoxj/archive/2010/08/26/329975.html">浅谈mock和stub</a></p>
<p>《xUnit测试模式--测试码重构》</p>]]></description></item><item><title>炸弹人游戏开发系列（9）：总结</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/21/3343198.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Mon, 21 Oct 2013 10:01:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/21/3343198.html</guid><description><![CDATA[<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">心得、体会</span></strong></p>
<p>终于到了系列最后1篇了，到此为止整个炸弹人游戏的开发就结束了~</p>
<p>从今年6月份开始写，到现在10月份完成，全部加在一起实际花了2个多月的时间来完成炸弹人系列博文的创作。在本系列的博文中，我一直试图向大家展现我的思考过程，并把重点放在了设计和重构上。相信大家在看完本系列后，对游戏开发、面向对象、迭代和重构应该有了一些基本的了解。</p>
<p>非常感谢博客园，给了我一个展示的窗口！同时也对博客园的编辑赞一个！我的系列第2篇和第7篇博文本来只发到了候选区，被好心的编辑移到了首页！非常感谢博客园的各位朋友，大家都很热情友好，你们的支持是我创作的动力，非常感谢大家！</p>
<p>如果您想继续研究面向对象思想，您可以先看看《冒号课堂-编程范式与OOP思想》中关于OOP的讲解，学习面向对象中的基本理念，然后再看看《敏捷软件开发：原则、模式与实践》，学习运用面向对象思想和敏捷方法开发的实例。看完上面两本书后，您就可以开始实践了，尝试在项目开发中运用面向对象思想。</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">不足之处</span></strong></p>
<ul>
<li>在开发的后期，由于时间紧迫，测试不够完善。</li>
<li>测试代码中对桩对象和mock技术运用得不好，测试代码之间耦合较强。</li>
</ul>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">可以改进之处</span></strong></p>
<p>因为本系列博文是在我完成了炸弹人游戏开发后，通过查看SVN记录来整理创作的，因此在系列博文写作中获得的经验，并不能很方便地反馈到炸弹人游戏代码的改进中（如果修改了SVN某个版本的代码，则后面的代码也都要对应修改，这样工作量很大）。</p>
<p>在下个系列博文的写作中，我会边开发边写博文。这样开发和写博文可以互相反馈，增加代码和博文的质量。</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">结语</span></strong></p>
<p>由于我经验尚浅，在博文中会有这样或那样的不足，欢迎大家及时告知，以便于我尽快修正。</p>
<p>希望与大家一起分享经验，一起来体会开发中的乐趣~</p>
<p>祝大家快乐学习，快乐生活！</p>
<h1>欢迎浏览上一篇博文：<a href="http://www.cnblogs.com/chaogex/p/3336783.html">炸弹人游戏开发系列（8）：放炸弹</a></h1>]]></description></item><item><title>炸弹人游戏开发系列（8）：放炸弹</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/21/3336783.html</link><dc:creator>yyc元超</dc:creator><author>yyc元超</author><pubDate>Mon, 21 Oct 2013 03:51:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/21/3336783.html</guid><description><![CDATA[<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">前言</span></strong></p>
<p>上文中我们加入了1个敌人，使用A*算法寻路。本文会给我们的炸弹人增加放炸弹的能力。</p>
<h1>说明</h1>
<h2>名词解释</h2>
<ul>
<li>xx类族<br /><span style="font-size: 14px; line-height: 1.5;">是指以xx为基类的继承树上的所有类。</span></li>














</ul>
<h1><strong><span>本文目的</span></strong></h1>
<p>实现&ldquo;放炸弹&rdquo;功能</p>
<p>增加1个敌人，即一共有2个敌人追踪炸弹人</p>
<h1><strong><span>本文主要内容</span></strong></h1>
<p>&nbsp;</p>
<ul>
<li><a href="#strategy">开发策略</a></li>
<li><a href="#show"><strong><span>显示炸弹和火焰</span></strong></a></li>
<li><a href="#observer"><strong><span>使用观察者模式</span></strong></a></li>
<li><a href="#refactor">重构</a></li>
<li><a href="#explode"><strong><span>炸弹可以炸死炸弹人和敌人</span></strong></a></li>
<li><a href="#move">移动时放炸弹</a></li>
<li><a href="#more">放置多个炸弹</a></li>
<li><a href="#change">改变地图</a></li>
<li><a href="#summary">小结</a></li>
<li><a href="#add">加入1个敌人</a></li>
<li><a href="#model">本文最终领域模型</a></li>
<li><a href="#demo">演示</a></li>
<li><a href="#reference">本文参考资料</a></li>











</ul>
<h1><strong><span>回顾上文更新后的领域模型</span></strong></h1>
<p><img src="http://images.cnitblog.com/blog/419321/201311/28133007-c8c1312f315b4497b79daee465892a42.jpg" alt="" width="721" height="381" /></p>
<p><a href="http://images.cnitblog.com/blog/419321/201311/28133007-c8c1312f315b4497b79daee465892a42.jpg" target="_blank">查看大图</a></p>
<h1>对领域模型进行思考</h1>
<h2>Layer类族的render方法改名为run</h2>
<p>Layer的render方法负责统一调用Layer的方法，在概念上属于<a href="http://www.cnblogs.com/chaogex/p/3163357.html#actor">Actor</a>，因此将其改名为run。</p>
<p>
<a name="strategy"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">开发策略</span></strong></p>
<p>首先实现&ldquo;放炸弹&rdquo;功能。把这个功能分解成很多个子功能，一个一个地实现子功能。</p>
<p>然后再加入1个敌人。实际上就是在Game中往EnemyLayer集合中再加入一个EnemySprite实例，SpriteData增加第2个敌人的数据，SpriteFactory增加工厂方法createEnemy2。</p>
<h1>放炸弹流程</h1>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/419321/201309/24142637-2ddb81d59ce64c0aa69dd8e5add136ed.jpg" alt="" /></p>
<h1>功能分解</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/21112932-edebea63527742f18c9372646c187031.jpg" alt="" /></p>
<p>
<a name="show"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">显示炸弹和火焰</span></strong></p>
<h1>显示炸弹</h1>
<p>首先来实现&ldquo;地图上显示炸弹&rdquo;的功能，目前最多显示1个炸弹，玩家、敌人不能穿过炸弹。如果玩家处于炸弹方格中，则敌人会原地等待，玩家离开后，敌人继续追踪。</p>
<h2>增加图片</h2>
<p>增加图片bomb.png：</p>
<p><img src="http://images.cnitblog.com/blog/419321/201309/24203018-a0eccd1cdb35432bb76b430cb49f5e16.png" alt="" /></p>
<h2>增加BomberSprite</h2>
<p>增加炸弹精灵类BomberSprite：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> BombSprite =<span style="color: #000000;"> YYC.Class(Sprite, {
        Init: function (data, bitmap) {
            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span>(<span style="color: #0000ff;">null</span><span style="color: #000000;">, bitmap);
        },
        Public: {
            draw: function (context) {
                context.drawImage(</span><span style="color: #0000ff;">this</span>.bitmap.img, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span>.y, <span style="color: #0000ff;">this</span>.bitmap.width, <span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.height);
            },
            clear: function (context) {
                    context.clearRect(</span><span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
            }
        }
    });

    window.BombSprite </span>=<span style="color: #000000;"> BombSprite;
}());</span></pre>
</div>
<h2>增加BombLayer</h2>
<p>在画布上增加炸弹层。同时增加对应的BombLayer类，它的集合元素为BombSprite类的实例。</p>
<p>将玩家、敌人画布Canvas的zIndex设为3，炸弹画布的zIndex设为1，使得，炸弹画布位于地图画布（zIndex为0）之上，玩家和敌人画布之下。</p>
<p>BomberLayer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> BombLayer =<span style="color: #000000;"> YYC.Class(Layer, {
        Private: {
            ___hasBomb: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.getChilds().length &gt; <span style="color: #800080;">0</span><span style="color: #000000;">;
            },
            ___render: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.___hasBomb()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.clear();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.draw();
                }
            }
        },
        Public: {
            setCanvas: function () {
                </span><span style="color: #0000ff;">this</span>.P__canvas = document.getElementById(<span style="color: #800000;">"</span><span style="color: #800000;">bombLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">var</span> css =<span style="color: #000000;"> {
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">1</span><span style="color: #000000;">
                };

                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#bombLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">).css(css);
            },
            draw: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">draw</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
            },
            clear: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">clear</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
            },
            run: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___render();
            }
        }
    });

    window.BombLayer </span>=<span style="color: #000000;"> BombLayer;
}());</span></pre>
</div>
<h2>增加工厂方法</h2>
<p>SpriteFactory增加创建炸弹精灵类实例的工厂方法。</p>
<p>LyaerFactory增加创建炸弹层实例的工厂方法。</p>
<p>SpriteFactory</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">       createBomb: function (playerSprite) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> BombSprite(playerSprite, bitmapFactory.createBitmap({ img: window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">bomb</span><span style="color: #800000;">"</span><span style="color: #000000;">), width: bomberConfig.WIDTH, height: bomberConfig.HEIGHT }));
        },</span></pre>
</div>
<p>LayerFactory</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">    createBomb: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> BombLayer();
        },</span></pre>
</div>
<h2>修改PlayerSprite</h2>
<p>PlayerSprite增加createBomb方法：</p>
<div class="cnblogs_code">
<pre>           bombNum: <span style="color: #800080;">0</span><span style="color: #000000;">,
...
            createBomb: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.moving || <span style="color: #0000ff;">this</span>.bombNum === <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">var</span> bomb =<span style="color: #000000;"> spriteFactory.createBomb();

                bomb.x </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.x;
                bomb.y </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.y;

                </span><span style="color: #0000ff;">this</span>.bombNum += <span style="color: #800080;">1</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> bomb;
            }</span></pre>
</div>
<h2>修改PlayerLayer</h2>
<p>PlayerLayer增加getBomb和createAndAddBomb方法：</p>
<div class="cnblogs_code">
<pre>            bombLayer: <span style="color: #0000ff;">null</span><span style="color: #000000;">,
...
            getBomb: function (bombLayer) {
                </span><span style="color: #0000ff;">this</span>.bombLayer =<span style="color: #000000;"> bombLayer;
            },
            createAndAddBomb: function () {
                </span><span style="color: #0000ff;">var</span> bomb = <span style="color: #0000ff;">this</span>.getChildAt(<span style="color: #800080;">0</span><span style="color: #000000;">).createBomb();
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">bomb) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.bombLayer.appendChild(bomb);
            }</span></pre>
</div>
<h2>监听空格键</h2>
<p>空格键用于炸弹人放炸弹。</p>
<p>KeyCodeMap增加空格键枚举值：</p>
<div class="cnblogs_code">
<pre>    <span style="color: #0000ff;">var</span> keyCodeMap =<span style="color: #000000;"> {
        Left: </span><span style="color: #800080;">65</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> A键</span>
        Right: <span style="color: #800080;">68</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> D键</span>
        Down: <span style="color: #800080;">83</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> S键</span>
        Up: <span style="color: #800080;">87</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> W键</span>
        Space: <span style="color: #800080;">32</span>   <span style="color: #008000;">//</span><span style="color: #008000;">空格键</span>
<span style="color: #000000;">    };
</span>
    keyState[keyCodeMap.A] = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    keyState[keyCodeMap.D] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    keyState[keyCodeMap.W] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    keyState[keyCodeMap.S] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    keyState[keyCodeMap.Space] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;</span><span style="color: #000000;"><br /></span></pre>
</div>
<p>然后在PlayerLayer中对KeyState的空格键进行判定：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">            run: function () {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (keyState[keyCodeMap.Space]) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.createAndAddBomb();
                    keyState[keyCodeMap.Space] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
            }</span></pre>
</div>
<h2>领域模型</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/15203426-f97223df5ef64168a0629024687d03f7.jpg" alt="" /></p>
<p>　　</p>
<h1>显示火焰</h1>
<p>火力范围设为1格，分为上下左右四个方向。地图的墙对火焰有阻断作用。</p>
<h2>增加图片</h2>
<p>爆炸中心为图片boom.png：</p>
<p><img src="http://images.cnitblog.com/blog/419321/201309/24203034-e2821a020bc545cfa3c157eadb6a42cc.png" alt="" /></p>
<p>火焰为图片explode.png：</p>
<p><img src="http://images.cnitblog.com/blog/419321/201309/24203042-291c470a916d4d0fa00373ca51f0a8f9.png" alt="" /></p>
<h2>增加FireSprite</h2>
<p>增加火焰精灵类。</p>
<h2>增加FireLayer</h2>
<p>在画布上增加火焰画布，同时对应的FireLayer类。</p>
<p>该画布位于地图和炸弹画布之上，玩家和敌人画布之下。</p>
<h2>增加工厂方法</h2>
<p>SpriteFactory增加创建爆炸中心火焰精灵类实例和创建火焰精灵类实例的工厂方法。</p>
<p>LayerFactory增加创建火焰层实例的工厂方法。</p>
<h2>领域模型</h2>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/419321/201309/24204632-76f1eca002ac43beb0741d6ed9d2c8cd.jpg" alt="" /></p>
<h2><span style="color: #c0c0c0;"><span style="color: #000000;">相关代码</span></span></h2>
<p>Sprite</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('f77b45f9-5ad6-4359-8594-70e8ef845b93')"><img id="code_img_closed_f77b45f9-5ad6-4359-8594-70e8ef845b93" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_f77b45f9-5ad6-4359-8594-70e8ef845b93" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f77b45f9-5ad6-4359-8594-70e8ef845b93',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_f77b45f9-5ad6-4359-8594-70e8ef845b93" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Sprite =<span style="color: #000000;"> YYC.AClass({
        Init: function (data, bitmap) {
            </span><span style="color: #0000ff;">this</span>.bitmap =<span style="color: #000000;"> bitmap;

            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (data) {
                </span><span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
                </span><span style="color: #0000ff;">this</span>.y =<span style="color: #000000;"> data.y;

                </span><span style="color: #0000ff;">this</span>.defaultAnimId =<span style="color: #000000;"> data.defaultAnimId;
                </span><span style="color: #0000ff;">this</span>.anims =<span style="color: #000000;"> data.anims;
            }
        },
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">更新帧动画</span>
<span style="color: #000000;">            _updateFrame: function (deltaTime) {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.update(deltaTime);
                }
            }
        },
        Public: {
            bitmap: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标</span>
            x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵包含的所有 Animation 集合. Object类型, 数据存放方式为" id : animation ".</span>
            anims: <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">默认的Animation的Id , string类型</span>
            defaultAnimId: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">当前的Animation.</span>
            currentAnim: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation, 参数为Animation的id, String类型</span>
<span style="color: #000000;">            setAnim: function (animId) {
                </span><span style="color: #0000ff;">this</span>.currentAnim = <span style="color: #0000ff;">this</span><span style="color: #000000;">.anims[animId];
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">重置当前帧</span>
<span style="color: #000000;">            resetCurrentFrame: function (index) {
                </span><span style="color: #0000ff;">this</span>.currentAnim &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.setCurrentFrame(index);
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">取得精灵的碰撞区域,</span>
<span style="color: #000000;">            getCollideRect: function () {
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                    x1: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.x,
                    y1: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.y,
                    x2: </span><span style="color: #0000ff;">this</span>.x + <span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.width,
                    y2: </span><span style="color: #0000ff;">this</span>.y + <span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.height
                }
            },
            Virtual: {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">初始化方法</span>
<span style="color: #000000;">                init: function () {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation</span>
                    <span style="color: #0000ff;">this</span>.setAnim(<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId);
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新精灵当前状态.</span>
<span style="color: #000000;">                update: function (deltaTime) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._updateFrame(deltaTime);
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">获得坐标对应的方格坐标</span>
<span style="color: #000000;">                getCellPosition: function (x, y) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                        x: x </span>/<span style="color: #000000;"> bomberConfig.WIDTH,
                        y: y </span>/<span style="color: #000000;"> bomberConfig.HEIGHT
                    }
                },
                draw: function (context) {
                    context.drawImage(</span><span style="color: #0000ff;">this</span>.bitmap.img, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span>.y, <span style="color: #0000ff;">this</span>.bitmap.width, <span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.height);
                },
                clear: function (context) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">直接清空画布区域</span>
                    context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
                }
            }
        },
        Abstract: {
        }
    });

    window.Sprite </span>=<span style="color: #000000;"> Sprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>FireSprite</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> FireSprite =<span style="color: #000000;"> YYC.Class(Sprite, {
        Init: function (data, bitmap) {
            </span><span style="color: #0000ff;">this</span>.base(<span style="color: #0000ff;">null</span><span style="color: #000000;">, bitmap);
        }
    });

    window.FireSprite </span>=<span style="color: #000000;"> FireSprite;
}());</span></pre>
</div>
<p>BombSprite</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('6ca074fd-1748-463d-9804-830be74d7f2d')"><img id="code_img_closed_6ca074fd-1748-463d-9804-830be74d7f2d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_6ca074fd-1748-463d-9804-830be74d7f2d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6ca074fd-1748-463d-9804-830be74d7f2d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_6ca074fd-1748-463d-9804-830be74d7f2d" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> BombSprite =<span style="color: #000000;"> YYC.Class(Sprite, {
        Init: function (playerSprite, bitmap) {
            </span><span style="color: #0000ff;">this</span>.playerSprite =<span style="color: #000000;"> playerSprite;

            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span>(<span style="color: #0000ff;">null</span><span style="color: #000000;">, bitmap);
        },
        Protected: {
        },
        Private: {
            __createFire: function () {
                </span><span style="color: #0000ff;">var</span> fires =<span style="color: #000000;"> [],

                    up </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                    down </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                    left </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                    right </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__createCenter(fires);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__createUp(fires);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__createDown(fires);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__createLeft(fires);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__createRight(fires);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> fires;
            },
            __createCenter: function (fires) {
                </span><span style="color: #0000ff;">var</span> center =<span style="color: #000000;"> spriteFactory.createExplode();

                center.x </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.x;
                center.y </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.y;
                fires.push(center);
            },
            __createUp: function (fires) {
                </span><span style="color: #0000ff;">this</span>.__createOneDir(fires, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span>.y -<span style="color: #000000;"> bomberConfig.HEIGHT);
            },
            __createDown: function (fires) {
                </span><span style="color: #0000ff;">this</span>.__createOneDir(fires, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span>.y +<span style="color: #000000;"> bomberConfig.HEIGHT);
            },
            __createLeft: function (fires) {
                </span><span style="color: #0000ff;">this</span>.__createOneDir(fires, <span style="color: #0000ff;">this</span>.x - bomberConfig.WIDTH, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y);
            },
            __createRight: function (fires) {
                </span><span style="color: #0000ff;">this</span>.__createOneDir(fires, <span style="color: #0000ff;">this</span>.x + bomberConfig.WIDTH, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y);
            },
            __createOneDir: function (fires, x, y) {
                </span><span style="color: #0000ff;">var</span> fire = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">var</span> position = <span style="color: #0000ff;">this</span><span style="color: #000000;">.getCellPosition(x, y);

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.__isNotBorder(position) &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">.__isGround(position)) {
                    fire </span>=<span style="color: #000000;"> spriteFactory.createFire();
                    fire.x </span>=<span style="color: #000000;"> x;
                    fire.y </span>=<span style="color: #000000;"> y;
                    fires.push(fire);
                }
            },
            __isNotBorder: function (position) {
                </span><span style="color: #0000ff;">if</span> (position.x &lt; <span style="color: #800080;">0</span> || position.y &lt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">if</span> (position.x &gt;= window.mapData[<span style="color: #800080;">0</span>].length || position.y &gt;=<span style="color: #000000;"> window.mapData.length) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            },
            __isGround: function (position) {
                </span><span style="color: #0000ff;">return</span> window.mapData[position.y][position.x] ===<span style="color: #000000;"> window.bomberConfig.map.type.GROUND;
            },
            __changeTerrainData: function () {
                </span><span style="color: #0000ff;">var</span> pass =<span style="color: #000000;"> bomberConfig.map.terrain.pass,
                position </span>= <span style="color: #0000ff;">this</span>.getCellPosition(<span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y);

                window.terrainData[position.y][position.x] </span>=<span style="color: #000000;"> pass;
            }
        },
        Public: {
            playerSprite: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            explode: function () {
                </span><span style="color: #0000ff;">this</span>.playerSprite.bombNum -= <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__changeTerrainData();
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.__createFire();
            }
        }
    });

    window.BombSprite </span>=<span style="color: #000000;"> BombSprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>PlayerSprite</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('47816bc2-96ee-4cc2-99c4-5b44e6ef44c8')"><img id="code_img_closed_47816bc2-96ee-4cc2-99c4-5b44e6ef44c8" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_47816bc2-96ee-4cc2-99c4-5b44e6ef44c8" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('47816bc2-96ee-4cc2-99c4-5b44e6ef44c8',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_47816bc2-96ee-4cc2-99c4-5b44e6ef44c8" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> PlayerSprite =<span style="color: #000000;"> YYC.Class(MoveSprite, {
        Init: function (data, bitmap) {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base(data, bitmap);

            </span><span style="color: #0000ff;">this</span>.P__context = <span style="color: #0000ff;">new</span> Context(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        },
        Private: {
            __allKeyUp: function () {
                </span><span style="color: #0000ff;">return</span> window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">false</span> &amp;&amp; window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">false</span>
                     &amp;&amp; window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">false</span> &amp;&amp; window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            },
            __judgeAndSetDir: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkLeft();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkRight();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkUp();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkDown();
                }
            },
            __changeTerrainData: function () {
                </span><span style="color: #0000ff;">var</span> stop =<span style="color: #000000;"> bomberConfig.map.terrain.stop,
                position </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.getCurrentCellPosition();

                window.terrainData[position.y][position.x] </span>=<span style="color: #000000;"> stop;
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">已放置的炸弹数</span>
            bombNum: <span style="color: #800080;">0</span><span style="color: #000000;">,

            move: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.move();
            },
            setDir: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.moving) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.__allKeyUp()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.stand();
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__judgeAndSetDir();
                }
            },
            createBomb: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.moving || <span style="color: #0000ff;">this</span>.bombNum === <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">var</span> bomb = spriteFactory.createBomb(<span style="color: #0000ff;">this</span><span style="color: #000000;">);

                bomb.x </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.x;
                bomb.y </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.y;

                </span><span style="color: #0000ff;">this</span>.bombNum += <span style="color: #800080;">1</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__changeTerrainData();

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> bomb;
            }
        }
    });

    window.PlayerSprite </span>=<span style="color: #000000;"> PlayerSprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>Layer</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5432e151-9edb-4bbf-9108-02fbb6fa60f9')"><img id="code_img_closed_5432e151-9edb-4bbf-9108-02fbb6fa60f9" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_5432e151-9edb-4bbf-9108-02fbb6fa60f9" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5432e151-9edb-4bbf-9108-02fbb6fa60f9',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_5432e151-9edb-4bbf-9108-02fbb6fa60f9" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">层类（抽象类）
</span><span style="color: #008000;">//</span><span style="color: #008000;">职责：</span>
<span style="color: #808080;">///</span><span style="color: #008000;">/负责层内组件的统一draw</span>
<span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Layer =<span style="color: #000000;"> YYC.AClass(Collection, {
        Init: function () {
        },
        Private: {
            __state: bomberConfig.layer.state.CHANGE,   </span><span style="color: #008000;">//</span><span style="color: #008000;">默认为change</span>
<span style="color: #000000;">
            __getContext: function () {
                </span><span style="color: #0000ff;">this</span>.P__context = <span style="color: #0000ff;">this</span>.P__canvas.getContext(<span style="color: #800000;">"</span><span style="color: #800000;">2d</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        },
        Protected: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">*共用的变量（可读、写）</span>
<span style="color: #000000;">
            P__canvas: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            P__context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">*共用的方法（可读）</span>
<span style="color: #000000;">
            P__isChange: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.__state ===<span style="color: #000000;"> bomberConfig.layer.state.CHANGE;
            },
            P__isNormal: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.__state ===<span style="color: #000000;"> bomberConfig.layer.state.NORMAL;
            },
            P__setStateNormal: function () {
                </span><span style="color: #0000ff;">this</span>.__state =<span style="color: #000000;"> bomberConfig.layer.state.NORMAL;
            },
            P__setStateChange: function () {
                </span><span style="color: #0000ff;">this</span>.__state =<span style="color: #000000;"> bomberConfig.layer.state.CHANGE;
            },
            P__iterator: function (handler) {
                </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span><span style="color: #000000;">),
                    nextElement </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasNext()) {
                    nextElement </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.next();
                    nextElement[handler].apply(nextElement, args);  </span><span style="color: #008000;">//</span><span style="color: #008000;">要指向nextElement</span>
<span style="color: #000000;">                }
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.resetCursor();
            },
            P__render: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__isChange()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.clear();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.draw();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__setStateNormal();
                }
            }
        },
        Public: {
            addElements: function (elements) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.appendChilds(elements);
            },
            Virtual: {
                init: function () {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__getContext();
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">更改状态</span>
<span style="color: #000000;">                change: function () {
                    </span><span style="color: #0000ff;">this</span>.__state =<span style="color: #000000;"> bomberConfig.layer.state.CHANGE;
                }
            }
        },
        Abstract: {
            setCanvas: function () {
            },
            clear: function () {
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">统一绘制</span>
<span style="color: #000000;">            draw: function () { },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">游戏主线程调用的函数</span>
<span style="color: #000000;">            run: function () { }
        }
    });

    window.Layer </span>=<span style="color: #000000;"> Layer;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="font-size: 14px; line-height: 1.5;">FireLayer</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> FireLayer =<span style="color: #000000;"> YYC.Class(Layer, {
        Private: {
            ___hasFire: function(){
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.getChilds().length &gt; <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        },
        Public: {
            setCanvas: function () {
                </span><span style="color: #0000ff;">this</span>.P__canvas = document.getElementById(<span style="color: #800000;">"</span><span style="color: #800000;">fireLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);</span>
                <span style="color: #0000ff;">var</span> css =<span style="color: #000000;"> {
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,
</span>
                    <span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">2</span><span style="color: #000000;">
                };

                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#fireLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">).css(css);</span>
<span style="color: #000000;">            },
            draw: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">draw</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
            },
            clear: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">clear</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
            },
            change: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.___hasFire()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base();
                }
            },
            run: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__render();
            }
        }
    });

    window.FireLayer </span>=<span style="color: #000000;"> FireLayer;
}());</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">BombLayer</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> BombLayer =<span style="color: #000000;"> YYC.Class(Layer, {
        Private: {
            ___hasBomb: function(){
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.getChilds().length &gt; <span style="color: #800080;">0</span><span style="color: #000000;">;
            },
            ___removeBomb: function (bomb) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">*注意顺序！</span>

                <span style="color: #0000ff;">this</span><span style="color: #000000;">.clear();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.remove(bomb);
            },
            ___removeAllFire: function () {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">*注意顺序！</span>

                <span style="color: #0000ff;">this</span><span style="color: #000000;">.fireLayer.clear();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.fireLayer.removeAll();
            }
        },
        Public: {
            fireLayer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            setCanvas: function () {
                </span><span style="color: #0000ff;">this</span>.P__canvas = document.getElementById(<span style="color: #800000;">"</span><span style="color: #800000;">bombLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);</span>
                <span style="color: #0000ff;">var</span> css =<span style="color: #000000;"> {
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,</span>
                    <span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">1</span><span style="color: #000000;">
                };

                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#bombLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">).css(css);</span>
<span style="color: #000000;">            },
            draw: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">draw</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
            },
            clear: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">clear</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
            },
            getFire: function (fireLayer) {
                </span><span style="color: #0000ff;">this</span>.fireLayer =<span style="color: #000000;"> fireLayer;
            },
            explode: function (bomb) {
                </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.fireLayer.addElements(bomb.explode());
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___removeBomb(bomb);
                </span><span style="color: #008000;">//</span><span style="color: #008000;">定时清空fireLayer（火焰消失）</span>
<span style="color: #000000;">                setTimeout(function () {
                    self.___removeAllFire();
                }, </span><span style="color: #800080;">300</span><span style="color: #000000;">);
            },
            change: function(){
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.___hasBomb()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base();
                }
            },
            run: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__render();
            }
        }
    });

    window.BombLayer </span>=<span style="color: #000000;"> BombLayer;
}());</span></pre>
</div>
<p>SpriteFactory</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        createFire: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> FireSprite(<span style="color: #0000ff;">null</span>, bitmapFactory.createBitmap({ img: window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">fire</span><span style="color: #800000;">"</span><span style="color: #000000;">), width: bomberConfig.WIDTH, height: bomberConfig.HEIGHT }));
        },
        createExplode: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> FireSprite(<span style="color: #0000ff;">null</span>, bitmapFactory.createBitmap({ img: window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">explode</span><span style="color: #800000;">"</span><span style="color: #000000;">), width: bomberConfig.WIDTH, height: bomberConfig.HEIGHT }));
        }</span></pre>
</div>
<p>LayerFactory　　</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        createFire: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> FireLayer();
        }</span></pre>
</div>
<h1>&ldquo;显示炸弹和火焰&rdquo;演示</h1>
<p><a href="http://yang222.s2.jutuo.net/Bomber/Index8_1">演示地址</a></p>
<p><a name="observer"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">使用观察者模式</span></strong></p>
<h1>观察者模式介绍</h1>
<p>详见<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3340725.html">Javascript设计模式之我见：观察者模式</a>。</p>
<h1>应用场景</h1>
<p>墙被炸掉后，会变成空地。</p>
<h1>实现思路</h1>
<p>Maplayer的changeSpriteImg负责更改地图图片，BombSprite的explode负责处理爆炸逻辑。</p>
<p>需要在explode中调用Maplayer的changeSpriteImg。</p>
<p>因此，决定在Game中订阅Maplayer的changeSpriteImg方法，然后在BombSprite的explode方法中发布。　　　</p>
<h1>为什么此处用观察者模式</h1>
<p>因为MapLayer的Layer类族在BombSprite的Sprite类族的上层，我不希望下层BombSprite与上层MapLayer耦合。</p>
<p>因此，采用观察者模式来解除两者的耦合。</p>
<h1>领域模型</h1>
<p>使用观察模式前</p>
<p><img src="http://images.cnitblog.com/blog/419321/201309/26175516-3e41b8ee7b704454b2cfbe065f60b8c6.jpg" alt="" /></p>
<p>&nbsp;</p>
<p>使用观察模式后</p>
<p><img src="http://images.cnitblog.com/blog/419321/201310/02203600-728b8a29229c4a89bef9e08819312ebf.jpg" alt="" /></p>
<h1>相关代码</h1>
<p>Subject</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('6cbf2f6e-804e-4f9b-b610-78029acfaf2e')"><img id="code_img_closed_6cbf2f6e-804e-4f9b-b610-78029acfaf2e" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_6cbf2f6e-804e-4f9b-b610-78029acfaf2e" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6cbf2f6e-804e-4f9b-b610-78029acfaf2e',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_6cbf2f6e-804e-4f9b-b610-78029acfaf2e" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">Array.prototype.forEach) {
        Array.prototype.forEach </span>=<span style="color: #000000;"> function (fn, thisObj) {
            </span><span style="color: #0000ff;">var</span> scope = thisObj ||<span style="color: #000000;"> window;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #0000ff;">this</span>.length; i &lt; j; ++<span style="color: #000000;">i) {
                fn.call(scope, </span><span style="color: #0000ff;">this</span>[i], i, <span style="color: #0000ff;">this</span><span style="color: #000000;">);
            }
        };
    }

    </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">Array.prototype.filter) {
        Array.prototype.filter </span>=<span style="color: #000000;"> function (fn, thisObj) {
            </span><span style="color: #0000ff;">var</span> scope = thisObj ||<span style="color: #000000;"> window;
            </span><span style="color: #0000ff;">var</span> a =<span style="color: #000000;"> [];
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #0000ff;">this</span>.length; i &lt; j; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (!fn.call(scope, <span style="color: #0000ff;">this</span>[i], i, <span style="color: #0000ff;">this</span><span style="color: #000000;">)) {
                    </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                }
                a.push(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">[i]);
            }
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> a;
        };
    }

    Subject </span>=<span style="color: #000000;"> function () {
        </span><span style="color: #0000ff;">this</span>._events =<span style="color: #000000;"> [];
    }

    Subject.prototype </span>=<span style="color: #000000;"> (function () {

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">订阅方法</span>
<span style="color: #000000;">            subscribe: function (context, fn) {
                </span><span style="color: #0000ff;">if</span> (arguments.length == <span style="color: #800080;">2</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>._events.push({ context: arguments[<span style="color: #800080;">0</span>], fn: arguments[<span style="color: #800080;">1</span><span style="color: #000000;">] });
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span>._events.push(arguments[<span style="color: #800080;">0</span><span style="color: #000000;">]);
                }
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">发布指定方法</span>
<span style="color: #000000;">            publish: function (context, fn, args) {
                </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">2</span>);    <span style="color: #008000;">//</span><span style="color: #008000;">获得函数参数</span>
                <span style="color: #0000ff;">var</span> _context = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">var</span> _fn = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._events.filter(function (el) {
                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (el.context) {
                        _context </span>=<span style="color: #000000;"> el.context;
                        _fn </span>=<span style="color: #000000;"> el.fn;
                    }
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        _context </span>=<span style="color: #000000;"> context;
                        _fn </span>=<span style="color: #000000;"> el;
                    }

                    </span><span style="color: #0000ff;">if</span> (_fn ===<span style="color: #000000;"> fn) {
                        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> _fn;
                    }
                }).forEach(function (el) {  </span><span style="color: #008000;">//</span><span style="color: #008000;">指定方法可能有多个</span>
                        el.apply(_context, args);       <span style="color: #008000;">//</span><span style="color: #008000;">执行每个指定的方法</span>
<span style="color: #000000;">                    });
            },
            unSubscribe: function (fn) {
                </span><span style="color: #0000ff;">var</span> _fn = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">this</span>._events = <span style="color: #0000ff;">this</span><span style="color: #000000;">._events.filter(function (el) {
                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (el.fn) {
                        _fn </span>=<span style="color: #000000;"> el.fn;
                    }
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        _fn </span>=<span style="color: #000000;"> el;
                    }

                    </span><span style="color: #0000ff;">if</span> (_fn !==<span style="color: #000000;"> fn) {
                        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> el;
                    }
                });
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">全部发布</span>
<span style="color: #000000;">            publishAll: function (context, args) {
                </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span>);    <span style="color: #008000;">//</span><span style="color: #008000;">获得函数参数</span>
                <span style="color: #0000ff;">var</span> _context = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">var</span> _fn = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._events.forEach(function (el) {
                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (el.context) {
                        _context </span>=<span style="color: #000000;"> el.context;
                        _fn </span>=<span style="color: #000000;"> el.fn;
                    }
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        _context </span>=<span style="color: #000000;"> context;
                        _fn </span>=<span style="color: #000000;"> el;
                    }

                    _fn.apply(_context, args);       </span><span style="color: #008000;">//</span><span style="color: #008000;">执行每个指定的方法</span>
<span style="color: #000000;">                });
            },
            dispose: function () {
                </span><span style="color: #0000ff;">this</span>._events =<span style="color: #000000;"> [];
            }
        }
    })();

    YYC.Pattern.Subject </span>=<span style="color: #000000;"> Subject;
})();</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>MapLayer</p>
<div class="cnblogs_code">
<pre>            <span style="color: #008000;">//</span><span style="color: #008000;">改变指定精灵类的img对象
            </span><span style="color: #008000;">//</span><span style="color: #008000;">参数：
            </span><span style="color: #008000;">//</span><span style="color: #008000;">x:x坐标（方格对应值）；y:y坐标（方格对应值）；img:要替换的img对象</span>
<span style="color: #000000;">            changeSpriteImg: function (x, y, img) {</span>
                <span style="color: #0000ff;">var</span> index = y * window.bomberConfig.map.COL +<span style="color: #000000;"> x;
                </span><span style="color: #0000ff;">this</span>.getChildAt(index).bitmap.img =<span style="color: #000000;"> img;
            },</span></pre>
</div>
<p>BombSprite</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">         __destroyOneDir: function (x, y) {
...
                    window.observer.publishAll(</span><span style="color: #0000ff;">null</span><span style="color: #000000;">, position.x, position.y, groundImg);
...
            },</span></pre>
</div>
<p>Game</p>
<div class="cnblogs_code">
<pre>    <span style="color: #008000;">//</span><span style="color: #008000;">观察者全局实例</span>
    window.observer = <span style="color: #0000ff;">null</span>

    <span style="color: #0000ff;">var</span> Game =<span style="color: #000000;"> YYC.Class({
        Init: function () {
            window.observer </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> YYC.Pattern.Observer();
        },
...
    init: function () {
...
        </span><span style="color: #008000;">//</span><span style="color: #008000;">观察者模式 -&gt; 订阅                </span>
        window.observer.subscribe(<span style="color: #0000ff;">this</span>.layerManager.getLayer(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span>), <span style="color: #0000ff;">this</span>.layerManager.getLayer(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">).changeSpriteImg);
    },</span></pre>
</div>
<p><a name="refactor"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">重构</span></strong></p>
<h1>增加TerrainDataOperate</h1>
<p>增加TerrainData地形数据操作类TerrainDataOperate</p>
<h2>领域模型</h2>
<p>重构前</p>
<p><img src="http://images.cnitblog.com/blog/419321/201309/26211930-656536a01f274f1eb0a94f024a32df26.jpg" alt="" /></p>
<p>重构后</p>
<p><img src="http://images.cnitblog.com/blog/419321/201309/26212042-affa23f567da474ba52d5897b51b8c72.jpg" alt="" /></p>
<h2>相关代码</h2>
<p>TerrainDataOperate</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> terrainDataOperate =<span style="color: #000000;"> {
        getTerrainData: function () {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> YYC.Tool.array.clone(window.terrainData);
        },
        setTerrainData: function (x, y, data) {
            window.terrainData[y][x] </span>=<span style="color: #000000;"> data;
        }
    };

    window.terrainDataOperate </span>=<span style="color: #000000;"> terrainDataOperate;
}());</span></pre>
</div>
<h1>增加火力范围</h1>
<p>将范围从1格改为2格，方便演示游戏。</p>
<h1>增加游戏全局状态GameState</h1>
<p>在Game的run方法中，需要判断敌人是否抓住了玩家（是否与玩家碰撞）：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">    run: function () {
        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.layerManager.getLayer(<span style="color: #800000;">"</span><span style="color: #800000;">enemyLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">).collideWidthPlayer()) {
            YYC.Tool.asyn.clearAllTimer(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.mainLoop);
            alert(</span><span style="color: #800000;">"</span><span style="color: #800000;">Game Over！</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
...
    }</span></pre>
</div>
<p>这里注意到，Game需要知道EnemyLayer的collideWidthPlayer方法：</p>
<p><img src="http://images.cnitblog.com/blog/419321/201309/26214251-03b5c45ad7f94469914ce50e7264c64c.jpg" alt="" /></p>
<p>但Game类只应该知道LayerManager，而不应该知道Layer（见&ldquo;炸弹人游戏开发系列（1）：准备工作&rdquo;中的<a href="http://www.cnblogs.com/chaogex/p/3151033.html#conceptLayer">概念层次结构</a>）。</p>
<p>因此，增加游戏全局状态GameState，在Game的run判断GameState，然后把与炸弹人的碰撞检测的任务放到EnemyLayer的run方法中：</p>
<p><img src="http://images.cnitblog.com/blog/419321/201309/27165625-a0d0937c55dc4ea6b3771b73417d8dfa.jpg" alt="" /></p>
<h2>重构后相关代码</h2>
<p>Config</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">    game: {</span>
<span style="color: #000000;">        state: {
            NORAML: </span><span style="color: #800080;">1</span><span style="color: #000000;">,
            OVER: </span><span style="color: #800080;">2</span><span style="color: #000000;">
        }
    },</span></pre>
</div>
<p>Game</p>
<div class="cnblogs_code">
<pre>    <span style="color: #008000;">//</span><span style="color: #008000;">游戏全局状态</span>
    window.gameState =<span style="color: #000000;"> window.bomberConfig.game.state.NORMAL;
...
    run: function () {
        </span><span style="color: #0000ff;">if</span> (window.gameState ===<span style="color: #000000;"> window.bomberConfig.game.state.OVER) {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.gameOver();
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
...
    }
    ,
    gameOver: function () {
        YYC.Tool.asyn.clearAllTimer(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.mainLoop);
        alert(</span><span style="color: #800000;">"</span><span style="color: #800000;">Game Over！</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }</span></pre>
</div>
<p>EnemyLayer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">            run: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.collideWidthPlayer()) {
                    window.gameState </span>=<span style="color: #000000;"> window.bomberConfig.game.state.OVER;
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }<br />...</span></pre>
</div>
<p><a name="explode"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">炸弹可以炸死炸弹人和敌人</span></strong></p>
<p>在炸弹爆炸时，判断与炸弹人、敌人是否碰撞并进行相应处理。</p>
<h1>领域模型</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201309/26224027-0b14a1b707c64b54ba8ebd6810558c4e.jpg" alt="" /></p>
<h1>相关代码</h1>
<p>BombLayer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">___collideFireWithPlayer: function (bomb) {
    </span><span style="color: #0000ff;">if</span> (bomb.collideFireWithCharacter(<span style="color: #0000ff;">this</span>.playerLayer.getChildAt(<span style="color: #800080;">0</span><span style="color: #000000;">))) {
        window.gameState </span>=<span style="color: #000000;"> window.bomberConfig.game.state.OVER;
    }
},
___collideFireWithEnemy: function (bomb) {
    </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
        len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
        enemySprites </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.enemyLayer.getChilds();

    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = enemySprites.length ; i &lt; len; i++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (bomb.collideFireWithCharacter(enemySprites[i])) {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___removeEnemy(enemySprites[i]);
        }
    }
},
___removeEnemy: function (enemy) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">*注意顺序！</span>

    <span style="color: #0000ff;">this</span><span style="color: #000000;">.enemyLayer.clear();
    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.enemyLayer.remove(enemy);
},
___handleCollid: function (bomb) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">判断与炸弹人碰撞</span>
    <span style="color: #0000ff;">this</span><span style="color: #000000;">.___collideFireWithPlayer(bomb)
    </span><span style="color: #008000;">//</span><span style="color: #008000;">判断与每个敌人碰撞</span>
    <span style="color: #0000ff;">this</span><span style="color: #000000;">.___collideFireWithEnemy(bomb);
}
...
enemyLayer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
playerLayer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
...
explode: function (bomb) {
    </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">,
        result </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">处理碰撞</span>
    <span style="color: #0000ff;">this</span><span style="color: #000000;">.___handleCollid(bomb);
...</span></pre>
</div>
<p><a name="move"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">移动时放炸弹</span></strong></p>
<p>因为炸弹人移动时，根据炸弹人状态的不同，炸弹放置的坐标策略也不同（即如果炸弹人往上走，则炸弹放在炸弹人所在方格的上面相邻方格；如果往左走，则炸弹放在炸弹人所在方格的左侧相邻方格）。所以将PlayerSprite的createBomb方法委托给状态类处理。具体来说，就是把createBomb方法移到状态类的WalkState类和Stand类中来分别处理。</p>
<h1>领域模型</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/13195735-b08619fa4e58484fb3de79436c9dd22c.jpg" alt="" /></p>
<h1>分析</h1>
<p>因为PlayerSprite、EnemySprite都使用了状态类，因此两者都与BombSprite耦合。但只有PlayerSprite需要使用createBomb方法，EnemySprite并不需要使用该方法。所以此处违反了迪米特法则。</p>
<p>目前这种情况在可以接受的范围之内。如果在后面的开发中EnemySprite与BombSprite耦合得很严重，再来考虑解耦。</p>
<p><a name="more"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">放置多个炸弹</span></strong></p>
<p>可以最多放3个炸弹，炸弹爆炸时会引爆在火力范围内的炸弹。</p>
<h1>不能在一个方格叠加多个炸弹</h1>
<p>在状态类WalkState类族、StandState类族的createBomb中判断方格是否有炸弹（判断地形数据TerrainData来实现）。</p>
<p><a name="change"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">改变地图</span></strong></p>
<h1>炸掉墙</h1>
<p>如果墙处于火焰范围内，则修改MapData，将墙的图片换成空地图片，同时对应修改TerrainData，将墙所在的方格设成可通过。</p>
<h1><span>刷新地图</span></h1>
<p><span>在炸掉墙后，在BombLayer中需要调用MapLayer的</span>setStateChange方法，将MapLayer的state设为change，从而能够在游戏的下一个主循环中，刷新地图，从而显示为空地。</p>
<h2>领域模型</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201309/26223452-0671306e7c3f44d9bc0a06ebd9fbbd0f.jpg" alt="" /></p>
<h2>相关代码</h2>
<p>BombLayer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">___mapChange: function (mapChange) {
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (mapChange) {
        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.mapLayer.setStateChange();
    }
}</span></pre>
</div>
<p><a name="summary"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">小结</span></strong></p>
<p><span>现在我们就完成了&ldquo;放炸弹&rdquo;的功能，来看下成果吧~</span></p>
<h1><span>&ldquo;放炸弹&rdquo;演示</span></h1>
<p><span><a href="http://yang222.s2.jutuo.net/Bomber/Index8_2">演示地址</a></span></p>
<h1>相关代码</h1>
<p><span style="color: #000000;">FireSprite</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> FireSprite =<span style="color: #000000;"> YYC.Class(Sprite, {
        Init: function (data, bitmap) {
            </span><span style="color: #0000ff;">this</span>.base(<span style="color: #0000ff;">null</span><span style="color: #000000;">, bitmap);
        }
    });

    window.FireSprite </span>=<span style="color: #000000;"> FireSprite;
}());</span></pre>
</div>
<p><span style="color: #000000;">FireLayer</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('cde864d8-4dd0-4b2c-9e06-52ca35f32bef')"><img id="code_img_closed_cde864d8-4dd0-4b2c-9e06-52ca35f32bef" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_cde864d8-4dd0-4b2c-9e06-52ca35f32bef" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('cde864d8-4dd0-4b2c-9e06-52ca35f32bef',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_cde864d8-4dd0-4b2c-9e06-52ca35f32bef" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> FireLayer =<span style="color: #000000;"> YYC.Class(Layer, {
        Private: {
            ___hasFire: function(){
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.getChilds().length &gt; <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        },
        Public: {
            setCanvas: function () {
                </span><span style="color: #0000ff;">this</span>.P__canvas = document.getElementById(<span style="color: #800000;">"</span><span style="color: #800000;">fireLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">var</span> css =<span style="color: #000000;"> {
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">2</span><span style="color: #000000;">
                };

                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#fireLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">).css(css);
            },
            draw: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">draw</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
            },
            clear: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">clear</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
            },
            change: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.___hasFire()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.setStateChange();
                }
            },
            run: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__render();
            }
        }
    });

    window.FireLayer </span>=<span style="color: #000000;"> FireLayer;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="color: #000000;">PlayerSprite</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5ffd22a0-e4ae-47ec-8382-cb1f42f00489')"><img id="code_img_closed_5ffd22a0-e4ae-47ec-8382-cb1f42f00489" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_5ffd22a0-e4ae-47ec-8382-cb1f42f00489" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5ffd22a0-e4ae-47ec-8382-cb1f42f00489',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_5ffd22a0-e4ae-47ec-8382-cb1f42f00489" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> PlayerSprite =<span style="color: #000000;"> YYC.Class(MoveSprite, {
        Init: function (data, bitmap) {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base(data, bitmap);

            </span><span style="color: #0000ff;">this</span>.P__context = <span style="color: #0000ff;">new</span> Context(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        },
        Private: {
            __allKeyUp: function () {
                </span><span style="color: #0000ff;">return</span> window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">false</span> &amp;&amp; window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">false</span>
                     &amp;&amp; window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">false</span> &amp;&amp; window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            },
            __judgeAndSetDir: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkLeft();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkRight();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkUp();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkDown();
                }
            },
            __changeTerrainData: function () {
                </span><span style="color: #0000ff;">var</span> stop =<span style="color: #000000;"> bomberConfig.map.terrain.stop,
                position </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.getCurrentCellPosition();

                terrainDataOperate.setTerrainData(position.x, position.y, stop);
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">已放置的炸弹数</span>
            bombNum: <span style="color: #800080;">0</span><span style="color: #000000;">,

            move: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.move();
            },
            setDir: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.moving) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.__allKeyUp()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.stand();
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__judgeAndSetDir();
                }
            },
            createBomb: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.bombNum === <span style="color: #800080;">3</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.createBomb();
            }
        }
    });

    window.PlayerSprite </span>=<span style="color: #000000;"> PlayerSprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="color: #000000;">BomberSprite</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('56d503de-19d4-44a9-94de-5ddaec6e61ae')"><img id="code_img_closed_56d503de-19d4-44a9-94de-5ddaec6e61ae" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_56d503de-19d4-44a9-94de-5ddaec6e61ae" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('56d503de-19d4-44a9-94de-5ddaec6e61ae',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_56d503de-19d4-44a9-94de-5ddaec6e61ae" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> BombSprite =<span style="color: #000000;"> YYC.Class(Sprite, {
        Init: function (playerSprite, bitmap) {
            </span><span style="color: #0000ff;">this</span>.playerSprite =<span style="color: #000000;"> playerSprite;

            </span><span style="color: #0000ff;">this</span>.base(<span style="color: #0000ff;">null</span><span style="color: #000000;">, bitmap);
        },
        Protected: {
        },
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">返回火焰范围
            </span><span style="color: #008000;">//</span><span style="color: #008000;">返回顺序为[center、[up]、[down]、[left]、[right]]</span>
<span style="color: #000000;">            __getFireAllRange: function () {

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> [
                    { x: </span><span style="color: #0000ff;">this</span>.x, y: <span style="color: #0000ff;">this</span><span style="color: #000000;">.y },
                    [
                        { x: </span><span style="color: #0000ff;">this</span>.x, y: <span style="color: #0000ff;">this</span>.y -<span style="color: #000000;"> bomberConfig.HEIGHT },
                        { x: </span><span style="color: #0000ff;">this</span>.x, y: <span style="color: #0000ff;">this</span>.y - bomberConfig.HEIGHT * <span style="color: #800080;">2</span><span style="color: #000000;"> }
                    ],
                    [
                        { x: </span><span style="color: #0000ff;">this</span>.x, y: <span style="color: #0000ff;">this</span>.y +<span style="color: #000000;"> bomberConfig.HEIGHT },
                        { x: </span><span style="color: #0000ff;">this</span>.x, y: <span style="color: #0000ff;">this</span>.y + bomberConfig.HEIGHT * <span style="color: #800080;">2</span><span style="color: #000000;"> }
                    ],
                    [
                        { x: </span><span style="color: #0000ff;">this</span>.x - bomberConfig.WIDTH, y: <span style="color: #0000ff;">this</span><span style="color: #000000;">.y },
                        { x: </span><span style="color: #0000ff;">this</span>.x - bomberConfig.WIDTH * <span style="color: #800080;">2</span>, y: <span style="color: #0000ff;">this</span><span style="color: #000000;">.y }
                    ],
                    [
                        { x: </span><span style="color: #0000ff;">this</span>.x + bomberConfig.WIDTH, y: <span style="color: #0000ff;">this</span><span style="color: #000000;">.y },
                        { x: </span><span style="color: #0000ff;">this</span>.x + bomberConfig.WIDTH * <span style="color: #800080;">2</span>, y: <span style="color: #0000ff;">this</span><span style="color: #000000;">.y }
                    ]
                ];
            },
            __getCenterEffectiveRange: function (effectiveRange, center) {
                effectiveRange.center </span>=<span style="color: #000000;"> { x: center.x, y: center.y };
            },
            __getFourDirEffectiveRange: function (effectiveRange, allRange) {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len1 </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len2 </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    firePos </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                    cellPos </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                    groundRange </span>=<span style="color: #000000;"> [],
                    wallRange </span>=<span style="color: #000000;"> [];

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len1 = allRange.length; i &lt; len1; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>, len2 = allRange[i].length; j &lt; len2; j++<span style="color: #000000;">) {
                        firePos </span>=<span style="color: #000000;"> allRange[i][j];
                        cellPos </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.getCellPosition(firePos.x, firePos.y);

                        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.__isNotBorder(cellPos)) {
                            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.__isGround(cellPos)) {
                                groundRange.push(firePos);
                            }
                            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.__isWall(cellPos)) {
                                wallRange.push(firePos);
                                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                            }
                            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">未知的地图类型</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                            }
                        }
                    }
                }
                effectiveRange.groundRange </span>=<span style="color: #000000;"> groundRange;
                effectiveRange.wallRange </span>=<span style="color: #000000;"> wallRange;
            },
            __createFire: function (effectiveRange) {
                </span><span style="color: #0000ff;">var</span> fires =<span style="color: #000000;"> [];

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__createCenter(fires, effectiveRange);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__createFourDir(fires, effectiveRange);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> fires;
            },
            __createCenter: function (fires, effectiveRange) {
                </span><span style="color: #0000ff;">var</span> center =<span style="color: #000000;"> spriteFactory.createExplode();

                center.x </span>=<span style="color: #000000;"> effectiveRange.center.x;
                center.y </span>=<span style="color: #000000;"> effectiveRange.center.y;
                fires.push(center);
            },
            __createFourDir: function (fires, effectiveRange) {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    fire </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                    groundRange </span>=<span style="color: #000000;"> effectiveRange.groundRange;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = groundRange.length; i &lt; len; i++<span style="color: #000000;">) {
                            fire </span>=<span style="color: #000000;"> spriteFactory.createFire();
                            fire.x </span>=<span style="color: #000000;"> groundRange[i].x;
                            fire.y </span>=<span style="color: #000000;"> groundRange[i].y;
                            fires.push(fire);
                }
            },
            __isNotBorder: function (position) {
                </span><span style="color: #0000ff;">if</span> (position.x &lt; <span style="color: #800080;">0</span> || position.y &lt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">if</span> (position.x &gt;= window.mapData[<span style="color: #800080;">0</span>].length || position.y &gt;=<span style="color: #000000;"> window.mapData.length) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            },
            __isGround: function (position) {
                </span><span style="color: #0000ff;">return</span> window.mapDataOperate.getMapData()[position.y][position.x] ===<span style="color: #000000;"> window.bomberConfig.map.type.GROUND;
            },
            __bombPass: function () {
                </span><span style="color: #0000ff;">var</span> pass =<span style="color: #000000;"> bomberConfig.map.terrain.pass,
                position </span>= <span style="color: #0000ff;">this</span>.getCellPosition(<span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y);

                terrainDataOperate.setTerrainData(position.x, position.y, pass);
            },
            __destroyWall: function (effectiveRange) {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                mapChange </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">,
                wallRange </span>=<span style="color: #000000;"> effectiveRange.wallRange,
                cellPos </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                      ground </span>=<span style="color: #000000;"> bomberConfig.map.type.GROUND,
                    groundImg </span>= window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                    wall </span>=<span style="color: #000000;"> bomberConfig.map.type.WALL,
                    pass </span>=<span style="color: #000000;"> bomberConfig.map.terrain.pass,
                    stop </span>=<span style="color: #000000;"> bomberConfig.map.terrain.stop;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = wallRange.length; i &lt; len; i++<span style="color: #000000;">) {
                    cellPos </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.getCellPosition(wallRange[i].x, wallRange[i].y);
                    window.mapDataOperate.setMapData(cellPos.x, cellPos.y, ground);
                                window.terrainDataOperate.setTerrainData(cellPos.x, cellPos.y, pass);
                                </span><span style="color: #008000;">//</span><span style="color: #008000;">观察者模式 -&gt; 发布
                                </span><span style="color: #008000;">//</span><span style="color: #008000;">调用mapLayer.changeSpriteImg，改变地图层对应精灵类的img对象</span>
                                window.observer.publishAll(<span style="color: #0000ff;">null</span><span style="color: #000000;">, cellPos.x, cellPos.y, groundImg);
                                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">mapChange) {
                                    mapChange </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                                }
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> mapChange;
            },
            __isWall: function (position) {
                </span><span style="color: #0000ff;">return</span> window.mapDataOperate.getMapData()[position.y][position.x] ===<span style="color: #000000;"> window.bomberConfig.map.type.WALL;
            },
            __isInEffectiveRange: function (effectiveRange) {
                </span><span style="color: #0000ff;">var</span> range = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                range </span>=<span style="color: #000000;"> effectiveRange.groundRange.concat(effectiveRange.wallRange);
                range.push(effectiveRange.center);

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.__isInRange(range)) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            },
            __isInRange: function (range) {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = range.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (range[i].x === <span style="color: #0000ff;">this</span>.x &amp;&amp; range[i].y === <span style="color: #0000ff;">this</span><span style="color: #000000;">.y) {
                        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    }
                }

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        },
        Public: {
            playerSprite: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">是否已爆炸标志</span>
            exploded: <span style="color: #0000ff;">false</span><span style="color: #000000;">,

            explode: function () {
                </span><span style="color: #0000ff;">var</span> fires = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                    mapChange </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">,
                    effectiveRange </span>=<span style="color: #000000;"> [];

                </span><span style="color: #0000ff;">this</span>.playerSprite.bombNum -= <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">this</span>.exploded = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__bombPass();
                effectiveRange </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.getFireEffectiveRange();
                fires </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.__createFire(effectiveRange);
                mapChange </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.__destroyWall(effectiveRange);


                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                    fires: fires,
                    mapChange: mapChange
                };
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">检测火焰与玩家人物、敌人的碰撞</span>
<span style="color: #000000;">            collideFireWithCharacter: function (sprite) {
                </span><span style="color: #0000ff;">var</span> effectiveRange = <span style="color: #0000ff;">this</span><span style="color: #000000;">.getFireEffectiveRange(),
                range </span>=<span style="color: #000000;"> [],
                fire </span>=<span style="color: #000000;"> {},
                obj2 </span>=<span style="color: #000000;"> {},
                i </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #008000;">//</span><span style="color: #008000;">放到数组中</span>
<span style="color: #000000;">                range.push(effectiveRange.center);
                range </span>=<span style="color: #000000;"> range.concat(effectiveRange.groundRange, effectiveRange.wallRange);

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = range.length; i &lt; len; i++<span style="color: #000000;">) {
                    fire </span>=<span style="color: #000000;"> {
                        x: range[i].x,
                        y: range[i].y,
                        width: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.width,
                        height: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.height
                    };
                    obj2 </span>=<span style="color: #000000;"> {
                        x: sprite.x,
                        y: sprite.y,
                        width: sprite.bitmap.width,
                        height: sprite.bitmap.height
                    };
                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (YYC.Tool.collision.col_Between_Rects(fire, obj2)) {
                        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    }
                }

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">返回有效范围。（考虑墙、边界阻挡等问题）
            </span><span style="color: #008000;">//</span><span style="color: #008000;">返回值形如：{center: {x: 1,y: 1}}, {groundRange: [{{x: 1,y: 1}]}, {wallRange: [{{x: 1,y: 1}]}</span>
<span style="color: #000000;">            getFireEffectiveRange: function () {
                </span><span style="color: #0000ff;">var</span> effectiveRange =<span style="color: #000000;"> {},
                    allRange </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.__getFireAllRange();

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__getCenterEffectiveRange(effectiveRange, allRange.shift());
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__getFourDirEffectiveRange(effectiveRange, allRange);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> effectiveRange;
            },
            isInEffectiveRange: function (bomb) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.__isInEffectiveRange(bomb.getFireEffectiveRange());
            }
        }
    });

    window.BombSprite </span>=<span style="color: #000000;"> BombSprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="color: #000000;">Sprite</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('790f55f1-baf5-4b6a-ac9c-8b656f2bb670')"><img id="code_img_closed_790f55f1-baf5-4b6a-ac9c-8b656f2bb670" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_790f55f1-baf5-4b6a-ac9c-8b656f2bb670" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('790f55f1-baf5-4b6a-ac9c-8b656f2bb670',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_790f55f1-baf5-4b6a-ac9c-8b656f2bb670" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Sprite =<span style="color: #000000;"> YYC.AClass({
        Init: function (data, bitmap) {
            </span><span style="color: #0000ff;">this</span>.bitmap =<span style="color: #000000;"> bitmap;

            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (data) {
                </span><span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
                </span><span style="color: #0000ff;">this</span>.y =<span style="color: #000000;"> data.y;

                </span><span style="color: #0000ff;">this</span>.defaultAnimId =<span style="color: #000000;"> data.defaultAnimId;
                </span><span style="color: #0000ff;">this</span>.anims =<span style="color: #000000;"> data.anims;
            }
        },
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">更新帧动画</span>
<span style="color: #000000;">            _updateFrame: function (deltaTime) {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.update(deltaTime);
                }
            }
        },
        Public: {
            bitmap: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标</span>
            x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵包含的所有 Animation 集合. Object类型, 数据存放方式为" id : animation ".</span>
            anims: <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">默认的Animation的Id , string类型</span>
            defaultAnimId: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">当前的Animation.</span>
            currentAnim: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation, 参数为Animation的id, String类型</span>
<span style="color: #000000;">            setAnim: function (animId) {
                </span><span style="color: #0000ff;">this</span>.currentAnim = <span style="color: #0000ff;">this</span><span style="color: #000000;">.anims[animId];
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">重置当前帧</span>
<span style="color: #000000;">            resetCurrentFrame: function (index) {
                </span><span style="color: #0000ff;">this</span>.currentAnim &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.setCurrentFrame(index);
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">取得精灵的碰撞区域,</span>
<span style="color: #000000;">            getCollideRect: function () {
                </span><span style="color: #0000ff;">var</span> obj =<span style="color: #000000;"> {
                    x: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.x,
                    y: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.y,
                    width: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.width,
                    height: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.height
                };

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> YYC.Tool.collision.getCollideRect(obj);
            },
            Virtual: {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">初始化方法</span>
<span style="color: #000000;">                init: function () {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation</span>
                    <span style="color: #0000ff;">this</span>.setAnim(<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId);
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新精灵当前状态.</span>
<span style="color: #000000;">                update: function (deltaTime) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._updateFrame(deltaTime);
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">获得坐标对应的方格坐标（向下取值）</span>
<span style="color: #000000;">                getCellPosition: function (x, y) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                        x: Math.floor(x </span>/<span style="color: #000000;"> bomberConfig.WIDTH),
                        y: Math.floor(y </span>/<span style="color: #000000;"> bomberConfig.HEIGHT)
                    }
                },
                draw: function (context) {
                    context.drawImage(</span><span style="color: #0000ff;">this</span>.bitmap.img, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span>.y, <span style="color: #0000ff;">this</span>.bitmap.width, <span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.height);
                },
                clear: function (context) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">直接清空画布区域</span>
                    context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
                }
            }
        }
    });

    window.Sprite </span>=<span style="color: #000000;"> Sprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="color: #000000;">PlayerLayer</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('bfcb3ab1-8bda-4074-a96c-2161651dadd6')"><img id="code_img_closed_bfcb3ab1-8bda-4074-a96c-2161651dadd6" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_bfcb3ab1-8bda-4074-a96c-2161651dadd6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('bfcb3ab1-8bda-4074-a96c-2161651dadd6',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_bfcb3ab1-8bda-4074-a96c-2161651dadd6" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> PlayerLayer =<span style="color: #000000;"> YYC.Class(CharacterLayer, {
        Init: function (deltaTime) {
            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">(deltaTime);
        },
        Private: {
            ___keyDown: function () {
                </span><span style="color: #0000ff;">if</span> (keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span> || keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span>
                    || keyState[keyCodeMap.W] === <span style="color: #0000ff;">true</span> || keyState[keyCodeMap.S] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            },
            ___spriteMoving: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.getChildAt(<span style="color: #800080;">0</span><span style="color: #000000;">).moving
            },
            ___spriteStand: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.getChildAt(<span style="color: #800080;">0</span><span style="color: #000000;">).stand) {
                    </span><span style="color: #0000ff;">this</span>.getChildAt(<span style="color: #800080;">0</span>).stand = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            }
        },
        Public: {
            bombLayer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            setCanvas: function () {
                </span><span style="color: #0000ff;">this</span>.P__canvas = document.getElementById(<span style="color: #800000;">"</span><span style="color: #800000;">playerLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);

                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#playerLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">).css({
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">border</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">1px solid red</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">3</span><span style="color: #000000;">
                });
            },
            init: function (layers) {
                </span><span style="color: #0000ff;">this</span>.bombLayer =<span style="color: #000000;"> layers.bombLayer;

                </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
            },
            change: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.___keyDown() || <span style="color: #0000ff;">this</span>.___spriteMoving() || <span style="color: #0000ff;">this</span><span style="color: #000000;">.___spriteStand()) {
                    </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
                }
            },
            createAndAddBomb: function () {
                </span><span style="color: #0000ff;">var</span> bomb = <span style="color: #0000ff;">this</span>.getChildAt(<span style="color: #800080;">0</span><span style="color: #000000;">).createBomb();
                </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">bomb) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.bombLayer.appendChild(bomb);
                </span><span style="color: #008000;">//</span><span style="color: #008000;">3s后炸弹爆炸</span>
<span style="color: #000000;">                setTimeout(function () {
                    </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">bomb.exploded) {
                        self.bombLayer.explode(bomb);
                    }
                }, </span><span style="color: #800080;">3000</span><span style="color: #000000;">);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> bomb;
            },
            run: function () {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (keyState[keyCodeMap.Space]) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.createAndAddBomb();
                    keyState[keyCodeMap.Space] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
            }
        }
    });

    window.PlayerLayer </span>=<span style="color: #000000;"> PlayerLayer;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="color: #000000;">BomberLayer</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('788dcc5d-31cf-43ea-b7dc-6c1c63cc4988')"><img id="code_img_closed_788dcc5d-31cf-43ea-b7dc-6c1c63cc4988" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_788dcc5d-31cf-43ea-b7dc-6c1c63cc4988" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('788dcc5d-31cf-43ea-b7dc-6c1c63cc4988',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_788dcc5d-31cf-43ea-b7dc-6c1c63cc4988" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> BombLayer =<span style="color: #000000;"> YYC.Class(Layer, {
        Private: {
            ___hasBomb: function(){
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.getChilds().length &gt; <span style="color: #800080;">0</span><span style="color: #000000;">;
            },
            ___removeBomb: function (bomb) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">*注意顺序！</span>

                <span style="color: #0000ff;">this</span><span style="color: #000000;">.clear(bomb);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.remove(bomb);
            },
            ___removeAllFire: function () {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">*注意顺序！</span>

                <span style="color: #0000ff;">this</span><span style="color: #000000;">.fireLayer.clear();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.fireLayer.removeAll();
            },
            ___removeEnemy: function (enemy) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">*注意顺序！</span>

                <span style="color: #0000ff;">this</span><span style="color: #000000;">.enemyLayer.clear(enemy);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.enemyLayer.remove(enemy);
            },
            ___mapChange: function (mapChange) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (mapChange) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.mapLayer.setStateChange();
                }
            },
            ___collideFireWithPlayer: function (bomb) {
                    </span><span style="color: #0000ff;">if</span> (bomb.collideFireWithCharacter(<span style="color: #0000ff;">this</span>.playerLayer.getChildAt(<span style="color: #800080;">0</span><span style="color: #000000;">))) {
                        window.gameState </span>=<span style="color: #000000;"> window.bomberConfig.game.state.OVER;
                    }
            },
            ___collideFireWithEnemy: function (bomb) {
                    </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                        len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                        enemySprites </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.enemyLayer.getChilds();

                    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = enemySprites.length ; i &lt; len; i++<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (bomb.collideFireWithCharacter(enemySprites[i])) {
                            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___removeEnemy(enemySprites[i]);
                        }
                    }
            },
            ___handleCollid: function (bomb) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">判断与玩家人物碰撞</span>
                <span style="color: #0000ff;">this</span><span style="color: #000000;">.___collideFireWithPlayer(bomb)
                </span><span style="color: #008000;">//</span><span style="color: #008000;">判断与每个敌人碰撞</span>
                <span style="color: #0000ff;">this</span><span style="color: #000000;">.___collideFireWithEnemy(bomb);
            },
            ___explodeInEffectiveRange: function (bomb) {
                </span><span style="color: #0000ff;">var</span> eachBomb = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.resetCursor();
                </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasNext()) {
                    eachBomb </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.next();
                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (eachBomb.isInEffectiveRange.call(eachBomb, bomb)) {
                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.explode(eachBomb);
                    }
                }
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.resetCursor();
            }
        },
        Public: {
            fireLayer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            mapLayer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            playerLayer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            enemyLayer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            setCanvas: function () {
                </span><span style="color: #0000ff;">this</span>.P__canvas = document.getElementById(<span style="color: #800000;">"</span><span style="color: #800000;">bombLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">var</span> css =<span style="color: #000000;"> {
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">1</span><span style="color: #000000;">
                };

                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#bombLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">).css(css);
            },
            init: function(layers){
                </span><span style="color: #0000ff;">this</span>.fireLayer =<span style="color: #000000;"> layers.fireLayer;
                </span><span style="color: #0000ff;">this</span>.mapLayer =<span style="color: #000000;"> layers.mapLayer;
                </span><span style="color: #0000ff;">this</span>.playerLayer =<span style="color: #000000;"> layers.playerLayer;
                </span><span style="color: #0000ff;">this</span>.enemyLayer =<span style="color: #000000;"> layers.enemyLayer;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base();
            },
            draw: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">draw</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
            },
            explode: function (bomb) {
                </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">,
                    result </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #008000;">//</span><span style="color: #008000;">处理碰撞</span>
                <span style="color: #0000ff;">this</span><span style="color: #000000;">.___handleCollid(bomb);

                result </span>=<span style="color: #000000;"> bomb.explode();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.fireLayer.addSprites(result.fires);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___mapChange(result.mapChange);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___removeBomb(bomb);


                </span><span style="color: #008000;">//</span><span style="color: #008000;">炸弹爆炸时会引爆在火力范围内的炸弹。</span>
                <span style="color: #0000ff;">this</span><span style="color: #000000;">.___explodeInEffectiveRange(bomb);

                </span><span style="color: #008000;">//</span><span style="color: #008000;">定时清空fireLayer（火焰消失）</span>
<span style="color: #000000;">                setTimeout(function () {
                    self.___removeAllFire();
                }, </span><span style="color: #800080;">300</span><span style="color: #000000;">);

            },
            change: function(){
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.___hasBomb()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.setStateChange();
                }
            },
            run: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__render();
            }
        }
    });

    window.BombLayer </span>=<span style="color: #000000;"> BombLayer;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="color: #000000;">Layer</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('b4d915f4-8a09-4b35-ad18-efd8e2a71369')"><img id="code_img_closed_b4d915f4-8a09-4b35-ad18-efd8e2a71369" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_b4d915f4-8a09-4b35-ad18-efd8e2a71369" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b4d915f4-8a09-4b35-ad18-efd8e2a71369',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_b4d915f4-8a09-4b35-ad18-efd8e2a71369" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Layer =<span style="color: #000000;"> YYC.AClass(Collection, {
        Init: function () {
        },
        Private: {
            __state: bomberConfig.layer.state.CHANGE,   </span><span style="color: #008000;">//</span><span style="color: #008000;">默认为change</span>
<span style="color: #000000;">
            __getContext: function () {
                </span><span style="color: #0000ff;">this</span>.P__context = <span style="color: #0000ff;">this</span>.P__canvas.getContext(<span style="color: #800000;">"</span><span style="color: #800000;">2d</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        },
        Protected: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">*共用的变量（可读、写）</span>
<span style="color: #000000;">
            P__canvas: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            P__context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">*共用的方法（可读）</span>
<span style="color: #000000;">
            P__isChange: function(){
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.__state ===<span style="color: #000000;"> bomberConfig.layer.state.CHANGE;
            },
            P__isNormal: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.__state ===<span style="color: #000000;"> bomberConfig.layer.state.NORMAL;
            },
            P__iterator: function (handler) {
                </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span><span style="color: #000000;">),
                    nextElement </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasNext()) {
                    nextElement </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.next();
                    nextElement[handler].apply(nextElement, args);  </span><span style="color: #008000;">//</span><span style="color: #008000;">要指向nextElement</span>
<span style="color: #000000;">                }
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.resetCursor();
            },
            P__render: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__isChange()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.clear();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.draw();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.setStateNormal();
                }
            }
        },
        Public: {
            remove: function (sprite) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base(function (e, obj) {
                    </span><span style="color: #0000ff;">if</span> (e.x === obj.x &amp;&amp; e.y ===<span style="color: #000000;"> obj.y) {
                        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }, sprite);
            },
            addSprites: function(elements){
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.appendChilds(elements);
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">设置状态为NORMAL</span>
<span style="color: #000000;">            setStateNormal: function () {
                </span><span style="color: #0000ff;">this</span>.__state =<span style="color: #000000;"> bomberConfig.layer.state.NORMAL;
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">设置状态为CHANGE</span>
<span style="color: #000000;">            setStateChange: function () {
                </span><span style="color: #0000ff;">this</span>.__state =<span style="color: #000000;"> bomberConfig.layer.state.CHANGE;
            },
            Virtual: {
                init: function () {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__getContext();
                },
                clear: function (sprite) {
                    </span><span style="color: #0000ff;">if</span> (arguments.length === <span style="color: #800080;">0</span><span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">clear</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
                    }
                    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (arguments.length === <span style="color: #800080;">1</span><span style="color: #000000;">) {
                        sprite.clear(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
                    }
                }
            }
        },
        Abstract: {
            setCanvas: function () {
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">判断并更改状态</span>
<span style="color: #000000;">            change: function () {
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">统一绘制</span>
<span style="color: #000000;">            draw: function () { },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">游戏主线程调用的函数</span>
<span style="color: #000000;">            run: function () { }
        }
    });

    window.Layer </span>=<span style="color: #000000;"> Layer;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="color: #000000;">SpriteFactory</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        createBomb: function (playerSprite) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> BombSprite(playerSprite, bitmapFactory.createBitmap({ img: window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">bomb</span><span style="color: #800000;">"</span><span style="color: #000000;">), width: bomberConfig.WIDTH, height: bomberConfig.HEIGHT }));
        },
        createFire: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> FireSprite(<span style="color: #0000ff;">null</span>, bitmapFactory.createBitmap({ img: window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">fire</span><span style="color: #800000;">"</span><span style="color: #000000;">), width: bomberConfig.WIDTH, height: bomberConfig.HEIGHT }));
        },
        createExplode: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> FireSprite(<span style="color: #0000ff;">null</span>, bitmapFactory.createBitmap({ img: window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">explode</span><span style="color: #800000;">"</span><span style="color: #000000;">), width: bomberConfig.WIDTH, height: bomberConfig.HEIGHT }));
        }</span></pre>
</div>
<p><span style="color: #000000;">LayerFactory</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        createBomb: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> BombLayer();
        },
        createFire: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> FireLayer();
        }</span></pre>
</div>
<p><a name="add"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">加入1个敌人</span></strong></p>
<p>往EnemyLayer集合中再加入一个EnemySprite实例，SpriteData增加第2个敌人的数据，SpriteFactory增加工厂方法createEnemy2。</p>
<h1>相关代码</h1>
<p>Game</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">           _createEnemyLayerElement: function () {
                </span><span style="color: #0000ff;">var</span> element =<span style="color: #000000;"> [],
                    enemy </span>=<span style="color: #000000;"> spriteFactory.createEnemy(),
                    enemy2 </span>=<span style="color: #000000;"> spriteFactory.createEnemy2();

                enemy.init();
                enemy2.init();

                element.push(enemy);
                element.push(enemy2);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
            },</span></pre>
</div>
<p>SpriteData</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">enemy2: {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">初始坐标</span>
        x: bomberConfig.WIDTH * <span style="color: #800080;">10</span><span style="color: #000000;">,
    </span><span style="color: #008000;">//</span><span style="color: #008000;">x: 0,</span>
        y: bomberConfig.HEIGHT * <span style="color: #800080;">10</span><span style="color: #000000;">,
    </span><span style="color: #008000;">//</span><span style="color: #008000;">定义sprite走路速度的绝对值</span>
<span style="color: #000000;">        walkSpeed: bomberConfig.enemy.speed.NORMAL,

    </span><span style="color: #008000;">//</span><span style="color: #008000;">速度</span>
        speedX: <span style="color: #800080;">1</span><span style="color: #000000;">,
        speedY: </span><span style="color: #800080;">1</span><span style="color: #000000;">,

        minX: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        maxX: bomberConfig.canvas.WIDTH </span>-<span style="color: #000000;"> bomberConfig.player.IMGWIDTH,
        minY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        maxY: bomberConfig.canvas.HEIGHT </span>-<span style="color: #000000;"> bomberConfig.player.IMGHEIGHT,

        defaultAnimId: </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">,

        anims: {
            </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
            </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
            </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
            </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
            </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
            </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
            </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
            </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getFrames(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">))
        }
}</span></pre>
</div>
<p>SpriteFactory</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        createEnemy2: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> EnemySprite(getSpriteData(<span style="color: #800000;">"</span><span style="color: #800000;">enemy2</span><span style="color: #800000;">"</span>), bitmapFactory.createBitmap({ img: window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">), width: bomberConfig.player.IMGWIDTH, height: bomberConfig.player.IMGHEIGHT }));
        },</span></pre>
</div>
<h1><span style="color: #000000;">炸死所有敌人后，提示游戏胜利</span></h1>
<p>GameState增加WIN枚举值。在BombLayer中判断是否将敌人都炸死了，如果都炸死了则设置GameState为WIN。在Game中判断GameState，调用相应的方法。</p>
<h2>领域模型</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201309/27165443-99cdaa6068054767b6a96273e02bf222.jpg" alt="" /></p>
<h2>相关代码</h2>
<p>BombLayer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">           ___collideFireWithEnemy: function (bomb) {
                    </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                        len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                        enemySprites </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.enemyLayer.getChilds();

                    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = enemySprites.length ; i &lt; len; i++<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (bomb.collideFireWithCharacter(enemySprites[i])) {
                            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___removeEnemy(enemySprites[i]);
                        }
                    }

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">如果敌人都被炸死了，则游戏胜利！</span>
                    <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.enemyLayer.getChilds().length === <span style="color: #800080;">0</span><span style="color: #000000;">) {
                        window.gameState </span>=<span style="color: #000000;"> window.bomberConfig.game.state.WIN;
                    }
            },</span></pre>
</div>
<p>Game</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">_judgeGameState: function () {
    </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (window.gameState) {
        </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> window.bomberConfig.game.state.NORMAL:
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> window.bomberConfig.game.state.OVER:
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.gameOver();
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> window.bomberConfig.game.state.WIN:
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.gameWin();
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">未知的游戏状态</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
}
...
run: function () {
    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._judgeGameState();

    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layerManager.run();
    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layerManager.change();
},</span></pre>
</div>
<p><a name="model"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文最终领域模型</span></strong></p>
<p><img src="http://images.cnitblog.com/blog/419321/201311/28133034-427a57439c904d6fa719af30f2323ce9.jpg" alt="" width="755" height="405" /></p>
<p><a href="http://images.cnitblog.com/blog/419321/201311/28133034-427a57439c904d6fa719af30f2323ce9.jpg" target="_blank">查看大图</a></p>
<p><a name="layer"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">高层划分</span></strong></p>
<h1>炸弹层和炸弹精灵、火焰层和火焰精灵应该放到哪个包？</h1>
<p>炸弹层和玩家层、炸弹精灵和玩家精灵紧密关联，火焰层和火焰精灵与炸弹层和炸弹精灵紧密关联，因此将炸弹层和炸弹精灵、火焰层和火焰精灵移到人物包中。</p>
<h1>新增包</h1>
<ul>
<li>全局包<br /><span style="font-size: 14px; line-height: 1.5;">GameState</span></li>
<li>观察者模式包<br /><span style="font-size: 14px; line-height: 1.5;">Subject</span></li>
<li>炸弹实现包<br /><span style="font-size: 14px; line-height: 1.5;">BombSprite、FireSprite、BombLayer、FireLayer</span></li>












</ul>
<h1>层、包</h1>
<p><span style="color: #ff0000;"><img src="http://images.cnitblog.com/blog/419321/201310/21103802-49408d70ce634916b5a48332a5444b2c.jpg" alt="" width="722" height="1102" /></span></p>
<h1>对应领域模型</h1>
<ul>
<li>辅助操作层
<ul>
<li>控件包<br />PreLoadImg</li>
<li>配置包<br />Config</li>






















</ul>






















</li>
<li>用户交互层
<ul>
<li>入口包<br />Main</li>






















</ul>






















</li>
<li>业务逻辑层
<ul>
<li>辅助逻辑
<ul>
<li>工厂包<br />BitmapFactory、LayerFactory、SpriteFactory</li>
<li>事件管理包<br />KeyState、KeyEventManager</li>
<li>抽象包<br />Layer、Sprite、Hash、Collection</li>
<li>全局包<br />GameState</li>






















</ul>






















</li>
<li>游戏主逻辑
<ul>
<li>主逻辑包<br />Game</li>






















</ul>






















</li>
<li>层管理
<ul>
<li>层管理包<br />LayerManager</li>






















</ul>






















</li>
<li>实现
<ul>
<li>人物实现包<br />PlayerLayer、MoveSprite、PlayerSprite、EnemySprite、CharacterLayer、PlayerLayer、EnemyLayer、Context、PlayerState、WalkState、StandState、WalkState_X、WalkState_Y、StandLeftState、StandRightState、StandUpState、StandDownState、WalkLeftState、WalkRightState、WalkUpState、WalkDownState</li>
<li>炸弹实现包<br />BombSprite、FireSprite、BombLayer、FireLayer</li>
<li>地图实现包<br />MapLayer、MapElementSprite</li>
<li>算法包<br />FindPath</li>
<li>动画包<br />Animation、GetSpriteData、SpriteData、GetFrames、FrameData</li>
<li>观察者模式包<br />Subject</li>






















</ul>






















</li>






















</ul>






















</li>
<li>数据操作层
<ul>
<li>地图数据操作包<br />MapDataOperate、TerrainDataOperate</li>
<li>路径数据操作包<br />GetPath</li>
<li>图片数据操作包<br />Bitmap</li>






















</ul>






















</li>
<li>数据层
<ul>
<li>地图包<br />MapData、TerrainData</li>
<li>图片路径包<br />ImgPathData</li>












</ul>












</li>












</ul>
<p>
<a name="demo"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文参考资料</span></strong></p>
<p><a id="ctl01_lnkTitle" href="http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html">深入理解JavaScript系列（32）：设计模式之观察者模式</a></p>
<p>《设计模式之禅》</p>
<h1>欢迎浏览上一篇博文：<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3334223.html">炸弹人游戏开发系列（7）：加入敌人，使用A*算法寻路</a></h1>
<h1>欢迎浏览下一篇博文：<a href="http://www.cnblogs.com/chaogex/p/3343198.html">炸弹人游戏开发系列（9）：总结<span>&nbsp;</span></a></h1>]]></description></item><item><title>炸弹人游戏开发系列（7）：加入敌人，使用A*算法寻路</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/20/3334223.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sun, 20 Oct 2013 14:56:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/20/3334223.html</guid><description><![CDATA[<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">前言</span></strong></p>
<p>上文中我们实现了炸弹人与墙的碰撞检测，以及设置移动步长来解决发现的问题。本文会加入1个AI敌人，敌人使用A*算法追踪炸弹人。</p>
<h1>本文目的</h1>
<p>加入敌人，追踪炸弹人</p>
<h1>本文主要内容</h1>
<ul>
<li><a href="#strategy">开发策略</a></li>
<li><a href="#addEnemy">加入敌人</a></li>
<li><a href="#algorithm">实现 寻路算法</a></li>
<li><a href="#refactor">重构</a></li>
<li><a href="#model">本文最终领域模型</a></li>
<li><a href="#layer">高层划分</a></li>
<li><a href="#demo">演示</a></li>
<li><a href="#reference">本文参考资料</a></li>
</ul>
<h1>回顾上文更新后的领域模型</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201311/28133116-7db38316f22f45458a298a06bf3d4ff3.jpg" alt="" width="694" height="374" /></p>
<p><a href="http://images.cnitblog.com/blog/419321/201311/28133116-7db38316f22f45458a298a06bf3d4ff3.jpg" target="_blank">查看大图</a></p>
<p><a name="strategy"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">开发策略</span></strong></p>
<p>首先实现&ldquo;加入敌人&rdquo;功能。通过参考&ldquo;<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3213041.html">炸弹人游戏开发系列（4）：炸弹人显示与移动</a>&ldquo;中的实现，可以初步分析出需要加入敌人图片、敌人帧数据和精灵数据、敌人精灵类EnemySprite、敌人层EnemyLayer和敌人层管理类EnemyLayerManager。</p>
<p>然后实现&ldquo;追踪炸弹人&rdquo;功能。需要新建一个算法类FindPath，负责使用A*算法计算并返回路径数据。</p>
<p>敌人精灵类与算法类的交互关系：</p>
<p><img src="http://images.cnitblog.com/blog/419321/201310/28182801-4ecc22002319449783dc7cbd7fa42c91.jpg" alt="" /></p>
<h1>并行开发</h1>
<p>可以并行开发&ldquo;加入敌人&rdquo;和&ldquo;追踪炸弹人&rdquo;。</p>
<p>先定义一个FindPath类的的接口，指定findPath方法输入参数和返回参数的格式。</p>
<p>实现&ldquo;加入敌人&rdquo;功能时，可以按照接口指定的格式使用假的路径数据来测试EnemySprite类；实现&ldquo;追踪炸弹人&rdquo;功能时，按照接口指定格式使用假的坐标数据来测试FindPath类。</p>
<p>在EnemySprit和FindPath都实现后，再集成在一起测试。因为两者接口一致，因此集成时不会有什么困难。</p>
<p><a name="addEnemy"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">加入敌人</span></strong></p>
<h1>扩大地图</h1>
<p>现在地图大小为4*4，太小了。</p>
<p>加入一个敌人后：</p>
<ul>
<li>可玩性太低<br />很快游戏就结束了；玩家操作炸弹人躲避敌人的空间太小了。</li>
<li>不方便演示和测试游戏<br />由于游戏很快就结束，因此不方便演示和测试游戏。</li>













</ul>
<p>因此，将地图扩大为20*20。</p>
<p>要实现这个功能，只需要修改MapData和TerrainData即可。</p>
<h2>相关代码</h2>
<p>MapData</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('a9878aaa-84c1-4cf9-92d7-290c81d9c666')"><img id="code_img_closed_a9878aaa-84c1-4cf9-92d7-290c81d9c666" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_a9878aaa-84c1-4cf9-92d7-290c81d9c666" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a9878aaa-84c1-4cf9-92d7-290c81d9c666',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_a9878aaa-84c1-4cf9-92d7-290c81d9c666" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">地图数据</span>
<span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> ground =<span style="color: #000000;"> bomberConfig.map.type.GROUND,
        wall </span>=<span style="color: #000000;"> bomberConfig.map.type.WALL;

    </span><span style="color: #0000ff;">var</span> mapData =<span style="color: #000000;"> [
        [
            wall, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, wall, wall, wall,
            wall, wall, wall, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, wall, wall, ground,
            ground, ground, ground, wall, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, wall, wall, wall,
            ground, wall, ground, wall, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],



        [
            wall, ground, wall, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],

        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],


        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ],
        [
            wall, ground, ground, ground, wall,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground,
            ground, ground, ground, ground, ground
        ]
    ];

    window.mapData </span>=<span style="color: #000000;"> mapData;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>TerrainData</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('4c70df4c-0e28-4b11-8c11-53a107430488')"><img id="code_img_closed_4c70df4c-0e28-4b11-8c11-53a107430488" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_4c70df4c-0e28-4b11-8c11-53a107430488" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4c70df4c-0e28-4b11-8c11-53a107430488',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_4c70df4c-0e28-4b11-8c11-53a107430488" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> pass =<span style="color: #000000;"> bomberConfig.map.terrain.pass,
        stop </span>=<span style="color: #000000;"> bomberConfig.map.terrain.stop;

    </span><span style="color: #0000ff;">var</span> terrainData =<span style="color: #000000;"> [
        [
            stop, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, stop, stop, stop,
            stop, stop, stop, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, stop, stop, pass,
            pass, pass, pass, stop, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, stop, stop, stop,
            pass, stop, pass, stop, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],



        [
            stop, pass, stop, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],

        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],


        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ],
        [
            stop, pass, pass, pass, stop,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass,
            pass, pass, pass, pass, pass
        ]
    ];

    window.terrainData </span>=<span style="color: #000000;"> terrainData;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h1>加入敌人图片和数据</h1>
<p>首先加入敌人的精灵图片</p>
<p><img src="http://images.cnitblog.com/blog/419321/201309/24115406-baee08657685408cacbf832d4edb4a11.png" alt="" width="192" height="384" /></p>
<p>然后加入敌人帧动画数据类</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('067c1588-a104-4ca2-a4f0-569a1216066e')"><img id="code_img_closed_067c1588-a104-4ca2-a4f0-569a1216066e" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_067c1588-a104-4ca2-a4f0-569a1216066e" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('067c1588-a104-4ca2-a4f0-569a1216066e',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_067c1588-a104-4ca2-a4f0-569a1216066e" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> getEnemyFrames =<span style="color: #000000;"> (function () {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">一个动作在图片中的宽度</span>
        <span style="color: #0000ff;">var</span> width =<span style="color: #000000;"> bomberConfig.enemy.WIDTH,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">一个动作在图片中的高度</span>
            height =<span style="color: #000000;"> bomberConfig.enemy.HEIGHT,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">一个动作的偏移量</span>
            offset =<span style="color: #000000;"> {
                x: bomberConfig.enemy.offset.X,
                y: bomberConfig.enemy.offset.Y
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">一个动作横向截取的长度</span>
            sw =<span style="color: #000000;"> bomberConfig.enemy.SW,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">一个动作纵向截取的长度</span>
            sh =<span style="color: #000000;"> bomberConfig.enemy.SH,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">一个动作图片在canvas中的宽度</span>
            imgWidth =<span style="color: #000000;"> bomberConfig.enemy.IMGWIDTH,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">一个动作图片在canvas中的高度</span>
            imgHeight =<span style="color: #000000;"> bomberConfig.enemy.IMGHEIGHT;

        </span><span style="color: #008000;">//</span><span style="color: #008000;">帧数据</span>
        <span style="color: #0000ff;">var</span> frames =<span style="color: #000000;"> function () {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">向右站立</span>
<span style="color: #000000;">                stand_right: {
                    img: window.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                    frames: [
                        { x: offset.x, y: offset.y </span>+ <span style="color: #800080;">2</span> * height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> }
                    ]
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">向左站立</span>
<span style="color: #000000;">                stand_left: {
                    img: window.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                    frames: [
                        { x: offset.x, y: offset.y </span>+ height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> }
                    ]
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">向上站立</span>
<span style="color: #000000;">                stand_up: {
                    img: window.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                    frames: [
                        { x: offset.x, y: offset.y </span>+ <span style="color: #800080;">3</span> * height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> }
                    ]
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">向下站立</span>
<span style="color: #000000;">                stand_down: {
                    img: window.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                    frames: [
                        { x: offset.x, y: offset.y, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: </span><span style="color: #800080;">100</span><span style="color: #000000;"> }
                    ]
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">向上走</span>
<span style="color: #000000;">                walk_up: {
                    img: window.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                    frames: [
                        { x: offset.x, y: offset.y </span>+ <span style="color: #800080;">3</span> * height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: offset.x </span>+ width, y: offset.y + <span style="color: #800080;">3</span> * height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: offset.x </span>+ <span style="color: #800080;">2</span> * width, y: offset.y + <span style="color: #800080;">3</span> * height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: offset.x </span>+ <span style="color: #800080;">3</span> * width, y: offset.y + <span style="color: #800080;">3</span> * height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> }
                    ]
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">向下走</span>
<span style="color: #000000;">                walk_down: {
                    img: window.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                    frames: [
                        { x: offset.x, y: offset.y, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: </span><span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: offset.x </span>+ width, y: offset.y, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: offset.x </span>+ <span style="color: #800080;">2</span> * width, y: offset.y, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: offset.x </span>+ <span style="color: #800080;">3</span> * width, y: offset.y, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> }
                    ]
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">向右走</span>
<span style="color: #000000;">                walk_right: {
                    img: window.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                    frames: [
                        { x: offset.x, y: offset.y </span>+ <span style="color: #800080;">2</span> * height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: offset.x </span>+ width, y: offset.y + <span style="color: #800080;">2</span> * height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: offset.x </span>+ <span style="color: #800080;">2</span> * width, y: offset.y + <span style="color: #800080;">2</span> * height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: offset.x </span>+ <span style="color: #800080;">3</span> * width, y: offset.y + <span style="color: #800080;">2</span> * height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> }
                    ]
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">向左走</span>
<span style="color: #000000;">                walk_left: {
                    img: window.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                    frames: [
                        { x: offset.x, y: offset.y </span>+ height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: offset.x </span>+ width, y: offset.y + height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: offset.x </span>+ <span style="color: #800080;">2</span> * width, y: offset.y + height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: offset.x </span>+ <span style="color: #800080;">3</span> * width, y: offset.y + height, width: sw, height: sh, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> }
                    ]
                }
            }
        }

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> function (animName) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> frames()[animName];
        };
    }());

    window.getEnemyFrames </span>=<span style="color: #000000;"> getEnemyFrames;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>然后加入敌人精灵类数据</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> getSpriteData =<span style="color: #000000;"> (function () {
        </span><span style="color: #0000ff;">var</span> data =<span style="color: #000000;"> function(){
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
...
                </span><span style="color: #008000;">//</span><span style="color: #008000;">敌人精灵类</span>
<span style="color: #000000;">                enemy: {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">初始坐标</span>
                    x: bomberConfig.WIDTH * <span style="color: #800080;">10</span><span style="color: #000000;">,
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">x: 0,</span>
                    y: bomberConfig.HEIGHT * <span style="color: #800080;">3</span><span style="color: #000000;">,
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">定义sprite走路速度的绝对值</span>
<span style="color: #000000;">                    walkSpeed: bomberConfig.enemy.speed.NORMAL,

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">速度</span>
                    speedX: <span style="color: #800080;">1</span><span style="color: #000000;">,
                    speedY: </span><span style="color: #800080;">1</span><span style="color: #000000;">,

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">注意坐标起始点为图片左上点！</span>
<span style="color: #000000;">
                    minX: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
                    maxX: bomberConfig.canvas.WIDTH </span>-<span style="color: #000000;"> bomberConfig.player.IMGWIDTH,
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">maxX: 500,</span>
                    minY: <span style="color: #800080;">0</span><span style="color: #000000;">,
                    maxY: bomberConfig.canvas.HEIGHT </span>-<span style="color: #000000;"> bomberConfig.player.IMGHEIGHT,



                    defaultAnimId: </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">,

                    anims: {
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getEnemyFrames(<span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getEnemyFrames(<span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getEnemyFrames(<span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getEnemyFrames(<span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getEnemyFrames(<span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getEnemyFrames(<span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getEnemyFrames(<span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getEnemyFrames(<span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">))
                    }
                }
            }
        };

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> function (spriteName) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> data()[spriteName];
        };
    }());

    window.getSpriteData </span>=<span style="color: #000000;"> getSpriteData;
}());</span></pre>
</div>
<h1>加入EnemySprite类</h1>
<p>增加敌人精灵类。</p>
<h2>创建假的A*算法类FindPath类</h2>
<p>创建返回假数据的FindPath类，用于测试EnemySprite类。</p>
<h2>相关代码</h2>
<p>FindPath</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">构造假数据</span>
    <span style="color: #0000ff;">var</span> findPath =<span style="color: #000000;"> {
        aCompute: function (terrainData, begin, target) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                path: [{ x: </span><span style="color: #800080;">8</span>, y: <span style="color: #800080;">0</span> }, { x: <span style="color: #800080;">7</span>, y: <span style="color: #800080;">0</span> }, { x: <span style="color: #800080;">6</span>, y: <span style="color: #800080;">0</span> }, { x: <span style="color: #800080;">5</span>, y: <span style="color: #800080;">0</span> }, { x: <span style="color: #800080;">4</span>, y: <span style="color: #800080;">0</span><span style="color: #000000;"> }],
                time: </span><span style="color: #800080;">0.1</span><span style="color: #000000;">
            };
        }
    };

    window.findPath </span>=<span style="color: #000000;"> findPath;
}());</span></pre>
</div>
<p><span>EnemySprite</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('299d590d-a189-47fe-bb65-133015bd02b2')"><img id="code_img_closed_299d590d-a189-47fe-bb65-133015bd02b2" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_299d590d-a189-47fe-bb65-133015bd02b2" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('299d590d-a189-47fe-bb65-133015bd02b2',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_299d590d-a189-47fe-bb65-133015bd02b2" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> EnemySprite =<span style="color: #000000;"> YYC.Class({
        Init: function (data) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">初始坐标</span>
            <span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
            </span><span style="color: #0000ff;">this</span>.y =<span style="color: #000000;"> data.y;

            </span><span style="color: #0000ff;">this</span>.speedX =<span style="color: #000000;"> data.speedX;
            </span><span style="color: #0000ff;">this</span>.speedY =<span style="color: #000000;"> data.speedY;

            </span><span style="color: #008000;">//</span><span style="color: #008000;">x/y坐标的最大值和最小值, 可用来限定移动范围.</span>
            <span style="color: #0000ff;">this</span>.minX =<span style="color: #000000;"> data.minX;
            </span><span style="color: #0000ff;">this</span>.maxX =<span style="color: #000000;"> data.maxX;
            </span><span style="color: #0000ff;">this</span>.minY =<span style="color: #000000;"> data.minY;
            </span><span style="color: #0000ff;">this</span>.maxY =<span style="color: #000000;"> data.maxY;

            </span><span style="color: #0000ff;">this</span>.defaultAnimId =<span style="color: #000000;"> data.defaultAnimId;
            </span><span style="color: #0000ff;">this</span>.anims =<span style="color: #000000;"> data.anims;

            </span><span style="color: #0000ff;">this</span>.walkSpeed =<span style="color: #000000;"> data.walkSpeed;
            </span><span style="color: #0000ff;">this</span>.speedX =<span style="color: #000000;"> data.walkSpeed;
            </span><span style="color: #0000ff;">this</span>.speedY =<span style="color: #000000;"> data.walkSpeed;

            </span><span style="color: #0000ff;">this</span>._context = <span style="color: #0000ff;">new</span> Context(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        },
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">状态模式上下文类</span>
            __context: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">更新帧动画</span>
<span style="color: #000000;">            _updateFrame: function (deltaTime) {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.update(deltaTime);
                }
            },
            _computeCoordinate: function () {
                </span><span style="color: #0000ff;">this</span>.x = <span style="color: #0000ff;">this</span>.x + <span style="color: #0000ff;">this</span>.speedX * <span style="color: #0000ff;">this</span><span style="color: #000000;">.dirX;
                </span><span style="color: #0000ff;">this</span>.y = <span style="color: #0000ff;">this</span>.y + <span style="color: #0000ff;">this</span>.speedY * <span style="color: #0000ff;">this</span><span style="color: #000000;">.dirY;

                </span><span style="color: #008000;">//</span><span style="color: #008000;">因为移动次数是向上取整，可能会造成移动次数偏多（如stepX为2.5，取整则stepX为3），
                </span><span style="color: #008000;">//</span><span style="color: #008000;">坐标可能会偏大（大于bomberConfig.WIDTH / bomberConfig.HEIGHT的整数倍），
                </span><span style="color: #008000;">//</span><span style="color: #008000;">因此此处需要向下取整。


                </span><span style="color: #008000;">//</span><span style="color: #008000;">x、y为bomberConfig.WIDTH/bomberConfig.HEIGHT的整数倍（向下取整）</span>
                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.completeOneMove) {
                    </span><span style="color: #0000ff;">this</span>.x -= <span style="color: #0000ff;">this</span>.x %<span style="color: #000000;"> bomberConfig.WIDTH;
                    </span><span style="color: #0000ff;">this</span>.y -= <span style="color: #0000ff;">this</span>.y %<span style="color: #000000;"> bomberConfig.HEIGHT;
                }
            },
            __getCurrentState: function () {
                </span><span style="color: #0000ff;">var</span> currentState = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">switch</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandRightState();
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandDownState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandUpState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkDownState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkUpState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkRightState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">未知的状态</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
                ;

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> currentState;
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">计算移动次数</span>
<span style="color: #000000;">            __computeStep: function () {
                </span><span style="color: #0000ff;">this</span>.stepX = Math.ceil(bomberConfig.WIDTH / <span style="color: #0000ff;">this</span><span style="color: #000000;">.speedX);
                </span><span style="color: #0000ff;">this</span>.stepY = Math.ceil(bomberConfig.HEIGHT / <span style="color: #0000ff;">this</span><span style="color: #000000;">.speedY);
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标</span>
            x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的速度</span>
            speedX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            speedY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标区间</span>
            minX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            maxX: </span><span style="color: #800080;">9999</span><span style="color: #000000;">,
            minY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            maxY: </span><span style="color: #800080;">9999</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵包含的所有 Animation 集合. Object类型, 数据存放方式为" id : animation ".</span>
            anims: <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">默认的Animation的Id , string类型</span>
            defaultAnimId: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">当前的Animation.</span>
            currentAnim: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的方向系数：
            </span><span style="color: #008000;">//</span><span style="color: #008000;">往下走dirY为正数，往上走dirY为负数；
            </span><span style="color: #008000;">//</span><span style="color: #008000;">往右走dirX为正数，往左走dirX为负数。</span>
            dirX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            dirY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">定义sprite走路速度的绝对值</span>
            walkSpeed: <span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">一次移动步长中的需要移动的次数</span>
            stepX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            stepY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">一次移动步长中已经移动的次数</span>
            moveIndex_x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            moveIndex_y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">是否正在移动标志</span>
            moving: <span style="color: #0000ff;">false</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">站立标志
            </span><span style="color: #008000;">//</span><span style="color: #008000;">用于解决调用WalkState.stand后，PlayerLayer.render中P__isChange返回false的问题
            </span><span style="color: #008000;">//</span><span style="color: #008000;">（不调用draw，从而仍会显示精灵类walk的帧（而不会刷新为更新状态后的精灵类stand的帧））。</span>
            stand: <span style="color: #0000ff;">false</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">寻找的路径</span>
            path: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation, 参数为Animation的id, String类型</span>
<span style="color: #000000;">            setAnim: function (animId) {
                </span><span style="color: #0000ff;">this</span>.currentAnim = <span style="color: #0000ff;">this</span><span style="color: #000000;">.anims[animId];
            },
            init: function () {
                </span><span style="color: #0000ff;">this</span>.__context.setPlayerState(<span style="color: #0000ff;">this</span><span style="color: #000000;">.__getCurrentState());
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__computeStep();

                </span><span style="color: #0000ff;">this</span>.path =<span style="color: #000000;"> window.findPath.aCompute().path;

                </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation</span>
                <span style="color: #0000ff;">this</span>.setAnim(<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId);
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新精灵当前状态</span>
<span style="color: #000000;">            update: function (deltaTime) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._updateFrame(deltaTime);
            },
            draw: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    context.drawImage(</span><span style="color: #0000ff;">this</span>.currentAnim.getImg(), frame.x, frame.y, frame.width, frame.height, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y, frame.imgWidth, frame.imgHeight);
                }
            },
            clear: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">直接清空画布区域</span>
                    context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
                }
            },
            move: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.move();
            },
            setDir: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.moving) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #008000;">//</span><span style="color: #008000;">返回并移除要移动到的坐标</span>
                <span style="color: #0000ff;">var</span> target = <span style="color: #0000ff;">this</span><span style="color: #000000;">.path.shift();

                </span><span style="color: #008000;">//</span><span style="color: #008000;">当前坐标</span>
                <span style="color: #0000ff;">var</span> now =<span style="color: #000000;"> {
                    x: self.x </span>/<span style="color: #000000;"> bomberConfig.WIDTH,
                    y: self.y </span>/<span style="color: #000000;"> bomberConfig.HEIGHT
                };

                </span><span style="color: #008000;">//</span><span style="color: #008000;">判断要移动的方向，调用相应的方法</span>
                <span style="color: #0000ff;">if</span> (target.x &gt;<span style="color: #000000;"> now.x) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkRight();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (target.x &lt;<span style="color: #000000;"> now.x) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkLeft();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (target.y &gt;<span style="color: #000000;"> now.y) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkDown();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (target.y &lt;<span style="color: #000000;"> now.y) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkUp();
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.stand();
                }
            }
        }
    });

    window.EnemySprite </span>=<span style="color: #000000;"> EnemySprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h1>增加敌人精灵类工厂</h1>
<p>SpriteFactory新增工厂方法createEnemy，用于创建EnemySprite实例。</p>
<p>SpriteFactory</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        createEnemy: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> EnemySprite(getSpriteData(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">));
        }</span></pre>
</div>
<h1>新增EnemyLayer</h1>
<p>增加敌人画布，该画布于地图画布之上，与玩家画布的zIndex相同。同时增加对应的敌人层类EnemyLayer，它的集合元素为EnemySprite类的实例。</p>
<p>EnemyLayer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> EnemyLayer =<span style="color: #000000;"> YYC.Class(Layer, {
        Init: function (deltaTime) {
            </span><span style="color: #0000ff;">this</span>.___deltaTime =<span style="color: #000000;"> deltaTime;
        },
        Private: {
            ___deltaTime: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            ___iterator: function (handler) {
                </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span><span style="color: #000000;">),
                    nextElement </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasNext()) {
                    nextElement </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.next();
                    nextElement[handler].apply(nextElement, args);  </span><span style="color: #008000;">//</span><span style="color: #008000;">要指向nextElement</span>
<span style="color: #000000;">                }
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.resetCursor();
            },
            ___update: function (deltaTime) {
                </span><span style="color: #0000ff;">this</span>.___iterator(<span style="color: #800000;">"</span><span style="color: #800000;">update</span><span style="color: #800000;">"</span><span style="color: #000000;">, deltaTime);
            },
            __setDir: function () {
                </span><span style="color: #0000ff;">this</span>.___iterator(<span style="color: #800000;">"</span><span style="color: #800000;">setDir</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            },
            ___move: function (deltaTime) {
                </span><span style="color: #0000ff;">this</span>.___iterator(<span style="color: #800000;">"</span><span style="color: #800000;">move</span><span style="color: #800000;">"</span><span style="color: #000000;">, deltaTime);
            }
        },
        Public: {
            setCanvas: function () {
                </span><span style="color: #0000ff;">this</span>.P__canvas = document.getElementById(<span style="color: #800000;">"</span><span style="color: #800000;">enemyLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span>
                $(<span style="color: #800000;">"</span><span style="color: #800000;">#enemyLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">).css({
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">border</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">1px solid black</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">1</span>    <span style="color: #008000;">//</span><span style="color: #008000;">z-index与playerLayer相同</span>
<span style="color: #000000;">                });
            },
            draw: function (context) {
                </span><span style="color: #0000ff;">this</span>.___iterator(<span style="color: #800000;">"</span><span style="color: #800000;">draw</span><span style="color: #800000;">"</span><span style="color: #000000;">, context);
            },
            clear: function (context) {
                </span><span style="color: #0000ff;">this</span>.___iterator(<span style="color: #800000;">"</span><span style="color: #800000;">clear</span><span style="color: #800000;">"</span><span style="color: #000000;">, context);
            },
            render: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__setDir();
                </span><span style="color: #0000ff;">this</span>.___move(<span style="color: #0000ff;">this</span><span style="color: #000000;">.___deltaTime);

                </span><span style="color: #008000;">//</span><span style="color: #008000;">判断__state是否为change状态，如果是则调用canvas绘制精灵。</span>
                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__isChange()) {
                    </span><span style="color: #0000ff;">this</span>.clear(<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
                    </span><span style="color: #0000ff;">this</span>.___update(<span style="color: #0000ff;">this</span><span style="color: #000000;">.___deltaTime);
                    </span><span style="color: #0000ff;">this</span>.draw(<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__setStateNormal();
                }
            }
        }
    });

    window.EnemyLayer </span>=<span style="color: #000000;"> EnemyLayer;
}());</span></pre>
</div>
<h1>增加敌人层类工厂</h1>
<p>LayerFactory新增工厂方法createEnemy，用于创建EnemyLayer实例</p>
<p>LayerFactory</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        createEnemy: function (deltaTime) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> EnemyLayer(deltaTime);
        }</span></pre>
</div>
<h1>新增EnemyLayerManager</h1>
<p>增加EnemyLayer的管理类EnemyLayerManager</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> EnemyLayerManager =<span style="color: #000000;"> YYC.Class(LayerManager, {
    Init: function (layer) {
        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base(layer);
    },
    Public: {
        createElement: function () {
            </span><span style="color: #0000ff;">var</span> element =<span style="color: #000000;"> [],
                 enemy </span>=<span style="color: #000000;"> spriteFactory.createEnemy();

            enemy.init();
            element.push(enemy);

            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
        },
        change: function () {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.change();
        }
    }
});</span></pre>
</div>
<h1>领域模型</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/09092607-b6026e444071408e83af4f2dd5bf1eeb.jpg" alt="" /></p>
<p><a name="algorithm"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">实现寻路算法</span></strong></p>
<p>游戏中的敌人采用A*算法寻路。参考资料：<a href="http://hi.baidu.com/wsapyoemdfacmqr/item/bdfb5c0a74c904d01ef0466d">A星算法</a></p>
<h1>敌人寻路模式</h1>
<p>游戏开始时，敌人以它的当前位置为起始点，炸弹人的位置为终点寻路。如果敌人到达终点后，没有碰撞到炸弹人，则再一次以它的当前位置为起始点，炸弹人的位置为终点寻路。</p>
<h1>敌人寻路流程</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/14103933-a3f079ab4f6444b1a463751c086a43b7.jpg" alt="" /></p>
<h1>实现FindPath类</h1>
<h2>领域模型</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/09092901-43d0378013054ca09c57052200715900.jpg" alt="" /></p>
<h2><span style="color: #c0c0c0;"><span style="color: #000000;">相关代码</span></span></h2>
<p><span style="color: #c0c0c0;"><span style="color: #000000;">FindPath</span></span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('3de12418-c288-4e59-b9dd-575bbf185661')"><img id="code_img_closed_3de12418-c288-4e59-b9dd-575bbf185661" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_3de12418-c288-4e59-b9dd-575bbf185661" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3de12418-c288-4e59-b9dd-575bbf185661',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_3de12418-c288-4e59-b9dd-575bbf185661" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> map_w, beginx, beginy, endx, endy;
    </span><span style="color: #0000ff;">var</span> arr_path_out = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Array();

    </span><span style="color: #0000ff;">var</span> pass =<span style="color: #000000;"> bomberConfig.map.terrain.pass,
        stop </span>=<span style="color: #000000;"> bomberConfig.map.terrain.stop;


    </span><span style="color: #0000ff;">var</span> arr_map = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Array();
    </span><span style="color: #0000ff;">var</span> open_list = <span style="color: #0000ff;">new</span> Array(); <span style="color: #008000;">//</span><span style="color: #008000;">创建OpenList</span>
    <span style="color: #0000ff;">var</span> close_list = <span style="color: #0000ff;">new</span> Array(); <span style="color: #008000;">//</span><span style="color: #008000;">创建CloseList</span>
    <span style="color: #0000ff;">var</span> tmp = <span style="color: #0000ff;">new</span> Array(); <span style="color: #008000;">//</span><span style="color: #008000;">存放当前节点的八个方向的节点</span>
    <span style="color: #0000ff;">var</span> arr_map_tmp = window.mapData; <span style="color: #008000;">//</span><span style="color: #008000;">存储从游戏中读入的地图数据</span>
    <span style="color: #0000ff;">var</span> map_w =<span style="color: #000000;"> arr_map_tmp.length;

    function aCompute(mapData, begin, end) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">计算运行时间</span>
        <span style="color: #0000ff;">var</span><span style="color: #000000;"> startTime, endTime;
        </span><span style="color: #0000ff;">var</span> d = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Date();
        </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> time;
        startTime </span>=<span style="color: #000000;"> d.getTime();


        </span><span style="color: #0000ff;">var</span> arr_path = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Array();
        </span><span style="color: #0000ff;">var</span> stopn = <span style="color: #800080;">0</span><span style="color: #000000;">;

        </span><span style="color: #008000;">/*</span><span style="color: #008000;">*******************函数主体部分************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">

        arr_map </span>=<span style="color: #000000;"> setMap(mapData);

        map_w </span>=<span style="color: #000000;"> mapData.length;
        beginx </span>=<span style="color: #000000;"> begin.x;
        beginy </span>= map_w - <span style="color: #800080;">1</span> -<span style="color: #000000;"> begin.y;
        endx </span>=<span style="color: #000000;"> end.x;
        endy </span>= map_w - <span style="color: #800080;">1</span> -<span style="color: #000000;"> end.y;
        </span><span style="color: #0000ff;">var</span> startNodeNum =<span style="color: #000000;"> tile_num(beginx, beginy);
        </span><span style="color: #0000ff;">var</span> targetNodeNum =<span style="color: #000000;"> tile_num(endx, endy);

        </span><span style="color: #0000ff;">if</span> (arr_map[targetNodeNum] &amp;&amp; arr_map[targetNodeNum][<span style="color: #800080;">0</span>] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
            showError(</span><span style="color: #800000;">"</span><span style="color: #800000;">目的地无法到达！</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            time </span>=<span style="color: #000000;"> getTime(startTime);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> { path: [], time: time };
        }
        </span><span style="color: #0000ff;">if</span> (arr_map[startNodeNum][<span style="color: #800080;">0</span>] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
            showError(</span><span style="color: #800000;">"</span><span style="color: #800000;">起始点不可用！</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            time </span>=<span style="color: #000000;"> getTime(startTime);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> { path: [], time: time };
        }

        </span><span style="color: #0000ff;">if</span> (arr_map[targetNodeNum] &amp;&amp; arr_map[targetNodeNum][<span style="color: #800080;">0</span>] * arr_map[startNodeNum][<span style="color: #800080;">0</span>] == <span style="color: #800080;">1</span><span style="color: #000000;">) {
            arr_map[startNodeNum] </span>= [arr_map[startNodeNum][<span style="color: #800080;">0</span>], startNodeNum, arr_map[startNodeNum][<span style="color: #800080;">2</span>], arr_map[startNodeNum][<span style="color: #800080;">3</span>], arr_map[startNodeNum][<span style="color: #800080;">4</span>]];<span style="color: #008000;">//</span><span style="color: #008000;">起始点的父节点为自己</span>
<span style="color: #000000;">            setH(targetNodeNum);
            setOpenList(startNodeNum); </span><span style="color: #008000;">//</span><span style="color: #008000;">把开始节点加入到openlist中
            </span><span style="color: #008000;">//</span><span style="color: #008000;">就要开始那个令人发指的循环了，==！！A*算法主体</span>

            <span style="color: #0000ff;">while</span> (open_list.length != <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">var</span> bestNodeNum =<span style="color: #000000;"> selectFmin(open_list);
                stopn </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                open_list.shift();
                setCloseList(bestNodeNum);

                </span><span style="color: #0000ff;">if</span> (bestNodeNum ==<span style="color: #000000;"> targetNodeNum) {
                    showPath(close_list, arr_path);
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #008000;">//</span><span style="color: #008000;">当目标为孤岛时的判断</span>
                <span style="color: #0000ff;">var</span> tmp0 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Array();
                </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> k;
                tmp0 </span>=<span style="color: #000000;"> setSuccessorNode(targetNodeNum, map_w);
                </span><span style="color: #0000ff;">for</span> (j; j &lt; <span style="color: #800080;">9</span>; j++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (j == <span style="color: #800080;">8</span><span style="color: #000000;">) {
                        k </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #0000ff;">if</span> (tmp0[j][<span style="color: #800080;">0</span>] == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                        k </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    }
                }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">当目标为孤岛时的判断语句结束</span>
                <span style="color: #0000ff;">if</span> (k == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    showError(</span><span style="color: #800000;">"</span><span style="color: #800000;">目标成孤岛!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    time </span>=<span style="color: #000000;"> getTime(startTime);
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> { path: [], time: time };
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    tmp </span>=<span style="color: #000000;"> setSuccessorNode(bestNodeNum, map_w);
                    </span><span style="color: #0000ff;">for</span> (i; i &lt; <span style="color: #800080;">8</span>; i++<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">if</span> ((tmp[i][<span style="color: #800080;">0</span>] == <span style="color: #800080;">0</span>) || (findInCloseList(tmp[i][<span style="color: #800080;">4</span>]))) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;

                        </span><span style="color: #0000ff;">if</span> (findInOpenList(tmp[i][<span style="color: #800080;">4</span>]) == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                            </span><span style="color: #0000ff;">if</span> (tmp[i][<span style="color: #800080;">2</span>] &gt;= (arr_map[bestNodeNum][<span style="color: #800080;">2</span>] +<span style="color: #000000;"> cost(tmp[i], bestNodeNum))) {
                                setG(tmp[i][</span><span style="color: #800080;">4</span>], bestNodeNum); <span style="color: #008000;">//</span><span style="color: #008000;">算g值，修改arr_map中[2]的值</span>
                                arr_map[tmp[i][<span style="color: #800080;">4</span>]] = tmp[i] = [arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">0</span>], bestNodeNum, arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">2</span>], arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">3</span>], arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">4</span>]]; <span style="color: #008000;">//</span><span style="color: #008000;">修改tmp和arr_map中父节点的值，并修改tmp中g值，是之和arr_map中对应节点的值统一</span>
<span style="color: #000000;">                            }
                        }
                        </span><span style="color: #0000ff;">if</span> (findInOpenList(tmp[i][<span style="color: #800080;">4</span>]) == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                            setG(tmp[i][</span><span style="color: #800080;">4</span>], bestNodeNum); <span style="color: #008000;">//</span><span style="color: #008000;">算g值，修改arr_map中[2]的值</span>
                            arr_map[tmp[i][<span style="color: #800080;">4</span>]] = tmp[i] = [arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">0</span>], bestNodeNum, arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">2</span>], arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">3</span>], arr_map[tmp[i][<span style="color: #800080;">4</span>]][<span style="color: #800080;">4</span>]]; <span style="color: #008000;">//</span><span style="color: #008000;">修改tmp和arr_map中父节点的值，并修改tmp中g值，是之和arr_map中对应节点的值统一</span>
                            setOpenList(tmp[i][<span style="color: #800080;">4</span>]); <span style="color: #008000;">//</span><span style="color: #008000;">存进openlist中</span>
<span style="color: #000000;">
                        }
                    }
                }

                stopn</span>++<span style="color: #000000;">;
                </span><span style="color: #008000;">//</span><span style="color: #008000;">if (stopn == map_w * map_w - 1) {     </span><span style="color: #008000;">//</span><span style="color: #008000;">2013.5.27修改</span>
                <span style="color: #0000ff;">if</span> (stopn == map_w * map_w * <span style="color: #800080;">1000</span><span style="color: #000000;">) {
                    showError(</span><span style="color: #800000;">"</span><span style="color: #800000;">找不到路径!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    time </span>=<span style="color: #000000;"> getTime(startTime);
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> { path: [], time: time };

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">                break;</span>
<span style="color: #000000;">                }
            }


            </span><span style="color: #0000ff;">if</span> (open_list.length == <span style="color: #800080;">0</span> &amp;&amp; bestNodeNum !=<span style="color: #000000;"> targetNodeNum) {
                showError(</span><span style="color: #800000;">"</span><span style="color: #800000;">没有找到路径！！</span><span style="color: #800000;">"</span>);   <span style="color: #008000;">//</span><span style="color: #008000;">对于那种找不到路径的点的处理</span>
                time =<span style="color: #000000;"> getTime(startTime);
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> { path: [], time: time };
            }
        }

        time </span>=<span style="color: #000000;"> getTime(startTime);

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> { path: arr_path_out, time: time };

    }

    function getTime(startTime) {
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">**显示运行时间*******</span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">var</span> endTime = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Date().getTime();
        </span><span style="color: #0000ff;">return</span> (endTime - startTime) / <span style="color: #800080;">1000</span><span style="color: #000000;">;
    };


    function showError(error) {
        console.log(error);
    };


    </span><span style="color: #008000;">/*</span><span style="color: #008000;">*********************************************************************
     *function setMap(n)
     *功能：把外部的地图数据抽象成该算法中可操作数组的形式来输入算法
     *参数：n为地图的宽度，生成方阵地图
     ***********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function setMap(mapData) {

        map_w </span>=<span style="color: #000000;"> mapData.length;
        </span><span style="color: #0000ff;">var</span> m = map_w *<span style="color: #000000;"> map_w;

        </span><span style="color: #0000ff;">var</span> arr_map0 = <span style="color: #0000ff;">new</span> Array(); <span style="color: #008000;">//</span><span style="color: #008000;">该函数对地图数据转换的操作数组</span>
        <span style="color: #0000ff;">var</span> a = m - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (a; a &gt;= <span style="color: #800080;">0</span>; a--<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">var</span> xTmp = tile_x(a); <span style="color: #008000;">//</span><span style="color: #008000;">把ID 编号值转换为x坐标值，用来对应读入地图数据</span>
            <span style="color: #0000ff;">var</span> yTmp = map_w - <span style="color: #800080;">1</span> - tile_y(a); <span style="color: #008000;">//</span><span style="color: #008000;">把ID 编号值转换为y坐标值，用来对应读入地图数据,对应数组标号和我自定义xoy坐标位置

            </span><span style="color: #008000;">//</span><span style="color: #008000;">[cost,parent,g,h,id]</span>
            <span style="color: #0000ff;">if</span> (mapData[yTmp][xTmp] ==<span style="color: #000000;"> pass)
                arr_map0[a] </span>= [<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, a];
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
                arr_map0[a] </span>= [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, a];


        }

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> arr_map0;
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">********************************************************************
     *以下三个函数是地图上的编号与数组索引转换
     *function tile_num(x,y)
     *功能：将 x,y 坐标转换为地图上块的编号
     *function tile_x(n)
     *功能：由块编号得出 x 坐标
     *function tile_y(n)
     *功能：由块编号得出 y 坐标
     *****************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function tile_num(x, y) {
        </span><span style="color: #0000ff;">return</span> ((y) * map_w +<span style="color: #000000;"> (x));
    }

    function tile_x(n) {
        </span><span style="color: #0000ff;">return</span> (parseInt((n) %<span style="color: #000000;"> map_w));
    }

    function tile_y(n) {
        </span><span style="color: #0000ff;">return</span> (parseInt((n) /<span style="color: #000000;"> map_w));
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">********************************************************************
     *function setH(targetNode)
     *功能：初始化所有点H的值
     *参数：targetNode目标节点
     *********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function setH(targetNode) {

        </span><span style="color: #0000ff;">var</span> x0 =<span style="color: #000000;"> tile_x(targetNode);
        </span><span style="color: #0000ff;">var</span> y0 =<span style="color: #000000;"> tile_y(targetNode);
        </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (i; i &lt; arr_map.length; i++<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">var</span> x1 =<span style="color: #000000;"> tile_x(i);
            </span><span style="color: #0000ff;">var</span> y1 =<span style="color: #000000;"> tile_y(i);
            </span><span style="color: #008000;">/*</span><span style="color: #008000;">****欧几里德距离*******************************</span><span style="color: #008000;">*/</span>
            <span style="color: #008000;">//</span><span style="color: #008000;"> var h = (Math.sqrt((parseInt(x0) - parseInt(x1)) * (parseInt(x0) - parseInt(x1))) + Math.sqrt((parseInt(y0) - parseInt(y1)) * (parseInt(y0) - parseInt(y1))));</span>
            <span style="color: #008000;">/*</span><span style="color: #008000;">****对角线距离*******************************</span><span style="color: #008000;">*/</span>
            <span style="color: #0000ff;">var</span> h = Math.max(Math.abs(parseInt(x0) - parseInt(x1)), Math.abs(parseInt(y0) -<span style="color: #000000;"> parseInt(y1)));
            </span><span style="color: #008000;">/*</span><span style="color: #008000;">****曼哈顿距离*******************************</span><span style="color: #008000;">*/</span>
                <span style="color: #008000;">//</span><span style="color: #008000;"> var h=Math.abs(parseInt(x0) - parseInt(x1))+Math.abs(parseInt(y0) - parseInt(y1));</span>
            arr_map[i][<span style="color: #800080;">3</span>] = h * parseInt(<span style="color: #800080;">10</span><span style="color: #000000;">);
        }
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">********************************************************************
     *function setG(nowNode,bestNode)
     *功能：计算现节点G的值
     *参数：nowNode现节点，bestNode其父节点
     *********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function setG(nowNode, bestNode) {
        </span><span style="color: #0000ff;">var</span> x0 =<span style="color: #000000;"> tile_x(bestNode);
        </span><span style="color: #0000ff;">var</span> y0 =<span style="color: #000000;"> tile_y(bestNode);
        </span><span style="color: #0000ff;">var</span> x1 =<span style="color: #000000;"> tile_x(nowNode);
        </span><span style="color: #0000ff;">var</span> y1 =<span style="color: #000000;"> tile_y(nowNode);
        </span><span style="color: #0000ff;">if</span> (((x0 - x1) == <span style="color: #800080;">0</span>) || ((y0 - y1) == <span style="color: #800080;">0</span><span style="color: #000000;">)) {
            arr_map[nowNode] </span>= [arr_map[nowNode][<span style="color: #800080;">0</span>], arr_map[nowNode][<span style="color: #800080;">1</span>], arr_map[nowNode][<span style="color: #800080;">2</span>] + parseInt(<span style="color: #800080;">10</span>), arr_map[nowNode][<span style="color: #800080;">3</span>], arr_map[nowNode][<span style="color: #800080;">4</span><span style="color: #000000;">]];

        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {

            arr_map[nowNode] </span>= [arr_map[nowNode][<span style="color: #800080;">0</span>], arr_map[nowNode][<span style="color: #800080;">1</span>], arr_map[nowNode][<span style="color: #800080;">2</span>] + parseInt(<span style="color: #800080;">14</span>), arr_map[nowNode][<span style="color: #800080;">3</span>], arr_map[nowNode][<span style="color: #800080;">4</span><span style="color: #000000;">]];
        }
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">********************************************************************
     *function selectFmin(open_list)
     *功能：在openlist中对f值进行排序(冒泡排序)，并选择一个f值最小的节点返回
     *参数：openlist
     **********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function selectFmin(open_list) {
        </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> i, j, min, temp;
        </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; open_list.length; i++<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (j = i + <span style="color: #800080;">1</span>; j &lt; open_list.length; j++<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> ((open_list[i][<span style="color: #800080;">2</span>] + open_list[i][<span style="color: #800080;">3</span>]) &gt; (open_list[j][<span style="color: #800080;">2</span>] + open_list[j][<span style="color: #800080;">3</span><span style="color: #000000;">])) {
                    temp </span>=<span style="color: #000000;"> open_list[i];
                    open_list[i] </span>=<span style="color: #000000;"> open_list[j];
                    open_list[j] </span>=<span style="color: #000000;"> temp;
                }
            }
        }
        </span><span style="color: #0000ff;">var</span> min = open_list[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">return</span> min[<span style="color: #800080;">4</span><span style="color: #000000;">];
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">**********************************************************************
     *function setOpenList(NodeNum)
     *功能：把节点加入open表中
     *参数：待加入openlist的节点的编号
     ***********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function setOpenList(NodeNum) {
        </span><span style="color: #0000ff;">var</span> n =<span style="color: #000000;"> open_list.length;
        open_list[n] </span>= [arr_map[NodeNum][<span style="color: #800080;">0</span>], arr_map[NodeNum][<span style="color: #800080;">1</span>], arr_map[NodeNum][<span style="color: #800080;">2</span>], arr_map[NodeNum][<span style="color: #800080;">3</span>], arr_map[NodeNum][<span style="color: #800080;">4</span><span style="color: #000000;">]];
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">**********************************************************************
     *function setCloseList(NodeNum)
     *功能：把节点加入close表中
     *参数：待加入closelist的节点的编号
     ***********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function setCloseList(NodeNum) {
        </span><span style="color: #0000ff;">var</span> n =<span style="color: #000000;"> close_list.length;
        close_list[n] </span>= [arr_map[NodeNum][<span style="color: #800080;">0</span>], arr_map[NodeNum][<span style="color: #800080;">1</span>], arr_map[NodeNum][<span style="color: #800080;">2</span>], arr_map[NodeNum][<span style="color: #800080;">3</span>], arr_map[NodeNum][<span style="color: #800080;">4</span><span style="color: #000000;">]];
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">**********************************************************************
     *function findInOpenList(nowNodeNum)
     *功能：查询当前节点是否在openlist中，找到返回1，找不到返回0
     *参数：待查询的节点的编号
     ***********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function findInOpenList(nowNodeNum) {
        </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; open_list.length; i++<span style="color: #000000;">) {

            </span><span style="color: #0000ff;">if</span> (open_list[i][<span style="color: #800080;">4</span>] ==<span style="color: #000000;"> nowNodeNum)
                </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">**********************************************************************
     *function findInCloseList(nowNodeNum)
     *功能：查询当前节点是否在closelist中，找到返回1，找不到返回0
     *参数：待查询的节点的编号
     ***********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function findInCloseList(nowNodeNum) {
        </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; close_list.length; i++<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (close_list[i][<span style="color: #800080;">4</span>] ==<span style="color: #000000;"> nowNodeNum)
                </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">**********************************************************************
     *function cost(SuccessorNodeNum,bestNodeNum)
     *功能：现节点到达周围节点的代价
     *参数：SuccessorNodeNum周围节点编号，bestNodeNum现节点
     ***********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function cost(SuccessorNodeNum, bestNodeNum) {
        </span><span style="color: #0000ff;">var</span> x0 =<span style="color: #000000;"> tile_x(bestNodeNum);
        </span><span style="color: #0000ff;">var</span> y0 =<span style="color: #000000;"> tile_y(bestNodeNum);
        </span><span style="color: #0000ff;">var</span> x1 =<span style="color: #000000;"> tile_x(SuccessorNodeNum);
        </span><span style="color: #0000ff;">var</span> y1 =<span style="color: #000000;"> tile_y(SuccessorNodeNum);
        </span><span style="color: #0000ff;">if</span> (((x0 - x1) == <span style="color: #800080;">0</span>) || ((y0 - y1) == <span style="color: #800080;">0</span><span style="color: #000000;">)) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">else</span>
            <span style="color: #0000ff;">return</span> <span style="color: #800080;">14</span><span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">*********************************************************************
     *function setSuccessorNode(bestNodeNum,map_w)
     *功能：把现节点的周围8个节点放入预先准备好的临时arr中以备检察
     *参数：现节点的编号
     035
     1 6
     247
     周围八个点的排序
     **********************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function setSuccessorNode(bestNodeNum, n) {
        </span><span style="color: #0000ff;">var</span> x0 =<span style="color: #000000;"> tile_x(bestNodeNum);
        </span><span style="color: #0000ff;">var</span> y0 =<span style="color: #000000;"> tile_y(bestNodeNum);
        </span><span style="color: #0000ff;">var</span> m = n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> ((x0 - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0 - <span style="color: #800080;">1</span>) &lt;= m &amp;&amp; (y0) &lt;= m) tmp[<span style="color: #800080;">1</span>] = [arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            tmp[</span><span style="color: #800080;">1</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">if</span> ((x0) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0 + <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0) &lt;= m &amp;&amp; (y0 + <span style="color: #800080;">1</span>) &lt;= m) tmp[<span style="color: #800080;">3</span>] = [arr_map[tile_num(x0, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            tmp[</span><span style="color: #800080;">3</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">if</span> ((x0) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0 - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0) &lt;= m &amp;&amp; (y0 - <span style="color: #800080;">1</span>) &lt;= m) tmp[<span style="color: #800080;">4</span>] = [arr_map[tile_num(x0, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            tmp[</span><span style="color: #800080;">4</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">if</span> ((x0 + <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0 + <span style="color: #800080;">1</span>) &lt;= m &amp;&amp; (y0) &lt;= m) tmp[<span style="color: #800080;">6</span>] = [arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            tmp[</span><span style="color: #800080;">6</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">if</span> (bomberConfig.algorithm.DIRECTION == <span style="color: #800080;">8</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> ((x0 - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0 + <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0 - <span style="color: #800080;">1</span>) &lt;= m &amp;&amp; (y0 + <span style="color: #800080;">1</span>) &lt;= m) tmp[<span style="color: #800080;">0</span>] = [arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                tmp[</span><span style="color: #800080;">0</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            }

            </span><span style="color: #0000ff;">if</span> ((x0 - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0 - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0 - <span style="color: #800080;">1</span>) &lt;= m &amp;&amp; (y0 - <span style="color: #800080;">1</span>) &lt;= m) tmp[<span style="color: #800080;">2</span>] = [arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0 - <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                tmp[</span><span style="color: #800080;">2</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            }

            </span><span style="color: #0000ff;">if</span> ((x0 + <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0 + <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0 + <span style="color: #800080;">1</span>) &lt;= m &amp;&amp; (y0 + <span style="color: #800080;">1</span>) &lt;= m) tmp[<span style="color: #800080;">5</span>] = [arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 + <span style="color: #800080;">1</span>)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                tmp[</span><span style="color: #800080;">5</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            }

            </span><span style="color: #0000ff;">if</span> ((x0 + <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (y0 - <span style="color: #800080;">1</span>) &gt;= <span style="color: #800080;">0</span> &amp;&amp; (x0 + <span style="color: #800080;">1</span>) &lt;= m &amp;&amp; (y0 - <span style="color: #800080;">1</span>) &lt;= m) tmp[<span style="color: #800080;">7</span>] = [arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">0</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">1</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">2</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">3</span>], arr_map[tile_num(x0 + <span style="color: #800080;">1</span>, y0 - <span style="color: #800080;">1</span>)][<span style="color: #800080;">4</span>]]; <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                tmp[</span><span style="color: #800080;">7</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            }

        }
        </span><span style="color: #0000ff;">if</span> (bomberConfig.algorithm.DIRECTION == <span style="color: #800080;">4</span><span style="color: #000000;">) {
            tmp[</span><span style="color: #800080;">0</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            tmp[</span><span style="color: #800080;">2</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            tmp[</span><span style="color: #800080;">5</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
            tmp[</span><span style="color: #800080;">7</span>] = [<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">];
        }

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> tmp;
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">******************************************************************
     *function showPath(close_list)
     *功能：把结果路径存入arr_path输出
     *参数：close_list
     *******************************************************************</span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function showPath(close_list, arr_path) {
        </span><span style="color: #0000ff;">var</span> n =<span style="color: #000000;"> close_list.length;
        </span><span style="color: #0000ff;">var</span> i = n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">var</span> ii = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">var</span> nn = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">var</span> mm = <span style="color: #800080;">0</span><span style="color: #000000;">;


        </span><span style="color: #0000ff;">var</span> arr_path_tmp = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Array();
        </span><span style="color: #0000ff;">var</span> target = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        </span><span style="color: #008000;">/*</span><span style="color: #008000;">*********把close_list中有用的点存入arr_path_tmp中************</span><span style="color: #008000;">*/</span>

        <span style="color: #0000ff;">for</span> (ii; ; ii++<span style="color: #000000;">) {
            arr_path_tmp[ii] </span>= close_list[n - <span style="color: #800080;">1</span>][<span style="color: #800080;">4</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (close_list[n - <span style="color: #800080;">1</span>][<span style="color: #800080;">1</span>] == close_list[i][<span style="color: #800080;">4</span><span style="color: #000000;">]) {
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">for</span> (i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; i--<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (close_list[i][<span style="color: #800080;">4</span>] == close_list[n - <span style="color: #800080;">1</span>][<span style="color: #800080;">1</span><span style="color: #000000;">]) {
                    n </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
        }

        </span><span style="color: #0000ff;">var</span> w = arr_path_tmp.length - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">var</span> j = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = w; i &gt;= <span style="color: #800080;">0</span>; i--<span style="color: #000000;">) {
            arr_path[j] </span>=<span style="color: #000000;"> arr_path_tmp[i];
            j</span>++<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> k = <span style="color: #800080;">0</span>; k &lt;= w; k++<span style="color: #000000;">) {
            target </span>=<span style="color: #000000;"> {
                x: tile_x(arr_path[k]),
                y: map_w </span>- <span style="color: #800080;">1</span> -<span style="color: #000000;"> tile_y(arr_path[k])
            };
            arr_path_out.push(target);
        }
        arr_path_out.shift();
    }

    function _reset() {
        arr_path_out </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Array();
        arr_map </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Array();
        arr_map_tmp </span>=<span style="color: #000000;"> window.mapData;
        map_w </span>=<span style="color: #000000;"> arr_map_tmp.length;

        open_list </span>= <span style="color: #0000ff;">new</span> Array(); <span style="color: #008000;">//</span><span style="color: #008000;">创建OpenList</span>
        close_list = <span style="color: #0000ff;">new</span> Array(); <span style="color: #008000;">//</span><span style="color: #008000;">创建CloseList</span>
        tmp = <span style="color: #0000ff;">new</span> Array(); <span style="color: #008000;">//</span><span style="color: #008000;">存放当前节点的八个方向的节点</span>
<span style="color: #000000;">    };


    </span><span style="color: #0000ff;">var</span> findPath =<span style="color: #000000;"> {
        aCompute: function (terrainData, begin, end) {
            _reset();
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> aCompute(terrainData, begin, end);
        }
    };

    window.findPath </span>=<span style="color: #000000;"> findPath;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><a name="refactor"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">重构</span></strong></p>
<h1>重构状态模式Context类</h1>
<p>重构前：</p>
<div class="cnblogs_code">
<pre>(<span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    </span><span style="color: #0000ff;">var</span> Context =<span style="color: #000000;"> YYC.Class({
        Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (sprite) {
            </span><span style="color: #0000ff;">this</span>.sprite =<span style="color: #000000;"> sprite;
        },
...
        Static: {
            walkLeftState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkLeftState(),
            walkRightState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkRightState(),
            walkUpState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkUpState(),
            walkDownState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkDownState(),
            standLeftState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> StandLeftState(),
            standRightState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> StandRightState(),
            standUpState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> StandUpState(),
            standDownState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> StandDownState()
        }
    });

    window.Context </span>=<span style="color: #000000;"> Context;
}());</span></pre>
</div>
<h2><span style="line-height: 1.5;">删除Context的静态实例，改为在构造函数中创建具体状态类实例</span></h2>
<p>原因：</p>
<p>因为EnemySprite和PlayerSprite都要使用Context的实例。如果为静态实例的话，EnemySprite中的Context类实例与PlayerSprite中的Context类实例会共享静态实例（具体状态类实例）！会造成互相干扰！</p>
<p>重构后：</p>
<div class="cnblogs_code">
<pre>(<span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    </span><span style="color: #0000ff;">var</span> Context =<span style="color: #000000;"> YYC.Class({
        Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (sprite) {
            </span><span style="color: #0000ff;">this</span>.sprite =<span style="color: #000000;"> sprite;

            </span><span style="color: #0000ff;">this</span>.walkLeftState = <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkLeftState();
            </span><span style="color: #0000ff;">this</span>.walkRightState = <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkRightState();
            </span><span style="color: #0000ff;">this</span>.walkUpState = <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkUpState();
            </span><span style="color: #0000ff;">this</span>.walkDownState = <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkDownState();
            </span><span style="color: #0000ff;">this</span>.standLeftState = <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandLeftState();
            </span><span style="color: #0000ff;">this</span>.standRightState = <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandRightState();
            </span><span style="color: #0000ff;">this</span>.standUpState = <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandUpState();
            </span><span style="color: #0000ff;">this</span>.standDownState = <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandDownState();
        },
...</span><span style="color: #000000;">
        Static: {
        }
    });

    window.Context </span>=<span style="color: #000000;"> Context;
}());</span></pre>
</div>
<h1>提出基类Sprite</h1>
<h2>为什么要提出</h2>
<ul>
<li>EnemySprite与PlayerSpite有很多相同的代码</li>
<li>从概念上来说，玩家精灵类与敌人精灵类都属于精灵类的概念</li>
</ul>
<p>因此，提出EnemySprite、PlayerSprite基类Sprite。</p>
<h2>修改碰撞检测</h2>
<p>Sprite 增加getCollideRect获得碰撞面积。EnemySprite增加collideWidthOther。</p>
<h2>领域模型</h2>
<p><span style="color: #ff0000;"><img src="http://images.cnitblog.com/blog/419321/201310/14112035-aa4a373632854cc597938fcb04ee6701.jpg" alt="" /></span></p>
<h2>相关的代码</h2>
<p>Sprite</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('7a078e56-2a6c-4e63-95ce-cd25052d1aad')"><img id="code_img_closed_7a078e56-2a6c-4e63-95ce-cd25052d1aad" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_7a078e56-2a6c-4e63-95ce-cd25052d1aad" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('7a078e56-2a6c-4e63-95ce-cd25052d1aad',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_7a078e56-2a6c-4e63-95ce-cd25052d1aad" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Sprite =<span style="color: #000000;"> YYC.AClass({
        Init: function (data) {
            </span><span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
            </span><span style="color: #0000ff;">this</span>.y =<span style="color: #000000;"> data.y;

            </span><span style="color: #0000ff;">this</span>.speedX =<span style="color: #000000;"> data.speedX;
            </span><span style="color: #0000ff;">this</span>.speedY =<span style="color: #000000;"> data.speedY;

            </span><span style="color: #0000ff;">this</span>.minX  =<span style="color: #000000;"> data.minX;
            </span><span style="color: #0000ff;">this</span>.maxX  =<span style="color: #000000;"> data.maxX;
            </span><span style="color: #0000ff;">this</span>.minY  =<span style="color: #000000;"> data.minY;
            </span><span style="color: #0000ff;">this</span>.maxY  =<span style="color: #000000;"> data.maxY;

            </span><span style="color: #0000ff;">this</span>.defaultAnimId =<span style="color: #000000;"> data.defaultAnimId;
            </span><span style="color: #0000ff;">this</span>.anims =<span style="color: #000000;"> data.anims;
        },
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">更新帧动画</span>
<span style="color: #000000;">            _updateFrame: function (deltaTime) {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.update(deltaTime);
                }
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">在一个移动步长中已经移动的次数</span>
            moveIndex: <span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标</span>
            x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的速度</span>
            speedX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            speedY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标区间</span>
            minX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            maxX: </span><span style="color: #800080;">9999</span><span style="color: #000000;">,
            minY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            maxY: </span><span style="color: #800080;">9999</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵包含的所有 Animation 集合. Object类型, 数据存放方式为" id : animation ".</span>
            anims: <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">默认的Animation的Id , string类型</span>
            defaultAnimId: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">当前的Animation.</span>
            currentAnim: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation, 参数为Animation的id, String类型</span>
<span style="color: #000000;">            setAnim: function (animId) {
                </span><span style="color: #0000ff;">this</span>.currentAnim = <span style="color: #0000ff;">this</span><span style="color: #000000;">.anims[animId];
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">重置当前帧</span>
<span style="color: #000000;">            resetCurrentFrame: function (index) {
                </span><span style="color: #0000ff;">this</span>.currentAnim &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.setCurrentFrame(index);
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">取得精灵的碰撞区域,</span>
<span style="color: #000000;">            getCollideRect: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">var</span> f = <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                        x1: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.x,
                        y1: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.y,
                        x2: </span><span style="color: #0000ff;">this</span>.x +<span style="color: #000000;"> f.imgWidth,
                        y2: </span><span style="color: #0000ff;">this</span>.y +<span style="color: #000000;"> f.imgHeight
                    }
                }
            },
            Virtual: {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">初始化方法</span>
<span style="color: #000000;">                init: function () {
                    </span><span style="color: #0000ff;">this</span>.setAnim(<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId);
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新精灵当前状态.</span>
<span style="color: #000000;">                update: function (deltaTime) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._updateFrame(deltaTime);
                }
            }
        },
        Abstract: {
            draw: function (context) { },
            clear: function (context) { },
            move: function () { },
            setDir: function () { }
        }
    });

    window.Sprite </span>=<span style="color: #000000;"> Sprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>EnemySprite</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('dba52502-35df-4d21-bf1b-f18c8efaaccc')"><img id="code_img_closed_dba52502-35df-4d21-bf1b-f18c8efaaccc" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_dba52502-35df-4d21-bf1b-f18c8efaaccc" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('dba52502-35df-4d21-bf1b-f18c8efaaccc',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_dba52502-35df-4d21-bf1b-f18c8efaaccc" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> EnemySprite =<span style="color: #000000;"> YYC.Class(Sprite, {
        Init: function (data) {
            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">(data);

            </span><span style="color: #0000ff;">this</span>.walkSpeed =<span style="color: #000000;"> data.walkSpeed;
            </span><span style="color: #0000ff;">this</span>.speedX =<span style="color: #000000;"> data.walkSpeed;
            </span><span style="color: #0000ff;">this</span>.speedY =<span style="color: #000000;"> data.walkSpeed;

            </span><span style="color: #0000ff;">this</span>.__context = <span style="color: #0000ff;">new</span> Context(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        },
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">状态模式上下文类</span>
            __context: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            __getCurrentState: function () {
                </span><span style="color: #0000ff;">var</span> currentState = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">switch</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandRightState();
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandDownState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandUpState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkDownState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkUpState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkRightState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">未知的状态</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> currentState;
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">计算移动次数</span>
<span style="color: #000000;">            __computeStep: function () {
                </span><span style="color: #0000ff;">this</span>.stepX = Math.ceil(bomberConfig.WIDTH / <span style="color: #0000ff;">this</span><span style="color: #000000;">.speedX);
                </span><span style="color: #0000ff;">this</span>.stepY = Math.ceil(bomberConfig.HEIGHT / <span style="color: #0000ff;">this</span><span style="color: #000000;">.speedY);
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的方向系数：
            </span><span style="color: #008000;">//</span><span style="color: #008000;">往下走dirY为正数，往上走dirY为负数；
            </span><span style="color: #008000;">//</span><span style="color: #008000;">往右走dirX为正数，往左走dirX为负数。</span>
            dirX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            dirY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">定义sprite走路速度的绝对值</span>
            walkSpeed: <span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">一次移动步长中的需要移动的次数</span>
            stepX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            stepY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">一次移动步长中已经移动的次数</span>
            moveIndex_x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            moveIndex_y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">是否正在移动标志</span>
            moving: <span style="color: #0000ff;">false</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">站立标志
            </span><span style="color: #008000;">//</span><span style="color: #008000;">用于解决调用WalkState.stand后，PlayerLayer.render中P__isChange返回false的问题
            </span><span style="color: #008000;">//</span><span style="color: #008000;">（不调用draw，从而仍会显示精灵类walk的帧（而不会刷新为更新状态后的精灵类stand的帧））。</span>
            stand: <span style="color: #0000ff;">false</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">寻找的路径</span>
<span style="color: #000000;">            path: [],

            playerSprite: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            init: function () {
                </span><span style="color: #0000ff;">this</span>.__context.setPlayerState(<span style="color: #0000ff;">this</span><span style="color: #000000;">.__getCurrentState());
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__computeStep();

                </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
            },
            draw: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    context.drawImage(</span><span style="color: #0000ff;">this</span>.currentAnim.getImg(), frame.x, frame.y, frame.width, frame.height, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y, frame.imgWidth, frame.imgHeight);
                }
            },
            clear: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">直接清空画布区域</span>
                    context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
                }
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">判断是否和另外一个精灵碰撞</span>
<span style="color: #000000;">            collideWidthOther: function (sprite2) {
                </span><span style="color: #0000ff;">var</span> rect1 = <span style="color: #0000ff;">this</span><span style="color: #000000;">.getCollideRect();
                </span><span style="color: #0000ff;">var</span> rect2 =<span style="color: #000000;"> sprite2.getCollideRect();

                </span><span style="color: #008000;">//</span><span style="color: #008000;">如果碰撞，则抛出异常</span>
                <span style="color: #0000ff;">if</span> (rect1 &amp;&amp; rect2 &amp;&amp; !(rect1.x1 &gt;= rect2.x2 || rect1.y1 &gt;= rect2.y2 || rect1.x2 &lt;= rect2.x1 || rect1.y2 &lt;=<span style="color: #000000;"> rect2.y1)) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Error();
                }
            },
            setPlayerSprite: function (sprite) {
                </span><span style="color: #0000ff;">this</span>.playerSprite =<span style="color: #000000;"> sprite;
            },
            __computePath: function () {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">playerSprite的坐标要向下取整</span>
                <span style="color: #0000ff;">var</span> x = (<span style="color: #0000ff;">this</span>.playerSprite.x - <span style="color: #0000ff;">this</span>.playerSprite.x % window.bomberConfig.WIDTH) /<span style="color: #000000;"> window.bomberConfig.WIDTH;
                </span><span style="color: #0000ff;">var</span> y = (<span style="color: #0000ff;">this</span>.playerSprite.y - <span style="color: #0000ff;">this</span>.playerSprite.y % window.bomberConfig.HEIGHT) /<span style="color: #000000;"> window.bomberConfig.HEIGHT;

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;">  window.findPath.aCompute(window.terrainData, 
                    { x: </span><span style="color: #0000ff;">this</span>.x / window.bomberConfig.WIDTH, y: <span style="color: #0000ff;">this</span>.y /<span style="color: #000000;"> window.bomberConfig.HEIGHT },
                    { x: x, y: y }).path
            },
            move: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.move();
            },
            setDir: function () {
                </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> target, now;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.moving) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">特殊情况，如寻找不到路径</span>
                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.path === <span style="color: #0000ff;">false</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.path.length == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.path = <span style="color: #0000ff;">this</span><span style="color: #000000;">.__computePath();
                }

                </span><span style="color: #008000;">//</span><span style="color: #008000;">返回并移除要移动到的坐标</span>
                target = <span style="color: #0000ff;">this</span><span style="color: #000000;">.path.shift();

                </span><span style="color: #008000;">//</span><span style="color: #008000;">当前坐标</span>
                now =<span style="color: #000000;"> {
                    x: self.x </span>/<span style="color: #000000;"> bomberConfig.WIDTH,
                    y: self.y </span>/<span style="color: #000000;"> bomberConfig.HEIGHT
                };

                </span><span style="color: #008000;">//</span><span style="color: #008000;">判断要移动的方向，调用相应的方法</span>
                <span style="color: #0000ff;">if</span> (target.x &gt;<span style="color: #000000;"> now.x) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkRight();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (target.x &lt;<span style="color: #000000;"> now.x) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkLeft();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (target.y &gt;<span style="color: #000000;"> now.y) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkDown();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (target.y &lt;<span style="color: #000000;"> now.y) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkUp();
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.stand();
                }
            }
        }
    });

    window.EnemySprite </span>=<span style="color: #000000;"> EnemySprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>PlayerSprite</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('867c4979-7a64-46ee-b8a3-e821ebf6933d')"><img id="code_img_closed_867c4979-7a64-46ee-b8a3-e821ebf6933d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_867c4979-7a64-46ee-b8a3-e821ebf6933d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('867c4979-7a64-46ee-b8a3-e821ebf6933d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_867c4979-7a64-46ee-b8a3-e821ebf6933d" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> PlayerSprite =<span style="color: #000000;"> YYC.Class(Sprite, {
        Init: function (data) {
            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">(data);

            </span><span style="color: #0000ff;">this</span>.walkSpeed =<span style="color: #000000;"> data.walkSpeed;
            </span><span style="color: #0000ff;">this</span>.speedX =<span style="color: #000000;"> data.walkSpeed;
            </span><span style="color: #0000ff;">this</span>.speedY =<span style="color: #000000;"> data.walkSpeed;

            </span><span style="color: #0000ff;">this</span>.__context = <span style="color: #0000ff;">new</span> Context(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        },
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">状态模式上下文类</span>
            __context: <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            
            __getCurrentState: function () {
                </span><span style="color: #0000ff;">var</span> currentState = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">switch</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandRightState();
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandDownState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandUpState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkDownState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkUpState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkRightState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">未知的状态</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> currentState;
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">计算移动次数</span>
<span style="color: #000000;">            __computeStep: function () {
                </span><span style="color: #0000ff;">this</span>.stepX = Math.ceil(bomberConfig.WIDTH / <span style="color: #0000ff;">this</span><span style="color: #000000;">.speedX);
                </span><span style="color: #0000ff;">this</span>.stepY = Math.ceil(bomberConfig.HEIGHT / <span style="color: #0000ff;">this</span><span style="color: #000000;">.speedY);
            },
            __allKeyUp: function () {
                </span><span style="color: #0000ff;">return</span> window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">false</span> &amp;&amp; window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">false</span>
                    &amp;&amp; window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">false</span> &amp;&amp; window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            },
            __judgeAndSetDir: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkLeft();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkRight();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkUp();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkDown();
                }
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的方向系数：
            </span><span style="color: #008000;">//</span><span style="color: #008000;">往下走dirY为正数，往上走dirY为负数；
            </span><span style="color: #008000;">//</span><span style="color: #008000;">往右走dirX为正数，往左走dirX为负数。</span>
            dirX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            dirY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">定义sprite走路速度的绝对值</span>
            walkSpeed: <span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">一次移动步长中的需要移动的次数</span>
            stepX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            stepY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">一次移动步长中已经移动的次数</span>
            moveIndex_x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            moveIndex_y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">是否正在移动标志</span>
            moving: <span style="color: #0000ff;">false</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">站立标志
            </span><span style="color: #008000;">//</span><span style="color: #008000;">用于解决调用WalkState.stand后，PlayerLayer.render中P__isChange返回false的问题
            </span><span style="color: #008000;">//</span><span style="color: #008000;">（不调用draw，从而仍会显示精灵类walk的帧（而不会刷新为更新状态后的精灵类stand的帧））。</span>
            stand: <span style="color: #0000ff;">false</span><span style="color: #000000;">,

            init: function () {
                </span><span style="color: #0000ff;">this</span>.__context.setPlayerState(<span style="color: #0000ff;">this</span><span style="color: #000000;">.__getCurrentState());
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__computeStep();

                </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
            },
            draw: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    context.drawImage(</span><span style="color: #0000ff;">this</span>.currentAnim.getImg(), frame.x, frame.y, frame.width, frame.height, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y, frame.imgWidth, frame.imgHeight);
                }
            },
            clear: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">直接清空画布区域</span>
                    context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
                }
            },
            move: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.move();
            },
            setDir: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.moving) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.__allKeyUp()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.stand();
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__judgeAndSetDir();
                }
            }
        }
    });

    window.PlayerSprite </span>=<span style="color: #000000;"> PlayerSprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h1>增加CharacterLayer类</h1>
<ul>
<li>PlayerLayer、EnemyLayer有相似的模式</li>
<li>从语义上来看，PlayerLayer、EnemyLayer都是属于&rdquo;人物&ldquo;的语义</li>
</ul>
<p>因此，提出CharacterLayer父类</p>
<h2>领域模型</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/15200522-065f626393ee4914b52b08cee0dcaa75.jpg" alt="" /></p>
<h2>相关代码</h2>
<p>Layer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Layer =<span style="color: #000000;"> YYC.AClass(Collection, {
        Init: function () {
        },
        Private: {
            __state: bomberConfig.layer.state.CHANGE,   </span><span style="color: #008000;">//</span><span style="color: #008000;">默认为change</span>
<span style="color: #000000;">
            __getContext: function () {
                </span><span style="color: #0000ff;">this</span>.P__context = <span style="color: #0000ff;">this</span>.P__canvas.getContext(<span style="color: #800000;">"</span><span style="color: #800000;">2d</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        },
        Protected: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">*共用的变量（可读、写）</span>
<span style="color: #000000;">
            P__canvas: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            P__context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">*共用的方法（可读）</span>
<span style="color: #000000;">
            P__isChange: function(){
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.__state ===<span style="color: #000000;"> bomberConfig.layer.state.CHANGE;
            },
            P__isNormal: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.__state ===<span style="color: #000000;"> bomberConfig.layer.state.NORMAL;
            },
            P__setStateNormal: function () {
                </span><span style="color: #0000ff;">this</span>.__state =<span style="color: #000000;"> bomberConfig.layer.state.NORMAL;
            },
            P__setStateChange: function () {
                </span><span style="color: #0000ff;">this</span>.__state =<span style="color: #000000;"> bomberConfig.layer.state.CHANGE;
            },
            P__iterator: function (handler) {
                </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span><span style="color: #000000;">),
                    nextElement </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasNext()) {
                    nextElement </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.next();
                    nextElement[handler].apply(nextElement, args);  </span><span style="color: #008000;">//</span><span style="color: #008000;">要指向nextElement</span>
<span style="color: #000000;">                }
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.resetCursor();
            }
        },
        Public: {
            addElements: function(elements){
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.appendChilds(elements);
            },
            Virtual: {
                init: function () {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__getContext();
                },
                change: function () {
                    </span><span style="color: #0000ff;">this</span>.__state =<span style="color: #000000;"> bomberConfig.layer.state.CHANGE;
                }
            }
        },
        Abstract: {
            setCanvas: function () {
            },
            clear: function () {
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">统一绘制</span>
<span style="color: #000000;">            draw: function () { },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">游戏主线程调用的函数</span>
<span style="color: #000000;">            render: function () { }
        }
    });

    window.Layer </span>=<span style="color: #000000;"> Layer;
}());</span></pre>
</div>
<p>CharacterLayer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> CharacterLayer =<span style="color: #000000;"> YYC.AClass(Layer, {
        Init: function (deltaTime) {
            </span><span style="color: #0000ff;">this</span>.___deltaTime =<span style="color: #000000;"> deltaTime;
        },
        Private: {
            ___deltaTime: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            ___update: function (deltaTime) {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">update</span><span style="color: #800000;">"</span><span style="color: #000000;">, deltaTime);
            },
            ___setDir: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">setDir</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            },
            ___move: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">move</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        },
        Public: {
            draw: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">draw</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
            },
            clear: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">clear</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
            },
            render: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___setDir();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___move();
                
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__isChange()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.clear();
                    </span><span style="color: #0000ff;">this</span>.___update(<span style="color: #0000ff;">this</span><span style="color: #000000;">.___deltaTime);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.draw();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__setStateNormal();
                }
            }
        }
    });

    window.CharacterLayer </span>=<span style="color: #000000;"> CharacterLayer;
}());</span></pre>
</div>
<p>PlayerLayer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> PlayerLayer =<span style="color: #000000;"> YYC.Class(CharacterLayer, {
        Init: function (deltaTime) {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base(deltaTime);
        },
        Private: {
            ___keyDown: function () {
                </span><span style="color: #0000ff;">if</span> (keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span> || keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span>
                    || keyState[keyCodeMap.W] === <span style="color: #0000ff;">true</span> || keyState[keyCodeMap.S] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            },
            ___spriteMoving: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.getChildAt(<span style="color: #800080;">0</span><span style="color: #000000;">).moving
            },
            ___spriteStand: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.getChildAt(<span style="color: #800080;">0</span><span style="color: #000000;">).stand) {
                    </span><span style="color: #0000ff;">this</span>.getChildAt(<span style="color: #800080;">0</span>).stand = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            }
        },
        Public: {
            setCanvas: function () {
                </span><span style="color: #0000ff;">this</span>.P__canvas = document.getElementById(<span style="color: #800000;">"</span><span style="color: #800000;">playerLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span>
                $(<span style="color: #800000;">"</span><span style="color: #800000;">#playerLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">).css({
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">border</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">1px solid red</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">1</span><span style="color: #000000;">
                });
            },
            change: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.___keyDown() || <span style="color: #0000ff;">this</span>.___spriteMoving() || <span style="color: #0000ff;">this</span><span style="color: #000000;">.___spriteStand()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base();
                }
            }
        }
    });

    window.PlayerLayer </span>=<span style="color: #000000;"> PlayerLayer;
}());</span></pre>
</div>
<p>EnemyLayer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> EnemyLayer =<span style="color: #000000;"> YYC.Class(CharacterLayer, {
        Init: function (deltaTime) {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base(deltaTime);
        },
        Private: {
            __getPath: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">getPath</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        },
        Public: {
            playerLayer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            init: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base();
            },
            setCanvas: function () {
                </span><span style="color: #0000ff;">this</span>.P__canvas = document.getElementById(<span style="color: #800000;">"</span><span style="color: #800000;">enemyLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span>
                $(<span style="color: #800000;">"</span><span style="color: #800000;">#enemyLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">).css({
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">border</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">1px solid black</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">1</span><span style="color: #000000;">
                });
            },
            getPlayer: function (playerLayer) {
                </span><span style="color: #0000ff;">this</span>.playerLayer =<span style="color: #000000;"> playerLayer;
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">setPlayerSprite</span><span style="color: #800000;">"</span>, playerLayer.getChildAt(<span style="color: #800080;">0</span><span style="color: #000000;">));
            },
            collideWidthPlayer: function () {
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
                    </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">collideWidthPlayer</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span>.playerLayer.getChildAt(<span style="color: #800080;">0</span><span style="color: #000000;">));
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(e){
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            },

            render: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__getPath();

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base();
            }
        }
    });

    window.EnemyLayer </span>=<span style="color: #000000;"> EnemyLayer;
}());</span></pre>
</div>
<h1 align="left">提出父类MoveSprite</h1>
<ul>
<li>PlayerSprite、EnemySprite有相似的模式</li>
<li>从语义上来看，PlayerSprite、EnemySprite都是能够移动的精灵类</li>
</ul>
<p align="left">因此，提出父类MoveSprite</p>
<h2 align="left">为什么不把PlayerSprite、EnemySprite的相似的模式直接提到Sprite中？</h2>
<ul>
<li>抽象层次不同</li>
</ul>
<p align="left">因为我提取的语义是&ldquo;移动的精灵类&rdquo;，而Sprite的语义是&ldquo;精灵类&rdquo;，属于更抽象的概念</p>
<h2 align="left">为什么不叫CharacterSprite？</h2>
<ul>
<li>因为关注的语义不同。</li>
</ul>
<p align="left">在提取CharacterLayer类时，关注的是PlayerLayer、EnemyLayer中&ldquo;人物&rdquo;语义；而在提取MoveSprite类时，关注的是PlayerSprite、EnemySprite中&rdquo;移动&ldquo;语义。因此，凡是属于&rdquo;人物&ldquo;这个语义的Layer类，都可以考虑继承于CharacterLayer；而凡是有&rdquo;移动&ldquo;这个特点的Sprite类，都可以考虑继承于MoveSprite。</p>
<h2 align="left">领域模型</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201309/24114540-ff1965e0f07f489c88288d33c6ecb91b.jpg" alt="" /></p>
<h2>相关代码</h2>
<p>Sprite</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Sprite =<span style="color: #000000;"> YYC.AClass({
        Init: function (data, bitmap) {
            </span><span style="color: #0000ff;">this</span>.bitmap =<span style="color: #000000;"> bitmap;
            </span><span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
            </span><span style="color: #0000ff;">this</span>.y =<span style="color: #000000;"> data.y;
            </span><span style="color: #0000ff;">this</span>.defaultAnimId =<span style="color: #000000;"> data.defaultAnimId;
            </span><span style="color: #0000ff;">this</span>.anims =<span style="color: #000000;"> data.anims;
        },
        Private: {
            _updateFrame: function (deltaTime) {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.update(deltaTime);
                }
            }
        },
        Public: {
            bitmap: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标</span>
            x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵包含的所有 Animation 集合. Object类型, 数据存放方式为" id : animation ".</span>
            anims: <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">默认的Animation的Id , string类型</span>
            defaultAnimId: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">当前的Animation.</span>
            currentAnim: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            setAnim: function (animId) {
                </span><span style="color: #0000ff;">this</span>.currentAnim = <span style="color: #0000ff;">this</span><span style="color: #000000;">.anims[animId];
            },
            resetCurrentFrame: function (index) {
                </span><span style="color: #0000ff;">this</span>.currentAnim &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.setCurrentFrame(index);
            },
            getCollideRect: function () {
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                    x1: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.x,
                    y1: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.y,
                    x2: </span><span style="color: #0000ff;">this</span>.x + <span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.width,
                    y2: </span><span style="color: #0000ff;">this</span>.y + <span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.height
                }
            },
            Virtual: {
                init: function () {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation</span>
                    <span style="color: #0000ff;">this</span>.setAnim(<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId);
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新精灵当前状态.</span>
<span style="color: #000000;">                update: function (deltaTime) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._updateFrame(deltaTime);
                }
            }
        },
        Abstract: {
            draw: function (context) { },
            clear: function (context) { }
        }
    });

    window.Sprite </span>=<span style="color: #000000;"> Sprite;
}());</span></pre>
</div>
<p>MoveSprite</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('78f1744b-3ed2-4389-9d4e-1b4844fa2d67')"><img id="code_img_closed_78f1744b-3ed2-4389-9d4e-1b4844fa2d67" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_78f1744b-3ed2-4389-9d4e-1b4844fa2d67" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('78f1744b-3ed2-4389-9d4e-1b4844fa2d67',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_78f1744b-3ed2-4389-9d4e-1b4844fa2d67" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> MoveSprite =<span style="color: #000000;"> YYC.AClass(Sprite, {
        Init: function (data, bitmap) {
            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">(data, bitmap);
            </span><span style="color: #0000ff;">this</span>.minX =<span style="color: #000000;"> data.minX;
            </span><span style="color: #0000ff;">this</span>.maxX =<span style="color: #000000;"> data.maxX;
            </span><span style="color: #0000ff;">this</span>.minY =<span style="color: #000000;"> data.minY;
            </span><span style="color: #0000ff;">this</span>.maxY =<span style="color: #000000;"> data.maxY;

            </span><span style="color: #0000ff;">this</span>.walkSpeed =<span style="color: #000000;"> data.walkSpeed;
            </span><span style="color: #0000ff;">this</span>.speedX =<span style="color: #000000;"> data.walkSpeed;
            </span><span style="color: #0000ff;">this</span>.speedY =<span style="color: #000000;"> data.walkSpeed;
        },
        Protected: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">状态模式上下文类</span>
            P__context: <span style="color: #0000ff;">null</span><span style="color: #000000;">
        },
        Private: {
            __getCurrentState: function () {
                </span><span style="color: #0000ff;">var</span> currentState = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">switch</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandRightState();
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandDownState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StandUpState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkDownState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkUpState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkRightState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">未知的状态</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                };

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> currentState;
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">计算移动次数</span>
<span style="color: #000000;">            __computeStep: function () {
                </span><span style="color: #0000ff;">this</span>.stepX = Math.ceil(bomberConfig.WIDTH / <span style="color: #0000ff;">this</span><span style="color: #000000;">.speedX);
                </span><span style="color: #0000ff;">this</span>.stepY = Math.ceil(bomberConfig.HEIGHT / <span style="color: #0000ff;">this</span><span style="color: #000000;">.speedY);
            },
            __isMoving: function(){
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.x % bomberConfig.WIDTH !== <span style="color: #800080;">0</span> || <span style="color: #0000ff;">this</span>.y % bomberConfig.HEIGHT !== <span style="color: #800080;">0</span><span style="color: #000000;">
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的速度</span>
            speedX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            speedY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标区间</span>
            minX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            maxX: </span><span style="color: #800080;">9999</span><span style="color: #000000;">,
            minY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            maxY: </span><span style="color: #800080;">9999</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的方向系数：
            </span><span style="color: #008000;">//</span><span style="color: #008000;">往下走dirY为正数，往上走dirY为负数；
            </span><span style="color: #008000;">//</span><span style="color: #008000;">往右走dirX为正数，往左走dirX为负数。</span>
            dirX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            dirY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">定义sprite走路速度的绝对值</span>
            walkSpeed: <span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">一次移动步长中的需要移动的次数</span>
            stepX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            stepY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">一次移动步长中已经移动的次数</span>
            moveIndex_x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            moveIndex_y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">是否正在移动标志</span>
            moving: <span style="color: #0000ff;">false</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">站立标志
            </span><span style="color: #008000;">//</span><span style="color: #008000;">用于解决调用WalkState.stand后，PlayerLayer.render中P__isChange返回false的问题
            </span><span style="color: #008000;">//</span><span style="color: #008000;">（不调用draw，从而仍会显示精灵类walk的帧（而不会刷新为更新状态后的精灵类stand的帧））。</span>
            stand: <span style="color: #0000ff;">false</span><span style="color: #000000;">,

            init: function () {
                </span><span style="color: #0000ff;">this</span>.P__context.setPlayerState(<span style="color: #0000ff;">this</span><span style="color: #000000;">.__getCurrentState());
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__computeStep();

                </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
            },

            draw: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();
                    context.drawImage(</span><span style="color: #0000ff;">this</span>.bitmap.img, frame.x, frame.y, frame.width, frame.height, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span>.y, <span style="color: #0000ff;">this</span>.bitmap.width, <span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.height);
                }
            },
            clear: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">直接清空画布区域</span>
                    context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
                }
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">获得当前坐标对应的方格坐标</span>
<span style="color: #000000;">            getCurrentCellPosition: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.__isMoving()) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">精灵正在移动且未完成一个移动步长</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                    x: </span><span style="color: #0000ff;">this</span>.x /<span style="color: #000000;"> bomberConfig.WIDTH,
                    y: </span><span style="color: #0000ff;">this</span>.y /<span style="color: #000000;"> bomberConfig.HEIGHT
                }
            }
        },
        Abstract: {
            move: function () { },
            setDir: function () { }
        }
    });

    window.MoveSprite </span>=<span style="color: #000000;"> MoveSprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>PlayerSprite</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> PlayerSprite =<span style="color: #000000;"> YYC.Class(MoveSprite, {
        Init: function (data, bitmap) {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base(data, bitmap);

            </span><span style="color: #0000ff;">this</span>.P__context = <span style="color: #0000ff;">new</span> Context(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        },
        Private: {
            __allKeyUp: function () {
                </span><span style="color: #0000ff;">return</span> window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">false</span> &amp;&amp; window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">false</span>
                    &amp;&amp; window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">false</span> &amp;&amp; window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            },
            __judgeAndSetDir: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkLeft();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkRight();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkUp();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkDown();
                }
            }
        },
        Public: {
            move: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.move();
            },
            setDir: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.moving) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.__allKeyUp()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.stand();
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__judgeAndSetDir();
                }
            }
        }
    });

    window.PlayerSprite </span>=<span style="color: #000000;"> PlayerSprite;
}());</span></pre>
</div>
<p>EnemySprite</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('a73a2916-7ea1-4dc3-9e55-b460e3d11050')"><img id="code_img_closed_a73a2916-7ea1-4dc3-9e55-b460e3d11050" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_a73a2916-7ea1-4dc3-9e55-b460e3d11050" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a73a2916-7ea1-4dc3-9e55-b460e3d11050',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_a73a2916-7ea1-4dc3-9e55-b460e3d11050" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> EnemySprite =<span style="color: #000000;"> YYC.Class(MoveSprite, {
        Init: function (data, bitmap) {
            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">(data, bitmap);

            </span><span style="color: #0000ff;">this</span>.P__context = <span style="color: #0000ff;">new</span> Context(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        },
        Private: {
            ___findPath: function () {
                </span><span style="color: #0000ff;">return</span> window.findPath.aCompute(window.terrainData, <span style="color: #0000ff;">this</span><span style="color: #000000;">.___computeCurrentCoordinate(),
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___computePlayerCoordinate()).path
            },
            ___computeCurrentCoordinate: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.x % window.bomberConfig.WIDTH || <span style="color: #0000ff;">this</span>.y %<span style="color: #000000;"> window.bomberConfig.HEIGHT) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">当前坐标应该为方格尺寸的整数倍！</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                    x: </span><span style="color: #0000ff;">this</span>.x /<span style="color: #000000;"> window.bomberConfig.WIDTH,
                    y: </span><span style="color: #0000ff;">this</span>.y /<span style="color: #000000;"> window.bomberConfig.HEIGHT
                };
            },
            ___computePlayerCoordinate: function () {
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                    x: Math.floor(</span><span style="color: #0000ff;">this</span>.playerSprite.x /<span style="color: #000000;"> window.bomberConfig.WIDTH),
                    y: Math.floor(</span><span style="color: #0000ff;">this</span>.playerSprite.y /<span style="color: #000000;"> window.bomberConfig.HEIGHT)
                };
            },
            ___getAndRemoveTarget: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.path.shift();
            },
            ___judgeAndSetDir: function (target) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">当前坐标</span>
                <span style="color: #0000ff;">var</span> current = <span style="color: #0000ff;">this</span><span style="color: #000000;">.___computeCurrentCoordinate();

                </span><span style="color: #008000;">//</span><span style="color: #008000;">判断要移动的方向，调用相应的方法</span>
                <span style="color: #0000ff;">if</span> (target.x &gt;<span style="color: #000000;"> current.x) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkRight();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (target.x &lt;<span style="color: #000000;"> current.x) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkLeft();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (target.y &gt;<span style="color: #000000;"> current.y) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkDown();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (target.y &lt;<span style="color: #000000;"> current.y) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.walkUp();
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.stand();
                }
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">寻找的路径</span>
<span style="color: #000000;">            path: [],
            playerSprite: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            collideWidthPlayer : function(sprite2){
                </span><span style="color: #0000ff;">var</span> rect1=<span style="color: #0000ff;">this</span><span style="color: #000000;">.getCollideRect();
                </span><span style="color: #0000ff;">var</span> rect2=<span style="color: #000000;">sprite2.getCollideRect();

                </span><span style="color: #008000;">//</span><span style="color: #008000;">如果碰撞，则抛出异常</span>
                <span style="color: #0000ff;">if</span> (rect1 &amp;&amp; rect2 &amp;&amp; !(rect1.x1 &gt;= rect2.x2 || rect1.y1 &gt;= rect2.y2 || rect1.x2 &lt;= rect2.x1 || rect1.y2 &lt;=<span style="color: #000000;"> rect2.y1)) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Error();
                }
            },
            setPlayerSprite: function (sprite) {
                </span><span style="color: #0000ff;">this</span>.playerSprite =<span style="color: #000000;"> sprite;
            },
            move: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.move();
            },
            setDir: function () {

                </span><span style="color: #008000;">//</span><span style="color: #008000;">如果正在移动或者找不到路径，则返回</span>
                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.moving || <span style="color: #0000ff;">this</span>.path === <span style="color: #0000ff;">false</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">this</span>.___judgeAndSetDir(<span style="color: #0000ff;">this</span><span style="color: #000000;">.___getAndRemoveTarget());
            },
            getPath: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.moving) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.path.length == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.path = <span style="color: #0000ff;">this</span><span style="color: #000000;">.___findPath();
                }
            }
        }
    });

    window.EnemySprite </span>=<span style="color: #000000;"> EnemySprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h1>将Bitmap注入到Sprite中</h1>
<p>反思Sprite类，发现在getCollideRect方法中，使用了图片的宽度和高度：</p>
<div class="cnblogs_code">
<pre>          getCollideRect: <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">var</span> f = <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                        x1: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.x,
                        y1: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.y,
                        x2: </span><span style="color: #0000ff;">this</span>.x +<span style="color: #000000;"> f.imgWidth,
                        y2: </span><span style="color: #0000ff;">this</span>.y +<span style="color: #000000;"> f.imgHeight
                    }
                }
            },</span></pre>
</div>
<p>此处图片的宽度和高度是从FrameData中读取的：</p>
<div class="cnblogs_code">
<pre>    <span style="color: #0000ff;">var</span> getFrames = (<span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
...
            imgWidth </span>=<span style="color: #000000;"> bomberConfig.player.IMGWIDTH,
            imgHeight </span>=<span style="color: #000000;"> bomberConfig.player.IMGHEIGHT;
...</span></pre>
</div>
<p>图片的宽度和高度属于图片信息，应该都放到Bitmap类中！</p>
<p>在创建精灵实例时，将图片的宽度和高度包装到Bitmap中，并注入到精灵类中:</p>
<p>SpriteFactory</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> spriteFactory =<span style="color: #000000;"> {
        createPlayer: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> PlayerSprite(getSpriteData(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>), bitmapFactory.createBitmap({ img: window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span><span style="color: #000000;">), width: bomberConfig.player.IMGWIDTH, height: bomberConfig.player.IMGHEIGHT }));
        },
        createEnemy: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> EnemySprite(getSpriteData(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span>), bitmapFactory.createBitmap({ img: window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">enemy</span><span style="color: #800000;">"</span><span style="color: #000000;">), width: bomberConfig.player.IMGWIDTH, height: bomberConfig.player.IMGHEIGHT }));
        }
    }

    window.spriteFactory </span>=<span style="color: #000000;"> spriteFactory;
}());</span></pre>
</div>
<p>然后在getCollideRect方法中改为读取Bitmap实例引用的宽度和高度：</p>
<p>Sprite</p>
<div class="cnblogs_code">
<pre>Init: <span style="color: #0000ff;">function</span><span style="color: #000000;"> (data, bitmap) {
    </span><span style="color: #0000ff;">this</span>.bitmap =<span style="color: #000000;"> bitmap;
...
},
...
bitmap: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
...
getCollideRect: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
        x1: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.x,
        y1: </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.y,
        x2: </span><span style="color: #0000ff;">this</span>.x + <span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.width,
        y2: </span><span style="color: #0000ff;">this</span>.y + <span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.height
    }
},</span></pre>
</div>
<h2>领域模型&nbsp;</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/14113729-cec157f2ec4e477b85967f418618c961.jpg" alt="" /></p>
<h1>删除data -&gt; frames.js中的imgWidth、imgHeight</h1>
<p>现在FrameData中的imgWidth、imgHeight是多余的了，应该将其删除。</p>
<h1><span style="line-height: 1.5;">增加MapElementSprite</span></h1>
<p>增加地图元素精灵类，<span style="color: #000000;">它拥有图片Bitmap的实例</span>。其中，地图的一个单元格就是一个地图元素精灵类。</p>
<h2>为什么增加？</h2>
<p>1、可以在创建MapLayer元素时，元素由bitmap改为精灵类，这样x、y属性就可以从bitmap移到精灵类中了.<br />2、精灵类包含动画，方便后期增加动态地图。</p>
<h2>它的父类为Sprite还是MoveSprite？</h2>
<p>因为MapElementSprite不属于&ldquo;移动&rdquo;语义，且它与MoveSprite没有相同的模式，所以它应该继承于Sprite。</p>
<h2>领域模型</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/02202607-8df79dc2e81640b6a2acf974f7d76937.jpg" alt="" /></p>
<h2>相关代码</h2>
<p>MapElementSprite</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> MapElementSprite =<span style="color: #000000;"> YYC.Class(Sprite, {</span>
<span style="color: #000000;">        Init: function (data, bitmap) {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base(data, bitmap);
        },
        Protected: {
        },
        Private: {
        },
        Public: {
            draw: function (context) {</span>
                context.drawImage(<span style="color: #0000ff;">this</span>.bitmap.img, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span>.y, <span style="color: #0000ff;">this</span>.bitmap.width, <span style="color: #0000ff;">this</span><span style="color: #000000;">.bitmap.height);</span>
<span style="color: #000000;">            },
            clear: function (context) {</span><span style="color: #008000;">//</span><span style="color: #008000;">直接清空画布区域</span>
                context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);</span>
<span style="color: #000000;">            }
        }
    });

    window.MapElementSprite </span>=<span style="color: #000000;"> MapElementSprite;
}());</span></pre>
</div>
<p>MapLayer</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('afc6dda2-0433-4585-aad9-3a78c6ba3ff9')"><img id="code_img_closed_afc6dda2-0433-4585-aad9-3a78c6ba3ff9" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_afc6dda2-0433-4585-aad9-3a78c6ba3ff9" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('afc6dda2-0433-4585-aad9-3a78c6ba3ff9',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_afc6dda2-0433-4585-aad9-3a78c6ba3ff9" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> MapLayer =<span style="color: #000000;"> YYC.Class(Layer, {
        Init: function () {
        },
        Private: {
            ___canvasBuffer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            ___contextBuffer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            ___getCanvasBuffer: function () {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">缓冲的canvas也要在html中创建并设置width、height！</span>
                <span style="color: #0000ff;">this</span>.___canvasBuffer = document.getElementById(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayerCanvas_buffer</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            },
            ___getContextBuffer: function () {
                </span><span style="color: #0000ff;">this</span>.___contextBuffer = <span style="color: #0000ff;">this</span>.___canvasBuffer.getContext(<span style="color: #800000;">"</span><span style="color: #800000;">2d</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            },
            ___drawBuffer: function () {
                </span><span style="color: #0000ff;">this</span>.P__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">draw</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.___contextBuffer);
            }
        },
        Public: {
            setCanvas: function () {
                </span><span style="color: #0000ff;">this</span>.P__canvas = document.getElementById(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                
                </span><span style="color: #0000ff;">var</span> css =<span style="color: #000000;"> {
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">border</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">1px solid blue</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                    </span><span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">0</span><span style="color: #000000;">
                };

                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#mapLayerCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">).css(css);
                </span><span style="color: #008000;">//</span><span style="color: #008000;">缓冲canvas的css也要设置！</span>
                $(<span style="color: #800000;">"</span><span style="color: #800000;">#mapLayerCanvas_buffer</span><span style="color: #800000;">"</span><span style="color: #000000;">).css(css);
            },
            init: function(){
                </span><span style="color: #008000;">//</span><span style="color: #008000;">*双缓冲

                </span><span style="color: #008000;">//</span><span style="color: #008000;">获得缓冲canvas</span>
                <span style="color: #0000ff;">this</span><span style="color: #000000;">.___getCanvasBuffer();
                </span><span style="color: #008000;">//</span><span style="color: #008000;">获得缓冲context</span>
                <span style="color: #0000ff;">this</span><span style="color: #000000;">.___getContextBuffer();

                </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
            },


            draw: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___drawBuffer();

                </span><span style="color: #0000ff;">this</span>.P__context.drawImage(<span style="color: #0000ff;">this</span>.___canvasBuffer, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);

            },
            clear: function () {
                </span><span style="color: #0000ff;">this</span>.___contextBuffer.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
                </span><span style="color: #0000ff;">this</span>.P__context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
            },
            render: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__isChange()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.clear();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.draw();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__setStateNormal();
                }
            }
        }
    });

    window.MapLayer </span>=<span style="color: #000000;"> MapLayer;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h1><span style="line-height: 1.5;">重构Bitmap</span></h1>
<h2>删除Bitmap的x、y属性。<span style="color: #c0c0c0;"><br /></span></h2>
<p>现在Bitmap的x、y属性用于保存地图图片的坐标。现在坐标保存在地图精灵类中了，故Bitmap中多余的x、y属性。</p>
<h2>相关代码</h2>
<p>Bitmap</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Bitmap =<span style="color: #000000;"> YYC.Class({
        Init: function (data) {
            </span><span style="color: #0000ff;">this</span>.img =<span style="color: #000000;"> data.img;
            </span><span style="color: #0000ff;">this</span>.width =<span style="color: #000000;"> data.width;
            </span><span style="color: #0000ff;">this</span>.height =<span style="color: #000000;"> data.height;
        },
        Private: {
        },
        Public: {
            img: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            width: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            height: </span><span style="color: #800080;">0</span><span style="color: #000000;">
        }
    });

    window.Bitmap </span>=<span style="color: #000000;"> Bitmap;
}());</span></pre>
</div>
<h1>重构LayerManager</h1>
<p>LayerManager本来的职责为&ldquo;负责层的逻辑&rdquo;，但是我认为LayerManager的职责应该为&ldquo;负责层的统一操作&rdquo;，它应该为一个键-值集合类，它的元素应该为Layer的实例。</p>
<p>因此对LayerManager进行重构：</p>
<ul>
<li>将change的判断移到具体的Layer中</li>
</ul>
<p>由Layer类应该负责自己状态的维护。</p>
<ul>
<li>将createElement放到Game中</li>
</ul>
<p>创建层内元素createElement这个职责应该放到调用LayerManager的客户端，即Game类中。在Game中还要负责创建LayerManager、创建Layer。</p>
<ul>
<li>增加Hash</li>
</ul>
<p>增加一个Hash类，它实现键-值集合的通用操作，然后让LayerManager继承于Hash，使之成为集合类。</p>
<h2>为什么使用Hash类，而不是使用Collection类（数组集合类）</h2>
<p>功能上分析：</p>
<p>因为LayerManager集合的元素为Layer实例，而每一个层的实例都是唯一的，即如PlayerLayer实例只有一个，不会有二个PlayerLayer实例。因此，使用Hash结构，可以通过key获得LayerManager集合中的每个元素。</p>
<p>Hash的优势：</p>
<p>Hash结构不需要知道LayerManager集合装入Layer实例的顺序，通过key值就可以唯一获得元素；而Collection结构（数组结构）需要知道装入顺序。</p>
<h2><span>领域模型</span></h2>
<p><span><img src="http://images.cnitblog.com/blog/419321/201309/24103936-25360ec96ec540ef961582b65d04b617.jpg" alt="" /></span></p>
<h2>相关代码</h2>
<p>LayerManager、PlayerLayerManager、EnemyLayerManager、MapLayerManager重构前：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('07b745e5-c041-498c-95c7-1ee45c7414f2')"><img id="code_img_closed_07b745e5-c041-498c-95c7-1ee45c7414f2" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_07b745e5-c041-498c-95c7-1ee45c7414f2" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('07b745e5-c041-498c-95c7-1ee45c7414f2',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_07b745e5-c041-498c-95c7-1ee45c7414f2" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {

    </span><span style="color: #008000;">//</span><span style="color: #008000;">* 父类</span>

    <span style="color: #0000ff;">var</span> LayerManager =<span style="color: #000000;"> YYC.AClass({
        Init: function (layer) {
            </span><span style="color: #0000ff;">this</span>.layer =<span style="color: #000000;"> layer;
        },
        Private: {
        },
        Public: {
            layer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            addElement: function (element) {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = element.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.appendChild(element[i]);
                }
            },
            render: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.render();
            },
            Virtual: {
                initLayer: function () {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.setCanvas();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.init();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.change();
                }
            }
        },
        Abstract: {
            createElement: function () { },
            change: function () { }
        }
    });


    </span><span style="color: #008000;">//</span><span style="color: #008000;">*子类</span>

    <span style="color: #0000ff;">var</span> MapLayerManager =<span style="color: #000000;"> YYC.Class(LayerManager, {
        Init: function (layer) {
            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">(layer);
        },
        Private: {
            __getMapImg: function (i, j, mapData) {
                </span><span style="color: #0000ff;">var</span> img = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (mapData[i][j]) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">1</span><span style="color: #000000;">:
                        img </span>= window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">2</span><span style="color: #000000;">:
                        img </span>= window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> img;
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">创建并设置每个地图单元bitmap，加入到元素数组中并返回。</span>
<span style="color: #000000;">            createElement: function () {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    x </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    y </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    row </span>=<span style="color: #000000;"> bomberConfig.map.ROW,
                    col </span>=<span style="color: #000000;"> bomberConfig.map.COL,
                    element </span>=<span style="color: #000000;"> [],
                    mapData </span>=<span style="color: #000000;"> mapDataOperate.getMapData(),
                    img </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; row; i++<span style="color: #000000;">) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">注意！
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">y为纵向height，x为横向width</span>
                    y = i *<span style="color: #000000;"> bomberConfig.HEIGHT;

                    </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; col; j++<span style="color: #000000;">) {
                        x </span>= j *<span style="color: #000000;"> bomberConfig.WIDTH;
                        img </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.__getMapImg(i, j, mapData);

                        element.push(spriteFactory.createMapElement({ x: x, y: y }, bitmapFactory.createBitmap({ img: img, width: bomberConfig.WIDTH, height: bomberConfig.HEIGHT })));
                    }
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
            },
            change: function () {
            }
        }
    });


    </span><span style="color: #0000ff;">var</span> PlayerLayerManager =<span style="color: #000000;"> YYC.Class(LayerManager, {
        Init: function (layer) {
            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">(layer);
        },
        Private: {
            __keyDown: function () {
                </span><span style="color: #0000ff;">if</span> (keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span> || keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span>
                    || keyState[keyCodeMap.W] === <span style="color: #0000ff;">true</span> || keyState[keyCodeMap.S] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            },
            __spriteMoving: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.layer.getChildAt(<span style="color: #800080;">0</span><span style="color: #000000;">).moving
            },
            __spriteStand: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.layer.getChildAt(<span style="color: #800080;">0</span><span style="color: #000000;">).stand) {
                    </span><span style="color: #0000ff;">this</span>.layer.getChildAt(<span style="color: #800080;">0</span>).stand = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            }
        },
        Public: {
            createElement: function () {
                </span><span style="color: #0000ff;">var</span> element =<span style="color: #000000;"> [],
                    player </span>=<span style="color: #000000;"> spriteFactory.createPlayer();

                player.init();
                element.push(player);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
            },
            change: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.__keyDown() || <span style="color: #0000ff;">this</span>.__spriteMoving() || <span style="color: #0000ff;">this</span><span style="color: #000000;">.__spriteStand()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.change();
                }
            }
        }
    });


    </span><span style="color: #0000ff;">var</span> EnemyLayerManager =<span style="color: #000000;"> YYC.Class(LayerManager, {
        Init: function (layer) {
            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">(layer);
        },
        Private: {
        },
        Public: {
            initLayer: function (playerLayerManager) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.setCanvas();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.init();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.getPlayer(playerLayerManager.layer);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.change();
            },
            createElement: function () {
                </span><span style="color: #0000ff;">var</span> element =<span style="color: #000000;"> [],
                    enemy </span>=<span style="color: #000000;"> spriteFactory.createEnemy();

                enemy.init();
                element.push(enemy);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
            },

            collideWidthPlayer: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.collideWidthPlayer();
            },
            change: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.change();
            }
        }
    });


    window.LayerManager </span>= LayerManager;     <span style="color: #008000;">//</span><span style="color: #008000;">用于测试</span>
<span style="color: #000000;">
    window.MapLayerManager </span>=<span style="color: #000000;"> MapLayerManager;
    window.PlayerLayerManager </span>=<span style="color: #000000;"> PlayerLayerManager;
    window.EnemyLayerManager </span>=<span style="color: #000000;"> EnemyLayerManager;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>LayerManager重构后：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {

    </span><span style="color: #0000ff;">var</span> LayerManager =<span style="color: #000000;"> YYC.Class(Hash, {
        Private: {
            __iterator: function (handler) {
                </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span><span style="color: #000000;">),
                    i </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                    layers </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.getChilds();

                </span><span style="color: #0000ff;">for</span> (i <span style="color: #0000ff;">in</span><span style="color: #000000;"> layers) {
                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (layers.hasOwnProperty(i)) {
                        layers[i][handler].apply(layers[i], args);
                    }
                }
            }
        },
        Public: {
            addLayer: function (name, layer) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.add(name, layer);
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">;
            },
            getLayer: function (name) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.getValue(name);
            },
            initLayer: function () {
                </span><span style="color: #0000ff;">this</span>.__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">setCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">this</span>.__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">init</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            },
            render: function () {
                </span><span style="color: #0000ff;">this</span>.__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">render</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            },
            change: function () {
                </span><span style="color: #0000ff;">this</span>.__iterator(<span style="color: #800000;">"</span><span style="color: #800000;">change</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        }
    });

    window.LayerManager </span>=<span style="color: #000000;"> LayerManager;
}());</span></pre>
</div>
<p>Hash</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Hash =<span style="color: #000000;"> YYC.AClass({
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">容器</span>
<span style="color: #000000;">            _childs: {}
        },
        Public: {
            getChilds: function () {
                </span><span style="color: #0000ff;">return</span> YYC.Tool.extend.extend({}, <span style="color: #0000ff;">this</span><span style="color: #000000;">._childs);
            },
            getValue: function (key) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._childs[key];
            },
            add: function (key, value) {
                </span><span style="color: #0000ff;">this</span>._childs[key] =<span style="color: #000000;"> value;
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">;
            }
        }
    });

    window.Hash </span>=<span style="color: #000000;"> Hash;
}());</span></pre>
</div>
<p>Game</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('3de4cdb5-13ae-40b4-98f6-ca44598995c7')"><img id="code_img_closed_3de4cdb5-13ae-40b4-98f6-ca44598995c7" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_3de4cdb5-13ae-40b4-98f6-ca44598995c7" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3de4cdb5-13ae-40b4-98f6-ca44598995c7',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_3de4cdb5-13ae-40b4-98f6-ca44598995c7" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Game =<span style="color: #000000;"> YYC.Class({
        Init: function () {
        },
        Private: {
            _pattern: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            _ground: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            _layerManager: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            _createLayerManager: function () {
                </span><span style="color: #0000ff;">this</span>._layerManager = <span style="color: #0000ff;">new</span><span style="color: #000000;"> LayerManager();
                </span><span style="color: #0000ff;">this</span>._layerManager.addLayer(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, layerFactory.createMap());
                </span><span style="color: #0000ff;">this</span>._layerManager.addLayer(<span style="color: #800000;">"</span><span style="color: #800000;">playerLayer</span><span style="color: #800000;">"</span>, layerFactory.createPlayer(<span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep));
                </span><span style="color: #0000ff;">this</span>._layerManager.addLayer(<span style="color: #800000;">"</span><span style="color: #800000;">enemyLayer</span><span style="color: #800000;">"</span>, layerFactory.createEnemy(<span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep));
            },
            _addElements: function () {
                </span><span style="color: #0000ff;">var</span> mapLayerElements = <span style="color: #0000ff;">this</span><span style="color: #000000;">._createMapLayerElement(),
                    playerLayerElements </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._createPlayerLayerElement(),
                    enemyLayerElements </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._createEnemyLayerElement();

                </span><span style="color: #0000ff;">this</span>._layerManager.addElements(<span style="color: #800000;">"</span><span style="color: #800000;">mapLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, mapLayerElements);
                </span><span style="color: #0000ff;">this</span>._layerManager.addElements(<span style="color: #800000;">"</span><span style="color: #800000;">playerLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, playerLayerElements);
                </span><span style="color: #0000ff;">this</span>._layerManager.addElements(<span style="color: #800000;">"</span><span style="color: #800000;">enemyLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">, enemyLayerElements);
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">创建并设置每个地图方格精灵，加入到元素数组中并返回。</span>
<span style="color: #000000;">            _createMapLayerElement: function () {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    x </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    y </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    row </span>=<span style="color: #000000;"> bomberConfig.map.ROW,
                    col </span>=<span style="color: #000000;"> bomberConfig.map.COL,
                    element </span>=<span style="color: #000000;"> [],
                    mapData </span>=<span style="color: #000000;"> mapDataOperate.getMapData(),
                    img </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; row; i++<span style="color: #000000;">) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">注意！
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">y为纵向height，x为横向width</span>
                    y = i *<span style="color: #000000;"> bomberConfig.HEIGHT;

                    </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; col; j++<span style="color: #000000;">) {
                        x </span>= j *<span style="color: #000000;"> bomberConfig.WIDTH;
                        img </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._getMapImg(i, j, mapData);
                        element.push(spriteFactory.createMapElement({ x: x, y: y }, bitmapFactory.createBitmap({ img: img, width: bomberConfig.WIDTH, height: bomberConfig.HEIGHT })));
                    }
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
            },
            _getMapImg: function (i, j, mapData) {
                </span><span style="color: #0000ff;">var</span> img = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (mapData[i][j]) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">1</span><span style="color: #000000;">:
                        img </span>= window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">2</span><span style="color: #000000;">:
                        img </span>= window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> img;
            },
            _createPlayerLayerElement: function () {
                </span><span style="color: #0000ff;">var</span> element =<span style="color: #000000;"> [],
                    player </span>=<span style="color: #000000;"> spriteFactory.createPlayer();

                player.init();
                element.push(player);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
            },
            _createEnemyLayerElement: function () {
                </span><span style="color: #0000ff;">var</span> element =<span style="color: #000000;"> [],
                    enemy </span>=<span style="color: #000000;"> spriteFactory.createEnemy();

                enemy.init();
                element.push(enemy);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
            },
            _initLayer: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._layerManager.initLayer();
                </span><span style="color: #0000ff;">this</span>._layerManager.getLayer(<span style="color: #800000;">"</span><span style="color: #800000;">enemyLayer</span><span style="color: #800000;">"</span>).getPlayer(<span style="color: #0000ff;">this</span>._layerManager.getLayer(<span style="color: #800000;">"</span><span style="color: #800000;">playerLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">));
            },
            _initEvent: function () {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">监听整个document的keydown,keyup事件</span>
<span style="color: #000000;">                keyEventManager.addKeyDown();
                keyEventManager.addKeyUp();
            }
        },
        Public: {
            context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            sleep: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            x: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            mainLoop: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            init: function () {
                </span><span style="color: #0000ff;">this</span>.sleep = Math.floor(<span style="color: #800080;">1000</span> /<span style="color: #000000;"> bomberConfig.FPS);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._createLayerManager();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._addElements();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._initLayer();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._initEvent();
            },
            start: function () {
                </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span>.mainLoop =<span style="color: #000000;"> window.setInterval(function () {
                    self.run();
                }, </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep);
            },
            run: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._layerManager.getLayer(<span style="color: #800000;">"</span><span style="color: #800000;">enemyLayer</span><span style="color: #800000;">"</span><span style="color: #000000;">).collideWidthPlayer()) {
                    clearInterval(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.mainLoop);
                    alert(</span><span style="color: #800000;">"</span><span style="color: #800000;">Game Over！</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._layerManager.render();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._layerManager.change();
            }
        }
    });

    window.Game </span>=<span style="color: #000000;"> Game;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><a name="model"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文最终领域模型</span></strong></p>
<p><img src="http://images.cnitblog.com/blog/419321/201311/28133142-1c9a087654f84398b6adb0662bca59cd.jpg" alt="" width="700" height="370" /></p>
<p><a href="http://images.cnitblog.com/blog/419321/201311/28133142-1c9a087654f84398b6adb0662bca59cd.jpg" target="_blank">查看大图</a></p>
<p><a name="layer"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">高层划分</span></strong></p>
<h1>新增包</h1>
<ul>
<li>算法包<br /><span style="font-size: 14px; line-height: 1.5;">FindPath</span></li>
<li>精灵抽象包<br /><span style="font-size: 14px; line-height: 1.5;">Sprite</span></li>
<li><span style="font-size: 14px; line-height: 1.5;">哈希集合包<br /><span style="font-size: 14px; line-height: 1.5;"><span style="font-size: 14px; line-height: 1.5;">Hash</span></span></span></li>













</ul>
<h1>删除包</h1>
<ul>
<li>层管理实现包<br /><span style="font-size: 14px; line-height: 1.5;">经过本文重构后，去掉了PlayerLayerManager等子类，只保留了LayerManager类。因此去掉层管理实现包。</span></li>















</ul>
<h1>层、包</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/20214032-9901ee2fdb104412a6077bbf49816a05.jpg" alt="" width="744" height="1121" /></p>
<h1>重构</h1>
<h2>将集合包重命名为数组集合包</h2>
<p>&ldquo;层&rdquo;这个层级的集合包的命名太广泛了，应该具体化为数组集合包，这样才不至于与哈希集合包混淆。</p>
<p><span style="color: #ff0000;"><img src="http://images.cnitblog.com/blog/419321/201310/20214058-c54cc2f221634108acf3ebc244b17858.jpg" alt="" width="656" height="605" /></span></p>
<h1>将哈希集合包和数组集合包合并为集合包</h1>
<p>哈希集合包与数组集合包都属于集合，因此应该合并为集合包，然后将集合包放到辅助逻辑层。</p>
<p><span style="color: #ff0000;"><img src="http://images.cnitblog.com/blog/419321/201310/20214134-f17e172cd98245bc85da03547e513a81.jpg" alt="" width="716" height="499" /></span></p>
<h2>提出抽象包</h2>
<h3>　　分析</h3>
<p>封闭性：</p>
<p>层抽象包、精灵抽象包位于同一个层面（抽象层面），会对同一种性质的变化共同封闭。</p>
<p>如精灵抽象类（精灵抽象包）发生变化，可能会引起层抽象类的变化。</p>
<p>重用性：</p>
<p>两者相互关联。</p>
<p>两者为抽象类，具有通用性。</p>
<p>可以一起被重用。</p>
<h3>&nbsp;　　结论</h3>
<p>因此，将层抽象包、精灵抽象包合并成抽象包，并放到辅助逻辑层。</p>
<h2><span style="line-height: 1.5;">将集合包也合并到抽象包中</span></h2>
<p>抽象包与集合包有依赖关系，但实际上只是抽象包中的层抽象类与集合包有依赖，精灵抽象类与集合包没有管理，因此违反了共用重用原则CRP。</p>
<p>考虑到集合包也具有的通用性，将其也合并到抽象包中：</p>
<p><span style="color: #ff0000;"><img src="http://images.cnitblog.com/blog/419321/201310/20215249-c4e46a100475497eb7fe97caf70cca14.jpg" alt="" width="725" height="897" /></span></p>
<h2>提出人物包、地图包</h2>
<p>层和精灵都包含人物（精灵中为移动）、地图的概念，人物层与移动精灵、地图层与地图元素精灵联系紧密。</p>
<h3>　　分析</h3>
<p>封闭性：</p>
<p>层实现包与精灵实现包违反了共同封闭原则CCP。如地图发生变化时，只会引起地图层和地图元素精灵的变化，而不会引起人物层和移动精灵的变化。</p>
<p><span style="font-size: 14px; line-height: 1.5;">重用性：</span></p>
<p><span style="font-size: 14px; line-height: 1.5;">层实现包与精灵实现包中，人物层与地图层、移动精灵与地图元素精灵没有关联，因此违反了共同重用原则CRP。</span></p>
<p><span style="font-size: 14px; line-height: 1.5;">因此，分离出人物包、地图包，并将层、精灵这两个层合并为实现层：</span></p>
<p><span style="font-size: 14px; line-height: 1.5; color: #ff0000;"><img src="http://images.cnitblog.com/blog/419321/201310/20215402-e516b349f42c4ed0bbe73ffadbf062df.jpg" alt="" width="707" height="716" /></span></p>
<h3>　　状态类放到哪</h3>
<p>状态类与属于人物包的玩家精灵类和敌人精灵类紧密关联，因此应该放到人物包中。</p>
<h3>　　MoveSprite、CharacterLayer应不应该放到抽象包中</h3>
<p>MoveSprite、CharacterLayer是抽象类，但是它们与具体的人物实现密切相关（因为它们是从人物实现类PlayerSprite和EnemySprite、PlayerLayer和EnemyLayer提取共同模式而形成的父类）。因此，它们应该放到人物实现包中。</p>
<h1><span style="color: #000000;">本文最终层、包</span></h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/20215452-3acf306377b543259488def56a3d2b6c.jpg" alt="" width="743" height="1003" /></p>
<h1>对应领域模型</h1>
<ul>
<li>辅助操作层
<ul>
<li>控件包<br />PreLoadImg</li>
<li>配置包<br />Config</li>























</ul>























</li>
<li>用户交互层
<ul>
<li>入口包<br />Main</li>























</ul>























</li>
<li>业务逻辑层
<ul>
<li>辅助逻辑
<ul>
<li>工厂包<br />BitmapFactory、LayerFactory、SpriteFactory</li>
<li>事件管理包<br />KeyState、KeyEventManager</li>
<li>抽象包<br />Layer、Sprite、Hash、Collection</li>























</ul>























</li>
<li>游戏主逻辑
<ul>
<li>主逻辑包<br />Game</li>























</ul>























</li>
<li>层管理
<ul>
<li>层管理包<br />LayerManager</li>























</ul>























</li>
<li>实现
<ul>
<li>人物实现包<br />PlayerLayer、MoveSprite、PlayerSprite、EnemySprite、CharacterLayer、PlayerLayer、EnemyLayer、Context、PlayerState、WalkState、StandState、WalkState_X、WalkState_Y、StandLeftState、StandRightState、StandUpState、StandDownState、WalkLeftState、WalkRightState、WalkUpState、WalkDownState</li>
<li>地图实现包<br />MapLayer、MapElementSprite</li>
<li>算法包<br />FindPath</li>
<li>动画包<br />Animation、GetSpriteData、SpriteData、GetFrames、FrameData</li>























</ul>























</li>























</ul>























</li>
<li>数据操作层
<ul>
<li>地图数据操作包<br />MapDataOperate</li>
<li>路径数据操作包<br />GetPath</li>
<li>图片数据操作包<br />Bitmap</li>























</ul>























</li>
<li>数据层
<ul>
<li>地图包<br />MapData、TerrainData</li>
<li>图片路径包<br />ImgPathData</li>













</ul>













</li>













</ul>
<p>
<a name="demo"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">演示地址</span></strong></p>
<p><a href="http://yang222.s2.jutuo.net/Bomber/Index7"><strong><span>演示地址</span></strong></a></p>
<p>
<a name="reference"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文参考资料</span></strong></p>
<p><a href="http://hi.baidu.com/wsapyoemdfacmqr/item/bdfb5c0a74c904d01ef0466d">A星算法</a></p>
<h1>欢迎浏览上一篇博文：<a id="cb_post_title_url" href="http://www.cnblogs.com/chaogex/p/3327097.html">炸弹人游戏开发系列（6）：实现碰撞检测，设置移动步长</a></h1>
<h1>欢迎浏览下一篇博文：<a href="http://www.cnblogs.com/chaogex/p/3336783.html">炸弹人游戏开发系列（8）：放炸弹</a><span><br /></span></h1>]]></description></item><item><title>炸弹人游戏开发系列（6）：实现碰撞检测，设置移动步长</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/20/3327097.html</link><dc:creator>yyc元超</dc:creator><author>yyc元超</author><pubDate>Sun, 20 Oct 2013 03:25:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/20/3327097.html</guid><description><![CDATA[<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">前言</span></strong></p>
<p>上文中我们实现了&ldquo;玩家控制炸弹人&rdquo;的功能，本文将实现碰撞检测，让炸弹人不能穿过墙。在实现的过程中会发现炸弹人移动的问题，然后会通过设置移动步长来解决。</p>
<h1><strong>说明</strong></h1>
<h2>名词解释</h2>
<ul>
<li>具体状态类<br />指应用于炸弹人移动状态的状态模式的ConcreState角色的类。这里具体包括WalkLeftState、WalkRightState、WalkUpState、WalkDownState、StandLeftState等类。</li>













</ul>
<h1>本文目的</h1>
<p>实现碰撞检测</p>
<h1><strong>本文主要内容</strong></h1>
<ul>
<li><a href="#strategy">开发策略</a></li>
<li><a href="#firstCheck">初步实现碰撞检测</a></li>
<li><a href="#setMoveIndex">设置移动步长</a></li>
<li><a href="#secondCheck">继续完成碰撞检测</a></li>
<li><a href="#refactor">重构</a></li>
<li><a href="#model">本文最终领域模型</a></li>
<li><a href="#layer">高层划分</a></li>
<li><a href="#demo">演示</a></li>
<li><a href="#reference">本文参考资料</a></li>












</ul>
<h1><strong>回顾上文更新后的领域模型</strong></h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/20092225-121dbfa91436406e91cc969097428b10.jpg" alt="" width="766" height="347" /></p>
<p><a href="http://images.cnitblog.com/blog/419321/201310/20092225-121dbfa91436406e91cc969097428b10.jpg" target="_blank">查看大图</a></p>
<h1><strong>对领域模型进行思考</strong></h1>
<h2><strong>重构PlayerSprite</strong></h2>
<p>重构前代码</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('bf467568-bb04-4ed2-b49d-cfb7a37ebb9d')"><img id="code_img_closed_bf467568-bb04-4ed2-b49d-cfb7a37ebb9d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_bf467568-bb04-4ed2-b49d-cfb7a37ebb9d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('bf467568-bb04-4ed2-b49d-cfb7a37ebb9d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_bf467568-bb04-4ed2-b49d-cfb7a37ebb9d" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> PlayerSprite =<span style="color: #000000;"> YYC.Class({
        </span><span style="color: #008000;">//</span><span style="color: #008000;">供子类构造函数中调用</span>
<span style="color: #000000;">        Init: function (data) {
            </span><span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
            </span><span style="color: #0000ff;">this</span>.y =<span style="color: #000000;"> data.y;

            </span><span style="color: #0000ff;">this</span>.minX =<span style="color: #000000;"> data.minX;
            </span><span style="color: #0000ff;">this</span>.maxX =<span style="color: #000000;"> data.maxX;
            </span><span style="color: #0000ff;">this</span>.minY =<span style="color: #000000;"> data.minY;
            </span><span style="color: #0000ff;">this</span>.maxY =<span style="color: #000000;"> data.maxY;

            </span><span style="color: #0000ff;">this</span>.defaultAnimId =<span style="color: #000000;"> data.defaultAnimId;
            </span><span style="color: #0000ff;">this</span>.anims =<span style="color: #000000;"> data.anims;

            </span><span style="color: #0000ff;">this</span>.walkSpeed =<span style="color: #000000;"> data.walkSpeed;

            </span><span style="color: #0000ff;">this</span>._context = <span style="color: #0000ff;">new</span> Context(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        },
        Private: {
            _context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            _setCoordinate: function (deltaTime) {
                </span><span style="color: #0000ff;">this</span>.x = <span style="color: #0000ff;">this</span>.x + <span style="color: #0000ff;">this</span>.speedX *<span style="color: #000000;"> deltaTime;
                </span><span style="color: #0000ff;">this</span>.y = <span style="color: #0000ff;">this</span>.y + <span style="color: #0000ff;">this</span>.speedY *<span style="color: #000000;"> deltaTime;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._limitMove();
            },
            _limitMove: function () {
                </span><span style="color: #0000ff;">this</span>.x = Math.max(<span style="color: #0000ff;">this</span>.minX, Math.min(<span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.maxX));
                </span><span style="color: #0000ff;">this</span>.y = Math.max(<span style="color: #0000ff;">this</span>.minY, Math.min(<span style="color: #0000ff;">this</span>.y, <span style="color: #0000ff;">this</span><span style="color: #000000;">.maxY));
            },
            _getCurrentState: function () {
                </span><span style="color: #0000ff;">var</span> currentState = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">switch</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.standRightState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.standLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.standDownState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.standUpState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.walkDownState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.walkUpState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.walkRightState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.walkLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">未知的状态</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                };

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> currentState;
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标</span>
            x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的速度</span>
            walkSpeed: <span style="color: #800080;">0</span><span style="color: #000000;">,

            speedX: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            speedY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标区间</span>
            minX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            maxX: </span><span style="color: #800080;">9999</span><span style="color: #000000;">,
            minY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            maxY: </span><span style="color: #800080;">9999</span><span style="color: #000000;">,

            anims: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">默认的Animation的Id , string类型</span>
            defaultAnimId: <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">当前的Animation.</span>
            currentAnim: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            init: function () {
                </span><span style="color: #0000ff;">this</span>._context.setPlayerState(<span style="color: #0000ff;">this</span><span style="color: #000000;">._getCurrentState());

                </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation</span>
                <span style="color: #0000ff;">this</span>.setAnim(<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId);
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">重置当前帧</span>
<span style="color: #000000;">            resetCurrentFrame: function (index) {
                </span><span style="color: #0000ff;">this</span>.currentAnim &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.setCurrentFrame(index);
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation, 参数为Animation的id, String类型</span>
<span style="color: #000000;">            setAnim: function (animId) {
                </span><span style="color: #0000ff;">this</span>.currentAnim = <span style="color: #0000ff;">this</span><span style="color: #000000;">.anims[animId];
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新精灵当前状态.</span>
<span style="color: #000000;">            update: function (deltaTime) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">每次循环,改变一下绘制的坐标</span>
                <span style="color: #0000ff;">this</span><span style="color: #000000;">._setCoordinate(deltaTime);

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.update(deltaTime);
                }
            },
            draw: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    context.drawImage(</span><span style="color: #0000ff;">this</span>.currentAnim.getImg(), frame.x, frame.y, frame.width, frame.height, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y, frame.imgWidth, frame.imgHeight);
                }
            },
            clear: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    context.clearRect(</span><span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
                }
            },
            handleNext: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkLeft();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkRight();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkUp();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkDown();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.stand();
            }
        }
    });

    window.PlayerSprite </span>=<span style="color: #000000;"> PlayerSprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h3>　　handleNext改名为changeDir</h3>
<p>反思handleNext方法。从方法名来看，它的职责应该为处理本次循环的所有逻辑。然而，经过数次重构后，现在handleNext的职责只是调用状态类的方法，更具体的来说，它的职责为判断和设置炸弹人移动方向。</p>
<p>因此，应该将handleNext改名为changeDir，从而能够反映出它的职责。</p>
<h3>　　从update方法中分离出move方法</h3>
<p>再来审视update方法，发现它有两个职责：</p>
<ul>
<li>更新坐标</li>
<li>更新动画</li>
</ul>
<p>进一步思考，此处&ldquo;更新坐标&rdquo;的职责更抽象地来说应该为"炸弹人移动&ldquo;的职责。应该将其提出，形成move方法。然后去掉&rdquo;__setCoordinate&ldquo;方法，将其代码直接写到move方法中</p>
<h3>　　删除deltaTime</h3>
<div class="cnblogs_code">
<pre>            _setCoordinate: <span style="color: #0000ff;">function</span><span style="color: #000000;"> (deltaTime) {
                </span><span style="color: #0000ff;">this</span>.x = <span style="color: #0000ff;">this</span>.x + <span style="color: #0000ff;">this</span>.speedX *<span style="color: #000000;"> deltaTime;
                </span><span style="color: #0000ff;">this</span>.y = <span style="color: #0000ff;">this</span>.y + <span style="color: #0000ff;">this</span>.speedY *<span style="color: #000000;"> deltaTime;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._limitMove();
            },</span></pre>
</div>
<p>这里deltaTime其实没有什么作用，因此将其删除。</p>
<h3>　　重构后相关代码</h3>
<p>PlayerSprite</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">            update: function (deltaTime) {
                 </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.update(deltaTime);
                }
            },
            draw: function (context) {</span>
                <span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    context.drawImage(</span><span style="color: #0000ff;">this</span>.currentAnim.getImg(), frame.x, frame.y, frame.width, frame.height, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y, frame.imgWidth, frame.imgHeight);
                }
            },
            clear: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    context.clearRect(</span><span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
                }
            },
            move: function () {
                </span><span style="color: #0000ff;">this</span>.x = <span style="color: #0000ff;">this</span>.x + <span style="color: #0000ff;">this</span>.speedX<span style="color: #000000;">;
                </span><span style="color: #0000ff;">this</span>.y = <span style="color: #0000ff;">this</span>.y + <span style="color: #0000ff;">this</span>.speedY<span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._limitMove();
            },
            changeDir: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkLeft();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkRight();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkUp();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkDown();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.stand();
            }</span></pre>
</div>
<p>要对应修改PlayerLayer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">   　　　　   __changeDir: function () {
                </span><span style="color: #0000ff;">this</span>.___iterator(<span style="color: #800000;">"</span><span style="color: #800000;">changeDir</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            },
            ___move: function () {
                </span><span style="color: #0000ff;">this</span>.___iterator(<span style="color: #800000;">"</span><span style="color: #800000;">move</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            },
...
            render: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__isChange()) {
                    </span><span style="color: #0000ff;">this</span>.clear(<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__changeDir();
                    </span><span style="color: #0000ff;">this</span>.___move(<span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span>.___update(<span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span>.draw(<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__setStateNormal();
                }
            }    </span></pre>
</div>
<h2>分离speedX/speedY属性的语义，提出&ldquo;方向向量&rdquo;概念dirX/dirY</h2>
<p>状态类WalkLeftState</p>
<div class="cnblogs_code">
<pre><span>            walkLeft: function () {
                </span><span>var</span> sprite = <span>null</span><span>;

                </span><span>if</span> (window.keyState[keyCodeMap.A] === <span>true</span><span>) {
                    sprite </span>= <span>this</span><span>.P_context.sprite;
                    sprite.speedX </span>= -<span>sprite.walkSpeed;
                    sprite.speedY </span>= <span>0</span><span>;

                    sprite.setAnim(</span><span>"</span><span>walk_left</span><span>"</span><span>);</span>
<span>                }
            },</span></pre>
</div>
<p>目前是通过在具体状态类中改变speedX/speedY的正负（如+sprite.walkSpeed或-sprite.walkSpeed），来实现炸弹人移动方向的改变。因此，我发现speedX/speedY属性实际上有两个语义：</p>
<ul>
<li>炸弹人移动速度</li>
<li>炸弹人移动方向</li>
</ul>
<p>这样会造成speed语义混淆，不便于阅读和维护。因此，将&ldquo;炸弹人移动方向&rdquo;提出来，形成新的属性dirX/dirY，而speedX/speedY则保留&ldquo;炸弹人移动速度&rdquo;语义。</p>
<h3>　　重构后相关代码</h3>
<p>PlayerSprite</p>
<div class="cnblogs_code">
<pre>            dirX: 0<span style="color: #000000;">,
            dirY: </span>0<span style="color: #000000;">,
...
            move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span>.x = <span style="color: #0000ff;">this</span>.x + <span style="color: #0000ff;">this</span>.speedX * <span style="color: #0000ff;">this</span><span style="color: #000000;">.dirX;
                </span><span style="color: #0000ff;">this</span>.y = <span style="color: #0000ff;">this</span>.y + <span style="color: #0000ff;">this</span>.speedY * <span style="color: #0000ff;">this</span><span style="color: #000000;">.dirY;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._limitMove();
            },    </span></pre>
</div>
<p>WalkLeftState（其它具体状态类也要做类似的修改）</p>
<div class="cnblogs_code">
<pre>            walkLeft: <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    sprite </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                    sprite.dirX </span>= -1<span style="color: #000000;">;
                    sprite.dirY </span>= 0<span style="color: #000000;">;

                    sprite.setAnim(</span>"walk_left"<span style="color: #000000;">);
                }
            },</span></pre>
</div>
<p><a name="strategy"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">开发策略</span></strong></p>
<p>首先查阅相关资料，确定碰撞检测的方法，然后再实现炸弹人与地图砖墙的碰撞检测。</p>
<p><a name="firstCheck"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">初步实现碰撞检测</span></strong></p>
<h1>提出&ldquo;碰撞检测&rdquo;的概念</h1>
<p><span>在第2篇博文中提出了&ldquo;碰撞检测&rdquo;的概念：</span></p>
<p><span>用于检测炸弹人与砖墙、炸弹人与怪物等之间的碰撞。碰撞检测包括矩形碰撞、多边形碰撞等，一般使用矩形碰撞即可。</span></p>
<p><span>此处我采用<span style="color: #000000;">矩形碰撞检测。</span></span></p>
<h1>增加地形数据TerrainData</h1>
<p>首先，我们需要一个存储地图中哪些区域能够通过，哪些区域不能通过的数据结构。</p>
<p>通过参考地图数据mapData，我决定数据结构选用二维数组，且地形数组与地图数组一一对应。</p>
<h2>相关代码</h2>
<p>地图数据MapData</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> ground =<span style="color: #000000;"> bomberConfig.map.type.GROUND,
        wall </span>=<span style="color: #000000;"> bomberConfig.map.type.WALL;

    </span><span style="color: #0000ff;">var</span> mapData =<span style="color: #000000;"> [
        [ground, wall, ground, ground],
        [ground, ground, ground, ground],
        [ground, wall, ground, ground],
        [ground, wall, ground, ground]
    ];

    window.mapData </span>=<span style="color: #000000;"> mapData;
}());</span></pre>
</div>
<p>地形数据TerrainData</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">地形数据</span>
<span style="color: #000000;">(function () {
　　</span><span style="color: #008000;">//</span><span style="color: #008000;">0表示可以通过，1表示不能通过</span>
    <span style="color: #0000ff;">var</span> terrainData =<span style="color: #000000;"> [
        [</span><span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">],
        [</span><span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">],
        [</span><span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">],
        [</span><span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">]
    ];

    window.terrainData </span>=<span style="color: #000000;"> terrainData;
}());</span></pre>
</div>
<h1>重构TerrainData</h1>
<p>受到MapData的启示，可以在Config中加入地形数据的枚举值（pass、stop），然后直接在TerrainData中使用枚举值。这样做有以下的好处：</p>
<ul>
<li>增强可读性</li>
<li>枚举值放到Config中，方便统一管理</li>
</ul>
<h2>相关代码</h2>
<p>Config</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">    map: {
...
        terrain: {
            pass: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            stop: </span><span style="color: #800080;">1</span><span style="color: #000000;">
        }
    },<br /></span></pre>
</div>
<p>TerrainData</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">地形数据
</span><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> pass =<span style="color: #000000;"> bomberConfig.map.terrain.pass,
        stop </span>=<span style="color: #000000;"> bomberConfig.map.terrain.stop;

    </span><span style="color: #0000ff;">var</span> terrainData =<span style="color: #000000;"> [
        [pass, stop, pass, pass],
        [pass, pass, pass, pass],
        [pass, stop, pass, pass],
        [pass, stop, pass, pass]
    ];

    window.terrainData </span>=<span style="color: #000000;"> terrainData;
}());</span></pre>
</div>
<h1>在PlayerSprite中实现矩形碰撞检测</h1>
<p>实现checkCollideWithMap方法：</p>
<div class="cnblogs_code">
<pre>            _checkCollideWithMap: <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> i1 = Math.floor((<span style="color: #0000ff;">this</span>.y) /<span style="color: #000000;"> bomberConfig.HEIGHT),
                    i2 </span>= Math.floor((<span style="color: #0000ff;">this</span>.y + bomberConfig.player.IMGHEIGHT - 1) /<span style="color: #000000;"> bomberConfig.HEIGHT),
                    j1 </span>= Math.floor((<span style="color: #0000ff;">this</span>.x) /<span style="color: #000000;"> bomberConfig.WIDTH),
                    j2 </span>= Math.floor((<span style="color: #0000ff;">this</span>.x + bomberConfig.player.IMGWIDTH - 1) /<span style="color: #000000;"> bomberConfig.WIDTH),
                    terrainData </span>=<span style="color: #000000;"> window.terrainData,
                    pass </span>=<span style="color: #000000;"> bomberConfig.map.terrain.pass,
                    stop </span>=<span style="color: #000000;"> bomberConfig.map.terrain.stop;

                </span><span style="color: #0000ff;">if</span> (terrainData[i1][j1] === pass &amp;&amp; terrainData[i1][j2] ===<span style="color: #000000;"> pass
                    </span>&amp;&amp; terrainData[i2][j1] === pass &amp;&amp; terrainData[i2][j2] ===<span style="color: #000000;"> pass) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            },</span></pre>
</div>
<p>在move中判断：</p>
<div class="cnblogs_code">
<pre>move: <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    </span><span style="color: #0000ff;">var</span> origin_x = <span style="color: #0000ff;">this</span><span style="color: #000000;">.x,
        origin_y </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.y;

    </span><span style="color: #0000ff;">this</span>.x = <span style="color: #0000ff;">this</span>.x + <span style="color: #0000ff;">this</span>.speedX * <span style="color: #0000ff;">this</span><span style="color: #000000;">.dirX;
    </span><span style="color: #0000ff;">this</span>.y = <span style="color: #0000ff;">this</span>.y + <span style="color: #0000ff;">this</span>.speedY * <span style="color: #0000ff;">this</span><span style="color: #000000;">.dirY;

    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._limitMove();

    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">._checkCollideWithMap()) {
        </span><span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> origin_x;
        </span><span style="color: #0000ff;">this</span>.y =<span style="color: #000000;"> origin_y;
    }
},</span></pre>
</div>
<h1>领域模型</h1>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/419321/201309/26093512-4b5606f4821146829c4bfbd0440e70bb.jpg" alt="" /></p>
<p><a name="setMoveIndex"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">设置移动步长</span></strong></p>
<h1>发现问题</h1>
<p>如果炸弹人每次移动0.2个方格，炸弹人想通过两个障碍物之间的空地，则炸弹人所在矩形区域必须与空地区域平行时才能通过。这通常导致玩家需要调整多次才能顺利通过。</p>
<p>如图所示：</p>
<p style="text-align: left;" align="center">&nbsp;<img src="http://images.cnitblog.com/blog/419321/201309/19151642-847ed96e62914234929b110ef5b30aa5.png" alt="" width="161" height="237" /></p>
<p style="text-align: left;" align="center">不能通过</p>
<p style="text-align: left;" align="center">&nbsp;<img src="http://images.cnitblog.com/blog/419321/201309/19151658-dd305b05fc9146e58ce91941115052de.png" alt="" width="159" height="251" /></p>
<p style="text-align: left;" align="center">可以通过</p>
<h1>引入&rdquo;移动步长&ldquo;概念　　</h1>
<p>结合参考资料&rdquo;<a href="http://blog.csdn.net/lufy_legend/article/details/7076064">html5游戏开发-零基础开发RPG游戏-开源讲座(二)-跑起来吧英雄</a>&ldquo;，这里可以引出&ldquo;移动步长&rdquo;的概念：</p>
<p>即炸弹人一次移动一个地图方格（炸弹人一次会移动多步）。即如果一个方格长为10px，而游戏每次主循环轮询时炸弹人移动2px，则炸弹人一次需要移动5步。在炸弹人的一个移动步长完成之前，玩家不能操作炸弹人，直到炸弹人完成一个移动步长（即移动了一个方格），玩家才能操作炸弹人。</p>
<h1>实现移动步长</h1>
<h2>提出概念</h2>
<p>这里先提出以下概念：</p>
<ul>
<li>step</li>
</ul>
<p>移动步数，炸弹人移动一个方格需要的步数</p>
<ul>
<li><span style="color: #000000;">completeOneMov</span>e<span style="color: #000000;">（该标志会在后面重构中被删除）</span></li>
</ul>
<p><span style="color: #000000;">炸弹人完成一个移动步长的标志</span></p>
<ul>
<li>moving</li>
</ul>
<p>炸弹人正在移动的标志</p>
<ul>
<li>moveIndex</li>
</ul>
<p>炸弹人在一次移动步长中已经移动的次数</p>
<h2>具体实现</h2>
<p>首先在游戏开始时，计算一次炸弹人移动一个方格需要的步数；然后在移动前，先判断是否完成一次移动步长，如果正在移动且没有完成一次步长，则moveIndex加1；在移动后，判断该次移动是否完成移动步长，并相应更新移动标志和moveIndex。</p>
<h1>重构</h1>
<h2>将&ldquo;moveIndex加1&rdquo;移到状态类中</h2>
<p><span style="color: #000000;">具体状态类的职责为：负责本状态的逻辑以及决定状态过渡。</span>&ldquo;moveIndex加1&rdquo;这个职责属于&ldquo;本状态的逻辑&rdquo;，因此应该将其移到具体状态类中，封装为addIndex方法。</p>
<h2>将按键判断移到PlayerSprite中</h2>
<p>&nbsp;&ldquo;按键判断&rdquo;是状态转换事件的判断，这里因为炸弹人<span>不同状态转换为同一状态的触发事件相同，所以可以</span>将其移到上一层的客户端（调用具体状态类的地方）中，即移到PlayerSprite的changeDir方法中。具体分析详见<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3342166.html">Javascript设计模式之我见：状态模式</a>中的&ldquo;将触发状态的事件判断移到Warrior类中&rdquo;。</p>
<h2><span style="color: #000000;">相关代码</span></h2>
<p><span style="color: #000000;">PlayerSprite</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">...      
             _computeCoordinate: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span>.x = <span style="color: #0000ff;">this</span>.x + <span style="color: #0000ff;">this</span>.speedX * <span style="color: #0000ff;">this</span><span style="color: #000000;">.dirX;
                </span><span style="color: #0000ff;">this</span>.y = <span style="color: #0000ff;">this</span>.y + <span style="color: #0000ff;">this</span>.speedY * <span style="color: #0000ff;">this</span><span style="color: #000000;">.dirY;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._limitMove();

                </span><span style="color: #008000;">//</span><span style="color: #008000;">因为移动次数是向上取整，可能会造成移动次数偏多（如stepX为2.5，取整则stepX为3），</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">坐标可能会偏大（大于bomberConfig.WIDTH / bomberConfig.HEIGHT的整数倍），</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">因此此处需要向下取整。</span>
                
                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.completeOneMove) {
                    </span><span style="color: #0000ff;">this</span>.x -= <span style="color: #0000ff;">this</span>.x %<span style="color: #000000;"> bomberConfig.WIDTH;
                    </span><span style="color: #0000ff;">this</span>.y -= <span style="color: #0000ff;">this</span>.y %<span style="color: #000000;"> bomberConfig.HEIGHT;
                }
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">计算移动次数</span>
            _computeStep: <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span>.stepX = Math.ceil(bomberConfig.WIDTH / <span style="color: #0000ff;">this</span><span style="color: #000000;">.speedX);
                </span><span style="color: #0000ff;">this</span>.stepY = Math.ceil(bomberConfig.HEIGHT / <span style="color: #0000ff;">this</span><span style="color: #000000;">.speedY);
            },
            _allKeyUp: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">return</span> window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">false</span> &amp;&amp; window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">false</span>
                     &amp;&amp; window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">false</span> &amp;&amp; window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            },
            _judgeCompleteOneMoveByIndex: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">this</span><span style="color: #000000;">.moving) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                 </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.moveIndex_x &gt;= <span style="color: #0000ff;">this</span><span style="color: #000000;">.stepX) {
                    </span><span style="color: #0000ff;">this</span>.moveIndex_x = 0<span style="color: #000000;">;
                    </span><span style="color: #0000ff;">this</span>.completeOneMove = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.moveIndex_y &gt;= <span style="color: #0000ff;">this</span><span style="color: #000000;">.stepY) {
                    </span><span style="color: #0000ff;">this</span>.moveIndex_y = 0<span style="color: #000000;">;
                    </span><span style="color: #0000ff;">this</span>.completeOneMove = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span>.completeOneMove = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            },
            _judgeAndSetDir: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkLeft();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkRight();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkUp();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkDown();
                }
            }
...

            </span><span style="color: #008000;">//</span><span style="color: #008000;">一次移动步长中的需要移动的次数</span>
            stepX: 0<span style="color: #000000;">,
            stepY: </span>0<span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">一次移动步长中已经移动的次数</span>
            moveIndex_x: 0<span style="color: #000000;">,
            moveIndex_y: </span>0<span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">是否正在移动标志</span>
            moving: <span style="color: #0000ff;">false</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">完成一次移动标志</span>
            completeOneMove: <span style="color: #0000ff;">false</span><span style="color: #000000;">,

            init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span>._context.setPlayerState(<span style="color: #0000ff;">this</span><span style="color: #000000;">._getCurrentState());
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._computeStep();

                </span><span style="color: #0000ff;">this</span>.setAnim(<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId);
            },
...
            move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._judgeCompleteOneMoveByIndex();

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._computeCoordinate();
            },
            changeDir: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">this</span>.completeOneMove &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">.moving) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.addIndex();
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">._allKeyUp()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.stand();
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._judgeAndSetDir();
                }
            }<br />...</span></pre>
</div>
<p><span style="color: #000000;">Context</span></p>
<div class="cnblogs_code">
<pre>(<span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    </span><span style="color: #0000ff;">var</span> Context =<span style="color: #000000;"> YYC.Class({
        Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (sprite) {
            </span><span style="color: #0000ff;">this</span>.sprite =<span style="color: #000000;"> sprite;
        },
        Private: {
            _state: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">
        },
        Public: {
            sprite: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            setPlayerState: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (state) {
                </span><span style="color: #0000ff;">this</span>._state =<span style="color: #000000;"> state;
                </span><span style="color: #0000ff;">this</span>._state.setContext(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
            },
            walkLeft: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.walkLeft();
            },
            walkRight: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.walkRight();
            },
            walkUp: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.walkUp();
            },
            walkDown: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.walkDown();
            },
            stand: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.stand();
            },
            addIndex: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.addIndex();
            }
        },
        Static: {
            walkLeftState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkLeftState(),
            walkRightState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkRightState(),
            walkUpState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkUpState(),
            walkDownState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkDownState(),
            standLeftState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> StandLeftState(),
            standRightState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> StandRightState(),
            standUpState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> StandUpState(),
            standDownState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> StandDownState()
        }
    });

    window.Context </span>=<span style="color: #000000;"> Context;
}());</span></pre>
</div>
<p><span style="color: #000000;">WalkLeftState（此处只举一个状态类说明，其它状态类与该类类似）:</span></p>
<div class="cnblogs_code">
<pre>...            <br />　　　　　　　　walkLeft: <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                    sprite.dirX </span>= -1<span style="color: #000000;">;
                    sprite.dirY </span>= 0<span style="color: #000000;">;

                    sprite.setAnim(</span>"walk_left"<span style="color: #000000;">);
                    sprite.moving </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.addIndex();
            },
            addIndex: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span>.P_context.sprite.moveIndex_x += 1<span style="color: #000000;">;
            }<br />...</span></pre>
</div>
<p><a name="secondCheck"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">继续完成碰撞检测</span></strong></p>
<p>对地图障碍物检测进行了修改，并将碰撞检测和边界检测移到具体状态类中。</p>
<h1>相关代码</h1>
<p>WalkLeftState（此处只举一个状态类说明，其它状态类与该类类似）</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">...
walkLeft: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
    sprite.setAnim(</span>"walk_left"<span style="color: #000000;">);

    </span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">this</span><span style="color: #000000;">.checkPassMap()) {
        sprite.moving </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        sprite.dirX </span>= 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }

    sprite.dirX </span>= -1<span style="color: #000000;">;
    sprite.dirY </span>= 0<span style="color: #000000;">;
    sprite.moving </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.addIndex();
},
...
</span><span style="color: #008000;">//</span><span style="color: #008000;">检测是否可通过该地图。可以通过返回true，不能通过返回false</span>
checkPassMap: <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    </span><span style="color: #0000ff;">return</span> !<span style="color: #0000ff;">this</span><span style="color: #000000;">.checkCollideWithBarrier();
},
checkCollideWithBarrier: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    </span><span style="color: #0000ff;">var</span> pass =<span style="color: #000000;"> bomberConfig.map.terrain.pass,
        stop </span>=<span style="color: #000000;"> bomberConfig.map.terrain.stop;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">计算目的地地形数组下标</span>
    <span style="color: #0000ff;">var</span> target_x = <span style="color: #0000ff;">this</span>.P_context.sprite.x / bomberConfig.WIDTH - 1<span style="color: #000000;">,
        target_y </span>= <span style="color: #0000ff;">this</span>.P_context.sprite.y /<span style="color: #000000;"> bomberConfig.HEIGHT;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">超出边界</span>
    <span style="color: #0000ff;">if</span> (target_x &gt;= terrainData.length || target_y &gt;= terrainData[0<span style="color: #000000;">].length) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

    </span><span style="color: #0000ff;">if</span> (target_x &lt; 0<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">碰撞</span>
    <span style="color: #0000ff;">if</span> (window.terrainData[target_y][target_x] ===<span style="color: #000000;"> stop) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
}
...</span></pre>
</div>
<p><a name="refactor"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">重构</span></strong></p>
<h1>重构PlayerSprite</h1>
<h2>将move移到状态类中</h2>
<p>PlayerSprite的move方法负责炸弹人的移动，其应该属于具体状态类的职责（负责本状态的逻辑），故将PlayerSprite的move移到具体状态类中。</p>
<h2>进一步分析</h2>
<p>将PlayerSprite的move移到具体状态类中，从职责上来进一步分析，实质是将&ldquo;炸弹人移动&rdquo;的职责分散到各个具体状态类中了（如WalkLeftState、WalkRightState只负责X方向的移动，WalkUpState、WalkDownState只负责Y方向的移动）</p>
<p><strong>优点</strong></p>
<p>增加了细粒度的控制。可以控制各个具体状态类下炸弹人的移动。</p>
<p><strong>缺点</strong></p>
<p>不好统一管理。当想修改&ldquo;炸弹人移动&rdquo;的逻辑时，可能需要修改每个具体状态类的move。</p>
<p>不过这个缺点可以在后面的提取具体状态类的基类的重构中解决。因为该重构会将具体状态类中&ldquo;炸弹人移动&rdquo;的职责汇聚到基类中。</p>
<h2>重构addIndex</h2>
<p>现在<span>PlayerSprite -&gt; changeDir中不用调用addIndex方法了，可以直接在具体状态类的move方法中调用。</span></p>
<p><span>这样做的好处是具体状态类不用再公开addIndex方法了，而是将其私有化。</span></p>
<h2><span>为什么把公有方法addIndex改为私有方法比较好？</span></h2>
<p><span>这是因为改动一个类的私有成员时，只会影响到该类，而不会影响到与该类关联的其它类；而改动公有成员则可能会影响与之关联的其它类。特别当我们是在创建供别人使用的类库时，如果发布后再来修改公有成员，会对很多人造成影响！</span>这也是符合&ldquo;高内聚低耦合&rdquo;的思想。</p>
<p><span>我们应该对公有权限保持警惕的态度，能设成私有的就私有，只公开必要的接口成员。</span></p>
<h2>相关代码</h2>
<p>PlayerSprite</p>
<div class="cnblogs_code">
<pre>           move: <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.move();
            },</span></pre>
</div>
<p>WalkLeftState（WalkRightState与之类似）</p>
<div class="cnblogs_code">
<pre>            move: <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite.moving) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.addIndex();
                }

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__judgeCompleteOneMoveByIndex();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__computeCoordinate();
            },
            __addIndex: </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
                </span><span style="color: #0000ff;">this</span>.P_context.sprite.moveIndex_x += 1<span style="color: #000000;">;
            },
            __judgeCompleteOneMoveByIndex: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">sprite.moving) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">if</span> (sprite.moveIndex_x &gt;=<span style="color: #000000;"> sprite.stepX) {
                    sprite.moveIndex_x </span>= 0<span style="color: #000000;">;
                    sprite.completeOneMove </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    sprite.completeOneMove </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            },
            __computeCoordinate: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                sprite.x </span>= sprite.x + sprite.speedX *<span style="color: #000000;"> sprite.dirX;

                </span><span style="color: #008000;">//</span><span style="color: #008000;">因为移动次数是向上取整，可能会造成移动次数偏多（如stepX为2.5，取整则stepX为3），</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">坐标可能会偏大（大于bomberConfig.WIDTH / bomberConfig.HEIGHT的整数倍），</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">因此此处需要向下取整。</span>


                <span style="color: #008000;">//</span><span style="color: #008000;">x、y为bomberConfig.WIDTH/bomberConfig.HEIGHT的整数倍（向下取整）</span>
                <span style="color: #0000ff;">if</span><span style="color: #000000;"> (sprite.completeOneMove) {
                    sprite.x </span>-= sprite.x %<span style="color: #000000;"> bomberConfig.WIDTH;
                }
            }</span></pre>
</div>
<p>WalkUpState（WalkDownState与之类似）</p>
<div class="cnblogs_code">
<pre>            move: <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite.moving) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.addIndex();
                }

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__judgeCompleteOneMoveByIndex();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__computeCoordinate();
            },
            __addIndex: </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){
                </span><span style="color: #0000ff;">this</span>.P_context.sprite.moveIndex_y += 1<span style="color: #000000;">;
            },
            __judgeCompleteOneMoveByIndex: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">sprite.moving) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">if</span> (sprite.moveIndex_y &gt;=<span style="color: #000000;"> sprite.stepY) {
                    sprite.moveIndex_y </span>= 0<span style="color: #000000;">;
                    sprite.completeOneMove </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    sprite.completeOneMove </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            },
            __computeCoordinate: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                sprite.y </span>= sprite.y + sprite.speedY *<span style="color: #000000;"> sprite.dirY;

                </span><span style="color: #008000;">//</span><span style="color: #008000;">因为移动次数是向上取整，可能会造成移动次数偏多（如stepX为2.5，取整则stepX为3），</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">坐标可能会偏大（大于bomberConfig.WIDTH / bomberConfig.HEIGHT的整数倍），</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">因此此处需要向下取整。</span>


                <span style="color: #008000;">//</span><span style="color: #008000;">x、y为bomberConfig.WIDTH/bomberConfig.HEIGHT的整数倍（向下取整）</span>
                <span style="color: #0000ff;">if</span><span style="color: #000000;"> (sprite.completeOneMove) {
                    sprite.y </span>-= sprite.y %<span style="color: #000000;"> bomberConfig.HEIGHT;
                }
            }</span></pre>
</div>
<h1>重构状态模式</h1>
<p>让我们来看看状态类。</p>
<h2>思路</h2>
<p>我发现具体状态类有很多重复的代码，有些方法有很多相似之处。这促使我提炼出一个高层的共同模式。具体的方法就是提炼出基类，然后用模板模式，在子类中实现不同点。</p>
<h2>提炼出WalkState、StandState</h2>
<p>因此，我从WalkLeftState，WalkRightState，WalkDownState，WalkUpState中提炼出基类WalkState，从StandLeftState、StandRightState、StandDownState、StandUpState中提炼出基类StandState。</p>
<h2>提炼出WalkState_X、WalkState_Y</h2>
<p>我发现在WalkLeftState，WalkRightState中和WalkDownState，WalkUpState中，它们分别有共同的模式，而这共同模式不能提到WalkState中。因此，我又从WalkLeftState，WalkRightState中提炼出WalkState_X，WalkDownState，WalkUpState中提炼出WalkState_Y，然后让WalkState_X和WalkState_Y继承于WalkState。</p>
<h2>状态模式最新的领域模型</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/20103256-b023797f1f474e5fbf8f7f19ad732b04.jpg" alt="" width="563" height="224" /></p>
<h2>相关代码</h2>
<p>PlayerState</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('a6a90816-9c02-4454-9808-c58e00cd7970')"><img id="code_img_closed_a6a90816-9c02-4454-9808-c58e00cd7970" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_a6a90816-9c02-4454-9808-c58e00cd7970" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a6a90816-9c02-4454-9808-c58e00cd7970',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_a6a90816-9c02-4454-9808-c58e00cd7970" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> PlayerState =<span style="color: #000000;"> YYC.AClass({
        Protected: {
            P_context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">
        },
        Public: {
            setContext: function (context) {
                </span><span style="color: #0000ff;">this</span>.P_context =<span style="color: #000000;"> context;
            }
        },
        Abstract: {
            stand: function () { },
            walkLeft: function () { },
            walkRight: function () { },
            walkUp: function () { },
            walkDown: function () { },
            move: function () { }
        }
    });

    window.PlayerState </span>=<span style="color: #000000;"> PlayerState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>WalkState</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('3ffe03be-c236-43a4-8089-69c2fb7c6a9b')"><img id="code_img_closed_3ffe03be-c236-43a4-8089-69c2fb7c6a9b" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_3ffe03be-c236-43a4-8089-69c2fb7c6a9b" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3ffe03be-c236-43a4-8089-69c2fb7c6a9b',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_3ffe03be-c236-43a4-8089-69c2fb7c6a9b" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> WalkState =<span style="color: #000000;"> YYC.AClass(PlayerState, {
        Protected: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">*子类可复用的代码</span>
<span style="color: #000000;">
            P__checkMapAndSetDir: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__setDir();

                </span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">this</span><span style="color: #000000;">.__checkPassMap()) {
                    sprite.moving </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">sprite.dirX = 0;</span>
                    <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__stop();
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    sprite.moving </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            },
            Abstract: {
                P__setPlayerState: function () { },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">计算并返回目的地地形数组下标</span>
<span style="color: #000000;">                P__computeTarget: function () { },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">检测是否超出地图边界。
                </span><span style="color: #008000;">//</span><span style="color: #008000;">超出返回true，否则返回false</span>
<span style="color: #000000;">                P__checkBorder: function () { },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">设置方向</span>
<span style="color: #000000;">                P__setDir: function () { },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">停止</span>
<span style="color: #000000;">                P__stop: function () { }
            }
        },
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">检测是否可通过该地图。可以通过返回true，不能通过返回false</span>
<span style="color: #000000;">            __checkPassMap: function () {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">计算目的地地形数组下标</span>
                <span style="color: #0000ff;">var</span> target = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__computeTarget();

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__checkBorder(target)) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">return</span> !<span style="color: #0000ff;">this</span><span style="color: #000000;">.__checkCollideWithBarrier(target);
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">地形障碍物碰撞检测</span>
<span style="color: #000000;">            __checkCollideWithBarrier: function (target) {
                </span><span style="color: #0000ff;">var</span> stop =<span style="color: #000000;"> bomberConfig.map.terrain.stop;

                </span><span style="color: #008000;">//</span><span style="color: #008000;">碰撞</span>
                <span style="color: #0000ff;">if</span> (window.terrainData[target.y][target.x] ===<span style="color: #000000;"> stop) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        },
        Public: {
            stand: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__setPlayerState();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.stand();
                </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">this</span>.P_context.sprite.stand = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            },
            Virtual: {
                walkLeft: function () {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkLeftState);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.walkLeft();
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                },
                walkRight: function () {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkRightState);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.walkRight();
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                },
                walkUp: function () {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkUpState);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.walkUp();
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                },
                walkDown: function () {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkDownState);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.walkDown();
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                }
            }
        },
        Abstract: {
            move: function () {
            }
        }
    });

    window.WalkState </span>=<span style="color: #000000;"> WalkState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>WalkState_X</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('61cbe4c6-df81-4466-ab63-b4cb3ddcc8f6')"><img id="code_img_closed_61cbe4c6-df81-4466-ab63-b4cb3ddcc8f6" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_61cbe4c6-df81-4466-ab63-b4cb3ddcc8f6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('61cbe4c6-df81-4466-ab63-b4cb3ddcc8f6',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_61cbe4c6-df81-4466-ab63-b4cb3ddcc8f6" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> WalkState_X =<span style="color: #000000;"> YYC.AClass(WalkState, {
        Protected: {
        },
        Private: {
            __judgeCompleteOneMoveByIndex: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                </span><span style="color: #0000ff;">if</span> (sprite.moveIndex_x &gt;=<span style="color: #000000;"> sprite.stepX) {
                    sprite.moveIndex_x </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    sprite.moving </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    sprite.moving </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            },
            __computeCoordinate: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                sprite.x </span>= sprite.x + sprite.speedX *<span style="color: #000000;"> sprite.dirX;
            },
            __roundingDown: function () {
                </span><span style="color: #0000ff;">this</span>.P_context.sprite.x -= <span style="color: #0000ff;">this</span>.P_context.sprite.x %<span style="color: #000000;"> bomberConfig.WIDTH;
            }
        },
        Public: {
            move: function () {
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite.moving) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__roundingDown();
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">this</span>.P_context.sprite.moveIndex_x += <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__judgeCompleteOneMoveByIndex();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__computeCoordinate();
            }
        },
        Abstract: {
        }
    });

    window.WalkState_X </span>=<span style="color: #000000;"> WalkState_X;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>WalkState_Y</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('256665ce-93a4-4af2-82e6-4d6ae8c67a7d')"><img id="code_img_closed_256665ce-93a4-4af2-82e6-4d6ae8c67a7d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_256665ce-93a4-4af2-82e6-4d6ae8c67a7d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('256665ce-93a4-4af2-82e6-4d6ae8c67a7d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_256665ce-93a4-4af2-82e6-4d6ae8c67a7d" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> WalkState_Y =<span style="color: #000000;"> YYC.AClass(WalkState, {
        Protected: {
        },
        Private: {
            __judgeCompleteOneMoveByIndex: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                </span><span style="color: #0000ff;">if</span> (sprite.moveIndex_y &gt;=<span style="color: #000000;"> sprite.stepY) {
                    sprite.moveIndex_y </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    sprite.moving </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    sprite.moving </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            },
            __computeCoordinate: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                sprite.y </span>= sprite.y + sprite.speedY *<span style="color: #000000;"> sprite.dirY;
            },
            __roundingDown: function () {
                </span><span style="color: #0000ff;">this</span>.P_context.sprite.y -= <span style="color: #0000ff;">this</span>.P_context.sprite.y %<span style="color: #000000;"> bomberConfig.WIDTH;
            }
        },
        Public: {
            move: function () {
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite.moving) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__roundingDown();
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">this</span>.P_context.sprite.moveIndex_y += <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__judgeCompleteOneMoveByIndex();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__computeCoordinate();
            }
        },
        Abstract: {
        }
    });

    window.WalkState_Y </span>=<span style="color: #000000;"> WalkState_Y;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>WalkLeftState</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('4b752619-920d-4d10-86c8-f2663f0f1838')"><img id="code_img_closed_4b752619-920d-4d10-86c8-f2663f0f1838" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_4b752619-920d-4d10-86c8-f2663f0f1838" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4b752619-920d-4d10-86c8-f2663f0f1838',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_4b752619-920d-4d10-86c8-f2663f0f1838" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> WalkLeftState =<span style="color: #000000;"> YYC.Class(WalkState_X, {
        Protected: {
            P__setPlayerState: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.standLeftState);
            },
            P__computeTarget: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                    x: sprite.x </span>/ window.bomberConfig.WIDTH - <span style="color: #800080;">1</span><span style="color: #000000;">,
                    y: sprite.y </span>/<span style="color: #000000;"> window.bomberConfig.HEIGHT
                };
            },
            P__checkBorder: function (target) {
                </span><span style="color: #0000ff;">if</span> (target.x &lt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            },
            P__setDir: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                sprite.dirX </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
            },
            P__stop: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                sprite.dirX </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        },
        Public: {
            walkLeft: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__checkMapAndSetDir();
            }
        }
    });

    window.WalkLeftState </span>=<span style="color: #000000;"> WalkLeftState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="color: #000000;">WalkRightState</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('8f0555c4-556d-4982-bbd3-baf75f959b1c')"><img id="code_img_closed_8f0555c4-556d-4982-bbd3-baf75f959b1c" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_8f0555c4-556d-4982-bbd3-baf75f959b1c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8f0555c4-556d-4982-bbd3-baf75f959b1c',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_8f0555c4-556d-4982-bbd3-baf75f959b1c" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> WalkRightState =<span style="color: #000000;"> YYC.Class(WalkState_X, {
        Protected: {
            P__setPlayerState: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.standRightState);
            },
            P__computeTarget: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                    x: sprite.x </span>/ window.bomberConfig.WIDTH + <span style="color: #800080;">1</span><span style="color: #000000;">,
                    y: sprite.y </span>/<span style="color: #000000;"> window.bomberConfig.HEIGHT
                };
            },
            P__checkBorder: function (target) {
                </span><span style="color: #0000ff;">if</span> (target.x &gt;= window.terrainData[<span style="color: #800080;">0</span><span style="color: #000000;">].length) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            },
            P__setDir: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                sprite.dirX </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            },
            P__stop: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                sprite.dirX </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        },
        Public: {
            walkRight: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__checkMapAndSetDir();
            }
        }
    });

    window.WalkRightState </span>=<span style="color: #000000;"> WalkRightState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="color: #000000;">WalkDownState</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('cb983ee3-083e-4584-a094-e3f841e60e73')"><img id="code_img_closed_cb983ee3-083e-4584-a094-e3f841e60e73" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_cb983ee3-083e-4584-a094-e3f841e60e73" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('cb983ee3-083e-4584-a094-e3f841e60e73',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_cb983ee3-083e-4584-a094-e3f841e60e73" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> WalkDownState =<span style="color: #000000;"> YYC.Class(WalkState_Y, {
        Protected: {
            P__setPlayerState: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.standDownState);
            },
            P__computeTarget: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                    x: sprite.x </span>/<span style="color: #000000;"> window.bomberConfig.WIDTH,
                    y: sprite.y </span>/ window.bomberConfig.HEIGHT + <span style="color: #800080;">1</span><span style="color: #000000;">
                };
            },
            P__checkBorder: function (target) {
                </span><span style="color: #0000ff;">if</span> (target.y &gt;=<span style="color: #000000;"> window.terrainData.length) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            },
            P__setDir: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                sprite.dirY </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            },
            P__stop: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                sprite.dirY </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        },
        Private: {
        },
        Public: {
            walkDown: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__checkMapAndSetDir();
            }
        }
    });

    window.WalkDownState </span>=<span style="color: #000000;"> WalkDownState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="color: #000000;">WalkUpState</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('dccf682a-ac30-44dc-909d-ab56c2a510cb')"><img id="code_img_closed_dccf682a-ac30-44dc-909d-ab56c2a510cb" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_dccf682a-ac30-44dc-909d-ab56c2a510cb" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('dccf682a-ac30-44dc-909d-ab56c2a510cb',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_dccf682a-ac30-44dc-909d-ab56c2a510cb" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> WalkUpState =<span style="color: #000000;"> YYC.Class(WalkState_Y, {
        Protected: {
            P__setPlayerState: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.standUpState);
            },
            P__computeTarget: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                    x: sprite.x </span>/<span style="color: #000000;"> window.bomberConfig.WIDTH,
                    y: sprite.y </span>/ window.bomberConfig.HEIGHT - <span style="color: #800080;">1</span><span style="color: #000000;">
                };
            },
            P__checkBorder: function (target) {
                </span><span style="color: #0000ff;">if</span> (target.y &lt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            },
            P__setDir: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                sprite.dirY </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
            },
            P__stop: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;

                sprite.dirY </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        },
        Public: {
            walkUp: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__checkMapAndSetDir();
            }
        }
    });

    window.WalkUpState </span>=<span style="color: #000000;"> WalkUpState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>StandState</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> StandState =<span style="color: #000000;"> YYC.AClass(PlayerState, {
        Protected: {
        },
        Public: {
            walkLeft: function () {
                </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkLeftState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.walkLeft();
            },
            walkRight: function () {
                </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkRightState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.walkRight();
            },
            walkUp: function () {
                </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkUpState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.walkUp();
            },
            walkDown: function () {
                </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkDownState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.walkDown();
            },
            move: function () {
            }
        },
        Abstract: {
        }
    });

    window.StandState </span>=<span style="color: #000000;"> StandState;
}());</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">StandLeftState</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> StandLeftState =<span style="color: #000000;"> YYC.Class(StandState, {
        Public: {
            stand: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                
                sprite.dirX </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                sprite.moving </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
    });

    window.StandLeftState </span>=<span style="color: #000000;"> StandLeftState;
}());</span></pre>
</div>
<p>StandRightState</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> StandRightState =<span style="color: #000000;"> YYC.Class(StandState, {
        Public: {
            stand: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                
                sprite.dirX </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                sprite.moving </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
    });

    window.StandRightState </span>=<span style="color: #000000;"> StandRightState;
}());</span></pre>
</div>
<p>StandDownState</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> StandDownState =<span style="color: #000000;"> YYC.Class(StandState, {
        Public: {
            stand: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                
                sprite.dirY </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                sprite.moving </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
    });

    window.StandDownState </span>=<span style="color: #000000;"> StandDownState;
}());</span></pre>
</div>
<p>StandUpState</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> StandUpState =<span style="color: #000000;"> YYC.Class(StandState, {
        Public: {
            stand: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                
                sprite.dirY </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                sprite.moving </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
    });

    window.StandUpState </span>=<span style="color: #000000;"> StandUpState;
}());</span></pre>
</div>
<h1>重构PlayerSprite</h1>
<h2><span style="color: #000000;">changeDir改名为setDir</span></h2>
<p><span style="color: #000000;">该方法会在游戏主循环中调用，并不会每次轮询时都改变炸弹人移动方向，因此changDir这个方法名不合理，改为setDir更为合适。</span></p>
<h2><span style="color: #000000;">删除completeOneMove</span></h2>
<p><span style="color: #000000;">现在可以不需要completeOneMove标志了，故将其删除。&nbsp;</span></p>
<p>重构后的PlayerSprite</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('59fe070a-0f33-4b50-97ac-8806f9c721b8')"><img id="code_img_closed_59fe070a-0f33-4b50-97ac-8806f9c721b8" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_59fe070a-0f33-4b50-97ac-8806f9c721b8" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('59fe070a-0f33-4b50-97ac-8806f9c721b8',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_59fe070a-0f33-4b50-97ac-8806f9c721b8" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> PlayerSprite =<span style="color: #000000;"> YYC.Class({
        Init: function (data) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">初始坐标</span>
            <span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
            </span><span style="color: #0000ff;">this</span>.y =<span style="color: #000000;"> data.y;

            </span><span style="color: #0000ff;">this</span>.speedX =<span style="color: #000000;"> data.speedX;
            </span><span style="color: #0000ff;">this</span>.speedY =<span style="color: #000000;"> data.speedY;

            </span><span style="color: #008000;">//</span><span style="color: #008000;">x/y坐标的最大值和最小值, 可用来限定移动范围.</span>
            <span style="color: #0000ff;">this</span>.minX =<span style="color: #000000;"> data.minX;
            </span><span style="color: #0000ff;">this</span>.maxX =<span style="color: #000000;"> data.maxX;
            </span><span style="color: #0000ff;">this</span>.minY =<span style="color: #000000;"> data.minY;
            </span><span style="color: #0000ff;">this</span>.maxY =<span style="color: #000000;"> data.maxY;

            </span><span style="color: #0000ff;">this</span>.defaultAnimId =<span style="color: #000000;"> data.defaultAnimId;
            </span><span style="color: #0000ff;">this</span>.anims =<span style="color: #000000;"> data.anims;

            </span><span style="color: #0000ff;">this</span>.walkSpeed =<span style="color: #000000;"> data.walkSpeed;
            </span><span style="color: #0000ff;">this</span>.speedX =<span style="color: #000000;"> data.walkSpeed;
            </span><span style="color: #0000ff;">this</span>.speedY =<span style="color: #000000;"> data.walkSpeed;

            </span><span style="color: #0000ff;">this</span>._context = <span style="color: #0000ff;">new</span> Context(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        },
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">状态模式上下文类</span>
            _context: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">更新帧动画</span>
<span style="color: #000000;">            _updateFrame: function (deltaTime) {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.update(deltaTime);
                }
            },
            _computeCoordinate: function () {
                </span><span style="color: #0000ff;">this</span>.x = <span style="color: #0000ff;">this</span>.x + <span style="color: #0000ff;">this</span>.speedX * <span style="color: #0000ff;">this</span><span style="color: #000000;">.dirX;
                </span><span style="color: #0000ff;">this</span>.y = <span style="color: #0000ff;">this</span>.y + <span style="color: #0000ff;">this</span>.speedY * <span style="color: #0000ff;">this</span><span style="color: #000000;">.dirY;

                </span><span style="color: #008000;">//</span><span style="color: #008000;">因为移动次数是向上取整，可能会造成移动次数偏多（如stepX为2.5，取整则stepX为3），
                </span><span style="color: #008000;">//</span><span style="color: #008000;">坐标可能会偏大（大于bomberConfig.WIDTH / bomberConfig.HEIGHT的整数倍），
                </span><span style="color: #008000;">//</span><span style="color: #008000;">因此此处需要向下取整。


                </span><span style="color: #008000;">//</span><span style="color: #008000;">x、y为bomberConfig.WIDTH/bomberConfig.HEIGHT的整数倍（向下取整）</span>
                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.completeOneMove) {
                    </span><span style="color: #0000ff;">this</span>.x -= <span style="color: #0000ff;">this</span>.x %<span style="color: #000000;"> bomberConfig.WIDTH;
                    </span><span style="color: #0000ff;">this</span>.y -= <span style="color: #0000ff;">this</span>.y %<span style="color: #000000;"> bomberConfig.HEIGHT;
                }
            },
            _getCurrentState: function () {
                </span><span style="color: #0000ff;">var</span> currentState = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">switch</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.standRightState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.standLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.standDownState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.standUpState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.walkDownState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.walkUpState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.walkRightState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.walkLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">未知的状态</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                };

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> currentState;
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">计算移动次数</span>
<span style="color: #000000;">            _computeStep: function () {
                </span><span style="color: #0000ff;">this</span>.stepX = Math.ceil(bomberConfig.WIDTH / <span style="color: #0000ff;">this</span><span style="color: #000000;">.speedX);
                </span><span style="color: #0000ff;">this</span>.stepY = Math.ceil(bomberConfig.HEIGHT / <span style="color: #0000ff;">this</span><span style="color: #000000;">.speedY);
            },
            _allKeyUp: function () {
                </span><span style="color: #0000ff;">return</span> window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">false</span> &amp;&amp; window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">false</span>
                    &amp;&amp; window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">false</span> &amp;&amp; window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            },
            _judgeCompleteOneMoveByIndex: function () {
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">this</span><span style="color: #000000;">.moving) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.moveIndex_x &gt;= <span style="color: #0000ff;">this</span><span style="color: #000000;">.stepX) {
                    </span><span style="color: #0000ff;">this</span>.moveIndex_x = <span style="color: #800080;">0</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">this</span>.completeOneMove = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.moveIndex_y &gt;= <span style="color: #0000ff;">this</span><span style="color: #000000;">.stepY) {
                    </span><span style="color: #0000ff;">this</span>.moveIndex_y = <span style="color: #800080;">0</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">this</span>.completeOneMove = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span>.completeOneMove = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            },
            _judgeAndSetDir: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkLeft();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkRight();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkUp();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.walkDown();
                }
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标</span>
            x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的速度</span>
            speedX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            speedY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标区间</span>
            minX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            maxX: </span><span style="color: #800080;">9999</span><span style="color: #000000;">,
            minY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            maxY: </span><span style="color: #800080;">9999</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵包含的所有 Animation 集合. Object类型, 数据存放方式为" id : animation ".</span>
            anims: <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">默认的Animation的Id , string类型</span>
            defaultAnimId: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">当前的Animation.</span>
            currentAnim: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的方向系数：
            </span><span style="color: #008000;">//</span><span style="color: #008000;">往下走dirY为正数，往上走dirY为负数；
            </span><span style="color: #008000;">//</span><span style="color: #008000;">往右走dirX为正数，往左走dirX为负数。</span>
            dirX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            dirY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">定义sprite走路速度的绝对值</span>
            walkSpeed: <span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">一次移动步长中的需要移动的次数</span>
            stepX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            stepY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">一次移动步长中已经移动的次数</span>
            moveIndex_x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            moveIndex_y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">是否正在移动标志</span>
            moving: <span style="color: #0000ff;">false</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">站立标志
            </span><span style="color: #008000;">//</span><span style="color: #008000;">用于解决调用WalkState.stand后，PlayerLayer.render中P__isChange返回false的问题
            </span><span style="color: #008000;">//</span><span style="color: #008000;">（不调用draw，从而仍会显示精灵类walk的帧（而不会刷新为更新状态后的精灵类stand的帧））。</span>
            stand: <span style="color: #0000ff;">false</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation, 参数为Animation的id, String类型</span>
<span style="color: #000000;">            setAnim: function (animId) {
                </span><span style="color: #0000ff;">this</span>.currentAnim = <span style="color: #0000ff;">this</span><span style="color: #000000;">.anims[animId];
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">重置当前帧</span>
<span style="color: #000000;">            resetCurrentFrame: function (index) {
                </span><span style="color: #0000ff;">this</span>.currentAnim &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.setCurrentFrame(index);
            },
            init: function () {
                </span><span style="color: #0000ff;">this</span>._context.setPlayerState(<span style="color: #0000ff;">this</span><span style="color: #000000;">._getCurrentState());
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._computeStep();

                </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation</span>
                <span style="color: #0000ff;">this</span>.setAnim(<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId);
            },

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新精灵当前状态</span>
<span style="color: #000000;">            update: function (deltaTime) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._updateFrame(deltaTime);
            },
            draw: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    context.drawImage(</span><span style="color: #0000ff;">this</span>.currentAnim.getImg(), frame.x, frame.y, frame.width, frame.height, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y, frame.imgWidth, frame.imgHeight);
                }
            },
            clear: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">直接清空画布区域</span>
                    context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
                }
            },
            move: function () {

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.move();
            },
            setDir: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.moving) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">._allKeyUp()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.stand();
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._judgeAndSetDir();
                }
            }
        }
    });

    window.PlayerSprite </span>=<span style="color: #000000;"> PlayerSprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><a name="model"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文最终领域模型</span></strong></p>
<p><img src="http://images.cnitblog.com/blog/419321/201311/28133227-7a7630509e554ac0b484ac07360b784d.jpg" alt="" width="719" height="387" /></p>
<p><a href="http://images.cnitblog.com/blog/419321/201311/28133227-7a7630509e554ac0b484ac07360b784d.jpg" target="_blank">查看大图</a></p>
<p><a name="layer"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">高层划分</span></strong></p>
<p>与上文相同，没有增加新的包</p>
<h1>层、包</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/21161619-00a101649dbf4b01820e56b797c3cb44.jpg" alt="" width="745" height="1121" /></p>
<h1>对应领域模型</h1>
<ul>
<li>辅助操作层
<ul>
<li>控件包<br />PreLoadImg</li>
<li>配置包<br />Config</li>


















</ul>


















</li>
<li>用户交互层
<ul>
<li>入口包<br />Main</li>


















</ul>


















</li>
<li>业务逻辑层
<ul>
<li>辅助逻辑
<ul>
<li>工厂包<br />BitmapFactory、LayerFactory、SpriteFactory</li>
<li>事件管理包<br />KeyState、KeyEventManager</li>


















</ul>


















</li>
<li>游戏主逻辑
<ul>
<li>主逻辑包<br />Game</li>


















</ul>


















</li>
<li>层管理
<ul>
<li>层管理实现包<br />PlayerLayerManager、MapLayerManager</li>
<li>层管理抽象包</li>
<li>LayerManager</li>


















</ul>


















</li>
<li>层
<ul>
<li>层实现包<br />PlayerLayer、MapLayer</li>
<li>层抽象包<br />Layer</li>
<li>集合包<br />Collection</li>


















</ul>


















</li>
<li>精灵
<ul>
<li>精灵包<br />PlayerSprite、Context、PlayerState、WalkState、StandState、WalkState_X、WalkState_Y、StandLeftState、StandRightState、StandUpState、StandDownState、WalkLeftState、WalkRightState、WalkUpState、WalkDownState</li>
<li>动画包<br />Animation、GetSpriteData、SpriteData、GetFrames、FrameData</li>


















</ul>


















</li>


















</ul>


















</li>
<li>数据操作层
<ul>
<li>地图数据操作包<br />MapDataOperate</li>
<li>路径数据操作包<br />GetPath</li>
<li>图片数据操作包<br />Bitmap</li>


















</ul>


















</li>
<li>数据层
<ul>
<li>地图包<br />MapData、TerrainData</li>
<li>图片路径包<br />ImgPathData</li>


















</ul>


















</li>


















</ul>
<p>
<a name="demo"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文参考资料</span></strong></p>
<p><a href="http://blog.csdn.net/lufy_legend/article/details/7076064">html5游戏开发-零基础开发RPG游戏-开源讲座(二)-跑起来吧英雄</a></p>
<h1>欢迎浏览上一篇博文：<a class="titlelnk" href="http://www.cnblogs.com/chaogex/p/3265119.html" target="_blank">炸弹人游戏开发系列（5）：控制炸弹人移动，引入状态模式</a></h1>
<h1>欢迎浏览下一篇博文：<a href="http://www.cnblogs.com/chaogex/p/3334223.html">炸弹人游戏开发系列（7）：加入敌人，使用A*算法寻路</a><span><br /></span></h1>]]></description></item><item><title>炸弹人游戏开发系列（5）：控制炸弹人移动，引入状态模式</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/19/3265119.html</link><dc:creator>yyc元超</dc:creator><author>yyc元超</author><pubDate>Sat, 19 Oct 2013 14:32:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/19/3265119.html</guid><description><![CDATA[<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">前言</span></strong></p>
<p>上文中我们实现了炸弹人显示和左右移动。本文开始监听键盘事件，使玩家能控制炸弹人移动。然后会在重构的过程中会引入状态模式。大家会看到我是如何在开发的过程中通过重构来提出设计模式，而不是在初步设计阶段提出设计模式的。</p>
<h1>本文目的</h1>
<p><span>实现&ldquo;使用键盘控制玩家移动&rdquo;</span></p>
<p>完善炸弹人移动，增加上下方向的移动</p>
<h1>本文主要内容</h1>
<ul>
<li><a href="#strategy">开发策略</a></li>
<li><a href="#optimize">性能优化</a></li>
<li><a href="#control">控制炸弹人移动</a></li>
<li><a href="#state">引入状态模式</a></li>
<li><a href="#refactor">重构PlayerSprite</a></li>
<li><a href="#add">增加炸弹人上下方向的移动</a></li>
<li><a href="#question">解决问题</a></li>
<li><a href="#model">本文最终领域模型</a></li>
<li><a href="#layer">高层划分</a></li>
<li><a href="#demo">演示</a></li>
<li><a href="#reference">本文参考资料</a></li>
</ul>
<h1>回顾上文更新后的领域模型</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/19221016-d70d93b0bc31465ab60d63f73e25748a.jpg" alt="" width="785" height="428" /></p>
<p><a name="strategy"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;"><a id="strategy"></a><a id="strategy"></a>开发策略</span></strong></p>
<p><span>首先进行性能优化，使用双缓冲技术显示地图。接着考虑到&ldquo;增加上下移动&rdquo;的功能与上文实现的&ldquo;左右移动&rdquo;功能类似，实现起来没有难度，因此优先实现&ldquo;使用键盘控制玩家移动&rdquo;，再实现&ldquo;增加上下移动&rdquo;。</span></p>
<p><a name="optimize"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">性能优化</span></strong></p>
<h1>双缓冲</h1>
<h2>什么是双缓冲</h2>
<div class="para">当数据量很大时，绘图可能需要几秒钟甚至更长的时间，而且有时还会出现闪烁现象，为了解决这些问题，可采用双缓冲技术来绘图。</div>
<div class="para">双缓冲即在内存中创建一个与屏幕绘图区域一致的对象，先将图形绘制到内存中的这个对象上，再一次性将这个对象上的图形拷贝到屏幕上，这样能大大加快绘图的速度。双缓冲实现过程如下：</div>
<div class="para">1、在内存中创建与画布一致的缓冲区</div>
<div class="para">2、在缓冲区画图</div>
<div class="para">3、将缓冲区位图拷贝到当前画布上</div>
<div class="para">4、释放内存缓冲区</div>
<h2>为什么要用双缓冲</h2>
<p>因为显示地图是这样显示的：假设地图大小为40*40，每个单元格是一个bitmap，则有40*40个bitmap。使用canvas的drawImage绘制每个bitmap，则要绘制40*40次才能绘制完一张完整的地图，开销很大。</p>
<p>那么应该如何优化呢？</p>
<ul>
<li>每次只绘制地图中变化的部分。</li>
<li>当变化的范围也很大时（涉及到多个bitmap），则可用双缓冲，减小页面抖动的现象。</li>
</ul>
<p>因此，使用&ldquo;分层渲染&rdquo;可以实现第1个优化，而使用&ldquo;双缓冲&rdquo;则可实现第2个优化。</p>
<h2>实现</h2>
<p>在MapLayer中创建一个缓冲画布，在绘制地图时先在缓冲画布上绘制，绘制完成后再将缓冲画布拷贝到地图画布中。</p>
<p>MapLayer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> MapLayer =<span style="color: #000000;"> YYC.Class(Layer, {
        Init: function () {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">*双缓冲

            </span><span style="color: #008000;">//</span><span style="color: #008000;">创建缓冲canvas</span>
            <span style="color: #0000ff;">this</span><span style="color: #000000;">.___createCanvasBuffer();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">获得缓冲context</span>
            <span style="color: #0000ff;">this</span><span style="color: #000000;">.___getContextBuffer();
        },
        Private: {
            ___canvasBuffer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            ___contextBuffer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            ___createCanvasBuffer: function () {
                </span><span style="color: #0000ff;">this</span>.___canvasBuffer = $(<span style="color: #800000;">"</span><span style="color: #800000;">&lt;canvas/&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">, {
                    width: bomberConfig.canvas.WIDTH.toString(),
                    height: bomberConfig.canvas.HEIGHT.toString()
                })[</span><span style="color: #800080;">0</span><span style="color: #000000;">];
            },
            ___getContextBuffer: function () {
                </span><span style="color: #0000ff;">this</span>.___contextBuffer = <span style="color: #0000ff;">this</span>.___canvasBuffer.getContext(<span style="color: #800000;">"</span><span style="color: #800000;">2d</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            },
            ___drawBuffer: function (img) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___contextBuffer.drawImage(img.img, img.x, img.y, img.width, img.height);
            }
        },
        Protected: {
            P__createCanvas: function () {
                </span><span style="color: #0000ff;">var</span> canvas = $(<span style="color: #800000;">"</span><span style="color: #800000;">&lt;canvas/&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">, {
                    width: bomberConfig.canvas.WIDTH.toString(),
                    height: bomberConfig.canvas.HEIGHT.toString(),
                    css: {
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">border</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">1px solid blue</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">0</span><span style="color: #000000;">
                    }
                });
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">body</span><span style="color: #800000;">"</span><span style="color: #000000;">).append(canvas);

                </span><span style="color: #0000ff;">this</span>.P__canvas = canvas[<span style="color: #800080;">0</span><span style="color: #000000;">];
            }
        },
        Public: {
            draw: function () {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    imgs </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                imgs </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.getChilds();

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = imgs.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___drawBuffer(imgs[i]);
                }
                </span><span style="color: #0000ff;">this</span>.P__context.drawImage(<span style="color: #0000ff;">this</span>.___canvasBuffer, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
            },
            clear: function () {
                </span><span style="color: #0000ff;">this</span>.___contextBuffer.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
                </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
            },
            render: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__isChange()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.clear();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.draw();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__setStateNormal();
                }
            }
        }
    });

    window.MapLayer </span>=<span style="color: #000000;"> MapLayer;
}());</span></pre>
</div>
<p><a name="control"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">控制炸弹人移动</span></strong></p>
<p>现在，让我们来实现&ldquo;使用键盘控制炸弹人家移动&rdquo; 。</p>
<h1>分离出KeyEventManager类</h1>
<p>因为玩家是通过键盘事件来控制炸弹人的，所以考虑提出一个专门处理事件的KeyEventManager类，它负责键盘事件的绑定与移除。</p>
<h1>提出按键枚举值</h1>
<p>因为控制炸弹人移动的方向键可以为W、S、A、D，也可以为上、下、左、右方向键。也就是说，具体的方向键可能根据个人喜好变化，可以提供几套方向键方案，让玩家自己选择。</p>
<p>为了实现上述需求，需要使用枚举值KeyCodeMap来代替具体的方向键。这样有以下好处：</p>
<ul>
<li>使用抽象隔离具体变化。当具体的方向键变化时，只要改变枚举值对应的value即可，而枚举值不会变化</li>
<li>增加可读性。枚举值如Up一看就知道表示向上走，而87（W键的keycode）则看不出来是什么意思。</li>
</ul>
<h2>增加keystate</h2>
<p>如果在KeyEventManager绑定的键盘事件中直接操作PlayerSprite：</p>
<ul>
<li>耦合太重。PlayerSprite变化时也会影响到KeyEventManager</li>
<li>不够灵活。如果以后增加多个玩家的需求，那么就需要修改KeyEventManager，使其直接操作多个玩家精灵类，这样耦合会更中，第一点的情况也会更严重。</li>
</ul>
<p>因此，我增加按键状态keyState。这是一个空类，用于存储当前的按键状态。</p>
<p>当触发键盘事件时，KeyEventManager类改变keyState。然后在需要处理炸弹人移动的地方（如PlayerSprite），判断keyState，就可以知道当前按下的是哪个键，进而控制炸弹人进行相应方向的移动。</p>
<h2>领域模型</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201308/20063625-a52b8fcfa79f4275ac23ca89c5b80d8c.jpg" alt="" /></p>
<h2>相关代码</h2>
<p>KeyCodeMap</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> keyCodeMap =<span style="color: #000000;"> {
    Left: </span><span style="color: #800080;">65</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> A键</span>
    Right: <span style="color: #800080;">68</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> D键</span>
    Down: <span style="color: #800080;">83</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> S键</span>
    Up: <span style="color: #800080;">87</span> <span style="color: #008000;">//</span><span style="color: #008000;"> W键</span>
};</pre>
</div>
<p>KeyEventManager、KeyState</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">枚举值</span>
    <span style="color: #0000ff;">var</span> keyCodeMap =<span style="color: #000000;"> {
        Left: </span><span style="color: #800080;">65</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> A键</span>
        Right: <span style="color: #800080;">68</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> D键</span>
        Down: <span style="color: #800080;">83</span>, <span style="color: #008000;">//</span><span style="color: #008000;"> S键</span>
        Up: <span style="color: #800080;">87</span> <span style="color: #008000;">//</span><span style="color: #008000;"> W键</span>
<span style="color: #000000;">    };
    </span><span style="color: #008000;">//</span><span style="color: #008000;">按键状态</span>
    <span style="color: #0000ff;">var</span> keyState =<span style="color: #000000;"> {};


    </span><span style="color: #0000ff;">var</span> KeyEventManager =<span style="color: #000000;"> YYC.Class({
        Private: {
            _keyDown: function () { },
            _keyUp: function () { },
            _clearKeyState: function () {
                window.keyState </span>=<span style="color: #000000;"> {};
            }
        },
        Public: {
            addKeyDown: function () {
                </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span>._keyDown = YYC.Tool.<span style="color: #0000ff;">event</span>.bindEvent(<span style="color: #0000ff;">this</span><span style="color: #000000;">, function (e) {
                    self._clearKeyState();

                    window.keyState[e.keyCode] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                });

                YYC.Tool.</span><span style="color: #0000ff;">event</span>.addEvent(document, <span style="color: #800000;">"</span><span style="color: #800000;">keydown</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">._keyDown);
            },
            removeKeyDown: function(){
                YYC.Tool.</span><span style="color: #0000ff;">event</span>.removeEvent(document, <span style="color: #800000;">"</span><span style="color: #800000;">keydown</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">._keyDown);
            },
            addKeyUp: function () {
                </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span>._keyUp = YYC.Tool.<span style="color: #0000ff;">event</span>.bindEvent(<span style="color: #0000ff;">this</span><span style="color: #000000;">, function (e) {
                    self._clearKeyState();

                    window.keyState[e.keyCode] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                });

                YYC.Tool.</span><span style="color: #0000ff;">event</span>.addEvent(document, <span style="color: #800000;">"</span><span style="color: #800000;">keyup</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">._keyUp);
            },
            removeKeyUp: function () {
                YYC.Tool.</span><span style="color: #0000ff;">event</span>.removeEvent(document, <span style="color: #800000;">"</span><span style="color: #800000;">keyup</span><span style="color: #800000;">"</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">._keyUp);
            },
        }
    });

    window.keyCodeMap </span>=<span style="color: #000000;"> keyCodeMap;
    window.keyState </span>=<span style="color: #000000;"> keyState;
    window.keyEventManager </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> KeyEventManager();
}());</span></pre>
</div>
<p>PlayerSprite</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">            handleNext: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.speedX = -<span style="color: #0000ff;">this</span><span style="color: #000000;">.speedX;
                    </span><span style="color: #0000ff;">this</span>.setAnim(<span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.speedX = <span style="color: #0000ff;">this</span><span style="color: #000000;">.speedX;
                    </span><span style="color: #0000ff;">this</span>.setAnim(<span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">this</span>.speedX = <span style="color: #800080;">0</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">this</span>.setAnim(<span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            }</span></pre>
</div>
<p>在游戏初始化时绑定事件：</p>
<p>Game</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        _initEvent: function () {</span>
<span style="color: #000000;">            keyEventManager.addKeyDown();
            keyEventManager.addKeyUp();
        }
        ...
        init: function () {
            ...
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._initEvent();
        },</span></pre>
</div>
<p><a name="state"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">引入状态模式</span></strong></p>
<h1>发现&ldquo;炸弹人移动&rdquo;中，存在不同状态，且状态可以转换的现象</h1>
<p><span>在上一篇博文中，我实现了显示和移动炸弹人，炸弹人可以在画布上左右走动。</span></p>
<p>我发现在游戏中，炸弹人是处于不同的状态的：站立、走动。又可以将状态具体为：左站、右站、左走、右走。</p>
<p>炸弹人处于不同状态时，它的行为是不一样的（如处于左走状态时，炸弹人移动方向为向左；处于右走状态时，炸弹人移动方向为向右），且不同状态之间可以转换。</p>
<h2>状态图</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201309/17122154-169cdcaf158345aaa9c8e183cc673292.jpg" alt="" width="502" height="267" /></p>
<p>根据上面的分析，让我萌生了可以使用状态模式的想法。 状态模式介绍详见<strong><span style="font-size: 16px;"><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3342166.html">Javascript设计模式之我见：状态模式</a></span></strong>。</p>
<h1>为什么在此处用状态模式</h1>
<p>其实此处炸弹人的状态数并不多，且每个状态的逻辑也不复杂，完全可以直接在PlayerState中使用if else来实现状态的逻辑和状态切换。</p>
<p>那为什么我要用状态模式了？</p>
<p>1、做这个游戏是为了学习，状态模式我之前没有实际应用过，因此可以在此处练手</p>
<p>2、此处也符合状态模式的应用场景：一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为</p>
<p>3、扩展方便。目前实现了炸弹人左右移动，后面还会实现炸弹人上下移动。如果用状态模式的话，只需要增加四个状态：上走、上站、下走、下站，再对应修改Context和客户端即可。</p>
<h1>应用状态模式的领域模型</h1>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/419321/201310/13194800-67f1d43054d54eb1ad5f0c8798cd7630.jpg" alt="" /></p>
<h1>状态模式具体实现&nbsp;</h1>
<p>因为有右走、右站、左走、左站四个状态类，因此就要创建4个具体状态类，分别对应这四个状态类。&nbsp;</p>
<p><span>PlayerSprite</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('95a9c759-16cc-411c-9808-67ee4abe588d')"><img id="code_img_closed_95a9c759-16cc-411c-9808-67ee4abe588d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_95a9c759-16cc-411c-9808-67ee4abe588d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('95a9c759-16cc-411c-9808-67ee4abe588d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_95a9c759-16cc-411c-9808-67ee4abe588d" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> PlayerSprite =<span style="color: #000000;"> YYC.Class(Sprite, {
        Init: function (data) {
            </span><span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
            </span><span style="color: #0000ff;">this</span>.speedX =<span style="color: #000000;"> data.speedX;
            </span><span style="color: #0000ff;">this</span>.walkSpeed =<span style="color: #000000;"> data.walkSpeed;
            </span><span style="color: #0000ff;">this</span>.minX =<span style="color: #000000;"> data.minX;
            </span><span style="color: #0000ff;">this</span>.maxX =<span style="color: #000000;"> data.maxX;
            </span><span style="color: #0000ff;">this</span>.defaultAnimId =<span style="color: #000000;"> data.defaultAnimId;
            </span><span style="color: #0000ff;">this</span>.anims =<span style="color: #000000;"> data.anims;

            </span><span style="color: #0000ff;">this</span>.setAnim(<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId);

            </span><span style="color: #0000ff;">this</span>.__context = <span style="color: #0000ff;">new</span> Context(<span style="color: #0000ff;">this</span><span style="color: #000000;">);

            </span><span style="color: #0000ff;">this</span>.__context.setPlayerState(<span style="color: #0000ff;">this</span><span style="color: #000000;">.__getCurrentState());
        },
        Private: {
            __context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            _getCurrentState: function () {
                </span><span style="color: #0000ff;">var</span> currentState = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">switch</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.standRightState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.standLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.walkRightState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">:
                        currentState </span>=<span style="color: #000000;"> Context.walkLeftState;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">未知的状态</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的速度</span>
            speedX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            speedY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">定义sprite走路速度的绝对值</span>
            walkSpeed: <span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新精灵当前状态</span>
<span style="color: #000000;">            update: function (deltaTime) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">每次循环,改变一下绘制的坐标</span>
                <span style="color: #0000ff;">this</span><span style="color: #000000;">.__setCoordinate(deltaTime);

                </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">(deltaTime);
            },
            draw: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    context.drawImage(</span><span style="color: #0000ff;">this</span>.currentAnim.getImg(), frame.x, frame.y, frame.width, frame.height, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y, frame.imgWidth, frame.imgHeight);
                }
            },
            clear: function (context) {
                </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    frame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">要加上图片的宽度/高度</span>
                    context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #0000ff;">this</span>.maxX + frame.imgWidth, <span style="color: #0000ff;">this</span>.maxY +<span style="color: #000000;"> frame.imgHeight);
                }
            },
            handleNext: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkLeft();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.walkRight();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__context.stand();
            }
        }
    });

    window.PlayerSprite </span>=<span style="color: #000000;"> PlayerSprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="line-height: 1.5;">Context</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('13429c9e-9e7b-4826-98ae-50d258ca327c')"><img id="code_img_closed_13429c9e-9e7b-4826-98ae-50d258ca327c" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_13429c9e-9e7b-4826-98ae-50d258ca327c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('13429c9e-9e7b-4826-98ae-50d258ca327c',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_13429c9e-9e7b-4826-98ae-50d258ca327c" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Context =<span style="color: #000000;"> YYC.Class({
        Init: function (sprite) {
            </span><span style="color: #0000ff;">this</span>.sprite =<span style="color: #000000;"> sprite;
        },
        Private: {
            _state: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">
        },
        Public: {
            sprite: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            setPlayerState: function (state) {
                </span><span style="color: #0000ff;">this</span>._state =<span style="color: #000000;"> state;
                </span><span style="color: #008000;">//</span><span style="color: #008000;">把当前的上下文通知到当前状态类对象中</span>
                <span style="color: #0000ff;">this</span>._state.setContext(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
            },
            walkLeft: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.walkLeft();
            },
            walkRight: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.walkRight();
            },
            stand: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.stand();
            }
        },
        Static: {
            walkLeftState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkLeftState(),
            walkRightState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkRightState(),
            standLeftState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> StandLeftState(),
            standRightState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> StandRightState()
        }
    });

    window.Context </span>=<span style="color: #000000;"> Context;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>PlayerState</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('6df2e07e-0cae-460e-bf8c-ba0070f36b49')"><img id="code_img_closed_6df2e07e-0cae-460e-bf8c-ba0070f36b49" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_6df2e07e-0cae-460e-bf8c-ba0070f36b49" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6df2e07e-0cae-460e-bf8c-ba0070f36b49',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_6df2e07e-0cae-460e-bf8c-ba0070f36b49" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> PlayerState =<span style="color: #000000;"> YYC.AClass({
        Protected: {
            P_context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">
        },
        Public: {
            setContext: function (context) {
                </span><span style="color: #0000ff;">this</span>.P_context =<span style="color: #000000;"> context;
            }
        },
        Abstract: {
            stand: function () { },
            walkLeft: function () { },
            walkRight: function () { }
        }
    });

    window.PlayerState </span>=<span style="color: #000000;"> PlayerState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>WalkLeftState</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('63bc7772-5332-4d84-841b-663c9921a702')"><img id="code_img_closed_63bc7772-5332-4d84-841b-663c9921a702" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_63bc7772-5332-4d84-841b-663c9921a702" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('63bc7772-5332-4d84-841b-663c9921a702',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_63bc7772-5332-4d84-841b-663c9921a702" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> WalkLeftState =<span style="color: #000000;"> YYC.Class(PlayerState, {
        Public: {
            stand: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">false</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.standLeftState);
                }
            },
            walkLeft: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    sprite </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                    sprite.speedX </span>= -<span style="color: #000000;">sprite.walkSpeed;
                    sprite.speedY </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            },
            walkRight: function () {
            }
        }
    });

    window.WalkLeftState </span>=<span style="color: #000000;"> WalkLeftState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>StandLeftState</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('452f7b13-797c-4299-bfc4-814add6885f7')"><img id="code_img_closed_452f7b13-797c-4299-bfc4-814add6885f7" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_452f7b13-797c-4299-bfc4-814add6885f7" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('452f7b13-797c-4299-bfc4-814add6885f7',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_452f7b13-797c-4299-bfc4-814add6885f7" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> StandLeftState =<span style="color: #000000;"> YYC.Class(PlayerState, {
        Public: {
            stand: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">false</span><span style="color: #000000;">) {
                    sprite </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                    sprite.speedX </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">stand_left</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            },
            walkLeft: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkLeftState);
                }
            },
            walkRight: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkRightState);
                }
            }
        }
    });

    window.StandLeftState </span>=<span style="color: #000000;"> StandLeftState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="font-size: 14px; line-height: 1.5;">WalkRightState</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('97acb371-286a-405f-a7cd-4c6adc9ecb8a')"><img id="code_img_closed_97acb371-286a-405f-a7cd-4c6adc9ecb8a" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_97acb371-286a-405f-a7cd-4c6adc9ecb8a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('97acb371-286a-405f-a7cd-4c6adc9ecb8a',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_97acb371-286a-405f-a7cd-4c6adc9ecb8a" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> WalkRightState =<span style="color: #000000;"> YYC.Class(PlayerState, {
        Public: {
            stand: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">false</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.standRightState);
                }
            },
            walkLeft: function () {
            },
            walkRight: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    sprite </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                    sprite.speedX </span>=<span style="color: #000000;"> sprite.walkSpeed;
                    sprite.speedY </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            }
        }
    });

    window.WalkRightState </span>=<span style="color: #000000;"> WalkRightState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>StandRightState</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('6fbd79ec-b067-4c28-b5c8-763059541b2a')"><img id="code_img_closed_6fbd79ec-b067-4c28-b5c8-763059541b2a" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_6fbd79ec-b067-4c28-b5c8-763059541b2a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6fbd79ec-b067-4c28-b5c8-763059541b2a',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_6fbd79ec-b067-4c28-b5c8-763059541b2a" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> StandRightState =<span style="color: #000000;"> YYC.Class(PlayerState, {
        Public: {
            stand: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">false</span><span style="color: #000000;">) {
                    sprite </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                    sprite.speedX </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            },
            walkLeft: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkLeftState);
                }
            },
            walkRight: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkRightState);
                }
            }
        }
    });

    window.StandRightState </span>=<span style="color: #000000;"> StandRightState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><a name="refactor"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">重构PlayerSprite</span></strong></p>
<p><span style="color: #000000;">PlayerSprite重构前相关代码</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        Init: function (data) {
            </span><span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
            </span><span style="color: #0000ff;">this</span>.speedX =<span style="color: #000000;"> data.speedX;
            </span><span style="color: #0000ff;">this</span>.walkSpeed =<span style="color: #000000;"> data.walkSpeed;
            </span><span style="color: #0000ff;">this</span>.minX =<span style="color: #000000;"> data.minX;
            </span><span style="color: #0000ff;">this</span>.maxX =<span style="color: #000000;"> data.maxX;
            </span><span style="color: #0000ff;">this</span>.defaultAnimId =<span style="color: #000000;"> data.defaultAnimId;
            </span><span style="color: #0000ff;">this</span>.anims =<span style="color: #000000;"> data.anims;<br />
            </span><span style="color: #0000ff;">this</span>.setAnim(<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId);

            </span><span style="color: #0000ff;">this</span>.__context = <span style="color: #0000ff;">new</span> Context(<span style="color: #0000ff;">this</span><span style="color: #000000;">);<br />
            </span><span style="color: #0000ff;">this</span>.__context.setPlayerState(<span style="color: #0000ff;">this</span><span style="color: #000000;">.__getCurrentState());
        },</span></pre>
</div>
<h1><span style="line-height: 1.5;">从构造函数中分离出init</span></h1>
<p>现在构造函数Init看起来有4个职责：</p>
<ul>
<li>读取参数</li>
<li>设置默认动画</li>
<li>创建Context实例，且因为状态类需要获得PlayerSprite类的成员，因此在创建Context实例时，将PlayerSprite的实例注入到Context中。</li>
<li>设置当前默认状态。</li>
</ul>
<p>在测试PlayerSprite时，发现难以测试。这是因为构造函数职责太多，造成了互相的干扰。</p>
<p>从较高的层面来看，现在构造函数做了两件事：</p>
<ul>
<li>读取参数</li>
<li>初始化</li>
</ul>
<p>因此，我将&ldquo;初始化&rdquo;提出来，形成init方法。</p>
<h1>构造函数保留&ldquo;创建Context实例&rdquo;职责</h1>
<p>这里比较难决定的是&ldquo;创建Context实例&rdquo;这个职责应该放到哪里。</p>
<p>考虑到PlayerSprite与Context属于组合关系，Context只属于PlayerSprite，它应该在创建PlayerSprite时而创建。因此，将&ldquo;创建Context实例&rdquo;保留在PlayerSprite的构造函数中。</p>
<h1>重构后的PlayerSprite</h1>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Init: function (data) {
    </span><span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
    </span><span style="color: #0000ff;">this</span>.speedX =<span style="color: #000000;"> data.speedX;
    </span><span style="color: #0000ff;">this</span>.walkSpeed =<span style="color: #000000;"> data.walkSpeed;
    </span><span style="color: #0000ff;">this</span>.minX =<span style="color: #000000;"> data.minX;
    </span><span style="color: #0000ff;">this</span>.maxX =<span style="color: #000000;"> data.maxX;
    </span><span style="color: #0000ff;">this</span>.defaultAnimId =<span style="color: #000000;"> data.defaultAnimId;
    </span><span style="color: #0000ff;">this</span>.anims =<span style="color: #000000;"> data.anims;

    </span><span style="color: #0000ff;">this</span>._context = <span style="color: #0000ff;">new</span> Context(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
},
...
    init: function () {
        </span><span style="color: #0000ff;">this</span>._context.setPlayerState(<span style="color: #0000ff;">this</span><span style="color: #000000;">._getCurrentState());

        </span><span style="color: #0000ff;">this</span>.setAnim(<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId);
    },
... </span></pre>
</div>
<p><a name="add"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">增加炸弹人上下方向的移动</span></strong></p>
<h1>增加状态类</h1>
<p>增加WalkUpState、WalkDownState、StandUpState、StandDownState类，并对应修改Context即可。</p>
<h1>关于&ldquo;为什么要有四个方向的Stand状态类&rdquo;的思考</h1>
<p>看到这里，有朋友可能会说，为什么用这么多的Stand状态类，直接用一个StandState类岂不是更简洁？</p>
<p>原因在于，上站、下站、左站、右站的行为是不一样的，这具体体现在显示的动画不一样（炸弹人站立的方向不一样）。</p>
<h1>领域模型</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/19214958-99ec84978efb49cfbd764a68de6b88f2.jpg" alt="" width="697" height="127" /></p>
<h1>相关代码</h1>
<p>WalkUpState</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('92e25170-bcaf-4aef-8dc7-829156aeb765')"><img id="code_img_closed_92e25170-bcaf-4aef-8dc7-829156aeb765" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_92e25170-bcaf-4aef-8dc7-829156aeb765" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('92e25170-bcaf-4aef-8dc7-829156aeb765',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_92e25170-bcaf-4aef-8dc7-829156aeb765" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> WalkUpState =<span style="color: #000000;"> YYC.Class(PlayerState, {
        Public: {
            stand: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">false</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.standUpState);
                }
            },
            walkLeft: function () {
            },
            walkRight: function () {
            },
            walkUp: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    sprite </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                    sprite.speedX </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    sprite.speedY </span>= -<span style="color: #000000;">sprite.walkSpeed;
                    sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">walk_up</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            },
            walkDown: function () {
            }
        }
    });

    window.WalkUpState </span>=<span style="color: #000000;"> WalkUpState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>WalkDownState</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('98389658-df61-4e05-891f-fcfc912d4249')"><img id="code_img_closed_98389658-df61-4e05-891f-fcfc912d4249" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_98389658-df61-4e05-891f-fcfc912d4249" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('98389658-df61-4e05-891f-fcfc912d4249',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_98389658-df61-4e05-891f-fcfc912d4249" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> WalkDownState =<span style="color: #000000;"> YYC.Class(PlayerState, {
        Public: {
            stand: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">false</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.standDownState);
                }
            },
            walkLeft: function () {
            },
            walkRight: function () {
            },
            walkUp: function () {
            },
            walkDown: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    sprite </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                    sprite.speedX </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    sprite.speedY </span>=<span style="color: #000000;"> sprite.walkSpeed;
                    sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">walk_down</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            }
        }
    });

    window.WalkDownState </span>=<span style="color: #000000;"> WalkDownState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>StandUpState</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('088da823-9f6c-4748-94d9-4eb1e121e62f')"><img id="code_img_closed_088da823-9f6c-4748-94d9-4eb1e121e62f" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_088da823-9f6c-4748-94d9-4eb1e121e62f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('088da823-9f6c-4748-94d9-4eb1e121e62f',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_088da823-9f6c-4748-94d9-4eb1e121e62f" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> StandUpState =<span style="color: #000000;"> YYC.Class(PlayerState, {
        Public: {
            stand: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">false</span><span style="color: #000000;">) {
                    sprite </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                    
                    sprite.speedY </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">stand_up</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            },
            walkLeft: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkLeftState);
                }
            },
            walkRight: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkRightState);
                }
            },
            walkUp: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkUpState);
                }
            },
            walkDown: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkDownState);
                }
            }
        }
    });

    window.StandUpState </span>=<span style="color: #000000;"> StandUpState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>StandDownState</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('636e3639-3d74-4561-bf77-8e2bfdaf40e7')"><img id="code_img_closed_636e3639-3d74-4561-bf77-8e2bfdaf40e7" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_636e3639-3d74-4561-bf77-8e2bfdaf40e7" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('636e3639-3d74-4561-bf77-8e2bfdaf40e7',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_636e3639-3d74-4561-bf77-8e2bfdaf40e7" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> StandDownState =<span style="color: #000000;"> YYC.Class(PlayerState, {
        Public: {
            stand: function () {
                </span><span style="color: #0000ff;">var</span> sprite = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">false</span><span style="color: #000000;">) {
                    sprite </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.sprite;
                    sprite.speedY </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    sprite.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">stand_down</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            },
            walkLeft: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.A] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkLeftState);
                }
            },
            walkRight: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.D] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkRightState);
                }
            },
            walkUp: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.W] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkUpState);
                }
            },
            walkDown: function () {
                </span><span style="color: #0000ff;">if</span> (window.keyState[keyCodeMap.S] === <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_context.sprite.resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setPlayerState(Context.walkDownState);
                }
            }
        }
    });

    window.StandDownState </span>=<span style="color: #000000;"> StandDownState;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>Context</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">            walkUp: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.walkUp();
            },
            walkDown: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.walkDown();
            },
...
        Static: {
            walkUpState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkUpState(),
            walkDownState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> WalkDownState(),
...
            standUpState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> StandUpState(),
            standDownState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> StandDownState()
        }</span></pre>
</div>
<p><a name="question"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">解决问题</span></strong></p>
<h1>解决&ldquo;<span>drawImage中的dx、dy和clearRect中的x、y按比例缩放</span>&rdquo;</h1>
<p>现在我需要解决在<strong><span style="font-size: 16px;"><a href="http://www.cnblogs.com/chaogex/p/3175811.html#question">第3篇博文中提到的问题</a></span></strong>。</p>
<h2>问题描述</h2>
<p>如果把PlayerSprite.js -&gt; draw -&gt; drawImage：</p>
<div class="cnblogs_code">
<pre>context.drawImage(<span>this</span>.currentAnim.getImg(), frame.x, frame.y, frame.width, frame.height, <span>this</span>.x, <span>this</span>.y, frame.imgWidth, frame.imgHeight);</pre>
</div>
<p>中的this.x、this.y设定成260、120：</p>
<div class="cnblogs_code">
<pre>context.drawImage(<span>this</span>.currentAnim.getImg(), frame.x, frame.y, frame.width, frame.height, <span>260</span>, <span>120</span>, frame.imgWidth, frame.imgHeight);</pre>
</div>
<p>则不管画布canvas的width、height如何设置，玩家人物都固定在画布的右下角！！！</p>
<p>照理说，坐标应该为一个固定值，不应该随画布的变化而变化。即如果canvas.width = 300, drawImage的dx=300，则图片应该在画布右侧边界处；如果canvas.width 变为600，则图片应该在画布中间！而不应该还在画布右侧边界处！</p>
<h2>问题分析</h2>
<p>这是因为我在PlayerLayer的创建canvas时，使用了css设置画布的大小，因此导致了画布按比例缩放的问题。</p>
<p>PlayerLayer</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">P__createCanvas: function () {
    </span><span style="color: #0000ff;">var</span> canvas = $(<span style="color: #800000;">"</span><span style="color: #800000;">&lt;canvas/&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">, {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">id: id,</span>
<span style="color: #000000;">        width: bomberConfig.canvas.WIDTH.toString(),
        height: bomberConfig.canvas.HEIGHT.toString(),
        css: {
            </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
            </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
            </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,
            </span><span style="color: #800000;">"</span><span style="color: #800000;">border</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">1px solid red</span><span style="color: #800000;">"</span><span style="color: #000000;">,
            </span><span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">1</span><span style="color: #000000;">
        }
    });
    $(</span><span style="color: #800000;">"</span><span style="color: #800000;">body</span><span style="color: #800000;">"</span><span style="color: #000000;">).append(canvas);

    </span><span style="color: #0000ff;">this</span>.P__canvas = canvas[<span style="color: #800080;">0</span><span style="color: #000000;">];
}</span></pre>
</div>
<p><span style="font-size: 16px;"><strong>详见<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3377692.html">关于使用Css设置Canvas画布大小的问题</a>。</strong></span></p>
<h2>解决方案</h2>
<p>通过HTML创建canvas，并在Html中设置它的width和height：</p>
<div class="cnblogs_code">
<pre>&lt;canvas width=<span>"</span><span>500</span><span>"</span> height=<span>"</span><span>500</span><span>"</span>&gt;
&lt;/canvas&gt;</pre>
</div>
<p><a name="model"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文最终领域模型</span></strong></p>
<p><img src="http://images.cnitblog.com/blog/419321/201310/19220051-46abb82cbc594be78ce4b56f75ba6c16.jpg" alt="" width="824" height="373" /></p>
<p><a href="http://images.cnitblog.com/blog/419321/201310/19220051-46abb82cbc594be78ce4b56f75ba6c16.jpg" target="_blank">查看大图</a></p>
<p><a name="layer"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">高层划分</span></strong></p>
<h1><span style="line-height: 1.5;">新增包</span></h1>
<ul>
<li>事件管理包<br />KeyState、KeyEventManager</li>





























</ul>
<h1>分析</h1>
<h2>状态类应该放到哪个包？</h2>
<p>状态类与玩家精灵类PlayerSprite互相依赖且共同重用，因此应该都放到&ldquo;精灵&rdquo;这个包中。</p>
<h1><span style="color: #ff0000;"><span style="color: #000000;">本文层、包</span></span></h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/24093353-e8f1af961d054ebe8762d249b969b891.jpg" alt="" width="791" height="1190" /></p>
<h1>对应领域模型</h1>
<ul>
<li>辅助操作层
<ul>
<li>控件包<br />PreLoadImg</li>
<li>配置包<br />Config</li>






























</ul>






























</li>
<li>用户交互层
<ul>
<li>入口包<br />Main</li>






























</ul>






























</li>
<li>业务逻辑层
<ul>
<li>辅助逻辑
<ul>
<li>工厂包<br />BitmapFactory、LayerFactory、SpriteFactory</li>
<li>事件管理包<br />KeyState、KeyEventManager</li>






























</ul>






























</li>
<li>游戏主逻辑
<ul>
<li>主逻辑包<br />Game</li>






























</ul>






























</li>
<li>层管理
<ul>
<li>层管理实现包<br />PlayerLayerManager、MapLayerManager</li>
<li>层管理抽象包</li>
<li>LayerManager</li>






























</ul>






























</li>
<li>层
<ul>
<li>层实现包<br />PlayerLayer、MapLayer</li>
<li>层抽象包<br />Layer</li>
<li>集合包<br />Collection</li>






























</ul>






























</li>
<li>精灵
<ul>
<li>精灵包<br />PlayerSprite、Context、PlayerState、WalkLeftState、WalkRightState、WalkUpState、WalkDownState、StandLeftState、StandRightState、StandUpState、StandDownState</li>
<li>动画包<br />Animation、GetSpriteData、SpriteData、GetFrames、FrameData</li>






























</ul>






























</li>






























</ul>






























</li>
<li>数据操作层
<ul>
<li>地图数据操作包<br />MapDataOperate</li>
<li>路径数据操作包<br />GetPath</li>
<li>图片数据操作包<br />Bitmap</li>






























</ul>






























</li>
<li>数据层
<ul>
<li>地图包<br />MapData</li>
<li>图片路径包<br />ImgPathData</li>






























</ul>






























</li>






























</ul>
<p>
<a name="demo"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文参考资料</span></strong></p>
<p><a href="http://pan.baidu.com/s/1y0dbk">HTML5超级玛丽小游戏源代码</a></p>
<p><a href="http://www.iteye.com/topic/1122395">完全分享，共同进步&mdash;&mdash;我开发的第一款HTML5游戏《驴子跳》</a></p>
<h1>欢迎浏览上一篇博文：<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3213041.html">炸弹人游戏开发系列（4）：炸弹人显示与移动</a></h1>
<h1>欢迎浏览下一篇博文：<a href="http://www.cnblogs.com/chaogex/p/3327097.html">炸弹人游戏开发系列（6）：实现碰撞检测，设置移动步长<span>&nbsp;</span></a></h1>]]></description></item><item><title>关于使用Css设置Canvas画布大小的问题</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/19/3377692.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sat, 19 Oct 2013 03:46:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/19/3377692.html</guid><description><![CDATA[<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">问题分析</span></strong></p>
<p>我们在调整画布大小时，希望画布中的图形保持不变，只是改变画布本身的大小。但是如果使用Css设置画布大小，则会出现问题。</p>
<h1>问题描述</h1>
<p>如果使用Css设置Canvas画布的大小，则<span>导致画布按比例缩放到你设置的值。</span></p>
<h1><span>原因</span></h1>
<p><span>在Canvas元素的内部存在一个名为2d渲染环境（2d redering context）的对象，所以，通过Css设置画布尺寸会引起奇怪的效果。</span></p>
<h1><span>解决方案</span></h1>
<p><span>在Html页面上加入canvas元素（不能使用js动态加入canvas）。</span></p>
<p><span>通过Html设置画布大小。可以直接在Html页面上设置Canvas元素的大小：</span></p>
<div class="cnblogs_code">
<pre>&lt;canvas id=<span style="color: #800000;">"</span><span style="color: #800000;">testCanvas</span><span style="color: #800000;">"</span> width=<span style="color: #800000;">"</span><span style="color: #800000;">200</span><span style="color: #800000;">"</span> height=<span style="color: #800000;">"</span><span style="color: #800000;">100</span><span style="color: #800000;">"</span>&gt;&lt;/canvas&gt;</pre>
</div>
<p><span>也可以通过js设置画布大小：</span></p>
<div class="cnblogs_code">
<pre>    <span style="color: #0000ff;">var</span> canvas = document.getElementById(<span style="color: #800000;">"</span><span style="color: #800000;">testCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    canvas.width </span>= <span style="color: #800080;">200</span><span style="color: #000000;">;
    canvas.height </span>= <span style="color: #800080;">100</span>;</pre>
</div>
<p>这两种方法都可以。</p>
<p><span style="font-size: 18px;">需要注意的是，<span style="color: #ff0000;">设置画布大小后，画布所有的样式和内容会重置（如画布上的图形会消失，在设置画布大小后需要重新绘制）。</span></span></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">示例</span></strong></p>
<p>首先我们创建一个宽度为200px，高度为100px的画布，它的边框为红色。然后在中间画一个大小为20*20的正方形：</p>
<p><img src="http://images.cnitblog.com/blog/419321/201310/19112208-6fea7fb343ab44559b1befb9e379b094.png" alt="" /></p>
<h1>代码</h1>
<div class="cnblogs_code">
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;canvas id=<span style="color: #800000;">"</span><span style="color: #800000;">testCanvas</span><span style="color: #800000;">"</span>&gt;&lt;/canvas&gt;
&lt;script&gt;
    <span style="color: #0000ff;">var</span><span style="color: #000000;"> canvas, context;
    canvas </span>= document.getElementById(<span style="color: #800000;">"</span><span style="color: #800000;">testCanvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);

    canvas.width </span>= <span style="color: #800080;">200</span><span style="color: #000000;">;
    canvas.height </span>= <span style="color: #800080;">100</span><span style="color: #000000;">;
    canvas.style.border </span>= <span style="color: #800000;">"</span><span style="color: #800000;">1px solid red</span><span style="color: #800000;">"</span><span style="color: #000000;">;

    context </span>= canvas.getContext(<span style="color: #800000;">"</span><span style="color: #800000;">2d</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    context.strokeStyle </span>= <span style="color: #800000;">"</span><span style="color: #800000;">#99cc33</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    context.fillRect(</span><span style="color: #800080;">90</span>, <span style="color: #800080;">40</span>, <span style="color: #800080;">20</span>, <span style="color: #800080;">20</span><span style="color: #000000;">);
</span>&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<h1>将画布大小缩小1倍</h1>
<h2>使用css设置画布大小</h2>
<h3>相关代码</h3>
<div class="cnblogs_code">
<pre>    canvas.style.width = <span style="color: #800000;">"</span><span style="color: #800000;">100px</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    canvas.style.height </span>= <span style="color: #800000;">"</span><span style="color: #800000;">50px</span><span style="color: #800000;">"</span>;</pre>
</div>
<h3>效果</h3>
<p><img src="http://images.cnitblog.com/blog/419321/201310/19112521-266b9c929f3a415c8dfd2d2bcf9b3c79.png" alt="" /></p>
<h3>分析</h3>
<p><span style="line-height: 1.5;">我们发现画布是整体按比例缩小了1倍。</span></p>
<h2>使用js设置画布大小</h2>
<h3>相关代码</h3>
<div class="cnblogs_code">
<pre>    canvas.width = <span style="color: #800080;">100</span><span style="color: #000000;">;
    canvas.height </span>= <span style="color: #800080;">50</span><span style="color: #000000;">;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">设置画布大小后，所有样式会重置。因此需要重新绘制正方形</span>
    context.fillRect(<span style="color: #800080;">90</span>, <span style="color: #800080;">40</span>, <span style="color: #800080;">20</span>, <span style="color: #800080;">20</span><span style="color: #000000;">);
 </span></pre>
</div>
<h3><span style="line-height: 1.5;">效果</span></h3>
<p><img src="http://images.cnitblog.com/blog/419321/201310/19114015-5ec6ce777f734147849d365e229719fc.png" alt="" /></p>
<h3><span style="line-height: 1.5;">分析</span></h3>
<p><span style="line-height: 1.5;">相当于把画布的右半部和下半部去掉了，达到了我们预期的效果。</span></p>]]></description></item><item><title>炸弹人游戏开发系列（4）：炸弹人显示与移动</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/17/3213041.html</link><dc:creator>yyc元超</dc:creator><author>yyc元超</author><pubDate>Thu, 17 Oct 2013 12:05:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/17/3213041.html</guid><description><![CDATA[<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">前言</span></strong></p>
<p>在上文中，我已经介绍了如何测试、如何重构测试，并且通过实验掌握了地图显示的技术。本文会将地图显示的技术用到炸弹人显示中，并且让我们的炸弹人动起来。</p>
<p>注：为了提升博文质量和把重点放在记录开发和迭代的思想实践，本文及后续博文将不再记录测试过程。</p>
<h1>本文目的</h1>
<p>实现炸弹人的显示和移动</p>
<h1>本文主要内容</h1>
<ul>
<li><span><a href="#strategy">开发策略</a></span></li>
<li><span><a href="#test">实验</a></span></li>
<li><span><a href="#animation">实现动画</a></span></li>
<li><span><a href="#leftRightMove">实现左右移动</a></span></li>
<li><span><a href="#draw">绘制地图和炸弹人</a></span></li>
<li><span><a href="#model">本文最终领域模型</a></span></li>
<li><span><a href="#layer">高层划分</a></span></li>
<li><span><a href="#demo">演示</a></span></li>
<li><span><a href="#reference">本文参考资料</a></span></li>
</ul>
<h1>回顾上文更新后的领域模型</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/17184727-b46ab1b898d44712b697467f952b28e8.jpg" alt="" /></p>
<h2>对领域模型进行思考</h2>
<p>ShowMap类是负责显示地图，包含了游戏逻辑。而Game类职责是负责游戏逻辑，因此ShowMap和Game在职责上是有重复的。况且显示地图这部分逻辑并不是很复杂，可以不需要专门的类来负责这部分逻辑，而是直接放到Game中。</p>
<p>现在来回头看看ShowMap类的显示地图实现：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">drawMap: function () {
    </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
        j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
        map </span>=<span style="color: #000000;"> bomberConfig.map,
        bitmap </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
        mapData </span>=<span style="color: #000000;"> mapDataOperate.getMapData(),
        x </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
        y </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
        img </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._createLayer();

    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; map.ROW; i++<span style="color: #000000;">) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">注意！
        </span><span style="color: #008000;">//</span><span style="color: #008000;">y为纵向height，x为横向width</span>
        y = i *<span style="color: #000000;"> map.HEIGHT;

        </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; map.COL; j++<span style="color: #000000;">) {
            x </span>= j *<span style="color: #000000;"> map.WIDTH;
            img </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._getMapImg(i, j, mapData);
            bitmap </span>=<span style="color: #000000;"> bitmapFactory.createBitmap({ img: img, width: map.WIDTH, height: map.HEIGHT, x: x, y: y });
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.appendChild(bitmap);
        }
    }
    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.draw();
}</span></pre>
</div>
<p>ShowMap将显示地图的具体实现委托给了Layer，自己负责操作Layer，这个职责也可以移到Game中。且考虑到ShowMap类是用作实验（见上文的开发策略）的，现在&ldquo;显示地图&rdquo;的功能已经实现，ShowMap没有存在的必要了。</p>
<p>因此，我去掉ShowMap类，将其移到Game中。</p>
<h2>重构后的领域模型</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/02233525-c287fe87a3594603a8d1e5c4c6e8bd75.jpg" alt="" /></p>
<h2>重构后Game类代码</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('2e2a7e13-ad08-45bc-8841-6f826b903e07')"><img id="code_img_closed_2e2a7e13-ad08-45bc-8841-6f826b903e07" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_2e2a7e13-ad08-45bc-8841-6f826b903e07" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2e2a7e13-ad08-45bc-8841-6f826b903e07',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_2e2a7e13-ad08-45bc-8841-6f826b903e07" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Game =<span style="color: #000000;"> YYC.Class({
        Init: function(){
        },
        Private: {
            _pattern: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            _ground: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            _createLayer: function () {
                </span><span style="color: #0000ff;">this</span>.layer = <span style="color: #0000ff;">new</span> Layer(<span style="color: #0000ff;">this</span><span style="color: #000000;">.createCanvas());
            },
            _getMapImg: function (i, j, mapData) {
                </span><span style="color: #0000ff;">var</span> img = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (mapData[i][j]) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">1</span><span style="color: #000000;">:
                        img </span>= main.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">2</span><span style="color: #000000;">:
                        img </span>= main.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> img;
            }
        },
        Public: {
            layer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            onload: function () {
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar</span><span style="color: #800000;">"</span>).css(<span style="color: #800000;">"</span><span style="color: #800000;">display</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">none</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.drawMap();
            },
            createCanvas: function (id) {
                </span><span style="color: #0000ff;">var</span> canvas = document.createElement(<span style="color: #800000;">"</span><span style="color: #800000;">canvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);

                canvas.width </span>= <span style="color: #800080;">600</span><span style="color: #000000;">;
                canvas.height </span>= <span style="color: #800080;">400</span><span style="color: #000000;">;
                canvas.id </span>=<span style="color: #000000;"> id;

                document.body.appendChild(canvas);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> canvas;
            },
            drawMap: function () {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    map </span>=<span style="color: #000000;"> bomberConfig.map,
                    bitmap </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                    mapData </span>=<span style="color: #000000;"> mapDataOperate.getMapData(),
                    x </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    y </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    img </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._createLayer();

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; map.ROW; i++<span style="color: #000000;">) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">注意！
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">y为纵向height，x为横向width</span>
                    y = i *<span style="color: #000000;"> map.HEIGHT;

                    </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; map.COL; j++<span style="color: #000000;">) {
                        x </span>= j *<span style="color: #000000;"> map.WIDTH;
                        img </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._getMapImg(i, j, mapData);
                        bitmap </span>=<span style="color: #000000;"> bitmapFactory.createBitmap({img: img, width: map.WIDTH, height: map.HEIGHT, x: x, y: y});

                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.appendChild(bitmap);
                    }
                }
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.draw();
            }
        }
    });

    window.Game </span>=<span style="color: #000000;"> Game;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><a name="stretagy"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">开发策略</span></strong></p>
<p>&ldquo;显示炸弹人&rdquo;没有难度，因为在上文中我已经掌握了使用canvas显示图片的方法。本文的难点在于让炸弹人移动起来。</p>
<p><span>我采用与上文相似的开发策略，先在Game这个游戏逻辑类中进行实验，实现炸弹人移动的功能，然后再进行重构。</span></p>
<p><a name="test"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">实验</span></strong></p>
<p>现在Game中的onload方法已经有了其它的职责（隐藏进度条、调用showMap显示地图），如果在该方法里实现&ldquo;炸弹人显示及移动&rdquo;的话，该实现会受到其它职责的影响，且不好编写测试。因此增加drawPlayer方法，在该方法中实现&ldquo;炸弹人显示及移动&rdquo;。</p>
<h1>Game中实现人物显示</h1>
<p>首先，要显示炸弹人。Game中需要创建画布并获得上下文，然后是清空画布区域，使用drawImage来绘制图片。</p>
<h2>加入玩家精灵图片</h2>
<p>这里炸弹人图片使用的是一个包含炸弹人移动的所有动作的精灵图片。所谓精灵图片就是包含多张小图片的一张大图片，使用它可以减少http请求，提升性能。</p>
<p>炸弹人精灵图片如下：</p>
<p><img src="http://images.cnitblog.com/blog/419321/201309/24115313-0328d2b50c164368bb682c86a0843afa.png" alt="" width="205" height="410" /></p>
<h2>相关代码</h2>
<div class="cnblogs_code">
<pre><span style="color: #000000;">drawPlayer: function () {
    </span><span style="color: #0000ff;">var</span> sx = <span style="color: #800080;">0</span>, sy = <span style="color: #800080;">0</span>, sw = <span style="color: #800080;">64</span>, sh = <span style="color: #800080;">64</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">var</span> dx = <span style="color: #0000ff;">0</span>, dy = <span style="color: #800080;">0</span>, dw = <span style="color: #800080;">34</span>, dh = <span style="color: #800080;">34</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">var</span> canvas = document.createElement(<span style="color: #800000;">"</span><span style="color: #800000;">canvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);<br />
</span>    canvas.width = <span style="color: #800080;">500</span><span style="color: #000000;">;
    canvas.height </span>= <span style="color: #800080;">500</span><span style="color: #000000;">;
    document.body.appendChild(canvas);

    </span><span style="color: #0000ff;">this</span>.context = canvas.getContext(<span style="color: #800000;">"</span><span style="color: #800000;">2d</span><span style="color: #800000;">"</span><span style="color: #000000;">);<br />
    </span><span style="color: #0000ff;">this</span>.context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">500</span>, <span style="color: #800080;">500</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">this</span>.context.drawImage(main.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span><span style="color: #000000;">), sx, sy, sw, sh, dx, dy, dw, dh);
}</span></pre>
</div>
<h1>Game中实现人物移动</h1>
<p>将精灵图片的不同动作图片，在画布上同一位置交替显示，就形成了人物原地移动的动画。在画布的不同的位置显示动作图片，就形成了人物在画布上来回移动的动画。</p>
<h2>开发策略</h2>
<p>首先实现炸弹人在画布上原地移动，显示移动动画；然后实现炸弹人在画布上左右移动；然后将背景地图与炸弹人同时显示出来。</p>
<h2>让人物原地移动</h2>
<p>需要一个循环，在循环体中清除画布，并绘制更新了坐标的炸弹人。</p>
<p>Game</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">drawPlayer: function () {
    </span><span style="color: #0000ff;">var</span> sx = <span style="color: #800080;">0</span>, sy = <span style="color: #800080;">0</span>, sw = <span style="color: #800080;">64</span>, sh = <span style="color: #800080;">64</span>, dx = <span style="color: #800080;">0</span>, dy = <span style="color: #800080;">0</span>, dw = <span style="color: #800080;">34</span>, dh = <span style="color: #800080;">34</span><span style="color: #000000;">,
        canvas </span>= document.createElement(<span style="color: #800000;">"</span><span style="color: #800000;">canvas</span><span style="color: #800000;">"</span><span style="color: #000000;">),
        sleep </span>= <span style="color: #800080;">500</span><span style="color: #000000;">,
        self </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">,
        loop </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    canvas.width </span>= <span style="color: #800080;">500</span><span style="color: #000000;">;
    canvas.height </span>= <span style="color: #800080;">500</span><span style="color: #000000;">;
    document.body.appendChild(canvas);
    </span><span style="color: #0000ff;">this</span>.context = canvas.getContext(<span style="color: #800000;">"</span><span style="color: #800000;">2d</span><span style="color: #800000;">"</span><span style="color: #000000;">);

    loop </span>=<span style="color: #000000;"> window.setInterval(function () {
        self.context.clearRect(</span><span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">600</span>, <span style="color: #800080;">400</span><span style="color: #000000;">);
        self.context.drawImage(main.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span><span style="color: #000000;">), sx, sy, sw, sh, dx, dy, dw, dh);
        dx </span>+= <span style="color: #800080;">1</span><span style="color: #000000;">;
    }, sleep);
}</span></pre>
</div>
<h1>重构Game<span style="color: #c0c0c0;"><br /></span></h1>
<h2>明确&ldquo;主循环&rdquo;的概念</h2>
<p><span style="color: #888888;"><span style="color: #000000;">回想我在第2篇博文中提到的&ldquo;游戏主循环&rdquo;的概念：</span></span></p>
<p><span style="color: #000000;">每一个游戏都是由获得用户输入，更新游戏状态，处理AI，播放音乐和音效，还有画面显示这些行为组成。游戏主循环就是用来处理这个行为序列，在javascript中可以用setInterval方法来轮询。</span></p>
<p>在drawPlayer中用到的循环，就是属于游戏主循环的概念。</p>
<h2>提出start方法</h2>
<p>因此，我loop变量重命名为mainLoop，并将主循环提出来，放到一个新的方法start中。然后在start的循环中调用drawPlayer。</p>
<h2>提出创建canvas的职责</h2>
<p>每次调用drawPlayer都会创建canvas，但是创建canvas不属于drawPlayer的职责（drawPlayer应该只负责绘制炸弹人）。因此我将创建canvas的职责提取出来形成prepare方法，然后在start的主循环外面调用prepare方法，这样就可以只创建一次canvas了。</p>
<h2>提出<span>游戏的帧数FPS</span></h2>
<p><span>回想我在第2篇博文中提到的&ldquo;<span>游戏的帧数</span>&rdquo;的概念：</span></p>
<p><span>每秒所运行的帧数。如游戏主循环每33.3（1000/30）ms轮询一次，则游戏的帧数FPS为30.</span></p>
<p>FPS决定游戏画面更新的频率，决定主循环的快慢。</p>
<p>这里主循环中的间隔时间sleep与FPS有一个换算公式：</p>
<p>间隔时间 = 向下取整（1000 / FPS）</p>
<p>又因为FPS需要经常变更（如在测试游戏时需要变更游戏帧数来测试游戏性能），因此在Config类中配置FPS。</p>
<h2>相关代码</h2>
<p>Game</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">　　　　　
onload: function () {
    $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar</span><span style="color: #800000;">"</span>).css(<span style="color: #800000;">"</span><span style="color: #800000;">display</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">none</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.start();
},
prepare: function () {
    </span><span style="color: #0000ff;">var</span> canvas = <span style="color: #0000ff;">this</span><span style="color: #000000;">.createCanvas();

    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._getContext(canvas);
},
createCanvas: function () {
    </span><span style="color: #0000ff;">var</span> canvas = document.createElement(<span style="color: #800000;">"</span><span style="color: #800000;">canvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);

    canvas.width </span>= <span style="color: #800080;">600</span><span style="color: #000000;">;
    canvas.height </span>= <span style="color: #800080;">400</span><span style="color: #000000;">;

    document.body.appendChild(canvas);

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> canvas;
},
start: function () {
    </span><span style="color: #0000ff;">var</span> FPS =<span style="color: #000000;"> bomberConfig.FPS,
        self </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">,
        mainLoop </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">this</span>.sleep = Math.floor(<span style="color: #800080;">1000</span> /<span style="color: #000000;"> FPS);

    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.prepare();
    mainLoop </span>=<span style="color: #000000;"> window.setInterval(function () {
        self.drawPlayer();
    }, </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep);
},</span></pre>
</div>
<p>注意：</p>
<p>目前将start、prepare、createCanvas设为公有成员，这样可以方便测试。</p>
<p>后面会只将Game与main类交互的函数设为公有成员，Game其余的公有成员都设为私有成员。这样在修改Game的私有成员时，就不会影响到调用Game的类了。</p>
<h1>重构Main</h1>
<p>重构前Main相关代码</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> _getImg =<span style="color: #000000;"> function () {
    </span><span style="color: #0000ff;">var</span> urls =<span style="color: #000000;"> [];
    </span><span style="color: #0000ff;">var</span> temp =<span style="color: #000000;"> [];
    </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;

    temp </span>=<span style="color: #000000;"> [
        { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>, url: <span style="color: #800000;">"</span><span style="color: #800000;">ground.png</span><span style="color: #800000;">"</span><span style="color: #000000;"> },
        { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span>, url: <span style="color: #800000;">"</span><span style="color: #800000;">wall.png</span><span style="color: #800000;">"</span><span style="color: #000000;"> }
        { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, url: <span style="color: #800000;">"</span><span style="color: #800000;">player.png</span><span style="color: #800000;">"</span><span style="color: #000000;">}
    ];

    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = <span style="color: #800080;">2</span>; i &lt; len; i++<span style="color: #000000;">) {
        urls.push({ id: temp[i].id, url: bomberConfig.url_pre.SHOWMAP </span>+ <span style="color: #800000;">"</span><span style="color: #800000;">image/map/</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> temp[i].url });
    }
    urls.push({ id: temp[</span><span style="color: #800080;">2</span>].id, url: bomberConfig.url_pre.SHOWMAP + <span style="color: #800000;">"</span><span style="color: #800000;">image/player/</span><span style="color: #800000;">"</span> + temp[<span style="color: #800080;">2</span><span style="color: #000000;">].url });

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> urls;
};
</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
    init: function () {
        </span><span style="color: #0000ff;">var</span> game = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Game();
        </span><span style="color: #0000ff;">this</span>.imgLoader = <span style="color: #0000ff;">new</span><span style="color: #000000;"> YYC.Control.PreLoadImg(_getImg(), ...</span></pre>
</div>
<h2><span style="line-height: 1.5;">重构</span><span style="line-height: 1.5;">imgLoader</span></h2>
<p>在init中，imgLoader为Main的属性。考虑到imgLoader经常会被其他类使用（用来获得图片对象），而其他类不想与Main类关联。</p>
<p>因此，将imgLoader设为全局属性：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">init: function () {
...
    window.imgLoader </span>=<span style="color: #000000;"> ...
},</span></pre>
</div>
<h2><span style="color: #000000;">分离temp出map和player</span></h2>
<p>temp包含了两种类型的图片路径信息：地图图片路径和玩家图片路径。</p>
<p>因此，将其分离为map和player：</p>
<div class="cnblogs_code">
<pre>        <span style="color: #0000ff;">var</span> map = [{ id: <span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">) },
            { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
        ];
        </span><span style="color: #0000ff;">var</span> player = [{ id: <span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, url: getImages(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>) }];</pre>
</div>
<h2><span style="color: #ff0000;"><span style="color: #000000;">提出_addImg</span></span></h2>
<p>在_getImg中提出&ldquo;加入图片&rdquo;职责，形成_addImg方法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> _getImg =<span style="color: #000000;"> function () {
    </span><span style="color: #0000ff;">var</span> urls =<span style="color: #000000;"> [];
    </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, len = <span style="color: #800080;">0</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">var</span> map = [{ id: <span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>, url: "ground.png"<span style="color: #000000;"> },
        { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span>, url: "wall.png"<span style="color: #000000;"> }
    ];
    </span><span style="color: #0000ff;">var</span> player = [{ id: <span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, url: "player.png"<span style="color: #000000;"> }];

    _addImg(urls, map, player);

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> urls;
};
</span><span style="color: #0000ff;">var</span> _addImg =<span style="color: #000000;"> function (urls, map, player) {
    </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span><span style="color: #000000;">),
        i </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
        j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
        len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = map.length; i &lt; len; i++<span style="color: #000000;">) {
        urls.push({ id: temp[i].id, url: bomberConfig.url_pre.SHOWMAP </span>+ <span style="color: #800000;">"</span><span style="color: #800000;">image/map/</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> temp[i].url });
    }
    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = player.length; i &lt; len; i++<span style="color: #000000;">) {
        urls.push({ id: temp[i].id, url: bomberConfig.url_pre.SHOWMAP </span>+ <span style="color: #800000;">"</span><span style="color: #800000;">image/player/</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> temp[i].url });
    }
};</span></pre>
</div>
<h2><span style="color: #ff0000;"><span style="color: #000000;">提出图片路径数据</span></span></h2>
<p>考虑到图片路径可能会经常变化，因此将其提出来形成ImgPathData，并提供数据访问类GetPath。在实现中将ImgPathData、GetPath写在同一个文件中。</p>
<h2><span style="color: #000000;">删除Config的url_pre</span></h2>
<p>将路径前缀url_pre直接放到GetPath中，删除<span>Config的url_pre，</span>对应修改Main。</p>
<h2><span style="color: #000000;">领域模型</span></h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/06152000-c69a3942e3b741948d5251eecec7ddb3.jpg" alt="" /></p>
<h2>相关代码</h2>
<p>GetPath和ImgPathData</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> getPath =<span style="color: #000000;"> (function () {
        </span><span style="color: #0000ff;">var</span> urlPre = <span style="color: #800000;">"</span><span style="color: #800000;">../Content/Image/</span><span style="color: #800000;">"</span><span style="color: #000000;">;

        </span><span style="color: #0000ff;">var</span> imgPathData =<span style="color: #000000;"> {
            ground: </span><span style="color: #800000;">"</span><span style="color: #800000;">Map/ground.png</span><span style="color: #800000;">"</span><span style="color: #000000;">,
            wall: </span><span style="color: #800000;">"</span><span style="color: #800000;">Map/wall.png</span><span style="color: #800000;">"</span><span style="color: #000000;">,
            player: </span><span style="color: #800000;">"</span><span style="color: #800000;">Player/player.png</span><span style="color: #800000;">"</span><span style="color: #000000;">
        };

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> function (id) {
        </span><span style="color: #0000ff;">return</span> urlPre +<span style="color: #000000;"> imgPathData[id];
    };
}());

window.getPath </span>=<span style="color: #000000;"> getPath;
}());</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">Main</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> _getImg =<span style="color: #000000;"> function () {
    </span><span style="color: #0000ff;">var</span> urls =<span style="color: #000000;"> [];
    </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, len = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">var</span> map =<span style="color: #000000;"> [
        { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>, url: getPath(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">) },
        { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span>, url: getPath(<span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
    ];
    </span><span style="color: #0000ff;">var</span> player =<span style="color: #000000;"> [
        { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span>, url: getPath(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span><span style="color: #000000;">) }
    ];

    _addImg(urls, map, player);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> urls;
};
</span><span style="color: #0000ff;">var</span> _addImg =<span style="color: #000000;"> function (urls, imgs) {
    </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span>), i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span>, len1 = <span style="color: #800080;">0</span>, len2 = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len1 = args.length; i &lt; len1; i++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>, len2 = args[i].length; j &lt; len2; j++<span style="color: #000000;">) {
            urls.push({ id: args[i][j].id, url: args[i][j].url });
        }
    }
}; </span></pre>
</div>
<p><a name="animation"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">实现动画</span></strong></p>
<h1>提出疑问　</h1>
<p>从第2篇博文的<span>帧动画概念</span>中，我们知道动画是通过绘制一组帧图片来实现的。具体实现时有几个需要考虑的问题：</p>
<ul>
<li>一组帧应该以怎样的顺序来绘制？</li>
<li>如何控制每一帧绘制的时间？</li>
<li>在画布的什么位置绘制帧？</li>
<li>如何控制绘制的帧的内容、图片大小？</li>
</ul>
<h1>提出帧动画控制和帧数据的概念</h1>
<p>结合以上的问题和本文参考资料，我引入帧动画控制类Animation和帧数据类FrameData的概念。</p>
<p>FrameData负责保存每一帧的数据，包括帧的图片对象、在精灵图片中的位置等。</p>
<p>Animation负责读取、配置、更新帧数据，控制帧数据的播放。</p>
<h1>实现Animation、FrameData</h1>
<p>在实现Animation类时，有一个问题需要思考清楚：</p>
<p>Animation是否应该包含绘制帧的职责呢？</p>
<p>我们从职责上来分析，Animation类的职责是负责帧播放的管理，而绘制帧是属于表现的职责，显然与该类的职责正交。</p>
<p>因此Animation不应该包含该职责。</p>
<h2>回答疑问</h2>
<p>现在来试着回答之前提出的疑问。</p>
<p>Animation来负责帧显示的顺序，以及每一帧显示的时间。</p>
<p>帧的内容和图片大小等数据保存在FrameData类中。</p>
<p>绘制帧的类负责决定在画布中绘制的帧的位置，以及如何读取Frame的数据来绘制帧。</p>
<h2>增加GetFrames</h2>
<p>当然可以增加数据操作类GetFrames。实现时也将GetFrames与FrameData写到同一个文件中。</p>
<h2><span style="color: #ff0000;"><span style="color: #000000;">领域模型</span></span></h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/12060824-1c6b882c47974af3903d19789da0d272.jpg" alt="" /></p>
<h2>相关代码</h2>
<p>Animation</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('67b0b0a9-e7f8-4237-8bbc-394543ee8c9e')"><img id="code_img_closed_67b0b0a9-e7f8-4237-8bbc-394543ee8c9e" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_67b0b0a9-e7f8-4237-8bbc-394543ee8c9e" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('67b0b0a9-e7f8-4237-8bbc-394543ee8c9e',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_67b0b0a9-e7f8-4237-8bbc-394543ee8c9e" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Animation =<span style="color: #000000;"> YYC.Class({
        Init: function (config) {
            </span><span style="color: #0000ff;">this</span>._frames =<span style="color: #000000;"> YYC.Tool.array.clone(config.frames);
            </span><span style="color: #008000;">//</span><span style="color: #008000;">config.img为HtmlImg对象 </span>
            <span style="color: #0000ff;">this</span>._img =<span style="color: #000000;"> config.img;

            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._init();
        },
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Animation 包含的Frame, 类型:数组</span>
            _frames: <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 包含的Frame数目</span>
            _frameCount: -<span style="color: #800080;">1</span><span style="color: #000000;">,
            _img: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            _currentFrame: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            _currentFrameIndex: </span>-<span style="color: #800080;">1</span><span style="color: #000000;">,
            _currentFramePlayed: </span>-<span style="color: #800080;">1</span><span style="color: #000000;">,

            _init: function () {
                </span><span style="color: #0000ff;">this</span>._frameCount = <span style="color: #0000ff;">this</span><span style="color: #000000;">._frames.length;
                </span><span style="color: #0000ff;">this</span>.setCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
            }
        },
        Public: {
            setCurrentFrame: function (index) {
                </span><span style="color: #0000ff;">this</span>._currentFrameIndex =<span style="color: #000000;"> index;
                </span><span style="color: #0000ff;">this</span>._currentFrame = <span style="color: #0000ff;">this</span><span style="color: #000000;">._frames[index];
                </span><span style="color: #0000ff;">this</span>._currentFramePlayed = <span style="color: #800080;">0</span><span style="color: #000000;">;
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新Animation状态. deltaTime表示时间的变化量.</span>
<span style="color: #000000;">            update: function (deltaTime) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">判断当前Frame是否已经播放完成, </span>
                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._currentFramePlayed &gt;= <span style="color: #0000ff;">this</span><span style="color: #000000;">._currentFrame.duration) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">播放下一帧</span>

                    <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._currentFrameIndex &gt;= <span style="color: #0000ff;">this</span>._frameCount - <span style="color: #800080;">1</span><span style="color: #000000;">) {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">当前是最后一帧,则播放第0帧</span>
                        <span style="color: #0000ff;">this</span>._currentFrameIndex = <span style="color: #800080;">0</span><span style="color: #000000;">;
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">播放下一帧</span>
                        <span style="color: #0000ff;">this</span>._currentFrameIndex++<span style="color: #000000;">;
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前帧信息</span>
                    <span style="color: #0000ff;">this</span>.setCurrentFrame(<span style="color: #0000ff;">this</span><span style="color: #000000;">._currentFrameIndex);

                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">增加当前帧的已播放时间.</span>
                    <span style="color: #0000ff;">this</span>._currentFramePlayed +=<span style="color: #000000;"> deltaTime;
                }
            },
            getCurrentFrame: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._currentFrame;
            },
            getImg: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._img;
            }
        }
    });

    window.Animation </span>=<span style="color: #000000;"> Animation;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="line-height: 1.5;">GetFrames、FrameData</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('146822ef-960f-4982-9780-db2af37d1e01')"><img id="code_img_closed_146822ef-960f-4982-9780-db2af37d1e01" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_146822ef-960f-4982-9780-db2af37d1e01" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('146822ef-960f-4982-9780-db2af37d1e01',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_146822ef-960f-4982-9780-db2af37d1e01" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> getPlayerFrames =<span style="color: #000000;"> (function () {
        </span><span style="color: #0000ff;">var</span> width =<span style="color: #000000;"> bomberConfig.player.WIDTH,
            height </span>=<span style="color: #000000;"> bomberConfig.player.HEIGHT,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">一帧在精灵图片中x方向的长度</span>
            x =<span style="color: #000000;"> bomberConfig.player.WIDTH,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">一帧在精灵图片中y方向的长度</span>
            y =<span style="color: #000000;"> bomberConfig.player.HEIGHT;

        </span><span style="color: #008000;">//</span><span style="color: #008000;">帧数据
        </span><span style="color: #008000;">//</span><span style="color: #008000;">img:图片对象
        </span><span style="color: #008000;">//</span><span style="color: #008000;">x和y：帧在精灵图片中的位置
        </span><span style="color: #008000;">//</span><span style="color: #008000;">width和height：在画布中显示的图片大小
        </span><span style="color: #008000;">//</span><span style="color: #008000;">duration：帧显示的时间</span>
        <span style="color: #0000ff;">var</span> frames =<span style="color: #000000;"> function () {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">向右站立</span>
<span style="color: #000000;">                stand_right: {
                    img: window.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                    frames: [
                        { x: </span><span style="color: #800080;">0</span>, y: <span style="color: #800080;">2</span> * y, width: width, height: height, imgWidth: imgWidth, imgHeight: imgHeight, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> }
                    ]
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">向右走</span>
<span style="color: #000000;">                walk_right: {
                    img: window.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                    frames: [
                        { x: </span><span style="color: #800080;">0</span>, y: <span style="color: #800080;">2</span> * y, width: width, height: height, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: x, y: </span><span style="color: #800080;">2</span> * y, width: width, height: height, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: </span><span style="color: #800080;">2</span> * x, y: <span style="color: #800080;">2</span> * y, width: width, height: height, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: </span><span style="color: #800080;">3</span> * x, y: <span style="color: #800080;">2</span> * y, width: width, height: height, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> }
                    ]
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">向左走</span>
<span style="color: #000000;">                walk_left: {
                    img: window.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span><span style="color: #000000;">),
                    frames: [
                        { x: </span><span style="color: #800080;">0</span>, y: y, width: width, height: height, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: x, y: y, width: width, height: height, duration: </span><span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: </span><span style="color: #800080;">2</span> * x, y: y, width: width, height: height, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> },
                        { x: </span><span style="color: #800080;">3</span> * x, y: y, width: width, height: height, duration: <span style="color: #800080;">100</span><span style="color: #000000;"> }
                    ]
                }
            }
        }

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> function (animName) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> frames()[animName];
        };
    }());

    window.getPlayerFrames </span>=<span style="color: #000000;"> getPlayerFrames;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="line-height: 1.5;">Game：</span></p>
<p>在start中创建animation，传入帧数据</p>
<p>在drawPlayer中控制帧的显示，显示向下走的动画。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">            start: function () {
                </span><span style="color: #0000ff;">var</span> FPS =<span style="color: #000000;"> bomberConfig.FPS,
                    self </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">,
                    mainLoop </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                    frames </span>= window.getPlayerFrames(<span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">);

                </span><span style="color: #0000ff;">this</span>.animation = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Animation(frames);
                </span><span style="color: #0000ff;">this</span>.sleep = Math.floor(<span style="color: #800080;">1000</span> /<span style="color: #000000;"> FPS);
                </span><span style="color: #0000ff;">this</span>.prepare(<span style="color: #000000;">);</span><span style="color: #000000;">

                mainLoop </span>=<span style="color: #000000;"> window.setInterval(function () {
                    self.drawPlayer();
                }, </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep);
            },
            drawPlayer: function () {
                </span><span style="color: #0000ff;">var</span> dx = <span style="color: #0000ff;">0</span>, dy = <span style="color: #800080;">0</span>, dw = bomberConfig.WIDTH, dh =<span style="color: #000000;"> bomberConfig.HEIGHT;
                </span><span style="color: #0000ff;">var</span> deltaTime = <span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep;
                </span><span style="color: #0000ff;">var</span> currentFrame = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.animation.update(deltaTime);
                currentFrame </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.animation.getCurrentFrame();
                </span><span style="color: #0000ff;">this</span>.context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">600</span>, <span style="color: #800080;">400</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">this</span>.context.drawImage(<span style="color: #0000ff;">this</span>.animation.getImg(), currentFrame.x, currentFrame.y, currentFrame.width, currentFrame.height, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, dw, dh);
            }</span></pre>
</div>
<h1>重构</h1>
<h2>提出init</h2>
<p>&nbsp;回头看下start方法，发现它做了两件事：</p>
<ul>
<li>初始化</li>
<li>主循环</li>
</ul>
<p>因此，我把初始化的职责提出来，形成init方法，从而使start只负责游戏主循环。</p>
<h2>去掉onload</h2>
<p>在onload方法中，负责隐藏进度条的职责显然不属于游戏的逻辑，因此应该提出去，放到Main类中。</p>
<p>onload方法跟Main中的图片预加载密切相关，应该把onload也移到Main中。</p>
<h2>增加run方法</h2>
<p>回顾第2篇博文中的&ldquo;<span>Action接口&rdquo;概念：</span></p>
<p><span><span>Actor&nbsp;是一个接口，他的作用是统一类的行为。。。。。。<span>所以我们让他们都实现Actor接口，只要调用接口定义的函数，他们就会做出各自的动作。</span></span></span></p>
<p><span><span>反思start中的游戏主循环。循环中直接调用drawPlayer。这样与绘制炸弹人的职责耦合太重，一旦drawPlayer发生了改变，则start也可能要相应变化。所以我提出一个抽象的actor方法run，主循环中只调用run，不用管run的实现。run方法负责每次循环的具体操作。</span></span></p>
<p><span><span>这里运用了间接原则，增加了一个中间方法run，来使得主循环与具体细节隔离开来，从而隔离变化。</span></span></p>
<h2>重构后Game的相关代码</h2>
<div class="cnblogs_code">
<pre><span style="color: #000000;">            init: function () {
                </span><span style="color: #0000ff;">var</span> frames = window.getPlayerFrames(<span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">);

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.prepare();
                </span><span style="color: #0000ff;">this</span>.animation = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Animation(frames);
            },
            start: function () {
                </span><span style="color: #0000ff;">var</span> FPS =<span style="color: #000000;"> bomberConfig.FPS,
                    self </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">,
                    mainLoop </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">this</span>.sleep = Math.floor(<span style="color: #800080;">1000</span> /<span style="color: #000000;"> FPS);

                mainLoop </span>=<span style="color: #000000;"> window.setInterval(function () {
                    self.run();
                }, </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep);
            },
            run: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.drawPlayer();
            }</span></pre>
</div>
<h2>重构后Main的相关代码</h2>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        init: function () {
            </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span>
            window.imgLoader = <span style="color: #0000ff;">new</span><span style="color: #000000;"> YYC.Control.PreLoadImg(_getImg(), function (currentLoad, imgCount) {
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar_img_show</span><span style="color: #800000;">"</span>).progressBar(parseInt(currentLoad * <span style="color: #800080;">100</span> / imgCount, <span style="color: #800080;">10</span>));     <span style="color: #008000;">//</span><span style="color: #008000;">调用进度条插件</span>
<span style="color: #000000;">            }, YYC.Tool.func.bind(self, self.onload));
        },
        onload: function () {
            _hideBar();

            </span><span style="color: #0000ff;">var</span> game = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Game();
            game.init();
            game.start();
        }</span></pre>
</div>
<h2>提出精灵类</h2>
<p>回顾第2篇博文的&ldquo;精灵&rdquo;概念：</p>
<p><span>游戏中具有独立外观和属性的个体。</span></p>
<p><span>&ldquo;炸弹人&rdquo;应该属于精灵的概念，因此提出PlayerSprite类，把与炸弹人相关的属性和方法都从Game类中移到PlayerSprite类。</span></p>
<h3><span>精灵类的职责</span></h3>
<p><span>那么，具体是哪些职责应该移到PlayerSprite中呢？</span></p>
<ul>
<li>帧的控制</li>
<li>炸弹人的绘制</li>
<li>炸弹人在画布中的坐标dx和dy等</li>
</ul>
<p>画布的创建依然由Game负责。</p>
<p>根据之前的分析，帧的控制由Animation负责，因此在PlayerSprite中也把这部分职责委托给Animation。</p>
<h3>提出精灵数据、精灵数据操作</h3>
<p>把炸弹人精灵类的初始配置数据提出来形成SpriteData类，并增加数据操作GetSpriteData类，将数据操作与精灵数据数据一起写到同一个文件中。</p>
<h2>提出精灵工厂</h2>
<p>增加一个SpriteFactory，工厂类负责创建精灵实例。</p>
<h1>重构后相关的领域模型</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/15194243-46c208fd4f4341c7a88c01a8850b5f84.jpg" alt="" /></p>
<h1>相关代码</h1>
<p>PlayerSprite</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('95bcc468-a16f-4f40-80f1-9e1141fb459d')"><img id="code_img_closed_95bcc468-a16f-4f40-80f1-9e1141fb459d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_95bcc468-a16f-4f40-80f1-9e1141fb459d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('95bcc468-a16f-4f40-80f1-9e1141fb459d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_95bcc468-a16f-4f40-80f1-9e1141fb459d" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> PlayerSprite =<span style="color: #000000;"> YYC.Class({
        Init: function (data) {
            </span><span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
            </span><span style="color: #0000ff;">this</span>.y =<span style="color: #000000;"> data.y;

            </span><span style="color: #0000ff;">this</span>.defaultAnimId =<span style="color: #000000;"> data.defaultAnimId;
            </span><span style="color: #0000ff;">this</span>.anims =<span style="color: #000000;"> data.anims;
        },
        Private: {
            _resetCurrentFrame: function (index) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.setCurrentFrame(index);
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标</span>
            x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            anims: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
　　　　　　  </span><span style="color: #008000;">//</span><span style="color: #008000;">当前的Animation.</span>
            currentAnim: <span style="color: #0000ff;">null</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation, 参数为Animation的id</span>
<span style="color: #000000;">            setAnim: function (animId) {
                </span><span style="color: #0000ff;">this</span>.currentAnim = <span style="color: #0000ff;">this</span><span style="color: #000000;">.anims[animId];
                
                </span><span style="color: #0000ff;">this</span>._resetCurrentFrame(<span style="color: #800080;">0</span><span style="color: #000000;">);
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新精灵当前状态.</span>
<span style="color: #000000;">            update: function (deltaTime) {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.update(deltaTime);
                }
            },
            draw: function (context) {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    context.clearRect(</span><span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">600</span>, <span style="color: #800080;">400</span><span style="color: #000000;">);
                    context.drawImage(</span><span style="color: #0000ff;">this</span>.currentAnim.getImg(), frame.x, frame.y, frame.width, frame.height, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y, frame.imgWidth, frame.imgHeight);
                }
            }
        }
    });

    window.PlayerSprite </span>=<span style="color: #000000;"> PlayerSprite;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="line-height: 1.5;">Game</span></p>
<div class="cnblogs_code">
<pre>init: function () {<span style="color: #0000ff;">this</span><span style="color: #000000;">.prepare();
    </span><span style="color: #0000ff;">this</span>.playerSprite =<span style="color: #000000;"> spriteFactory.createPlayer();
    </span><span style="color: #0000ff;">this</span>.playerSprite.setAnim(<span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">);
},
drawPlayer: function () {
    </span><span style="color: #0000ff;">this</span>.playerSprite.update(<span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep);
    </span><span style="color: #0000ff;">this</span>.playerSprite.draw(<span style="color: #0000ff;">this</span><span style="color: #000000;">.context);
}</span></pre>
</div>
<p>GetSpriteData和SpriteData</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> getSpriteData =<span style="color: #000000;"> (function () {
        </span><span style="color: #0000ff;">var</span> data =<span style="color: #000000;"> function(){
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">炸弹人精灵类</span>
<span style="color: #000000;">                player: {
                    x: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
                    y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

                    anims: {
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getPlayerFrames(<span style="color: #800000;">"</span><span style="color: #800000;">stand_right</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getPlayerFrames(<span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">)),
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span>: <span style="color: #0000ff;">new</span> Animation(getPlayerFrames(<span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">))
                    }
                }
            }
        };

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> function (spriteName) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> data()[spriteName];
        };
    }());

    window.getSpriteData </span>=<span style="color: #000000;"> getSpriteData;
}());</span></pre>
</div>
<p><span style="line-height: 1.5;">这里SpriteData其实设计得有问题，因为：</span></p>
<p><span style="line-height: 1.5;">1、数据类SpriteData依赖了数据操作类GetFrameData（因为SpriteData中调用getFrames方法获得帧数据）。</span></p>
<p><span style="line-height: 1.5;">数据操作类应该依赖数据类，而数据类不应该依赖数据操作类。</span></p>
<p>&nbsp;</p>
<p align="left">2、数据类与其它类耦合。</p>
<p align="left">因为数据类应该是独立的纯数据，保持简单，只有数据信息，这样才具有高度的可维护性、可读性和可移植性。而此处SpriteData却与GetFrameData、Animation强耦合。</p>
<p align="left">&nbsp;</p>
<p align="left">考虑到目前复杂度还不高，还在可接受的范围，因此暂时不重构设计。</p>
<p align="left">&nbsp;</p>
<p><span style="line-height: 1.5;">SpriteFactory</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> spriteFactory =<span style="color: #000000;"> {
        createPlayer: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> PlayerSprite(getSpriteData(<span style="color: #800000;">"</span><span style="color: #800000;">player</span><span style="color: #800000;">"</span><span style="color: #000000;">));
        }
    }

    window.spriteFactory </span>=<span style="color: #000000;"> spriteFactory;
}());</span></pre>
</div>
<p><a name="leftRightMove"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">实现左右移动</span></strong></p>
<p>掌握了炸弹人动画的技术后，我就开始尝试将移动与动画结合，实现炸弹人在画布上左右移动的动画。</p>
<p>考虑到PlayerSprite负责炸弹人的绘制，因此应该在PlayerSprite中实现炸弹人的左右移动。</p>
<p>PlayerSprite</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('f5ea145e-4a50-48f8-b512-e797bd69d657')"><img id="code_img_closed_f5ea145e-4a50-48f8-b512-e797bd69d657" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_f5ea145e-4a50-48f8-b512-e797bd69d657" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f5ea145e-4a50-48f8-b512-e797bd69d657',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_f5ea145e-4a50-48f8-b512-e797bd69d657" class="cnblogs_code_hide">
<pre><span style="color: #000000;">Init: function (data) {
            </span><span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
            </span><span style="color: #0000ff;">this</span>.y =<span style="color: #000000;"> data.y;

            </span><span style="color: #0000ff;">this</span>.speedX =<span style="color: #000000;"> data.speedX;
            </span><span style="color: #0000ff;">this</span>.speedY =<span style="color: #000000;"> data.speedY;

            </span><span style="color: #008000;">//</span><span style="color: #008000;">x/y坐标的最大值和最小值, 可用来限定移动范围.</span>
            <span style="color: #0000ff;">this</span>.minX =<span style="color: #000000;"> data.minX;
            </span><span style="color: #0000ff;">this</span>.maxX =<span style="color: #000000;"> data.maxX;
            </span><span style="color: #0000ff;">this</span>.minY =<span style="color: #000000;"> data.minY;
            </span><span style="color: #0000ff;">this</span>.maxY =<span style="color: #000000;"> data.maxY;

            </span><span style="color: #0000ff;">this</span>.defaultAnimId =<span style="color: #000000;"> data.defaultAnimId;
            </span><span style="color: #0000ff;">this</span>.anims =<span style="color: #000000;"> data.anims;

            </span><span style="color: #008000;">//</span><span style="color: #008000;">设置当前Animation</span>
            <span style="color: #0000ff;">this</span>.setAnim(<span style="color: #0000ff;">this</span><span style="color: #000000;">.defaultAnimId);
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标</span>
            x: <span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            speedX: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            speedY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            </span><span style="color: #008000;">//</span><span style="color: #008000;">精灵的坐标区间</span>
            minX: <span style="color: #800080;">0</span><span style="color: #000000;">,
            maxX: </span><span style="color: #800080;">9999</span><span style="color: #000000;">,
            minY: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            maxY: </span><span style="color: #800080;">9999</span><span style="color: #000000;">,

            ...

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新精灵当前状态.</span>
<span style="color: #000000;">            update: function (deltaTime) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">每次循环,改变一下绘制的坐标</span>
                <span style="color: #0000ff;">this</span>.x = <span style="color: #0000ff;">this</span>.x + <span style="color: #0000ff;">this</span>.speedX *<span style="color: #000000;"> deltaTime;
                </span><span style="color: #008000;">//</span><span style="color: #008000;">限定移动范围</span>
                <span style="color: #0000ff;">this</span>.x = Math.max(<span style="color: #0000ff;">this</span>.minX, Math.min(<span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.maxX));

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.update(deltaTime);
                }
            },
            draw: function (context) {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
                    </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">要加上图片的宽度/高度</span>
                    context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #0000ff;">this</span>.maxX + frame.imgWidth, <span style="color: #0000ff;">this</span>.maxY +<span style="color: #000000;"> frame.imgHeight);
                    context.drawImage(</span><span style="color: #0000ff;">this</span>.currentAnim.getImg(), frame.x, frame.y, frame.width, frame.height, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y, frame.imgWidth, frame.imgHeight);
                }

　　　　　　　　　 </span><span style="color: #008000;">//</span><span style="color: #008000;">如果做到最右侧,则折向左走,如果走到最左侧,则向右走.
                </span><span style="color: #008000;">//</span><span style="color: #008000;">通过改变speedX的正负,来改变移动的方向.</span>
                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.x &gt;= <span style="color: #0000ff;">this</span><span style="color: #000000;">.maxX) {
                    </span><span style="color: #0000ff;">this</span>.speedX = -<span style="color: #0000ff;">this</span><span style="color: #000000;">.speedX;
                    </span><span style="color: #0000ff;">this</span>.setAnim(<span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.x &lt;= <span style="color: #0000ff;">this</span><span style="color: #000000;">.minX) {
                    </span><span style="color: #0000ff;">this</span>.speedX = -<span style="color: #0000ff;">this</span><span style="color: #000000;">.speedX;
                    </span><span style="color: #0000ff;">this</span>.setAnim(<span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            }      
}   </span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h1>重构PlayerSprite</h1>
<h2>分离职责</h2>
<p>现在draw方法既负责炸弹人绘制，又负责炸弹人移动方向的判断，显然违反了单一原则。因此，我将炸弹人移动方向的判断提出来成为一个新方法。</p>
<h2>方法的名字</h2>
<p>该方法应该叫什么名字呢？</p>
<p>这是一个值得认真思考的问题，方法的命名应该体现它的职责。</p>
<p>它的职责是判断方向与更新动画，那它的名字似乎就应该叫judgeDirAndSetAnim吗？</p>
<p>等等！现在它有两个职责：判断方向、更新动画，那么是不是应该分成两个方法：judgeDir、setAnim呢？</p>
<p>再仔细想想，这两个职责又是紧密关联的，因此不应该将其分开。</p>
<p>让我们换个角度，从更高的层面来分析。从调用PlayerSprite的Game类来看，这个职责应该属于一个更大的职责:</p>
<p>处理本次循环的逻辑，更新到下一次循环的初始状态。</p>
<p>因此，我将名字暂定为handleNext，以后在PlayerSprite中属于本循环逻辑的内容都可以放到handleNext。</p>
<p>可能有人会觉得handleNext名字好像也比较别扭。没关系，在后期的迭代中我们能根据实际情况和反馈再来修改，别忘了我们有测试作为保障！</p>
<h2>重构后的PlayerSprite的相关代码</h2>
<div class="cnblogs_code">
<pre><span style="color: #000000;">draw: function (context) {
    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim) {
        </span><span style="color: #0000ff;">var</span> frame = <span style="color: #0000ff;">this</span><span style="color: #000000;">.currentAnim.getCurrentFrame();

        </span><span style="color: #008000;">//</span><span style="color: #008000;">要加上图片的宽度/高度</span>
        context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #0000ff;">this</span>.maxX + frame.imgWidth, <span style="color: #0000ff;">this</span>.maxY +<span style="color: #000000;"> frame.imgHeight);
        context.drawImage(</span><span style="color: #0000ff;">this</span>.currentAnim.getImg(), frame.x, frame.y, frame.width, frame.height, <span style="color: #0000ff;">this</span>.x, <span style="color: #0000ff;">this</span><span style="color: #000000;">.y, frame.imgWidth, frame.imgHeight);
    }
},
handleNext: function () {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">如果走到最右侧,则向左走；如果走到最左侧,则向右走.
    </span><span style="color: #008000;">//</span><span style="color: #008000;">通过改变speedX的正负,来改变移动的方向.</span>
    <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.x &gt;= <span style="color: #0000ff;">this</span><span style="color: #000000;">.maxX) {
        </span><span style="color: #0000ff;">this</span>.speedX = -<span style="color: #0000ff;">this</span><span style="color: #000000;">.speedX;
        </span><span style="color: #0000ff;">this</span>.setAnim(<span style="color: #800000;">"</span><span style="color: #800000;">walk_left</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.x &lt;= <span style="color: #0000ff;">this</span><span style="color: #000000;">.minX) {
        </span><span style="color: #0000ff;">this</span>.speedX = -<span style="color: #0000ff;">this</span><span style="color: #000000;">.speedX;
        </span><span style="color: #0000ff;">this</span>.setAnim(<span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }


}</span></pre>
</div>
<p><a name="draw"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">绘制地图和炸弹人</span></strong></p>
<p>&nbsp;现在，需要同时在页面上绘制地图和炸弹人，有以下两种方案可以考虑：</p>
<ul>
<li>同一个画布中绘制地图和炸弹人</li>
<li>使用两个画布，位于页面上同一区域，分别显示地图和炸弹人。绘制地图的画布位于绘制炸弹人画布的下面。</li>
</ul>
<p>对于第一种方案，因为炸弹人和地图在同一个画布中，因此绘制炸弹人时势必会影响到绘制地图。</p>
<p>对于第二种方案，绘制地图和绘制炸弹人是分开的，互不影响。这样就可以在游戏初始化时绘制一次地图，游戏主循环中只绘制炸弹人，不绘制地图。只有在地图发生改变时才需要绘制地图。这样可以提高游戏性能。</p>
<p>因此，采用第二种方案，在页面上定义地图画布和玩家画布，地图画布绘制地图，玩家画布绘制炸弹人。通过设置画布Canvas的z-index，使绘制地图的画布位于绘制玩家画布的下面。</p>
<h1>重构</h1>
<h2>增加PlayerLayer</h2>
<p>根据第2篇博文中分层渲染的概念以及第3篇博文中提出Layer的经验，我认为现在是时候提出PlayerLayer类了。</p>
<p>PlayerLayer负责统一管理它的集合内元素PlayerSprite。</p>
<p>PlayerLayer有draw和clear方法，负责绘制炸弹人和清除画布。</p>
<p>PlayerLayer与玩家画布对应。</p>
<h2>重构PlayerLayer</h2>
<h3>　　　　增加render方法</h3>
<p>结合第2篇博文的actor接口和Game类中重构出run方法的经验，PlayerLayer应该增加一个render方法，它负责游戏主循环中PlayerLayer层的逻辑。这样在Game的主循环中，就只需要知道render方法就行了，而不用操心在循环中PlayerLayer层有哪些逻辑操作。</p>
<h3>　　　　Layer中创建canvas</h3>
<p>再来看看&ldquo;在Game中创建canvas，然后把canvas注入到Layer中&rdquo;的行为。</p>
<p>我注意到canvas与层密切相关，所以应该由层来负责canvas的创建。</p>
<h3>　　　　Collection.js采用迭代器模式</h3>
<p>由于PlayerLayer层中的draw方法需要调用层内每个元素的draw方法，这就让我想到了迭代器模式。因此，使用迭代器模式对Collection类重构。</p>
<p>Collection重构后：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">*使用迭代器模式</span>

    <span style="color: #0000ff;">var</span> IIterator = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">hasNext</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">next</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">resetCursor</span><span style="color: #800000;">"</span><span style="color: #000000;">);


    </span><span style="color: #0000ff;">var</span> Collection =<span style="color: #000000;"> YYC.AClass({Interface: IIterator}, {
        Private: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">当前游标</span>
            _cursor: <span style="color: #800080;">0</span><span style="color: #000000;">,
            </span><span style="color: #008000;">//</span><span style="color: #008000;">容器</span>
<span style="color: #000000;">            _childs: []
        },
        Public: {
            getChilds: function () {
                </span><span style="color: #0000ff;">return</span> YYC.Tool.array.clone(<span style="color: #0000ff;">this</span><span style="color: #000000;">._childs);
            },
            appendChild: function (child) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._childs.push(child);

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">;
            },
            hasNext: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._cursor === <span style="color: #0000ff;">this</span><span style="color: #000000;">._childs.length) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            },
            next: function () {
                </span><span style="color: #0000ff;">var</span> result = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasNext()) {
                    result </span>= <span style="color: #0000ff;">this</span>._childs[<span style="color: #0000ff;">this</span><span style="color: #000000;">._cursor];
                    </span><span style="color: #0000ff;">this</span>._cursor += <span style="color: #800080;">1</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    result </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
            },
            resetCursor: function () {
                </span><span style="color: #0000ff;">this</span>._cursor = <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        },
        Abstract: {
        }
    });

    window.Collection </span>=<span style="color: #000000;"> Collection;
}());</span></pre>
</div>
<p>PlayeLayer中使用迭代器调用每个元素的draw方法：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">            draw: function (context) {
                </span><span style="color: #0000ff;">var</span> nextElement = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasNext()) {
                    nextElement </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.next();
                    nextElement.draw.apply(nextElement, [context]);  </span><span style="color: #008000;">//</span><span style="color: #008000;">要指向nextElement</span>
<span style="color: #000000;">                }

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.resetCursor();
            },</span></pre>
</div>
<h2>有必要用迭代器模式吗？</h2>
<h3>&nbsp;　　设计过度？</h3>
<p>有同学可能要问：这里PlayerLayer的元素明明就只有一个（即炸弹人精灵类PlayerSprite），为什么要遍历集合呢？直接把PlayerSprite作为PlayerLayer的一个属性，使PlayerLayer保持对PlayerSprite的引用，不是也能更简单地使PlayerLayer操作PlayerSprite了吗？</p>
<p>确实，目前来看是没必要遍历集合的。而且根据敏捷思想，只要实现现有需求就好了，保持简单。但是，开发炸弹人游戏并不是为了商用，而是为了学习知识。</p>
<p>我对迭代器模式不是很熟悉，并且考虑到以后在创建EnemyLayer时，会包括多个敌人精灵，那时也会需要遍历集合。</p>
<p>因此，此处我用了迭代器模式，在PlayerLayer中遍历集合。</p>
<p>迭代器模式请详见<strong><span style="font-size: 16px;"><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3342274.html">Javascript设计模式之我见：迭代器模式</a></span></strong>。</p>
<h2><span style="color: #000000;">将原Layer重命名为MapLayer</span></h2>
<p><span style="color: #000000;">再来看看之前第3篇博文中创建的Layer类。这个类负责地图图片的渲染，应该将其重命名为MapLayer地图层。</span></p>
<h2>提出父类Layer</h2>
<p>现在有了PlayerLayer和MapLayer类后，需要将其通用操作提出来形成父类Layer类，然后由Layer类来继承Collection类。这样PlayerLayer和MapLayer类也就具有集合类的功能了。</p>
<h2>重构Layer</h2>
<h3>　　增加change 状态</h3>
<p>&nbsp;在上面的实现中，在游戏主循环中每次循环都会绘制一遍地图和炸弹人。考虑到地图是没有变化的，没必要重复的绘制相同的地图；而且如果炸弹人在画布上站到不动时，也是没有必要重复绘制炸弹人。</p>
<p>所以为了提升画布的性能，当只有画布内容发生变化时（如改变地图、炸弹人移动），才绘制画布。</p>
<p>因此，在Layer中增加state属性，该属性有两个枚举值：change、normal，用来标记画布改变和没有改变的状态。</p>
<p>在绘制画布时先判断Layer的state状态，如果为change，则绘制；否则则不绘制。</p>
<h3>　　在哪里判断？</h3>
<p>应该在绘制画布的地方判断状态。那么应该是在Game的游戏主循环中判断，还是在Layer的render中判断呢？</p>
<p>还是从职责上分析。</p>
<p>Layer的职责：负责层内元素的统一管理。</p>
<p>Game的职责：负责游戏逻辑。</p>
<p>显然判断状态的职责应该属于Layer的职责，且与Layer的render方法最相关。所以应该在Layer的render中判断。</p>
<h3>　　什么时候改变state状态为change，什么时候为normal？</h3>
<p>应该在画布内容发生改变时，画布需要重绘的时候改变state为change，然后在重绘完后，再回复状态为normal。</p>
<h2><span style="color: #000000;">领域模型</span></h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/03081226-8f8ea4264de847dbb39729d6b2602d90.jpg" alt="" /></p>
<h2>相关代码</h2>
<p>Layer</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('ee84ca49-acf0-41ef-89a4-fa6db446238c')"><img id="code_img_closed_ee84ca49-acf0-41ef-89a4-fa6db446238c" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_ee84ca49-acf0-41ef-89a4-fa6db446238c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('ee84ca49-acf0-41ef-89a4-fa6db446238c',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_ee84ca49-acf0-41ef-89a4-fa6db446238c" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Layer =<span style="color: #000000;"> YYC.AClass(Collection, {
        Init: function () {
        },
        Private: {
            __state: bomberConfig.layer.state.NORMAL,

            __getContext: function () {
                </span><span style="color: #0000ff;">this</span>.P__context = <span style="color: #0000ff;">this</span>.P__canvas.getContext(<span style="color: #800000;">"</span><span style="color: #800000;">2d</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        },
        Protected: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">*子类使用的变量（可读、写）</span>
<span style="color: #000000;">            
            P__canvas: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            P__context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            P__isChange: function(){
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.__state ===<span style="color: #000000;"> bomberConfig.layer.state.CHANGE;
            },
            P__isNormal: function () {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.__state ===<span style="color: #000000;"> bomberConfig.layer.state.NORMAL;
            },
            P__setStateNormal: function () {
                </span><span style="color: #0000ff;">this</span>.__state =<span style="color: #000000;"> bomberConfig.layer.state.NORMAL;
            },
            P__setStateChange: function () {
                </span><span style="color: #0000ff;">this</span>.__state =<span style="color: #000000;"> bomberConfig.layer.state.CHANGE;
            },

            Abstract: {
                P__createCanvas: function () { }
            }
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">更改状态</span>
<span style="color: #000000;">            change: function () {
                </span><span style="color: #0000ff;">this</span>.__state =<span style="color: #000000;"> bomberConfig.layer.state.CHANGE;
            },
            setCanvas: function (canvas) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (canvas) {
                    </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">YYC.Tool.canvas.isCanvas(canvas)) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">参数必须为canvas元素</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                    </span><span style="color: #0000ff;">this</span>.P__canvas =<span style="color: #000000;"> canvas;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">子类实现</span>
                    <span style="color: #0000ff;">this</span><span style="color: #000000;">.P__createCanvas();
                }
            },
            clear: function () {
                </span><span style="color: #0000ff;">this</span>.P__context.clearRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, bomberConfig.canvas.WIDTH, bomberConfig.canvas.HEIGHT);
            },

            Virtual: {
                init: function () {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.__getContext();
                }
            }
        },
        Abstract: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">统一绘制</span>
<span style="color: #000000;">            draw: function () { },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">渲染到画布上</span>
<span style="color: #000000;">            render: function () { }
        }
    });

    window.Layer </span>=<span style="color: #000000;"> Layer;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="line-height: 1.5;">MapLayer</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('7648f6c2-99bb-4731-8ed2-73d0a653bdb4')"><img id="code_img_closed_7648f6c2-99bb-4731-8ed2-73d0a653bdb4" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_7648f6c2-99bb-4731-8ed2-73d0a653bdb4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('7648f6c2-99bb-4731-8ed2-73d0a653bdb4',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_7648f6c2-99bb-4731-8ed2-73d0a653bdb4" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> MapLayer =<span style="color: #000000;"> YYC.Class(Layer, {
        Init: function () {
        },
        Protected: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">实现父类的抽象保护方法</span>
<span style="color: #000000;">            P__createCanvas: function () {
                </span><span style="color: #0000ff;">var</span> canvas = $(<span style="color: #800000;">"</span><span style="color: #800000;">&lt;canvas/&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">, {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">id: id,</span>
<span style="color: #000000;">                    width: bomberConfig.canvas.WIDTH.toString(),
                    height: bomberConfig.canvas.HEIGHT.toString(),
                    css: {
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">border</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">1px solid blue</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">0</span><span style="color: #000000;">
                    }
                });
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">body</span><span style="color: #800000;">"</span><span style="color: #000000;">).append(canvas);

                </span><span style="color: #0000ff;">this</span>.P__canvas = canvas[<span style="color: #800080;">0</span><span style="color: #000000;">];
            }
        },
        Public: {
            draw: function () {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                    imgs </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                imgs </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.getChilds();

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = imgs.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context.drawImage(imgs[i].img, imgs[i].x, imgs[i].y, imgs[i].width, imgs[i].height);
                }
            },
            render: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__isChange()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.clear();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.draw();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__setStateNormal();
                }
            }
        }
    });

    window.MapLayer </span>=<span style="color: #000000;"> MapLayer;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>PlayerLayer</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('a79f0b84-9a0f-4ad6-9555-addd01e9ad64')"><img id="code_img_closed_a79f0b84-9a0f-4ad6-9555-addd01e9ad64" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_a79f0b84-9a0f-4ad6-9555-addd01e9ad64" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a79f0b84-9a0f-4ad6-9555-addd01e9ad64',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_a79f0b84-9a0f-4ad6-9555-addd01e9ad64" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> PlayerLayer =<span style="color: #000000;"> YYC.Class(Layer, {
        Init: function (deltaTime) {
            </span><span style="color: #0000ff;">this</span>.___deltaTime =<span style="color: #000000;"> deltaTime;
        },
        Private: {
            ___deltaTime: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            ___iterator: function (handler) {
                </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span><span style="color: #000000;">),
                    nextElement </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasNext()) {
                    nextElement </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.next();
                    nextElement[handler].apply(nextElement, args);  </span><span style="color: #008000;">//</span><span style="color: #008000;">要指向nextElement</span>
<span style="color: #000000;">                }
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.resetCursor();
            },
            ___update: function (deltaTime) {
                </span><span style="color: #0000ff;">this</span>.___iterator(<span style="color: #800000;">"</span><span style="color: #800000;">update</span><span style="color: #800000;">"</span><span style="color: #000000;">, deltaTime);
            },
            ___handleNext: function () {
                </span><span style="color: #0000ff;">this</span>.___iterator(<span style="color: #800000;">"</span><span style="color: #800000;">handleNext</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        },
        Protected: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">实现父类的抽象保护方法</span>
<span style="color: #000000;">            P__createCanvas: function () {
                </span><span style="color: #0000ff;">var</span> canvas = $(<span style="color: #800000;">"</span><span style="color: #800000;">&lt;canvas/&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">, {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">id: id,</span>
<span style="color: #000000;">                    width: bomberConfig.canvas.WIDTH.toString(),
                    height: bomberConfig.canvas.HEIGHT.toString(),
                    css: {
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">position</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">absolute</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">top</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.TOP,
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span><span style="color: #000000;">: bomberConfig.canvas.LEFT,
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">border</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">1px solid red</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">z-index</span><span style="color: #800000;">"</span>: <span style="color: #800080;">1</span><span style="color: #000000;">
                    }
                });
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">body</span><span style="color: #800000;">"</span><span style="color: #000000;">).append(canvas);

                </span><span style="color: #0000ff;">this</span>.P__canvas = canvas[<span style="color: #800080;">0</span><span style="color: #000000;">];
            }
        },
        Public: {
            draw: function (context) {
                </span><span style="color: #0000ff;">this</span>.___iterator(<span style="color: #800000;">"</span><span style="color: #800000;">draw</span><span style="color: #800000;">"</span><span style="color: #000000;">, context);
            },
            render: function () {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__isChange()) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.clear();
                    </span><span style="color: #0000ff;">this</span>.___update(<span style="color: #0000ff;">this</span><span style="color: #000000;">.___deltaTime);
                    </span><span style="color: #0000ff;">this</span>.draw(<span style="color: #0000ff;">this</span><span style="color: #000000;">.P__context);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.___handleNext();
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P__setStateNormal();
                }
            }
        }
    });

    window.PlayerLayer </span>=<span style="color: #000000;"> PlayerLayer;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h2>增加LayerFactory</h2>
<p>增加LayerFactory工厂，负责创建PlayerLayer和MapLayer类的实例。</p>
<p>LayerFactory</p>
<div class="cnblogs_code">
<pre><span>(function () {
    </span><span>var</span> layerFactory =<span> {
        createMap: function () {
            </span><span>return</span> <span>new</span><span> MapLayer();
        },
        createPlayer: function (deltaTime) {
            </span><span>return</span> <span>new</span><span> PlayerLayer(deltaTime);
        }
    }

    window.layerFactory </span>=<span> layerFactory;
}());</span></pre>
</div>
<h2>分离出了LayerManager类</h2>
<p>回顾Game类，它做的事情太多了。</p>
<p>精灵类、Bitmap都是属于层的集合元素，因此由层来负责创建他们。</p>
<p>但是根据之前的分析，层的职责是负责统一管理层内元素，不应该给它增加创建元素的职责。</p>
<p>而且，现在Game中负责创建和管理两个层，这两个层在Game中的行为相似。</p>
<p>基于以上分析和参照了网上资料，我提出层管理类的概念。</p>
<h3>　　层管理类的职责</h3>
<p>负责层的逻辑</p>
<h3>　　与层的区别</h3>
<p>调用层面不一样。层是处理精灵的逻辑，它的元素为精灵。层管理是处理层的逻辑，它的元素为层。<span>一个层对应一个层管理类，</span>再把每一个层管理类中的通用行为提取出来，形成层管理类的父类。</p>
<p>因此，我提出了PlayerLayerManager、MapLayerManager、LayerManager类。</p>
<h3><span style="color: #000000;">　　领域模型</span></h3>
<p><img src="http://images.cnitblog.com/blog/419321/201310/07140511-afe7c2c4d268431c8a33622b328f44ac.jpg" alt="" /></p>
<h3>　　相关代码</h3>
<p>LayerManager</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> LayerManager =<span style="color: #000000;"> YYC.AClass({
        Init: function (layer) {
            </span><span style="color: #0000ff;">this</span>.layer =<span style="color: #000000;"> layer;
        },
        Private: {
        },
        Public: {
            layer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            addElement: function (element) {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = element.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.appendChild(element[i]);
                }
            },
            initLayer: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.setCanvas();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.init();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.layer.change();<br /></span><span style="color: #000000;">
            },
            render: function () {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.render();
            }
        },
        Abstract: {
            createElement: function () {
            }
        }
    });</span></pre>
</div>
<p>PlayerLayerManager</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> PlayerLayerManager =<span style="color: #000000;"> YYC.Class(LayerManager, {
        Init: function (layer) {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base(layer);
        },
        Private: {
        },
        Public: {
            createElement: function () {
                </span><span style="color: #0000ff;">var</span> element =<span style="color: #000000;"> [],
                     player </span>=<span style="color: #000000;"> spriteFactory.createPlayer();

                player.setAnim(</span><span style="color: #800000;">"</span><span style="color: #800000;">walk_right</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                element.push(player);

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
            }
        }
    });</span></pre>
</div>
<p>MapLayerManager</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> MapLayerManager =<span style="color: #000000;"> YYC.Class(LayerManager, {
        Init: function (layer) {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base(layer);
        },
        Private: {
            __getMapImg: function (i, j, mapData) {
                </span><span style="color: #0000ff;">var</span> img = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (mapData[i][j]) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">1</span><span style="color: #000000;">:
                        img </span>= window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">2</span><span style="color: #000000;">:
                        img </span>= window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> img;
            }
        },
        Public: {
            createElement: function () {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                   j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
                   map </span>=<span style="color: #000000;"> bomberConfig.map,
                   element </span>=<span style="color: #000000;"> [],
                   mapData </span>=<span style="color: #000000;"> mapDataOperate.getMapData(),
                   img </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; map.ROW; i++<span style="color: #000000;">) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">注意！
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">y为纵向height，x为横向width</span>
                    y = i *<span style="color: #000000;"> bomberConfig.HEIGHT;

                    </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; map.COL; j++<span style="color: #000000;">) {
                        x </span>= j *<span style="color: #000000;"> bomberConfig.WIDTH;
                        img </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.__getMapImg(i, j, mapData);
                        element.push(bitmapFactory.createBitmap({ img: img, width: bomberConfig.WIDTH, height: bomberConfig.HEIGHT, x: x, y: y }));
                    }
                }

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> element;
            }
        }
    });</span></pre>
</div>
<p>Game</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('2f819680-e86c-495c-9157-a7c9c4a4fe72')"><img id="code_img_closed_2f819680-e86c-495c-9157-a7c9c4a4fe72" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_2f819680-e86c-495c-9157-a7c9c4a4fe72" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2f819680-e86c-495c-9157-a7c9c4a4fe72',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_2f819680-e86c-495c-9157-a7c9c4a4fe72" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Game =<span style="color: #000000;"> YYC.Class({
        Init: function () {
        },
        Private: {
            _layerManager: [],

            _createLayer: function () {
                </span><span style="color: #0000ff;">this</span>.mapLayer =<span style="color: #000000;"> layerFactory.createMap();
                </span><span style="color: #0000ff;">this</span>.playerLayer = layerFactory.createPlayer(<span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep);
            },
            _createLayerManager: function () {
                </span><span style="color: #0000ff;">this</span>._layerManager.push(<span style="color: #0000ff;">new</span> MapLayerManager(<span style="color: #0000ff;">this</span><span style="color: #000000;">.mapLayer));
                </span><span style="color: #0000ff;">this</span>._layerManager.push(<span style="color: #0000ff;">new</span> PlayerLayerManager(<span style="color: #0000ff;">this</span><span style="color: #000000;">.playerLayer));
            },
            _initLayer: function () {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = <span style="color: #0000ff;">this</span>._layerManager.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>._layerManager[i].addElement(<span style="color: #0000ff;">this</span><span style="color: #000000;">._layerManager[i].createElement());
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._layerManager[i].initLayer();
                }
            }
        },
        Public: {
            context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            sleep: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            x: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

            mapLayer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            playerLayer: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            init: function () {
                </span><span style="color: #0000ff;">this</span>.sleep = Math.floor(<span style="color: #800080;">1000</span> /<span style="color: #000000;"> bomberConfig.FPS);

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._createLayer();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._createLayerManager();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._initLayer();
            },
            start: function () {
                </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">var</span> mainLoop =<span style="color: #000000;"> window.setInterval(function () {
                    self.run();
                }, </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.sleep);
            },
            run: function () {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                            len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = <span style="color: #0000ff;">this</span>._layerManager.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._layerManager[i].render();
                }
            }
        }
    });

    window.Game </span>=<span style="color: #000000;"> Game;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><span style="color: #c0c0c0;"><a name="model"></a></span></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文最终领域模型</span></strong></p>
<p><img src="http://images.cnitblog.com/blog/419321/201310/17190052-1a593928f60a490892d2d01b4fc526be.jpg" alt="" width="826" height="451" /></p>
<p><a name="layer"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">高层划分</span></strong></p>
<h1><span style="color: #000000;">重构层</span></h1>
<p>经过本文的开发后，实际的概念<span>层次结构为：</span></p>
<p><img src="http://images.cnitblog.com/blog/419321/201310/07193846-31de3d76017e401d8f425b41d69fc807.jpg" alt="" width="160" height="404" /></p>
<p>其中，入口对应用户交互层，主逻辑、层管理、层、精灵对应业务逻辑层，数据操作对应数据操作层，数据对应数据层。</p>
<p><span style="color: #000000;">受此启发，可以将业务逻辑层细化为主逻辑、层管理、层、精灵四个层。</span></p>
<p><span style="color: #000000;">另外，领域模型中的工厂类属于业务逻辑层，它与其它四个层中的层管理和层有关联，且不属于其它四个层。因此，在业务逻辑层中提出负责通用操作的辅助逻辑层，将工厂类放到该层中。</span></p>
<h2><span style="color: #000000;">重构后的层</span></h2>
<h1><img src="http://images.cnitblog.com/blog/419321/201310/17200130-b2070900c30649909659c202b4959649.jpg" alt="" width="611" height="659" /></h1>
<h1>层、领域模型</h1>
<h1><img src="http://images.cnitblog.com/blog/419321/201310/17190610-ffa37fb83ca24e2ab1840179e9ad3083.jpg" alt="" width="808" height="1147" /></h1>
<h1>提出包</h1>
<h2><span>包和组件的设计原则</span></h2>
<h3><span>　　</span>内聚</h3>
<ul>
<li>
<h4><span>重用发布等价原则（REP）</span>&nbsp;</h4>
</li>
</ul>
<p>重用的粒度就是发布的粒度：一个包中的软件要么都是可重用的，要么都是不可重用的。</p>
<ul>
<li>
<h4><span>共同重用原则（CRP）</span></h4>
</li>
</ul>
<p>一个包中所有类应该是共同重用的。如果重用了包中的一个类，那么就重用包中的所有类。</p>
<ul>
<li>
<h4><span>共同封闭原则（CCP）</span></h4>
</li>
</ul>
<p>包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对包中的所有类产生影响，而对于其他的包不造成任何影响。</p>
<h3><span>　　耦合</span>&nbsp;</h3>
<ul>
<li>
<h4><span>无环依赖原则（ADP）</span>&nbsp;</h4>
</li>
</ul>
<p>在包的依赖图中，不允许存在环。</p>
<ul>
<li>
<h4><span>稳定依赖原则（SDP）</span></h4>
</li>
</ul>
<p>朝着稳定的方向进行依赖。</p>
<ul>
<li>
<h4><span>稳定抽象原则（SAP）</span></h4>
</li>
</ul>
<p>包的抽象程度应该和其稳定程度一致。</p>
<h3><span>本文包划分</span></h3>
<p><span style="color: #ff0000;"><img src="http://images.cnitblog.com/blog/419321/201310/17191111-bb30980185774f628e1b1140dfae554e.jpg" alt="" width="744" height="1149" /></span></p>
<h2>对应领域模型</h2>
<ul>
<li>辅助操作层
<ul>
<li>控件包<br />PreLoadImg</li>
<li>配置包<br />Config</li>


























</ul>


























</li>
<li>用户交互层
<ul>
<li>入口包<br />Main</li>


























</ul>


























</li>
<li>业务逻辑层
<ul>
<li style="list-style-type: none;">辅助逻辑
<ul>
<li>工厂包<br />BitmapFactory、LayerFactory、SpriteFactory</li>


























</ul>


























</li>
<li style="list-style-type: none;">游戏主逻辑
<ul>
<li>主逻辑包<br />Game</li>


























</ul>


























</li>
<li style="list-style-type: none;">层管理
<ul>
<li>层管理实现包<br />PlayerLayerManager、MapLayerManager</li>
<li>层管理抽象包</li>
<li>LayerManager</li>


























</ul>


























</li>
<li style="list-style-type: none;">层
<ul>
<li>层实现包<br />PlayerLayer、MapLayer</li>
<li>层抽象包<br />Layer</li>
<li>集合包<br />Collection</li>


























</ul>


























</li>
<li style="list-style-type: none;">精灵
<ul>
<li>精灵包<br />PlayerSprite</li>
<li>动画包<br />Animation、GetSpriteData、SpriteData、GetFrames、FrameData</li>


























</ul>


























</li>


























</ul>


























</li>
<li>数据操作层
<ul>
<li>地图数据操作包<br />MapDataOperate</li>
<li>路径数据操作包<br />GetPath</li>
<li>图片数据操作包<br />Bitmap</li>


























</ul>


























</li>
<li>数据层
<ul>
<li>地图包<br />MapData</li>
<li>图片路径包<br />ImgPathData</li>

















</ul>

















</li>

















</ul>
<h3 style="margin-left: 30px;"><span style="color: #c0c0c0;"><span style="color: #000000;">Animation为什么与GetSpriteData、SpriteData、GetFrames、FrameData放在一起？</span></span></h3>
<p><span style="color: #c0c0c0;"><span style="color: #000000;">虽然从封闭性上分析，GetSpriteData、SpriteData、GetFrames、FrameData对于精灵数据的变化会一起变化，而Animation不会一起变化，Animation应该对于动画逻辑的变化而变化。因此，Animation与GetSpriteData、SpriteData、GetFrames、FrameData不满足共同封闭原则。</span></span></p>
<p><span style="color: #c0c0c0;"><span style="color: #000000;">但是，因为Animation与其它四个类紧密相关，可以一起重用。</span></span></p>
<p><span style="color: #c0c0c0;"><span style="color: #000000;">因此还是将Animation和GetSpriteData、SpriteData、GetFrames、FrameData都一起放到动画包中。</span></span></p>
<p><a name="demo"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文参考资料</span></strong></p>
<p>《敏捷软件开发:原则、模式与实践》&nbsp;</p>
<p><a href="http://v.youku.com/v_show/id_XMjU2NzEyNzgw.html?f=5711740">HTML5研究小组第二期技术讲座《手把手制作HTML5游戏》</a></p>
<p><a href="http://www.iteye.com/topic/1122395">完全分享，共同进步&mdash;&mdash;我开发的第一款HTML5游戏《驴子跳》</a></p>
<h1>欢迎浏览上一篇博文：<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3175811.html">炸弹人游戏开发系列（3）：显示地图</a></h1>
<h1>欢迎浏览下一篇博文：<a id="CategoryEntryList1_EntryStoryList_Entries_TitleUrl_0" class="entrylistItemTitle" href="http://www.cnblogs.com/chaogex/p/3265119.html">炸弹人游戏开发系列（5）：控制炸弹人移动，引入状态模式</a></h1>]]></description></item><item><title>炸弹人游戏开发系列（3）：显示地图</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/17/3175811.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Thu, 17 Oct 2013 03:45:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/17/3175811.html</guid><description><![CDATA[<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">前言</span></strong></p>
<p>上文我们进行了初步的高层设计，现在我们将实现图片预加载和显示地图的功能需求。我采用TDD开发，大家可以看到在实现的过程中我们会修改设计，修改设计后又会修改对应的实现代码，这是一个不断迭代的过程。在有测试套件的保护下，我们可以放心地重构。</p>
<h1>本文目的</h1>
<p>掌握地图绘制的技术。</p>
<h1>本文主要内容</h1>
<ul>
<li><span style="color: #000000;"><a href="#strategy">开发策略</a></span></li>
<li><span style="color: #000000;"><a href="#preLoad">预加载图片</a></span></li>
<li><span style="color: #000000;"><a href="#showMap">显示地图</a></span></li>
<li><span style="color: #000000;"><a href="#refactor">重构</a></span></li>
<li><span style="color: #000000;"><a href="#continue">继续实现显示地图</a></span></li>
<li><span style="color: #000000;"><a href="#model">本文最终领域模型</a></span></li>
<li><span style="color: #000000;"><a href="#layer">高层划分</a></span></li>
<li><span style="color: #000000;"><a href="#demo">演示</a></span></li>
<li><span style="color: #000000;"><a href="#reference">本文参考资料</a></span></li>
</ul>
<h1>回顾上文与显示地图相关的领域模型</h1>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/419321/201307/16205826-e5cf224f53464972a3d10f585a493b05.jpg" alt="" />&nbsp;</p>
<p><a name="strategy"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">开发策略</span></strong></p>
<p><span style="color: #000000;">使用我的控件<a href="http://www.cnblogs.com/chaogex/p/3203061.html">YPreLoadImg</a>来实现图片预加载，结合progressBar插件，能够显示出加载进度条。</span></p>
<p>只建一个ShowMap类，用这个类来进行实验，找到显示地图的方法，然后在重构的时候再分离出Main类和MapData数据类。</p>
<h1>原因</h1>
<ul>
<li>因为我对canvas很不熟悉，需要先集中精力熟悉canvas的使用，而不是把精力放在架构设计上。</li>
<li>因为我是采用TDD开发，因此可以安全地进行重构。可以在实现&ldquo;显示地图&rdquo;功能后，再在重构时提炼出Main和MapData类。</li>
</ul>
<h1>开发策略也是迭代修正的</h1>
<p>开发策略只是就当前的知识指定的大概计划，会随着开发的进行而进行细化和修正。如现在的开发策略并没有考虑到在重构时会增加Game类。</p>
<p><a name="preLoad"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">预加载图片</span></strong></p>
<h1>预加载的目的</h1>
<p>将图片下载到本地内存中。</p>
<h1>为什么要预加载</h1>
<ul>
<li><span>必须等到图片完全加载后才能使用canvas对图片进行操作。如果试图在图片未完全加载之前就将其呈现到canvas上，那么canvas将不会显示任何图片。</span></li>
<li>如果不使用预加载，则在使用图片之前需要先下载图片到本地。即使有浏览器优化，第一次使用图片时也需要先下载图片，这样在第一次使用图片时，会有卡的感觉。</li>
</ul>
<p>因此，在游戏开始之前，先要进行游戏初始化，预加载游戏所需的图片。</p>
<h1>如何进行预加载</h1>
<p>基本示例：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> img = <span style="color: #0000ff;">new</span> Image();    <span style="color: #008000;">//</span><span style="color: #008000;">创建一个图片对象</span>
img.src = <span style="color: #800000;">"</span><span style="color: #800000;">test.png</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;">下载该路径的图片 </span>
img.onload = function () { <span style="color: #008000;">//</span><span style="color: #008000;">图片下载完毕时异步调用callback函数。 </span>
<span style="color: #000000;">    callback(img); 
};</span></pre>
</div>
<h1><span style="line-height: 1.5;">预加载网上教程</span></h1>
<ul>
<li><a href="http://liboxlu.iteye.com/blog/796582">js图片预加载</a></li>
<li><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/carekee/articles/1917612.html">js 实现图片预加载</a></li>
<li><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/carekee/articles/1917612.html"></a><a href="http://www.cr173.com/html/11482_1.html">浏览器重图片的预加载问题onload事件</a></li>
</ul>
<h1>显示进度条</h1>
<p><a href="http://www.cnblogs.com/chaogex/p/3203061.html">YPreLoadImg</a>控件结合进度条插件progressbar，可以显示出进度条。</p>
<h1>新增ShowMap类并实现预加载图片</h1>
<p>新增ShowMap类，使用TDD开发并实现预加载图片，需要先写测试用例。</p>
<p>这里先简单介绍下测试驱动开发的步骤：</p>
<ol>
<li>写一个测试用例，验证行为</li>
<li>运行测试，检查测试用例本身是否有错误（测试是否按自己所期望的方式失败）。</li>
<li>写实现代码，使得测试通过</li>
<li>重构代码</li>
<li>运行测试，使得测试通过</li>
</ol>
<h2>测试代码</h2>
<p>下面是关于预加载的测试代码（这里只是展示最后结果，实际开发中并不是一口气就先把测试代码写完然后就直接写实现代码了，而是每次先写验证一个行为的测试代码，然后再写相应的实现代码，然后再写验证下一个行为的测试代码，这样迭代开发）：</p>
<div class="cnblogs_code">
<pre>describe(<span style="color: #800000;">"</span><span style="color: #800000;">showMap.js</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {

    describe(</span><span style="color: #800000;">"</span><span style="color: #800000;">init</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {

        beforeEach(function () {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">不执行onload</span>
            spyOn(showMap, <span style="color: #800000;">"</span><span style="color: #800000;">onload</span><span style="color: #800000;">"</span><span style="color: #000000;">).andCallFake(function () {
            });
        });
        afterEach(function () {
        });
        it(</span><span style="color: #800000;">"</span><span style="color: #800000;">传入的参数为数组，数组元素包含id和url属性</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
            </span><span style="color: #0000ff;">var</span> urls =<span style="color: #000000;"> [];
            </span><span style="color: #0000ff;">var</span> temp =<span style="color: #000000;"> [];
            </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, len = <span style="color: #800080;">0</span><span style="color: #000000;">;
            spyOn(window.YYC.Control, </span><span style="color: #800000;">"</span><span style="color: #800000;">PreLoadImg</span><span style="color: #800000;">"</span><span style="color: #000000;">);

            temp </span>=<span style="color: #000000;"> [
                { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>, url: <span style="color: #800000;">"</span><span style="color: #800000;">ground.png</span><span style="color: #800000;">"</span><span style="color: #000000;"> },
                { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span>, url: <span style="color: #800000;">"</span><span style="color: #800000;">wall.png</span><span style="color: #800000;">"</span><span style="color: #000000;"> }
            ];

            </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = temp.length; i &lt; len; i++<span style="color: #000000;">) {
                urls.push({ id: temp[i].id, url: </span><span style="color: #800000;">"</span><span style="color: #800000;">../../../../Content/Bomber/Image/Map/</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> temp[i].url });
            }
            showMap.init();
            expect(YYC.Control.PreLoadImg).toHaveBeenCalled();
            expect(YYC.Control.PreLoadImg.calls[</span><span style="color: #800080;">0</span>].args[<span style="color: #800080;">0</span><span style="color: #000000;">]).toBeArray();
            expect(YYC.Control.PreLoadImg.calls[</span><span style="color: #800080;">0</span>].args[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span><span style="color: #000000;">].id).toBeDefined();
            expect(YYC.Control.PreLoadImg.calls[</span><span style="color: #800080;">0</span>].args[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span><span style="color: #000000;">].url).toBeDefined();
        });
    });
    describe(</span><span style="color: #800000;">"</span><span style="color: #800000;">onload</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        </span><span style="color: #0000ff;">var</span> dom = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        function insertDom() {
            dom </span>= $(<span style="color: #800000;">"</span><span style="color: #800000;">&lt;div id='progressBar'&gt;&lt;/div&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            $(</span><span style="color: #800000;">"</span><span style="color: #800000;">body</span><span style="color: #800000;">"</span><span style="color: #000000;">).append(dom);
        };
        function removeDom() {
            dom.remove();
        };
        beforeEach(function () {
            insertDom();
        });
        afterEach(function () {
            removeDom();
        });
        it(</span><span style="color: #800000;">"</span><span style="color: #800000;">加载完毕后，隐藏加载进度条</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
            expect($(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar</span><span style="color: #800000;">"</span>).css(<span style="color: #800000;">"</span><span style="color: #800000;">display</span><span style="color: #800000;">"</span>)).toEqual(<span style="color: #800000;">"</span><span style="color: #800000;">block</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            showMap.onload();
            expect($(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar</span><span style="color: #800000;">"</span>).css(<span style="color: #800000;">"</span><span style="color: #800000;">display</span><span style="color: #800000;">"</span>)).toEqual(<span style="color: #800000;">"</span><span style="color: #800000;">none</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        });
    });
});</span></pre>
</div>
<h2>实现代码</h2>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> showMap =<span style="color: #000000;"> (function () {
    </span><span style="color: #0000ff;">var</span> _getImg =<span style="color: #000000;"> function () {
        </span><span style="color: #0000ff;">var</span> urls =<span style="color: #000000;"> [];
        </span><span style="color: #0000ff;">var</span> temp =<span style="color: #000000;"> [];
        </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, len = <span style="color: #800080;">0</span><span style="color: #000000;">;

        temp </span>= [{ id: <span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>, url: <span style="color: #800000;">"</span><span style="color: #800000;">ground.png</span><span style="color: #800000;">"</span> }, { id: <span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span>, url: <span style="color: #800000;">"</span><span style="color: #800000;">wall.png</span><span style="color: #800000;">"</span><span style="color: #000000;"> }];

        </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = temp.length; i &lt; len; i++<span style="color: #000000;">) {
            urls.push({ id: temp[i].id, url: </span><span style="color: #800000;">"../../../../Content/Bomber/</span><span style="color: #800000;">Image/Map/</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> temp[i].url });
        }

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> urls;
    };

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
        init: function () {           
            </span><span style="color: #0000ff;">this</span>.imgLoader = <span style="color: #0000ff;">new</span><span style="color: #000000;"> YYC.Control.PreLoadImg(_getImg(), function (currentLoad, imgCount) {
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar_img_show</span><span style="color: #800000;">"</span>).progressBar(parseInt(currentLoad * <span style="color: #800080;">100</span> / imgCount, <span style="color: #800080;">10</span>));     <span style="color: #008000;">//</span><span style="color: #008000;">调用进度条插件</span>
            }, YYC.Tool.func.bind(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.onload));
        },
        onload: function(){
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar</span><span style="color: #800000;">"</span>).css(<span style="color: #800000;">"</span><span style="color: #800000;">display</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">none</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                alert("complete!");</span><span style="color: #000000;">
        }
    };

    window.showMap </span>=<span style="color: #000000;"> showMap;
}());    </span></pre>
</div>
<h2>补充说明</h2>
<p>YYC.Tool.func.bind是我的一个工具类方法，作用是将onload中的this指向showMap。</p>
<p>预加载完成后，调用onload，隐藏进度条，弹出对话框，提示&ldquo;complete&rdquo;。</p>
<h2><span style="color: #ff0000;"><span style="color: #000000;">领域模型</span></span></h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/02225253-4244e9c84a8d48deb25d15c7c903d4d8.jpg" alt="" />　</p>
<h2>运行</h2>
<p>在页面上调用init方法</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">      $(function () {
          showMap.init();
      });</span></pre>
</div>
<h2>显示效果</h2>
<p style="text-align: left;">&nbsp;<img src="http://images.cnitblog.com/blog/419321/201307/16222259-b3da8136fff84d97b1fec138dc3f95d3.png" alt="" /></p>
<p style="text-align: left;">加载图片中</p>
<p style="text-align: left;"><img src="http://images.cnitblog.com/blog/419321/201307/16222359-964c2ae5e7f742d485213f236dde46b6.png" alt="" /></p>
<p style="text-align: left;">加载完成</p>
<h2>重构</h2>
<h3>识别出config类，放到辅助操作层</h3>
<h4>　　为什么要增加Config类？</h4>
<p>ShowMap中预加载图片的url是相对于当前页面的，所以在不同的页面预加载图片时（如在测试页面和实际页面），url的前缀可能不一样。<span style="color: #c0c0c0;"><br /></span></p>
<p>因此我希望url的前缀是可以配置的，这样当在不同的页面调用ShowMap时，只需要改动配置文件就好了。</p>
<h4><span style="color: #000000;">　　领域模型</span></h4>
<p><span style="color: #ff0000;"><img src="http://images.cnitblog.com/blog/419321/201310/02230606-366fafbc364a45378095936b57277801.jpg" alt="" /></span></p>
<h4>&nbsp;　　具体内容</h4>
<p>所以我增加Config全局配置类，在Config中配置url的前缀。该类属于辅助操作层。</p>
<p>Config</p>
<div class="cnblogs_code">
<pre><span>var</span> bomberConfig =<span> {
    url_pre: {
        </span><span>//</span><span>showMap.js</span>
        SHOWMAP: <span>"</span><span>../../../../Content/Bomber/</span><span>"</span><span>
    }
};</span></pre>
<p><span>&nbsp;</span></p>
</div>
<p>&nbsp;ShowMap</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> _getImg =<span style="color: #000000;"> function () {
...
    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = temp.length; i &lt; len; i++<span style="color: #000000;">) {
        urls.push({ id: temp[i].id, url: bomberConfig.url_pre.SHOWMAP </span>+<span style="color: #000000;"> temp[i].url });
    }

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> urls;
};</span></pre>
</div>
<p><a name="showMap"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">显示地图</span></strong></p>
<h1>开发策略</h1>
<p>现在我就要开始着手显示游戏地图了。考虑到我没有canvas的使用经验，因此我先进行试验，熟悉canvas中与显示地图相关的api；然后对代码和领域模型进行重构，提炼出新的显示地图的模型；最后再具体实现&ldquo;显示地图&rdquo;的功能。</p>
<p>因为要使用canvas显示图片，先要对该图片进行预加载。因此先在showMap.onload中进行试验。</p>
<p>注意：对onload的测试为异步测试（要等待图片加载完成后才能使用canvas显示图片）。</p>
<h1>用drawImage显示<span>空地图片</span></h1>
<p>因为canvas中使用drawImage来绘制图片，因此需要先掌握该API的用法。</p>
<h2>测试代码</h2>
<div class="cnblogs_code">
<pre>            it(<span style="color: #800000;">"</span><span style="color: #800000;">绘制一张空地图片</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {</span>
                spyOn(showMap, <span style="color: #800000;">"</span><span style="color: #800000;">getContext</span><span style="color: #800000;">"</span><span style="color: #000000;">).andCallFake(function (canvas) {
                    showMap.context </span>= canvas.getContext(<span style="color: #800000;">"</span><span style="color: #800000;">2d</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    spyOn(showMap.context, </span><span style="color: #800000;">"</span><span style="color: #800000;">drawImage</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                });

                showMap.init();

                </span><span style="color: #008000;">//</span><span style="color: #008000;">延迟100ms测试</span>
<span style="color: #000000;">                testTool.asynRun(function () {
                    expect(showMap.context.drawImage).toHaveBeenCalledWith(showMap.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>), <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
                }, </span><span style="color: #800080;">100</span><span style="color: #000000;">);
            });</span></pre>
</div>
<h2>实现代码</h2>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> showMap =<span style="color: #000000;"> (function () {
    </span><span style="color: #0000ff;">var</span> _createCanvas =<span style="color: #000000;"> function () {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建canvas，并初始化 （我们也可以直接以标签形式写在页面中，然后通过id等方式取得canvas）</span>
        <span style="color: #0000ff;">var</span> canvas = document.createElement(<span style="color: #800000;">"</span><span style="color: #800000;">canvas</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">设置宽度、高度</span>
        canvas.width = <span style="color: #800080;">600</span><span style="color: #000000;">;
        canvas.height </span>= <span style="color: #800080;">400</span><span style="color: #000000;">;

        document.body.appendChild(canvas);

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> canvas;
    };
    </span><span style="color: #0000ff;">var</span> _getImg =<span style="color: #000000;"> function () {
        </span><span style="color: #0000ff;">var</span> urls =<span style="color: #000000;"> [];
        </span><span style="color: #0000ff;">var</span> temp =<span style="color: #000000;"> [];
        </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, len = <span style="color: #800080;">0</span><span style="color: #000000;">;

        temp </span>= [{ id: <span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>, url: <span style="color: #800000;">"</span><span style="color: #800000;">ground.png</span><span style="color: #800000;">"</span> }, { id: <span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span>, url: <span style="color: #800000;">"</span><span style="color: #800000;">wall.png</span><span style="color: #800000;">"</span><span style="color: #000000;"> }];

        </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = temp.length; i &lt; len; i++<span style="color: #000000;">) {
            urls.push({ id: temp[i].id, url: bomberConfig.url_pre.SHOWMAP </span>+ <span style="color: #800000;">"</span><span style="color: #800000;">image/map/</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> temp[i].url });
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> urls;
    };
</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"> {
        context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
        imgLoader: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

        init: function () {
            </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">var</span> canvas =<span style="color: #000000;"> _createCanvas();

            </span><span style="color: #008000;">//</span><span style="color: #008000;">为了方便测试，将&ldquo;取得2d绘图上下文&rdquo;封装到方法中</span>
            <span style="color: #0000ff;">this</span><span style="color: #000000;">.getContext(canvas);   
           
            </span><span style="color: #0000ff;">this</span>.imgLoader = <span style="color: #0000ff;">new</span><span style="color: #000000;"> YYC.Control.PreLoadImg(_getImg(), function (currentLoad, imgCount) {
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar_img_show</span><span style="color: #800000;">"</span>).progressBar(parseInt(currentLoad * <span style="color: #800080;">100</span> / imgCount, <span style="color: #800080;">10</span>));     <span style="color: #008000;">//</span><span style="color: #008000;">调用进度条插件</span>
            }, YYC.Tool.func.bind(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">this</span><span style="color: #000000;">.onload));
        },
        onload: function(){
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar</span><span style="color: #800000;">"</span>).css(<span style="color: #800000;">"</span><span style="color: #800000;">display</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">none</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">this</span>.context.drawImage(<span style="color: #0000ff;">this</span>.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>), <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        },
        getContext: function (canvas) {
            </span><span style="color: #0000ff;">this</span>.context = canvas.getContext(<span style="color: #800000;">"</span><span style="color: #800000;">2d</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        }
    };

    window.showMap </span>=<span style="color: #000000;"> showMap;
}());</span></pre>
</div>
<h2><a name="question"></a>补充说明</h2>
<p><span style="color: #000000;">这里canvas是动态创建的，但是这样创建canvas会有drawImage中的dx、dy和clearRect中的x、y按比例缩放的问题。在<strong><span style="font-size: 16px;"><a href="http://www.cnblogs.com/chaogex/p/3265119.html#question">第5篇博文</a></span></strong>中，我们会碰到这个问题，到时候我再详细说明。</span></p>
<h2>运行效果</h2>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/419321/201307/16222831-734df279c4f142358bb0ae48e3653b86.png" alt="" /></p>
<h1>用createPattern显示空地图片区域</h1>
<p>在游戏开发中，可能需要绘制一片相同图片的区域，该区域由一张图片在x、y方向重复绘制而成，需要用到createPattern、fillStyle、fillRect。因此先进行实验。</p>
<h2>测试代码</h2>
<div class="cnblogs_code">
<pre>describe(<span style="color: #800000;">"</span><span style="color: #800000;">画出地图</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
    function spyOnContext(func) {
        spyOn(showMap, </span><span style="color: #800000;">"</span><span style="color: #800000;">getContext</span><span style="color: #800000;">"</span><span style="color: #000000;">).andCallFake(function (canvas) {
            showMap.context </span>= canvas.getContext(<span style="color: #800000;">"</span><span style="color: #800000;">2d</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            func();
        });
    };

    it(</span><span style="color: #800000;">"</span><span style="color: #800000;">获得pattern</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        spyOnContext(function () {
            spyOn(showMap.context, </span><span style="color: #800000;">"</span><span style="color: #800000;">createPattern</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        });

        showMap.init();

        </span><span style="color: #008000;">//</span><span style="color: #008000;">延迟100ms测试</span>
<span style="color: #000000;">        testTool.asynRun(function () {
            expect(showMap.context.createPattern).toHaveBeenCalledWith(showMap.imgLoader.</span><span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>), <span style="color: #800000;">"</span><span style="color: #800000;">repeat</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            expect(showMap._pattern).not.toBeNull();
        }, </span><span style="color: #800080;">100</span><span style="color: #000000;">);
    });
    it(</span><span style="color: #800000;">"</span><span style="color: #800000;">缓存pattern</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        spyOnContext(function () {
            spyOn(showMap.context, </span><span style="color: #800000;">"</span><span style="color: #800000;">createPattern</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        });

        showMap.init();

        expect(showMap.context.createPattern.calls.length).toEqual(</span><span style="color: #800080;">1</span><span style="color: #000000;">);

        </span><span style="color: #008000;">//</span><span style="color: #008000;">*延迟100ms后，执行&ldquo;showMap.init();&rdquo;。
        </span><span style="color: #008000;">//</span><span style="color: #008000;">*然后再延迟100ms后，如果showMap.context.createPattern没有被调用，就验证pattern被缓存了&ldquo;</span>
<span style="color: #000000;">
        testTool.asynRun(function () {
            showMap.init();
        }, </span><span style="color: #800080;">100</span><span style="color: #000000;">);
        testTool.asynRun(function () {
            expect(showMap.context.createPattern.calls.length).toEqual(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
        }, </span><span style="color: #800080;">100</span><span style="color: #000000;">);
    });
    it(</span><span style="color: #800000;">"</span><span style="color: #800000;">画出200*200的空地图片区域，ie、ff显示正常</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        spyOnContext(function () {
            spyOn(showMap.context, </span><span style="color: #800000;">"</span><span style="color: #800000;">fillRect</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        });

        showMap.init();

        testTool.asynRun(function () {
            expect(showMap.context.fillStyle).toEqual(showMap._pattern);
            expect(showMap.context.fillRect).toHaveBeenCalledWith(</span><span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">200</span>, <span style="color: #800080;">200</span><span style="color: #000000;">);
        }, </span><span style="color: #800080;">100</span><span style="color: #000000;">);
    });
});</span></pre>
</div>
<h2>实现代码</h2>
<div class="cnblogs_code">
<pre><span style="color: #000000;">onload: function(){
    $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar</span><span style="color: #800000;">"</span>).css(<span style="color: #800000;">"</span><span style="color: #800000;">display</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">none</span><span style="color: #800000;">"</span><span style="color: #000000;">);

    </span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">this</span><span style="color: #000000;">._pattern) {
        </span><span style="color: #0000ff;">this</span>._pattern = <span style="color: #0000ff;">this</span>.context.createPattern(showMap.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>), <span style="color: #800000;">"</span><span style="color: #800000;">repeat</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">this</span>.context.fillStyle = <span style="color: #0000ff;">this</span><span style="color: #000000;">._pattern;
    </span><span style="color: #0000ff;">this</span>.context.fillRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">200</span>, <span style="color: #800080;">200</span><span style="color: #000000;">);

},</span></pre>
</div>
<h2>运行效果</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201307/16222916-f82825a8b6284c06939e95c390c367f0.png" alt="" /></p>
<p><a name="refactor"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">重构</span></strong></p>
<p>现在需要停一下，对已有的代码进行梳理。</p>
<h2>创建Bitmap类，并进行对应重构</h2>
<p>我发现，在ShowMap的onload方法中，多次使用到了图片对象：showMap.imgLoader.get("ground")，这个对象是预加载图片后的Image对象。</p>
<p>考虑到在游戏中需要对图片进行操作，那为什么不能提出&ldquo;图片类&rdquo;的概念，将与图片本身相关的内容都放到该类中呢？</p>
<p>因此，我提炼出Bitmap类，该类有以下职责：</p>
<ul>
<li>包含图片的信息（如图片对象image、width、height等）</li>
<li>包含图片的基本操作（如剪切、缩放等）</li>
</ul>
<h3>进一步思考</h3>
<ul>
<li>绘制图片的draw方法应不应该放到Bitmap类中呢？</li>
</ul>
<p>考虑到Bitmap类是图片的包装类，包含与图片本身密切相关的属性和方法。而绘制图片方法的职责是读取图片的属性，使用canvas的api进行操作。<span style="font-size: 14px; line-height: 1.5;">Bitmap类不需要知道自己是如何被调用的，因此绘制图片的职责应该放到调用Bitmap的类，即放到ShowMap类中。</span></p>
<ul>
<li><span style="font-size: 14px; line-height: 1.5;">为什么不创建图片的精灵类？</span></li>
</ul>
<p><span style="font-size: 14px; line-height: 1.5;">因为图片不是独立的个体，它属于数据的概念，是精灵的一个属性，在概念上它并不是精灵。</span></p>
<ul>
<li>&nbsp;Bitmap应该具体有哪些成员？</li>
</ul>
<p>属性：</p>
<p>应该包含预加载后的图片对象、宽度和高度、图片的坐标。</p>
<p>方法：</p>
<p>目前来看，不需要对图片进行操作，因此不需要如剪切等方法。</p>
<h3><span>领域模型</span></h3>
<p><img src="http://images.cnitblog.com/blog/419321/201310/05205630-72f9023406da43e7a1aef3b8b08419b8.jpg" alt="" /></p>
<h3>测试代码</h3>
<div class="cnblogs_code">
<pre>describe(<span style="color: #800000;">"</span><span style="color: #800000;">Bitmap.js</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
    </span><span style="color: #0000ff;">var</span> bitmap = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    beforeEach(function () {
    });
    afterEach(function () {
    });

    describe(</span><span style="color: #800000;">"</span><span style="color: #800000;">构造函数Init</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        </span><span style="color: #0000ff;">var</span> dom = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        function insertDom() {
            dom </span>= $(<span style="color: #800000;">"</span><span style="color: #800000;">&lt;img id='test_img'&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            $(</span><span style="color: #800000;">"</span><span style="color: #800000;">body</span><span style="color: #800000;">"</span><span style="color: #000000;">).append(dom);
        };
        function removeDom() {
            dom.remove();
        };

        beforeEach(function () {
            insertDom();
        });
        afterEach(function () {
            removeDom();
        });

        it(</span><span style="color: #800000;">"</span><span style="color: #800000;">获得预加载后的图片对象、宽度、高度、图片的坐标</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
            bitmap </span>= <span style="color: #0000ff;">new</span> Bitmap($(<span style="color: #800000;">"</span><span style="color: #800000;">#test_img</span><span style="color: #800000;">"</span>)[<span style="color: #800080;">0</span>], <span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>, <span style="color: #800080;">4</span>, <span style="color: #800080;">5</span><span style="color: #000000;">);

            expect(bitmap.img).not.toBeNull();
            expect(bitmap.width).toEqual(</span><span style="color: #800080;">2</span><span style="color: #000000;">);
            expect(bitmap.height).toEqual(</span><span style="color: #800080;">3</span><span style="color: #000000;">);
            expect(bitmap.x).toEqual(</span><span style="color: #800080;">4</span><span style="color: #000000;">);
            expect(bitmap.y).toEqual(</span><span style="color: #800080;">5</span><span style="color: #000000;">);
        });
    });
});</span></pre>
</div>
<h3>实际代码</h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Bitmap =<span style="color: #000000;"> YYC.Class({
        Init: function (img, width, height, x, y) {
            </span><span style="color: #0000ff;">var</span> judge =<span style="color: #000000;"> YYC.Tool.judge;

            </span><span style="color: #0000ff;">this</span>.img =<span style="color: #000000;"> img;
            </span><span style="color: #0000ff;">this</span>.width =<span style="color: #000000;"> width;
            </span><span style="color: #0000ff;">this</span>.height =<span style="color: #000000;"> height;
            </span><span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> x;
            </span><span style="color: #0000ff;">this</span>.y =<span style="color: #000000;"> y;
        },
        Private: {
        },
        Public: {
            img: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            width: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            height: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            x: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">
        }
    });

    window.Bitmap </span>=<span style="color: #000000;"> Bitmap;
}());</span></pre>
</div>
<h2>重构Bitmap</h2>
<p>Bitmap构造函数的参数太多了，因此使用一个<span>对象直接量来包装参数：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Bitmap =<span style="color: #000000;"> YYC.Class({
        Init: function (data) {
            </span><span style="color: #0000ff;">this</span>.img =<span style="color: #000000;"> data.img;
            </span><span style="color: #0000ff;">this</span>.width =<span style="color: #000000;"> data.width;
            </span><span style="color: #0000ff;">this</span>.height =<span style="color: #000000;"> data.height;
            </span><span style="color: #0000ff;">this</span>.x =<span style="color: #000000;"> data.x;
            </span><span style="color: #0000ff;">this</span>.y =<span style="color: #000000;"> data.y;
        },
        Private: {
        },
        Public: {
            img: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,
            width: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            height: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            x: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
            y: </span><span style="color: #800080;">0</span><span style="color: #000000;">
        }
    });

    window.Bitmap </span>=<span style="color: #000000;"> Bitmap;
}());</span></pre>
</div>
<p>运行测试，测试失败。</p>
<p>修改测试代码，使测试通过：</p>
<div class="cnblogs_code">
<pre>        it(<span style="color: #800000;">"</span><span style="color: #800000;">获得预加载后的图片对象、宽度、高度、图片的坐标</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
            bitmap </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Bitmap({
                img: $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#test_img</span><span style="color: #800000;">"</span>)[<span style="color: #800080;">0</span><span style="color: #000000;">],
                width: </span><span style="color: #800080;">2</span><span style="color: #000000;">,
                height: </span><span style="color: #800080;">3</span><span style="color: #000000;">,
                x: </span><span style="color: #800080;">4</span><span style="color: #000000;">,
                y: </span><span style="color: #800080;">5</span><span style="color: #000000;">
            });

            expect(bitmap.img).not.toBeNull();
            expect(bitmap.width).toEqual(</span><span style="color: #800080;">2</span><span style="color: #000000;">);
            expect(bitmap.height).toEqual(</span><span style="color: #800080;">3</span><span style="color: #000000;">);
            expect(bitmap.x).toEqual(</span><span style="color: #800080;">4</span><span style="color: #000000;">);
            expect(bitmap.y).toEqual(</span><span style="color: #800080;">5</span><span style="color: #000000;">);
        });</span></pre>
</div>
<h2>创建BitmapFactory类</h2>
<p>因为在ShowMap类中需要创建Bitmap实例，因此需要增加Bitmap的工厂BitmapFactory类。</p>
<p>理由如下：</p>
<ul>
<li>Bitmap构造函数有3个参数，比较复杂，需要将创建实例这个过程封装起来。因此需要工厂类来负责和管理创建过程。</li>
</ul>
<h3><span>领域模型</span></h3>
<p><img src="http://images.cnitblog.com/blog/419321/201310/06182648-ca17516e54a64291af3e42510a9ce2d3.jpg" alt="" /></p>
<h3>&nbsp;测试代码</h3>
<div class="cnblogs_code">
<pre>describe(<span style="color: #800000;">"</span><span style="color: #800000;">bitmapFactory.js</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {

    describe(</span><span style="color: #800000;">"</span><span style="color: #800000;">createBitmap</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        </span><span style="color: #0000ff;">var</span> dom = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        function insertDom() {
            dom </span>= $(<span style="color: #800000;">"</span><span style="color: #800000;">&lt;img id='test_img'&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            $(</span><span style="color: #800000;">"</span><span style="color: #800000;">body</span><span style="color: #800000;">"</span><span style="color: #000000;">).append(dom);
        };
        function removeDom() {
            dom.remove();
        };

        beforeEach(function () {
            insertDom();
        });
        afterEach(function () {
            removeDom();
        });

        it(</span><span style="color: #800000;">"</span><span style="color: #800000;">方法存在</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
            expect(bitmapFactory.createBitmap).toBeDefined();
        });
        it(</span><span style="color: #800000;">"</span><span style="color: #800000;">如果参数为1个（HTMLImg对象），则bitmap的width、height为HTMLImg的width、height</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
            </span><span style="color: #0000ff;">var</span> bitmap = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            width </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
            height </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;


            bitmap </span>= bitmapFactory.createBitmap($(<span style="color: #800000;">"</span><span style="color: #800000;">#test_img</span><span style="color: #800000;">"</span>)[<span style="color: #800080;">0</span><span style="color: #000000;">]),
            width </span>= $(<span style="color: #800000;">"</span><span style="color: #800000;">#test_img</span><span style="color: #800000;">"</span><span style="color: #000000;">).width(),
            height </span>= $(<span style="color: #800000;">"</span><span style="color: #800000;">#test_img</span><span style="color: #800000;">"</span><span style="color: #000000;">).height();

            expect(bitmap.width).toEqual(width);
            expect(bitmap.height).toEqual(height);
        });
        it(</span><span style="color: #800000;">"</span><span style="color: #800000;">如果参数为3个（HTMLImg对象、width、height），则bitmap的width、height为传入的width、height</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
            </span><span style="color: #0000ff;">var</span> bitmap = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            bitmap </span>= bitmapFactory.createBitmap($(<span style="color: #800000;">"</span><span style="color: #800000;">#test_img</span><span style="color: #800000;">"</span>)[<span style="color: #800080;">0</span>], <span style="color: #800080;">100</span>, <span style="color: #800080;">200</span><span style="color: #000000;">),

            expect(bitmap.width).toEqual(</span><span style="color: #800080;">100</span><span style="color: #000000;">);
            expect(bitmap.height).toEqual(</span><span style="color: #800080;">200</span><span style="color: #000000;">);
        });
    });
});</span></pre>
</div>
<h3>实际代码</h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> bitmapFactory =<span style="color: #000000;"> {
        createBitmap: function (img, width, height) {
            </span><span style="color: #0000ff;">if</span> (arguments.length == <span style="color: #800080;">1</span><span style="color: #000000;">) {

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Bitmap(img, img.width, img.height);
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (arguments.length == <span style="color: #800080;">3</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Bitmap(img, width, height);
            }
        }
    };

    window.bitmapFactory </span>=<span style="color: #000000;"> bitmapFactory;
}());</span></pre>
</div>
<p>showMap.onload对应改变</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">onload: function(){
    $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar</span><span style="color: #800000;">"</span>).css(<span style="color: #800000;">"</span><span style="color: #800000;">display</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">none</span><span style="color: #800000;">"</span><span style="color: #000000;">);

    </span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">this</span><span style="color: #000000;">._pattern) {
        </span><span style="color: #0000ff;">this</span>._pattern = <span style="color: #0000ff;">this</span>.context.createPattern(bitmapFactory.createBitmap(showMap.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>)).img, <span style="color: #800000;">"</span><span style="color: #800000;">repeat</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">this</span>.context.fillStyle = <span style="color: #0000ff;">this</span><span style="color: #000000;">._pattern;
    </span><span style="color: #0000ff;">this</span>.context.fillRect(<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, <span style="color: #800080;">200</span>, <span style="color: #800080;">200</span><span style="color: #000000;">);
},</span></pre>
</div>
<h2>重构测试</h2>
<p>现在让我们来回头看下drawImage和createPattern的测试，在测试中都需要异步测试。</p>
<p>每增加一个测试用例就需要延迟测试，这样增加了很多重复代码，为什么不能把延迟测试分离出去，从而在测试中把精力放到我们的主要任务-即如何测试行为上呢？</p>
<p>因此，我把init方法放到测试页面SpecRunner上调用，然后在测试页面上对整个测试进行延迟，这样就能保证整个测试都是在图片预加载成功后进行的了。</p>
<p>测试页面相关代码：</p>
<div class="cnblogs_code">
<pre>&lt;body&gt;
&lt;script type=<span style="color: #800000;">"</span><span style="color: #800000;">text/javascript</span><span style="color: #800000;">"</span>&gt;<span style="color: #000000;">
(function () {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">图片预加载</span>
<span style="color: #000000;">    main.init()

    </span><span style="color: #008000;">//</span><span style="color: #008000;">清除&ldquo;main.init()&rdquo;创建的多余html元素</span>
<span style="color: #000000;">    function clear() {
        $(</span><span style="color: #800000;">"</span><span style="color: #800000;">body</span><span style="color: #800000;">"</span>).children().not(<span style="color: #800000;">"</span><span style="color: #800000;">script</span><span style="color: #800000;">"</span><span style="color: #000000;">).remove();
    };

    </span><span style="color: #0000ff;">var</span> jasmineEnv =<span style="color: #000000;"> jasmine.getEnv();
    jasmineEnv.updateInterval </span>= <span style="color: #800080;">1000</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">var</span> htmlReporter = <span style="color: #0000ff;">new</span><span style="color: #000000;"> jasmine.HtmlReporter();

    jasmineEnv.addReporter(htmlReporter);

    jasmineEnv.specFilter </span>=<span style="color: #000000;"> function (spec) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> htmlReporter.specFilter(spec);
    };

    </span><span style="color: #0000ff;">var</span> currentWindowOnload =<span style="color: #000000;"> window.onload;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">延迟300ms执行测试（等待预加载完后执行）</span>
<span style="color: #000000;">    setTimeout(function () {
        clear();

        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (currentWindowOnload) {
            currentWindowOnload();
        }
        execJasmine();
    }, </span><span style="color: #800080;">1000</span><span style="color: #000000;">);

    function execJasmine() {
        jasmineEnv.execute();
    }

})();
</span>&lt;/script&gt;
&lt;/body&gt;</pre>
</div>
<p>现在测试用例中就不再需要&ldquo;testTool.asynRun&rdquo;进行异步测试了。</p>
<h2>重构ShowMap</h2>
<p>现在，让我们再来看看showMap类，发现该类做了三件事：</p>
<ul>
<li>游戏初始化：图片预加载</li>
<li>游戏逻辑</li>
<li>显示地图</li>
</ul>
<h3>增加Main类</h3>
<p>根据单一职责原则，一个类只应该有一个职责，只有一个原因引起变化。再结合之前给出的领域模型，Main类是游戏入口，负责控制游戏的主循环，调用相关的操作。因此，将showMap中负责游戏初始化的init方法移到Main中。</p>
<h3>增加Game类</h3>
<p>showMap中还包含了游戏逻辑，如在onload中隐藏进度条，然后显示地图。根据以往游戏开发经验，知道游戏逻辑会越来越复杂，因此可以将游戏逻辑提取出来形成新类Game，这样ShowMap只负责调用canvas的API显示地图了。</p>
<h3>重构后的领域模型</h3>
<p><img src="http://images.cnitblog.com/blog/419321/201310/02232715-7c7dd0e6852c4da4bf78e0f7e85b1115.jpg" alt="" /></p>
<h3 style="text-align: left;">相关代码</h3>
<p style="text-align: left;">Main</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> main =<span style="color: #000000;"> (function () {
    </span><span style="color: #0000ff;">var</span> _getImg =<span style="color: #000000;"> function () {
        </span><span style="color: #0000ff;">var</span> urls =<span style="color: #000000;"> [];
        </span><span style="color: #0000ff;">var</span> temp =<span style="color: #000000;"> [];
        </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, len = <span style="color: #800080;">0</span><span style="color: #000000;">;

        temp </span>= [{ id: <span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span>, url: <span style="color: #800000;">"</span><span style="color: #800000;">ground.png</span><span style="color: #800000;">"</span> }, { id: <span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span>, url: <span style="color: #800000;">"</span><span style="color: #800000;">wall.png</span><span style="color: #800000;">"</span><span style="color: #000000;"> }];

        </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = temp.length; i &lt; len; i++<span style="color: #000000;">) {
            urls.push({ id: temp[i].id, url: bomberConfig.url_pre.SHOWMAP </span>+ <span style="color: #800000;">"</span><span style="color: #800000;">image/map/</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> temp[i].url });
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> urls;
    };

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
        imgLoader: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

        init: function () {
            </span><span style="color: #0000ff;">var</span> game = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Game();
            
            </span><span style="color: #0000ff;">this</span>.imgLoader = <span style="color: #0000ff;">new</span><span style="color: #000000;"> YYC.Control.PreLoadImg(_getImg(), function (currentLoad, imgCount) {
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar_img_show</span><span style="color: #800000;">"</span>).progressBar(parseInt(currentLoad * <span style="color: #800080;">100</span> / imgCount, <span style="color: #800080;">10</span>));     <span style="color: #008000;">//</span><span style="color: #008000;">调用进度条插件</span>
<span style="color: #000000;">            }, YYC.Tool.func.bind(game, game.onload));
        }
    };

    window.main </span>=<span style="color: #000000;"> main;
}());</span></pre>
</div>
<p style="text-align: left;">Game</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> Game =<span style="color: #000000;"> YYC.Frame.MyClass({
        Init: function () {
            </span><span style="color: #0000ff;">this</span>.showMap = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ShowMap();
        },
        Private: {
        },
        Public: {
            showMap: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

            onload: function () {
                $(</span><span style="color: #800000;">"</span><span style="color: #800000;">#progressBar</span><span style="color: #800000;">"</span>).css(<span style="color: #800000;">"</span><span style="color: #800000;">display</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">none</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.showMap.drawMap();
            }
        }
    });

    window.Game </span>=<span style="color: #000000;"> Game;
}());</span>&nbsp;</pre>
</div>
<h2 style="text-align: left;"><span style="line-height: 1.5;">重构showMap</span></h2>
<h3><span style="line-height: 1.5;">改成类的形式</span></h3>
<p style="text-align: left;"><span style="font-size: 14px; line-height: 1.5;">将ShowMap改成类的形式。</span></p>
<h3 style="text-align: left;"><span style="font-size: 14px; line-height: 1.5;">提出Layer</span></h3>
<p>结合领域模型分析和第2篇博文中分层渲染的概念，我增加Layer类，将图片类Bitmap装入Layer，然后使用Layer来统一绘制图片。</p>
<p>Layer包含canvas属性，canvas由Game创建并通过Layer的构造函数将其注入到Layer中。</p>
<p>Layer有一个draw方法，负责调用canvas的API来绘制图片。</p>
<h3>重构Layer</h3>
<h4>　　提出Collection</h4>
<p>考虑到Layer是集合类，因此可以将集合这个概念提出，形成新的Collection类，把集合的相关操作和集合的容器_childs放到Collection中，让Layer继承Collection。从而Layer就具有了集合类的功能。</p>
<h4>　　进一步思考</h4>
<p>为什么这里选择继承的方式复用，而不是选择组合的方式复用呢？</p>
<ul>
<li>　　通过继承来复用比起组合来说更方便和优雅，可以减少代码量。</li>
<li>　　从概念上来说，Collection和Layer都是属于集合类，应该属于一个类族。Collection是从Layer中提炼出来的，它是集合类的共性，因此Collection作为父类，Layer作为子类。</li>
</ul>
<h4><span style="color: #000000;">　　领域模型</span></h4>
<p><span style="color: #ff0000;"><img src="http://images.cnitblog.com/blog/419321/201310/02232428-4387e7efe2644dbcaf412e21dadad339.jpg" alt="" /></span></p>
<p><a name="continue"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">继续实现显示地图</span></strong></p>
<p>重构到这里就告一段落，现在继续实现&ldquo;显示地图&rdquo;。</p>
<h1>增加MapData</h1>
<p>根据领域模型，增加MapData类，它是一个二维数组，用来保存地图数据。</p>
<p><span style="color: #000000;">MapData</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> ground =<span style="color: #000000;"> 1,
        wall </span>=<span style="color: #000000;"> 2;

    </span><span style="color: #0000ff;">var</span> mapData =<span style="color: #000000;"> [
        [ground, wall, ground, ground],
        [ground, wall, ground, ground],
        [ground, wall, ground, ground],
        [ground, wall, ground, ground]
    ];

    window.mapData </span>=<span style="color: #000000;"> mapData;
}());</span></pre>
</div>
<h1>增加MapDataOperate</h1>
<p><span>ShowMap不应该直接操作MapData，因为：</span></p>
<ul>
<li><span>MapData在后续的迭代中可能会变化，因此需要封装这个变化，使得MapData变化时不会影响到ShowMap</span></li>
<li><span>根据分层的结果，应该由数据操作层的类来操作MapData</span></li>
</ul>
<p>因此增加数据操作层的MapDataOperate，它负责获得MapData。</p>
<h2>领域模型</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/10130213-6b2b843d1f8443fa80c5dc5f82f7df4c.jpg" alt="" /></p>
<h2>相关代码</h2>
<p><span style="color: #000000;">MapDataOperate</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(function () {
    </span><span style="color: #0000ff;">var</span> mapDataOperate =<span style="color: #000000;"> {
        getMapData: function () {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> YYC.Tool.array.clone(mapData);
        }
    };

    window.mapDataOperate </span>=<span style="color: #000000;"> mapDataOperate;
}());</span></pre>
</div>
<h1>显示地图的实现</h1>
<h2>实现drawMap</h2>
<p>在ShowMap中，通过调用MapDataOperate的getMapData方法，就可以获得地图数据，然后再根据数据向Layer中加入对应的Bitmap类即可。</p>
<h3>相关代码</h3>
<p>ShowMap</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">_getMapImg: function (i, j, mapData) {
    </span><span style="color: #0000ff;">var</span> img = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (mapData[i][j]) {
        </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">1</span><span style="color: #000000;">:
            img </span>= main.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">case</span> <span style="color: #800080;">2</span><span style="color: #000000;">:
            img </span>= main.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">
    }

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> img;
}
...
drawMap: function () {
    </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
        j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
        width </span>=   <span style="color: #800080;">34</span><span style="color: #000000;">,
        height </span>= <span style="color: #800080;">34</span><span style="color: #000000;">,
        row </span>= <span style="color: #800080;">4</span><span style="color: #000000;">,
        col </span>= <span style="color: #800080;">4</span><span style="color: #000000;">,
        bitmap </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
        mapData </span>=<span style="color: #000000;"> mapDataOperate.getMapData(),
        x </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
        y </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
        img </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._createLayer();

    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; row; i++<span style="color: #000000;">) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">注意！
        </span><span style="color: #008000;">//</span><span style="color: #008000;">y为纵向height，x为横向width</span>
        y = i *<span style="color: #000000;"> height;

        </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; col; j++<span style="color: #000000;">) {
            x </span>= j *<span style="color: #000000;"> width;
            img </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._getMapImg(i, j, mapData);
            bitmap </span>=<span style="color: #000000;"> bitmapFactory.createBitmap({ img: img, width: width, height: height, x: x, y: y });
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.appendChild(bitmap);
        }
    }
    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.draw();
}</span></pre>
</div>
<h1><span style="color: #000000;">重构</span></h1>
<h2><span style="font-size: 14px; line-height: 1.5;">重构MapData</span></h2>
<p><span style="font-size: 14px; line-height: 1.5;">将MapData的ground与wall设为枚举值，增加可读性。</span></p>
<p>将枚举值放到Config类中。</p>
<h3>相关代码</h3>
<p><span style="font-size: 14px; line-height: 1.5;">Config</span></p>
<div class="cnblogs_code" style="width: 590.2130737304688px;">
<pre>    map: {
...
        type: {
            GROUND: 1,
            WALL: 2
        }
    },</pre>
</div>
<p>MapData</p>
<div class="cnblogs_code" style="width: 590.2130737304688px;">
<pre>    <span style="color: #0000ff;">var</span> ground =<span> bomberConfig.map.type.GROUND,
        wall </span>= bomberConfig.map.type.WALL;</pre>
</div>
<h2><span>重构drawMap　　</span></h2>
<p><span>config增加bomberConfig.map配置</span></p>
<p>目前地图大小是在drawMap写死了：</p>
<p>大小为4*4，单元格宽度和高度为34px。</p>
<p>考虑到地图大小可能在后期的开发中不断变化，因此将其放到Config中进行统一配置。</p>
<h3>相关代码</h3>
<p>Config</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">   map: {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">方格宽度</span>
        WIDTH: <span style="color: #800080;">34</span><span style="color: #000000;">,
        </span><span style="color: #008000;">//</span><span style="color: #008000;">方格高度</span>
        HEIGHT: <span style="color: #800080;">34</span><span style="color: #000000;">,
        ROW: </span><span style="color: #800080;">4</span><span style="color: #000000;">,
        COL: </span><span style="color: #800080;">4</span><span style="color: #000000;">,
        type: {
            GROUND: </span><span style="color: #800080;">1</span><span style="color: #000000;">,
            WALL: </span><span style="color: #800080;">2</span><span style="color: #000000;">
        }
    },</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">ShowMap</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">_getMapImg: function (i, j, mapData) {
    </span><span style="color: #0000ff;">var</span> img = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
        type </span>=<span style="color: #000000;"> bomberConfig.map.type;

    </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (mapData[i][j]) {
        </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> type.GROUND:
            img </span>= window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">ground</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> type.WALL:
            img </span>= window.imgLoader.<span style="color: #0000ff;">get</span>(<span style="color: #800000;">"</span><span style="color: #800000;">wall</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">
    }

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> img;
}
...
drawMap: function () {
    </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
        j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
        map </span>=<span style="color: #000000;"> bomberConfig.map,
        bitmap </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
        mapData </span>=<span style="color: #000000;"> mapDataOperate.getMapData(),
        x </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
        y </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
        img </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._createLayer();

    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; map.ROW; i++<span style="color: #000000;">) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">注意！
        </span><span style="color: #008000;">//</span><span style="color: #008000;">y为纵向height，x为横向width</span>
        y = i *<span style="color: #000000;"> map.HEIGHT;

        </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; map.COL; j++<span style="color: #000000;">) {
            x </span>= j *<span style="color: #000000;"> map.WIDTH;
            img </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._getMapImg(i, j, mapData);
            bitmap </span>=<span style="color: #000000;"> bitmapFactory.createBitmap({ img: img, width: map.WIDTH, height: map.HEIGHT, x: x, y: y });
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.appendChild(bitmap);
        }
    }
    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.layer.draw();
}</span></pre>
</div>
<p><a name="model"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文最终领域模型</span></strong></p>
<p>&nbsp;</p>
<p><img src="http://images.cnitblog.com/blog/419321/201310/06183010-c4afbf30e4884a48a535072c43a45c91.jpg" alt="" /></p>
<p><a name="layer"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">高层划分</span></strong></p>
<h1><span style="color: #000000;">重构层<br /></span></h1>
<h2><span style="color: #000000;">增加数据操作层</span></h2>
<p><span>本文增加了MapDataOperate类，对应增加数据操作层。该层负责对数据进行操作。</span></p>
<h3><span style="color: #000000;">分析</span></h3>
<h4><span style="color: #000000;">　　Bitmap放到哪？</span></h4>
<p><span style="color: #000000;">我们来看下Bitmap的职责：</span></p>
<ul>
<li>包含图片的信息（如图片对象image、width、height等）</li>
<li>包含图片的基本操作（如剪切、缩放等）</li>





















</ul>
<p>从中得出Bitmap应该放到数据操作层。</p>
<h1><span style="color: #000000;">层、领域模型</span></h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/17110229-93abb8954cf1408b9f7a23aa8f950af0.jpg" alt="" /></p>
<p>
<a name="demo"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">演示</span></strong></p>
<p><a href="http://yang222.s2.jutuo.net/Bomber/Index3">演示地址</a></p>
<p>
<a name="reference"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文参考资料</span></strong></p>
<p><a href="http://liboxlu.iteye.com/blog/796582">js图片预加载</a></p>
<p><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/carekee/articles/1917612.html">js 实现图片预加载</a></p>
<p><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/carekee/articles/1917612.html"></a><a href="http://www.cr173.com/html/11482_1.html">浏览器重图片的预加载问题onload事件</a></p>
<h1>欢迎浏览上一篇博文：<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3163357.html">炸弹人游戏开发系列（2）：初步设计</a></h1>
<h1>欢迎浏览下一篇博文：<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3213041.html">炸弹人游戏开发系列（4）：炸弹人显示与移动</a></h1>]]></description></item><item><title>炸弹人游戏开发系列（1）：准备工作</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/16/3151033.html</link><dc:creator>Wonder-YYC</dc:creator><author>Wonder-YYC</author><pubDate>Wed, 16 Oct 2013 14:54:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/16/3151033.html</guid><description><![CDATA[<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">前言</span></strong></p>
<p>大家好！本系列博文记录了炸弹人游戏迭代开发的过程。在开发的过程中，代码会不断重构，领域模型会不断演变，高层划分也会不断变化。</p>
<p>博文重点在于记录面向对象思想运用、重构、迭代开发的过程，对于游戏的实现细节和原理不会深入讨论。</p>
<p>如果您对RPG游戏的基本概念不熟悉，我推荐您可以先看看<a href="http://v.youku.com/v_show/id_XMjU2NzEyNzgw.html?f=5711740">HTML5研究小组第二期技术讲座《手把手制作HTML5游戏》</a>，它讲解了Html5超级玛丽游戏开发的过程，提出了一些基本概念（如精灵、主循环等）。另外您可以学习它的代码<a href="http://pan.baidu.com/s/1y0dbk">HTML5超级玛丽小游戏源代码</a>，您可以看到它是如何一步一步实现游戏的。</p>
<p>希望能与大家一起分享游戏开发的过程和乐趣，为大家运用oo思想和实践迭代开发提供力所能及的帮助。</p>
<h1>关键词</h1>
<p>面向对象、测试驱动开发、重构、迭代、领域模型、炸弹人游戏</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">系列博文目录</span></strong></p>
<ul>
<li><a id="homepage1_HomePageDays_ctl04_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3151033.html">炸弹人游戏开发系列（1）：准备工作</a></li>
<li><a id="CategoryEntryList1_EntryStoryList_Entries_TitleUrl_3" class="entrylistItemTitle" href="http://www.cnblogs.com/chaogex/p/3163357.html">炸弹人游戏开发系列（2）：初步设计</a></li>
<li><a id="CategoryEntryList1_EntryStoryList_Entries_TitleUrl_2" class="entrylistItemTitle" href="http://www.cnblogs.com/chaogex/p/3175811.html">炸弹人游戏开发系列（3）：显示地图</a></li>
<li><a id="CategoryEntryList1_EntryStoryList_Entries_TitleUrl_1" class="entrylistItemTitle" href="http://www.cnblogs.com/chaogex/p/3213041.html">炸弹人游戏开发系列（4）：炸弹人显示与移动</a></li>
<li><a id="CategoryEntryList1_EntryStoryList_Entries_TitleUrl_0" class="entrylistItemTitle" href="http://www.cnblogs.com/chaogex/p/3265119.html">炸弹人游戏开发系列（5）：控制炸弹人移动，引入状态模式</a></li>
<li><a id="CategoryEntryList1_EntryStoryList_Entries_TitleUrl_0" class="entrylistItemTitle" href="http://www.cnblogs.com/chaogex/p/3265119.html"></a><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3327097.html">炸弹人游戏开发系列（6）：实现碰撞检测，设置移动步长</a></li>
<li><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3327097.html"></a><a class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3334223.html">炸弹人游戏开发系列（7）：加入敌人，使用A*算法寻路</a></li>
<li><a class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3336783.html">炸弹人游戏开发系列（8）：放炸弹</a></li>
<li><a class="titlelnk" href="http://www.cnblogs.com/chaogex/p/3343198.html" target="_blank">炸弹人游戏开发系列（9）：总结</a></li>
</ul>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">最终成果</span></strong></p>
<p>下面是完成整个游戏开发后的成果，大家可以先预览一下。</p>
<h1><span style="color: #0000ff;"><a href="https://github.com/yyc-git/Bomber" target="_blank"><span style="color: #0000ff;">代码下载</span></a></span></h1>
<h1><span style="color: #3366ff;"><span style="color: #000000;">游戏截图（</span></span>已测试通过的浏览器：chrome、ff<span style="color: #3366ff;"><span style="color: #000000;">）</span></span></h1>
<p><a href="https://yyc-git.github.io/bomber/Views/Index.html" target="_blank">演示地址</a></p>
<p>&nbsp;</p>
<p><img src="https://img2018.cnblogs.com/blog/419321/201812/419321-20181221133042386-1027317453.png" alt="" /><a id="conceptLayer" style="font-size: 2em; background-color: #ffffff;"></a></p>
<h1>概念层次结构</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/21085556-8458211226db48b69d6930d0c31da622.jpg" alt="" width="195" height="492" /></p>
<h1><span style="color: #000000;">画布层级</span></h1>
<p><span style="color: #000000;">游戏中包含了包含了多个画布，其中地图画布、炸弹画布、火焰画布分别对应地图层、炸弹层、火焰层，玩家画布和敌人画布对应人物层。下面是各个层的层叠顺序，地图层显示在最下面，人物层显示在最上面：</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #000000;"><img src="http://images.cnitblog.com/blog/419321/201310/21163818-8134308058544ede8964ae4104151918.jpg" alt="" /></span></p>
<p><span style="color: #000000;">具体概念请见第2篇博文的&ldquo;<a href="http://www.cnblogs.com/chaogex/p/3163357.html#layerDraw">分层渲染</a>&rdquo;。</span></p>
<h1><span style="color: #000000;">最终的领域模型</span></h1>
<p><img src="http://images.cnitblog.com/blog/419321/201311/28132656-f02fa565dfcc4eb3a50ab046ab2cde89.jpg" alt="" width="932" height="500" /></p>
<p><a href="http://images.cnitblog.com/blog/419321/201310/17104754-0b0683a21a594eafbf47fcc90888f6ce.jpg" target="_blank">查看大图</a></p>
<h1><span style="color: #000000;">最终的高层划分</span></h1>
<h2>　　层、包</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/16134611-f08993363a8c45e0bf6e6ae0f6a13380.jpg" alt="" width="858" height="1310" /></p>
<h2>　　对应的领域模型</h2>
<ul>
<li>辅助操作层
<ul>
<li>控件包<br />PreLoadImg</li>
<li>配置包<br />Config</li>
































































</ul>
































































</li>
<li>用户交互层
<ul>
<li>入口包<br />Main</li>
































































</ul>
































































</li>
<li>业务逻辑层
<ul>
<li>辅助逻辑
<ul>
<li>工厂包<br />BitmapFactory、LayerFactory、SpriteFactory</li>
<li>事件管理包<br />KeyState、KeyEventManager</li>
<li>抽象包<br />Layer、Sprite、Hash、Collection</li>
<li>全局包<br />GameState</li>
































































</ul>
































































</li>
<li>游戏主逻辑
<ul>
<li>主逻辑包<br />Game</li>
































































</ul>
































































</li>
<li>层管理
<ul>
<li>层管理包<br />LayerManager</li>
































































</ul>
































































</li>
<li>实现
<ul>
<li>人物实现包<br />PlayerLayer、MoveSprite、PlayerSprite、EnemySprite、CharacterLayer、PlayerLayer、EnemyLayer、Context、PlayerState、WalkState、StandState、WalkState_X、WalkState_Y、StandLeftState、StandRightState、StandUpState、StandDownState、WalkLeftState、WalkRightState、WalkUpState、WalkDownState</li>
<li>炸弹实现包<br />BombSprite、FireSprite、BombLayer、FireLayer</li>
<li>地图实现包<br />MapLayer、MapElementSprite</li>
<li>算法包<br />FindPath</li>
<li>动画包<br />Animation、GetSpriteData、SpriteData、GetFrames、FrameData</li>
<li>观察者模式包<br />Subject</li>
































































</ul>
































































</li>
































































</ul>
































































</li>
<li>数据操作层
<ul>
<li>地图数据操作包<br />MapDataOperate、TerrainDataOperate</li>
<li>路径数据操作包<br />GetPath</li>
<li>图片数据操作包<br />Bitmap</li>
































































</ul>
































































</li>
<li>数据层
<ul>
<li>地图包<br />MapData、TerrainData</li>
<li>图片路径包<br />ImgPathData</li>

























































</ul>

























































</li>

























































</ul>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">前期准备</span></strong></p>
<p>现在，就让我们一起踏上游戏开发的旅程。首先<span style="line-height: 1.5;">来看看在炸弹人游戏开发中需要的知识和参考的资源。</span></p>
<h1>需要的知识</h1>
<h2>必备知识</h2>
<ul>
<li>Html+css<br />掌握html常用的标签，掌握常用的css属性，掌握div布局、定位等知识。能够使用html和css来设计和显示页面。</li>
<li>Javascript<br />熟悉Javascript基本语法、原型、闭包、作用域链等知识。</li>
<li>Html5 Canvas<br />了解画布原理，掌握常用的API，掌握Canvas优化。</li>

















































































































</ul>
<h2>进阶知识</h2>
<ul>
<li><span style="line-height: 1.5;">面向对象思想<br />熟悉oo思想，能够运用oo来分析、设计、编程。</span></li>
<li>设计模式<br />了解23种设计模式。</li>
<li>领域驱动<br />了解模型驱动开发（DDD）的思想。</li>
<li>敏捷开发<br />了解敏捷开发流程。</li>
<li>测试驱动开发<br />熟悉测试驱动开发流程。</li>







































































</ul>
<h1>相关资源</h1>
<h2>游戏开发</h2>
<ul>
<li><a href="http://www.mhtml5.com/2011/08/2390.html">使用Javascript和Canvas开发游戏</a></li>
<li><a href="http://www.iteye.com/topic/1122395">完全分享，共同进步&mdash;&mdash;我开发的第一款HTML5游戏《驴子跳》</a></li>
<li><a href="http://blog.csdn.net/lufy_legend/article/details/7063316">html5游戏开发-零基础开发RPG游戏</a></li>
<li><a href="http://www.cnblogs.com/Cson/tag/HTML5/">Cson的博客</a></li>
<li><span id="subtitle"><a href="http://v.youku.com/v_show/id_XMjU2NzEyNzgw.html?f=5711740">HTML5研究小组第二期技术讲座《手把手制作HTML5游戏》</a></span></li>
<li><span id="subtitle"></span><a href="http://www.doc88.com/p-540550062888.html">Andriod游戏开发</a></li>


























































</ul>
<h2>Canvas</h2>
<ul>
<li><a href="http://pan.baidu.com/share/link?shareid=291379141&amp;uk=85082582">Canvas API（pdf文件）</a></li>
<li><a href="http://www.csser.com/board/4f3f516e38a5ebc978000535">HTML5 canvas 基础入门教程</a></li>


























































</ul>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">初步需求分析</span></strong></p>
<p>下面来进行初步的需求分析。首先进行高层的需求分析；然后根据分析结果，输出用例、功能需求、非功能需求和约束条件。</p>
<h1>确定高层需求</h1>
<h2>业务目标</h2>
<ol>
<li>学习RPG游戏领域的概念和技术。</li>
<li>学习运用面向对象思想来设计。</li>
<li>实践测试驱动开发。</li>
<li>学习模型驱动设计。</li>
<li>实践设计模式。　</li>


























































</ol>
<h2>范围</h2>
<ul>
<li>人工智能</li>















































































</ul>
<p>如敌人使用A*算法寻路。</p>
<ul>
<li>页面绘制</li>















































































</ul>
<p>如显示地图、人物，实现人物移动动画。</p>
<ul>
<li>事件绑定</li>















































































</ul>
<p>玩家通过操作键盘来控制炸弹人的行为，因此游戏需要监听判断键盘事件。</p>
<ul>
<li><span style="color: #000000;">炸弹</span></li>















































































</ul>
<p><span style="color: #000000;">炸弹人能够放置炸弹，炸弹能够爆炸并炸死敌人和炸弹人。</span></p>
<h2>Feature　　</h2>
<ol>
<li>具有良好可扩展性，方便进行二次开发。</li>
<li>学习RPG领域的概念（如精灵、层、帧的概念），提炼出相应的领域模型。</li>
<li>能够显示动画。</li>
<li>敌人能够追踪炸弹人。</li>
<li>炸弹人能够放炸弹，来炸毁砖墙或炸死敌人。</li>
<li>游戏规模应该控制为小规模，保持足够的简单性。因为开发该游戏主要是用来学习而不是用于商用。</li>










































































































</ol>
<h2>上下文</h2>
<p>系统、玩家<span style="color: #c0c0c0;"><br /></span></p>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/419321/201310/02220516-7001b8cb69b445dc8825216b429cf9a9.jpg" alt="" width="388" height="380" /></p>
<h2>游戏角色</h2>
<ul>
<li>炸弹人</li>







































































</ul>
<p>炸弹人可以放炸弹。该角色由玩家控制。</p>
<ul>
<li>敌人</li>







































































</ul>
<p>敌人会追踪炸弹人。该角色由系统控制。</p>
<h1>高层需求分析的输出结果</h1>
<h2>用例</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/06143815-3f3ed4273d30424da5799a14769c5162.jpg" alt="" width="399" height="572" /></p>
<h2>功能需求</h2>
<ul>
<li>预加载</li>















































































</ul>
<p>玩家进入游戏后，预先加载游戏使用的图片到内存中。</p>
<ul>
<li>显示地图</li>















































































</ul>
<p>地图大小为20 * 20。</p>
<p>地图由墙和空地组成。</p>
<p>墙可以被炸开。</p>
<p>炸弹人、敌人不能穿过墙、炸弹。</p>
<p>炸弹人、敌人不能走出地图边界。</p>
<ul>
<li>显示人物</li>















































































</ul>
<p>在地图上显示炸弹人和敌人。</p>
<ul>
<li>人物移动</li>


























































</ul>
<p><span style="color: #000000;">炸弹人和敌人可以在地图上移动，并以动画显示。</span></p>
<ul>
<li><span style="font-size: 14px; line-height: 1.5;">敌人追踪炸弹人</span></li>















































































</ul>
<p>使用A*算法寻找从敌人所在位置到炸弹人所在位置的路径，并按照路径移动。</p>
<p><span style="color: #000000;">如果遇到炸弹人，则游戏结束；如果走到终点时没有遇到炸弹人，则再次寻找路径，然后按照路径移动。</span></p>
<ul>
<li>炸弹</li>












































































</ul>
<p>炸弹人移动时也能放炸弹</p>
<p>不能在一个方格叠加多个炸弹</p>
<p>炸弹可以爆炸，显示火焰</p>
<p>玩家、敌人不能穿过炸弹</p>
<p>炸弹可以炸掉墙</p>
<p>炸弹可以炸死玩家、敌人</p>
<p>可放置多个炸弹（3个），炸弹爆炸时会引爆在火力范围内的炸弹</p>
<ul>
<li>控制炸弹人</li>















































































</ul>
<p>玩家可以通过W、A、S、D键控制炸弹人的移动方向，一共有上下左右四个方向。</p>
<p>玩家可以使用空格键控制炸弹人放置炸弹</p>
<h2>非功能需求</h2>
<h3><span style="line-height: 1.5;">　　质量</span></h3>
<h4>　　　　开发期质量</h4>
<ul>
<li>良好的易理解性</li>


























































</ul>
<p>通过记录日志、SVN提交日志、测试文档以及注释和相关的总结文档，开发人员可以理解游戏的架构设计（参照总结文档、代码）及实现（参照日志、测试文档、代码）。</p>
<ul>
<li>良好的可扩展性</li>


























































</ul>
<p>如需要增加一个敌人时，只需要增加相应代码即可；需要增加一类敌人，只需要增加一个敌人子类及相应的客户端代码即可。不用修改已有的代码，符合开闭原则。</p>
<ul>
<li>良好的可重用性</li>


























































</ul>
<p>即在游戏中提炼出具有通用性的模块，供以后复用。</p>
<ul>
<li>良好的可测试性</li>


























































</ul>
<p>采用TDD开发，保证低耦合高内聚，增强可测试性。</p>
<h4>　　　　运行期质量</h4>
<p><span style="color: #000000;">无，</span><span>因为开发炸弹人游戏仅为了个人学习，因此对性能等运行期质量没有要求。</span></p>
<h2>约束</h2>
<ul>
<li>开发人员没有RPG游戏领域经验</li>


























































</ul>
<p>采用迭代开发的方法，逐步细化。</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文参考资料</span></strong></p>
<p>《软件架构设计》</p>
<h1>欢迎浏览下一篇博文：<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/p/3163357.html">炸弹人游戏开发系列（2）：初步设计</a></h1>]]></description></item><item><title>炸弹人游戏开发系列（2）：初步设计</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/16/3163357.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Wed, 16 Oct 2013 14:54:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/16/3163357.html</guid><description><![CDATA[<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">前言</span></strong></p>
<p>有了上文的初步需求分析后，就可以进入初步设计阶段了。</p>
<h1>本文目的</h1>
<p>得到初步的领域模型，对层和模块进行初步的划分。</p>
<h1>本文主要内容</h1>
<ul>
<li><a href="#select">技术选择</a></li>
<li><a href="#environment">开发环境</a></li>
<li><a href="#depend">外部依赖</a></li>
<li><a href="#structure">代码结构</a></li>
<li><a href="#method">开发方法</a></li>
<li><a href="#model">初步领域模型</a></li>
<li><a href="#layer">高层划分</a></li>
<li><a href="#reference">本文参考资料</a></li>
</ul>
<p><a name="select"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">技术选择</span></strong></p>
<p>首先，要确定选择什么技术来开发游戏。</p>
<p>我以前开发过网站，也开发过javascript游戏，因此我决定使用web技术开发。</p>
<p>然后就是决定是采用传统的Html4，还是最新的Html5。</p>
<p>最终我决定使用Html5技术，因为使用Html5有如下的好处：</p>
<ul>
<li>可以使用强大的Canvas API绘制游戏图像方面。</li>
<li>未来可以使用本地存储、离线存储技术来存储游戏所需的数据，实现游戏的保存和读取，提高游戏的性能。</li>
<li>未来可以使用WebSocket API实现多人联网。</li>
<li>未来可以使用Web Worker API来优化游戏的计算，提高游戏性能。</li>
<li>Html5是未来发展趋势，有必要认真学习它。</li>
</ul>
<p><a name="environment"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">开发环境</span></strong></p>
<ul>
<li>win7操作系统</li>
<li>Vs2012</li>
</ul>
<p>因为在我以前的项目中，我主要使用Asp.net技术，因此开发工具我自然而然就会选用Vs2012，虽然该IDE对于前台开发显得重型了一点。。。。。。大家也可以选用Eclispe、Dreamweaver、Sublime、Webstorm等作为开发工具。</p>
<p><a name="depend"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">外部依赖</span></strong></p>
<p>在游戏开发中，我使用以下的库：</p>
<h1>第三方库</h1>
<ul>
<li>jQuery<br /><span>使用它的选择器，进行dom操作。</span></li>
<li><span>progressBar<br />这是一个jQuery的进度条插件，我用它来显示预加载图片的进度。</span></li>
<li>jasmine<br /><span>这是一个测试框架，使用它可以进行Javascript单元测试。</span></li>








































</ul>
<h1><span style="line-height: 1.5;">我的库</span></h1>
<ul>
<li>YOOP（命名空间：YYC.Class、YYC.AClass、YYC.Interface）<br /><span>这是我的Javascript的oop框架。具体可参见</span><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/chaogex/archive/2013/06/07/3123999.html">发布我的Javascript OOP框架YOOP v1.0</a></li>
<li>图片预加载控件<a href="http://www.cnblogs.com/chaogex/p/3203061.html">PreLoadImg</a>（命名空间：YYC.Control）</li>
<li><span style="font-size: 14px; line-height: 1.5;">工具库YTool（命名空间：YYC.Tool）<br /><span style="line-height: 1.5;">我的工具方法。</span></span></li>
<li><span style="color: #000000;">Javascript原生对象扩展<br />位于object_extend.js文件中，包括了对String和Array对象的扩展。<br /></span></li>
<li><span style="color: #000000;">模式库（命名空间：YYC.Pattern）<br />包括创建对象模式的命名空间方法namespace和观察者模式的Observer.js</span></li>




























</ul>
<p><a name="structure"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">代码结构</span></strong></p>
<p>&nbsp;<strong><img src="http://images.cnitblog.com/blog/419321/201310/06095020-a38828f76d544278a4dc188fcfe1ea51.png" alt="" /></strong></p>
<ul>
<li>Content<br /><span style="line-height: 1.5;">炸弹人游戏的资源文件</span>
<ul>
<li>Image<br /><span style="line-height: 1.5;">图片资源文件</span></li>





















</ul>





















</li>





















</ul>
<ul>
<li>Script<br /><span style="line-height: 1.5;">js文件</span>
<ul>
<li>bomber<br /><span style="line-height: 1.5;">炸弹人js</span></li>
<li>jasmine
<ul>
<li>lib<br /><span style="line-height: 1.5;">jasmine框架库文件</span></li>
<li>spec<br /><span style="line-height: 1.5;">游戏的测试文件</span></li>
<li>src<br /><span style="line-height: 1.5;">测试的工具方法</span></li>





















</ul>





















</li>
<li>myTool<br /><span style="line-height: 1.5;">我的javascript库、控件、工具箱等</span>
<ul>
<li>control<br /><span style="line-height: 1.5;">控件</span></li>
<li>extend<br /><span style="line-height: 1.5;">javascript原生对象扩展</span></li>
<li>frame<br /><span style="line-height: 1.5;">YOOP框架</span></li>
<li>pattern<br /><span style="line-height: 1.5;">模式库</span></li>
<li>tool<br /><span style="line-height: 1.5;">工具箱</span></li>





















</ul>





















</li>
<li>plugIn<br /><span style="line-height: 1.5;">外部插件</span></li>





















</ul>





















</li>
<li>View<br /><span style="line-height: 1.5;">html页面</span></li>





















</ul>
<p><a name="method"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">开发方法</span></strong></p>
<p>考虑到以下原因：</p>
<ul>
<li>我没有RPG游戏的开发经验，没有适合的架构来套用，不能预见到可能会出现的问题。</li>
<li><span style="color: #000000;">开发过程中需求可能会变化。</span></li>













































































</ul>
<p>所以不能够采用传统的瀑布模型开发，而应该采用迭代开发的方法。这里我的具体开发流程为：</p>
<p><img src="http://images.cnitblog.com/blog/419321/201309/19131605-4c9e10912c23406f81a19b4060fe80e4.jpg" alt="" width="823" height="106" /></p>
<h1>流程说明</h1>
<ul>
<li>明确系统目标<br />明确要实现的目标<span>（如实现哪些技术，为实现RTS游戏作准备等）</span>。</li>
<li>确定高层需求<br />这一步需要确定范围、定义Feature、画出上下文。</li>
<li>领域模型<br />根据需求和场景，给出相关的领域模型。</li>
<li>高层划分<br />划分游戏的层、子系统、模块。</li>
<li>架构详细设计<br />对要实现的用户故事，进行详细设计，具体包括细化模块，给出类图，描述交互关系等。</li>
<li>TDD开发<br />采用先写测试，再开发的方法，构建坚实的测试套件。经常重构代码，保证代码质量。</li>
<li>迭代、反馈<br />实现用户故事后，进入反馈阶段。此时可能需要对相应的领域模型、高层划分、具体的代码等进行重构。<br /><span style="font-size: 14px; line-height: 1.5;">当有新的或修改的用户故事时，则需要在原有基础上修改或进行新的开发。修改要保证测试能够通过，有必要的话还需要增加新的测试。</span></li>




























</ul>
<p><a name="model"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">初步领域模型</span></strong></p>
<h1>为什么要进行领域建模</h1>
<ul>
<li>模型和设计的核心互相影响</li>
<li>模型是团队所有成语所使用的交流语言的中枢</li>
<li>模型是浓缩的知识</li>




























</ul>
<h1>为什么我要使用领域模型</h1>
<ul>
<li>因为我没有开发过RPG游戏，迫切需要了解RPG领域的知识，而模型是对领域知识最好的固化、提炼。</li>
<li>在详细架构设计时，可以参考和映射对应的领域模型，减少了设计的难度。</li>
<li>通过不断迭代修改领域模型，可以反映出深层的认识，固化迭代所获得的知识。</li>




























</ul>
<h1>学习RPG领域的基本概念</h1>
<h2>我是从哪学习的？</h2>
<p>分析开源的RPG游戏代码：</p>
<ul>
<li><a href="http://www.iteye.com/topic/1122395">完全分享，共同进步&mdash;&mdash;我开发的第一款HTML5游戏《驴子跳》</a></li>
<li><a href="http://blog.csdn.net/lufy_legend/article/details/7063316">html5游戏开发-零基础开发RPG游戏</a></li>
<li><a href="http://www.cnblogs.com/Cson/tag/HTML5/">Cson的博客</a></li>





























</ul>
<p>看网上的学习资料：</p>
<ul>
<li><span id="subtitle"><a href="http://v.youku.com/v_show/id_XMjU2NzEyNzgw.html?f=5711740">HTML5研究小组第二期技术讲座《手把手制作HTML5游戏》</a></span></li>
<li><span id="subtitle"></span><a href="http://www.doc88.com/p-540550062888.html">Andriod游戏开发</a></li>





























</ul>
<h2>有哪些基本概念</h2>
<ul>
<li><span style="font-size: 14px; line-height: 1.5;">精灵</span></li>















































</ul>
<p align="left">游戏中具有独立外观和属性的个体。如主角、NPC、宝箱、子弹等。</p>
<ul>
<li><a id="layerDraw"></a>分层渲染</li>















































</ul>
<p align="left">在游戏的世界里，我们可以看到各种地图，各种游戏人物，看到人物在地图上行走，对话等，无论是地图还是人物，其实都是图片的处理与显示，把不同的图片显示到屏幕上，我们就看到不同的游戏界面，要想让这些图片同时显示到界面上，我们就需要处理好层次，让他们来分层显示，我们可以想象，如果游戏人物显示在地图的下层的话，显然会被地图遮挡住。</p>
<p align="left">一个游戏中可能包含许多内容，比如主角、玩家、NPC、怪兽、道具、效果、地图和其它场景，我们没必要把它们堆到一起，这样你无法进行管理和维护，因此我将它们放到多个层级，就可以方便地对每个层级内的元素进行统一控制。如一款RPG游戏，我简单把它分为地图层，人物层，效果层(一些法术效果等)，对话层，控制层(按钮菜单等)。</p>
<p align="left"><span style="color: #888888;"><img src="http://images.cnitblog.com/blog/419321/201306/30235123-fc0f5510944646249a25304041c0fa46.png" alt="" width="550" height="309" /></span></p>
<p align="left">我们只要依次将图片画在屏幕上，游戏人物将站在地图上，如果有对话，对话将出现在人物和地图的上面，而按钮等控件会出现在游戏的最外层。<br />这里的分层不仅仅是在逻辑上将不同类型的元素分离开，不同的Layer对象还可以配置到不同的Canvas画布上，这是提升性能的一种重要的方式。</p>
<ul>
<li>帧动画</li>
































































</ul>
<p align="left">一组图片（或一个图的不同位置）在同一位置以一定的时间间隔显示，就形成了动画。一张图片就是一个帧。</p>
<ul>
<li>碰撞检测</li>
































































</ul>
<p align="left">用于检测炸弹人与砖墙、炸弹人与怪物等之间的碰撞。碰撞检测包括矩形碰撞、多边形碰撞等，一般使用矩形碰撞即可。</p>
<ul>
<li>方格地图</li>
































































</ul>
<p align="left">地图由一个个方格组成，一个方格不是对应到一个屏幕像素（1px），而是特定范围内的一整片像素（如一个方格大小为5px*5px）。</p>
<p align="left">角色在这种砖块环境中的移动路线会呈现锯齿状。为了尽量让锯齿状现象不那么明显，同时也为了避免跳格现象，游戏角色每次都只能移动到邻近方块，即一次移动一个方格。</p>
<ul>
<li>动态地图</li>
































































</ul>
<p>多张地图图片在用一个方格显示，形成动画。</p>
<ul>
<li>游戏主循环</li>
































































</ul>
<p align="left">每一个游戏都是由获得用户输入，更新游戏状态，处理AI，播放音乐和音效，还有画面显示这些行为组成。游戏主循环就是用来处理这个行为序列，在javascript中可以用setInterval方法来轮询。</p>
<ul>
<li>游戏的帧数</li>
































































</ul>
<p align="left">每秒所运行的帧数。如游戏主循环每33.3（1000/30）ms轮询一次，则游戏的帧数FPS为30.</p>
<ul>
<li><a id="actor"></a>Action接口</li>
































































</ul>
<p align="left">Actor&nbsp;是一个接口，他的作用是统一类的行为（读者可以阅读一下Facede模式相关文章）。我们用一个比喻来说明：演员们有了各自的剧本，导演对所有演员说：做&nbsp;下一个动作！演员们就会各自行动。而不用导演分别告诉每个人，你要这样做，他要那样做。具体到程序中，帧动画、动态图块两种操作会调用完全不同的函数，这&nbsp;样不利于在游戏循环中做出一致的处理。所以我们让他们都实现Actor接口，只要调用接口定义的函数，他们就会做出各自的动作。</p>
<ul>
<li><span style="font-size: 14px; line-height: 1.5;">寻路算法</span></li>

</ul>
<p><span style="color: #000000;">因为需求中有怪物追踪炸弹人的功能，因此需要使用寻路算法，怪物可以根据算法寻找到从当前方格到炸弹人方格的路径。</span></p>
<h1>建模思路</h1>
<p>现在可以根据已有的知识，建立初步的领域模型。</p>
<p>根据精灵的概念，我识别出Sprite类。一个Sprite类就代表游戏中一种独立的个体，包含了该个体相关的属性和方法。在游戏中，炸弹人就是一个Sprite类，敌人也是一个Sprite类。</p>
<p>然后，根据分层的概念，我可以识别出Layer类。Layer是集合类，Sprite可以作为其元素，Layer统一来控制Sprite的显示。</p>
<p>根据游戏主循环的概念，识别出Main类，作为游戏入口，负责控制游戏的主循环，调用相关的操作。</p>
<p>功能需求中有地图设置功能，因此需要一个MapData类来存储地图数据，需要一个ShowMap类负责显示地图。</p>
<p>功能需求中有图片预加载功能，因此需要一个PreLoadImg类负责图片预加载。</p>
<p>功能需求中有怪物追踪炸弹人的功能，因此需要有一个算法类Algorithm，负责寻找路径。</p>
<h2>领域模型</h2>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/419321/201307/15231801-8244eef719234d5fbe20a87eb10ee33b.jpg" alt="" /></p>
<p><a name="layer"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">高层划分</span></strong></p>
<p>进行初步的划分，在后面的开发中会不断地重构。</p>
<h1>分层</h1>
<p>按照经典的三层划分，应该分出表现层、业务逻辑层、数据操作层，但考虑到目前数据的操作过于简单，所以这里先去掉数据操作层。在系列第3篇博文中，我会根据实际情况再增加数据操作层。</p>
<p>根据领域模型的分析，地图数据是以类的形式保存到内存中的，因此增加一个数据层，将存放数据的数据类放到该层中。<br />增加辅助操作层，把工具类、通用的操作放到该层中。</p>
<p>因此，层就分为表现层、业务逻辑层、数据层、辅助操作层。</p>
<h2>层的职责</h2>
<ul>
<li>用户交互层<br /><span style="line-height: 1.5;">负责与HTML页面交互，提供游戏入口。</span></li>
<li>业务逻辑层<br /><span style="line-height: 1.5;">负责游戏的逻辑处理。</span></li>
<li>数据层<br /><span style="line-height: 1.5;">负责保存数据。</span></li>
<li>辅助操作层<br /><span style="line-height: 1.5;">提供通用的操作、工具方法。</span></li>




























</ul>
<h2>层的划分（目前没有确定层间关联方向）</h2>
<p><span style="color: #ff0000;"><img src="http://images.cnitblog.com/blog/419321/201310/16222630-746b5b30b74647d7969f7d15c838f671.jpg" alt="" /></span></p>
<h1>切分系统</h1>
<p>&nbsp;由于游戏规模太小，不需要切分系统。</p>
<h1>划分模块</h1>
<p>进行初步的模块划分，根据输入项得到划分的包。</p>
<h2>输入</h2>
<p><span style="line-height: 1.5;">功能树、领域模型</span></p>
<h2>输出</h2>
<p>入口包</p>
<p>算法包</p>
<p>显示精灵包</p>
<p>显示地图包</p>
<p>地图数据包</p>
<p>控件包</p>
<h2>对应的领域模型</h2>
<p><span style="color: #000000;">将领域模型划分到对应的包中，根据领域模型之间的关联，确定层之间的关联方向：</span><span style="color: #000000;"><br /></span></p>
<p><img src="http://images.cnitblog.com/blog/419321/201310/18090228-d472e1207af6427ab1648be972fd0149.jpg" alt="" /></p>
<p><a name="reference"></a></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">本文参考资料</span></strong></p>
<p>《领域驱动设计》</p>
<p>《敏捷软件开发:原则、模式与实践》&nbsp;</p>
<p><a href="http://www.iteye.com/topic/1122395">完全分享，共同进步&mdash;&mdash;我开发的第一款HTML5游戏《驴子跳》</a></p>
<p><a href="http://blog.csdn.net/lufy_legend/article/details/7063316">html5游戏开发-零基础开发RPG游戏</a></p>
<p><a href="http://www.cnblogs.com/Cson/tag/HTML5/">Cson的博客</a></p>
<p title="HTML5研究小组第二期技术讲座《手把手制作HTML5游戏》上集"><a href="http://v.youku.com/v_show/id_XMjU2NzEyNzgw.html?f=5711740"><span id="subtitle">HTML5研究小组第二期技术讲座《手把手制作HTML5游戏》</span></a></p>
<p title="Andriod游戏开发_第三章_显示文字和图片"><a href="http://www.doc88.com/p-540550062888.html">Andriod游戏开发</a></p>
<h1 title="Andriod游戏开发_第三章_显示文字和图片">欢迎浏览上一篇博文：<a id="cb_post_title_url" href="http://www.cnblogs.com/chaogex/p/3151033.html">炸弹人游戏开发系列（1）：准备工作</a></h1>
<h1 title="Andriod游戏开发_第三章_显示文字和图片">欢迎浏览下一篇博文：<a href="http://www.cnblogs.com/chaogex/p/3175811.html">炸弹人游戏开发系列（3）：显示地图</a></h1>]]></description></item><item><title>发布我的图片预加载控件YPreLoadImg v1.0</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/14/3203061.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Mon, 14 Oct 2013 12:48:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/14/3203061.html</guid><description><![CDATA[<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">介绍</span></strong></p>
<p>大家好！很高兴向大家介绍我的图片预加载控件YPreLoadImg。它可以帮助您预加载图片，并且能显示加载的进度，在预加载完成后调用指定的方法。</p>
<p>YPreLoadImg控件由一个名为PreLoadImg的类组成。该类的构造函数为：PreLoadImg(images, onstep, onload)</p>
<h1>依赖库</h1>
<p><a href="http://www.cnblogs.com/chaogex/archive/2013/06/07/3123999.html">YOOP</a></p>
<h1>用法</h1>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">new</span><span style="color: #000000;"> PreLoadImg(
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
     * 图片数据
     * id为图片id号，url为图片地址
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    [
        { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">a1</span><span style="color: #800000;">"</span>, url: <span style="color: #800000;">"</span><span style="color: #800000;">a1.png</span><span style="color: #800000;">"</span><span style="color: #000000;"> },
        { id: </span><span style="color: #800000;">"</span><span style="color: #800000;">a2</span><span style="color: #800000;">"</span>, url: <span style="color: #800000;">"</span><span style="color: #800000;">a2.png</span><span style="color: #800000;">"</span><span style="color: #000000;"> }
    ],
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
     * 获得加载进度
     * @param currentLoad 已加载的图片数量
     * @param imgCount 图片总数
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function (currentLoad, imgCount) {
    },
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
     * 加载完成后调用
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    function () {
    }
);</span></pre>
</div>
<h1><span style="color: #000000;">代码</span></h1>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> PreLoadImg =<span style="color: #000000;"> YYC.Class({
    Init: function (images, onstep, onload) {
        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._checkImages(images);

        </span><span style="color: #0000ff;">this</span>.config =<span style="color: #000000;"> {
            images: images </span>||<span style="color: #000000;"> [],
            onstep: onstep </span>||<span style="color: #000000;"> function () {},
            onload: onload </span>||<span style="color: #000000;"> function () {}
        };
        </span><span style="color: #0000ff;">this</span>._imgs =<span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">this</span>.imgCount = <span style="color: #0000ff;">this</span><span style="color: #000000;">.config.images.length;
        </span><span style="color: #0000ff;">this</span>.currentLoad = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">this</span>.timerID = <span style="color: #800080;">0</span><span style="color: #000000;">;

        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.loadImg();
    },
    Private: {
        _imgs: {},

        _checkImages: function (images) {
            </span><span style="color: #0000ff;">var</span> i = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> images) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (images.hasOwnProperty(i)) {
                    </span><span style="color: #0000ff;">if</span> (images[i].id === undefined || images[i].url ===<span style="color: #000000;"> undefined) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">应该包含id和url属性</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                }
            }
        },
        _bind: function (</span><span style="color: #0000ff;">object</span><span style="color: #000000;">, fun) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> function () {
                </span><span style="color: #0000ff;">return</span> fun.apply(<span style="color: #0000ff;">object</span><span style="color: #000000;">, arguments);
            };
        }
    },
    Public: {
        imgCount: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        currentLoad: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        timerID: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

        </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
         * 通过图片id号来获得图片对象
         * @param id 图片id号
         * @returns {*} 图片对象
         </span><span style="color: #008000;">*/</span>
        get<span style="color: #000000;">: function (id) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._imgs[id];
        },
        loadImg: function () {
            </span><span style="color: #0000ff;">var</span> c = <span style="color: #0000ff;">this</span><span style="color: #000000;">.config,
                img </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                i,
                self </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">,
                image </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; c.images.length; i++<span style="color: #000000;">) {
                img </span>=<span style="color: #000000;"> c.images[i];
                image </span>= <span style="color: #0000ff;">this</span>._imgs[img.id] = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Image();
                image.onload </span>=<span style="color: #000000;"> function () {
                    </span><span style="color: #0000ff;">this</span>.onload = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    self._bind(self, self.onload)();
                };
                image.src </span>=<span style="color: #000000;"> img.url;

                </span><span style="color: #0000ff;">this</span>.timerID =<span style="color: #000000;"> (function (i) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> setTimeout(function () {
                        </span><span style="color: #0000ff;">if</span> (i ==<span style="color: #000000;"> self.currentLoad) {
                            image.src </span>=<span style="color: #000000;"> img.url;
                        }
                    }, </span><span style="color: #800080;">500</span><span style="color: #000000;">);
                })(i);
            }
        },
        onload: function (i) {
            clearTimeout(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.timerID);
            </span><span style="color: #0000ff;">this</span>.currentLoad++<span style="color: #000000;">;
            </span><span style="color: #0000ff;">this</span>.config.onstep(<span style="color: #0000ff;">this</span>.currentLoad, <span style="color: #0000ff;">this</span><span style="color: #000000;">.imgCount);
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.currentLoad === <span style="color: #0000ff;">this</span><span style="color: #000000;">.imgCount) {
                </span><span style="color: #0000ff;">this</span>.config.onload(<span style="color: #0000ff;">this</span><span style="color: #000000;">.currentLoad);
            }
        },
        dispose: function () {
            </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> i,
                _imgs </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">._imgs;

            </span><span style="color: #0000ff;">for</span> (i <span style="color: #0000ff;">in</span><span style="color: #000000;"> _imgs) {
                _imgs[i].onload </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                _imgs[i] </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">this</span>.config = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
    }
});</span></pre>
</div>
<h1><span><a href="http://yang222.s2.jutuo.net/Control/YPreLoad"><span>效果演示</span></a></span></h1>
<p><span><span><img src="http://images.cnitblog.com/blog/419321/201310/15114536-193801ca5b6745fea5ae21d68482853d.png" alt="" /></span></span></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">下载</span></strong></p>
<p><span><a href="http://pan.baidu.com/s/1DYucl">Demo下载</a></span></p>]]></description></item><item><title>Javascript设计模式之我见：状态模式</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/13/3342166.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sun, 13 Oct 2013 11:31:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/13/3342166.html</guid><description><![CDATA[<p><span style="font-size: 14px; line-height: 1.5;">大家好！本文介绍状态模式及其在Javascript中的应用。</span></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">模式介绍</span></strong></p>
<h1>定义</h1>
<p>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p>
<p>状态模式主要解决的是控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。</p>
<h1>类图及说明</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201309/17131830-d91c5d89d1024ab2a306727b06af7e73.png" alt="" /></p>
<p>State：抽象状态</p>
<p>接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换</p>
<p>ConcreState：具体状态</p>
<p>每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态处理。通俗地说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。</p>
<p>Context：环境　</p>
<p>定义客户端需要的接口，并且负责具体状态的切换。</p>
<h1>应用场景</h1>
<ul>
<li>一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。</li>
<li>代码中包含大量与对象状态有关的条件语句:一个操作中含有庞大的多分支的条件（if else(或switch case)语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常 , 有多个操作包含这一相同的条件结构。 State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</li>
</ul>
<h1>优点</h1>
<div><ol>
<li>避免了过多的 swith&hellip;case 或者 if..else 语句的使用，避免了程序的复杂性</li>
<li>很好的使用体现了开闭原则和单一职责原则，每个状态都是一个子类，你要增加状态就增加子类，你要修改状态，你只修改一个子类就可以了</li>
<li>封装性非常好，这也是状态模式的基本要求。状态变换放置到了类的内部来实现，外部的调用不用知道类内部如何实现状态和行为的变换。</li>
</ol></div>
<h1>缺点&nbsp;</h1>
<ol>
<li>具体状态类可能会有很多个，不好管理。</li>
</ol>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">状态模式在Javascript中的应用</span></strong></p>
<h1>我的理解</h1>
<ul>
<li>ConcreteState具体状态类有两个职责：处理本状态必须完成的任务；过渡到其他状态。</li>
<li>可以采自下而上的方法来实现状态类，即先实现ConcreteState类，然后再将ConcreteState类的共性提取出来，形成父类State。</li>
</ul>
<h1><strong>类图及说明</strong></h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/13192353-bbbbde2bd8574cbaba532f5fbbfb836e.jpg" alt="" /></p>
<p>User：使用者</p>
<p>使用者具有不同的状态，它创建Context类并将状态的逻辑委托给Context类处理。</p>
<h1><span>示例</span></h1>
<p>小时候大家应该都玩过魂斗罗游戏吧，魂斗罗吃了无敌道具后会变成刀枪不入，吃了火力增强道具后会变成杀人机器。让我们来看看它的状态是如何转换的。</p>
<h2>状态图</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/13192425-61b62b37c4414a4e99b4ddcbe268ab0c.jpg" alt="" /></p>
<p>魂斗罗Warrior有NORMAL、INVINCIBLE、POWER、DEAD四个状态，每个状态都有beNormal、beInvincible、bePower、dead四个方法。有timeOver、getInvincible、getPower、beShotDead四个触发状态的事件。</p>
<h2>类图</h2>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/419321/201310/13192510-31dc1e900f3e48a3bdce0089a3e0166d.jpg" alt="" /></p>
<h2>代码</h2>
<p>代码中使用的库：<a href="http://www.cnblogs.com/chaogex/archive/2013/06/07/3123999.html">YOOP</a></p>
<p>Warrior</p>
<div class="cnblogs_code">
<pre>    <span style="color: #0000ff;">var</span> Warrior =<span style="color: #000000;"> YYC.Class({
        Private: {
            _state: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">
        },
        Public: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">*事件标志</span>
<span style="color: #000000;">
            _getInvincible: </span><span style="color: #0000ff;">false</span><span style="color: #000000;">,
            _getPower: </span><span style="color: #0000ff;">false</span><span style="color: #000000;">,
            _timeOver: </span><span style="color: #0000ff;">false</span><span style="color: #000000;">,
            _beShotDead: </span><span style="color: #0000ff;">false</span><span style="color: #000000;">,

            setState: function (state) {
                </span><span style="color: #0000ff;">this</span>._state =<span style="color: #000000;"> state;
            },
            </span><span style="color: #008000;">//</span><span style="color: #008000;">*状态方法</span>
<span style="color: #000000;">
            beNormal: function () {
                </span><span style="color: #0000ff;">switch</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">._state) {
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;">  Warrior.NORMAL_STATE:
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">本状态beNormal方法的逻辑。已经处于NORMAL状态，不用再转换为NORMAL状态了</span>
                        console.log(<span style="color: #800000;">"</span><span style="color: #800000;">恢复正常</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> Warrior.INVINCIBLE_STATE:
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">INVINCIBLE状态下beNormal方法的逻辑</span>
                        console.log(<span style="color: #800000;">"</span><span style="color: #800000;">恢复正常</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">从INVINCIBLE状态转换到NORMAL状态</span>
                        <span style="color: #0000ff;">this</span><span style="color: #000000;">.setState(Warrior.NORMAL_STATE);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> Warrior.POWER_STATE:
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">POWER状态下beNormal方法的逻辑</span>
                        console.log(<span style="color: #800000;">"</span><span style="color: #800000;">恢复正常</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">从POWER状态转换到NORMAL状态</span>
                        <span style="color: #0000ff;">this</span><span style="color: #000000;">.setState(Warrior.NORMAL_STATE);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> Warrior.DEAD_STATE:
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">不能起死回生</span>
                        <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            },
            beInvincible: function () {
                </span><span style="color: #0000ff;">switch</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">._state) {
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;">  Warrior.NORMAL_STATE:
                        console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">无敌</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.setState(Warrior.INVINCIBLE_STATE);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> Warrior.INVINCIBLE_STATE:
                        console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">无敌</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> Warrior.POWER_STATE:
                        console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">无敌</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.setState(Warrior.INVINCIBLE_STATE);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> Warrior.DEAD_STATE:
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            },
            bePower: function () {
                </span><span style="color: #0000ff;">switch</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">._state) {
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;">  Warrior.NORMAL_STATE:
                        console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">火力增强</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.setState(Warrior.POWER_STATE);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> Warrior.INVINCIBLE_STATE:
                        console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">火力增强</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.setState(Warrior.POWER_STATE);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> Warrior.POWER_STATE:
                        console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">火力增强</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> Warrior.DEAD_STATE:
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            },
            dead: function () {
                </span><span style="color: #0000ff;">switch</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">._state) {
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;">  Warrior.NORMAL_STATE:
                        console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">死亡</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.setState(Warrior.DEAD_STATE);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> Warrior.INVINCIBLE_STATE:
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">都无敌了当然不会死亡</span>
                        <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> Warrior.POWER_STATE:
                        console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">死亡</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.setState(Warrior.DEAD_STATE);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> Warrior.DEAD_STATE:
                        console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">死亡</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            },

            action: function () {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">*此处进行触发状态的事件判断</span>

                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">._timeOver) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.beNormal();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">._getInvincible) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.beInvincible();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">._getPower) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.bePower();
                }
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">._beShotDead) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.dead();
                }
            }
        },
        Static: {
            NORMAL_STATE: </span><span style="color: #800080;">1</span><span style="color: #000000;">,
            INVINCIBLE_STATE: </span><span style="color: #800080;">2</span><span style="color: #000000;">,
            POWER_STATE: </span><span style="color: #800080;">3</span><span style="color: #000000;">,
            DEAD_STATE: </span><span style="color: #800080;">4</span><span style="color: #000000;">
        }
    });</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">场景类</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">    function _resetFlag(warrior) {
        warrior._getInvincible </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        warrior._getPower </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        warrior._timeOver </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        warrior._beShotDead </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
    function _getInvincible(warrior) {
        _resetFlag(warrior);

        warrior._getInvincible </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    function _getPower(warrior) {
        _resetFlag(warrior);

        warrior._getPower </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    function _beShotDead(warrior) {
        _resetFlag(warrior);

        warrior._beShotDead </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }


    function main() {
        </span><span style="color: #0000ff;">var</span> warrior = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Warrior();

        </span><span style="color: #008000;">//</span><span style="color: #008000;">初始状态为Normal</span>
<span style="color: #000000;">        warrior.setState(Warrior.NORMAL);

        </span><span style="color: #008000;">//</span><span style="color: #008000;">获得无敌道具，进入无敌状态</span>
<span style="color: #000000;">        _getInvincible(warrior);

        warrior.action();

        </span><span style="color: #008000;">//</span><span style="color: #008000;">获得火力增强道具，进入火力增强状态</span>
<span style="color: #000000;">        _getPower(warrior);

        warrior.action();

        </span><span style="color: #008000;">//</span><span style="color: #008000;">被击中，进入死亡状态</span>
<span style="color: #000000;">        _beShotDead(warrior);

        warrior.action();
    }</span></pre>
</div>
<h2><span style="font-size: 1.5em; line-height: 1.5;">运行结果</span></h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/12231521-63c8d60a7a9d42b4954f7dfa1194ff01.png" alt="" /></p>
<h2>示例分析</h2>
<p>我们来看看这段程序的问题。</p>
<ul>
<li>实现类Warrior用了大量的switch...case判断，增加了大量代码，可读性和可维护性差。</li>
<li>扩展性差。<br />如果要增加1个状态，则beNormal、beInvincible、bePower、dead方法中都要增加判断条件，这不符合开闭原则。</li>














</ul>
<h1>使用状态模式</h1>
<h2><span>类图</span></h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/13192613-4b94e010b26b4fe296ae6b7e0e115da2.jpg" alt="" /></p>
<h2>代码</h2>
<p>State</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> State =<span style="color: #000000;"> YYC.AClass({
    Public: {
        setContext: function (context) {
            </span><span style="color: #0000ff;">this</span>.P_context =<span style="color: #000000;"> context;
        }
    },
    Protected: {
        P_context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">
    },
    Abstract: {
        beNormal: function () {
        },
        beInvincible: function () {
        },
        bePower: function () {
        },
        dead: function () {
        }
    }
});</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">NormalState</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> NormalState =<span style="color: #000000;"> YYC.Class(State, {
    Public: {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">*在具体状态类中进行触发状态的事件判断</span>
<span style="color: #000000;">
        beNormal: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.timeOver) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">本状态逻辑</span>
                console.log(<span style="color: #800000;">"</span><span style="color: #800000;">恢复正常</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        },
        beInvincible: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.getInvincible) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">过度到无敌状态的逻辑</span>
                <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setState(Context.InvincibleState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.beInvincible();
            }
        },
        bePower: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.getPower) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">过度到火力增强状态的逻辑</span>
                <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setState(Context.PowerState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.bePower();
            }
        },
        dead: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.beShotDead) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">过度到死亡状态的逻辑</span>
                <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setState(Context.DeadState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.dead();
            }
        }
    }
});</span></pre>
</div>
<p>InvincibleState</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> InvincibleState =<span style="color: #000000;"> YYC.Class(State, {
    Public: {
        beNormal: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.timeOver) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setState(Context.NormalState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.beNormal();
            }
        },
        beInvincible: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.getInvincible) {
                console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">无敌</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        },
        bePower: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.getPower) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setState(Context.PowerState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.bePower();
            }
        },
        dead: function () {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">都无敌了当然不会死亡</span>
<span style="color: #000000;">        }
    }
});</span></pre>
</div>
<p>PowerState</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> PowerState =<span style="color: #000000;"> YYC.Class(State, {
    Public: {
        beNormal: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.timeOver) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setState(Context.NormalState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.beNormal();
            }
        },
        beInvincible: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.getInvincible) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setState(Context.InvincibleState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.beInvincible();
            }
        },
        bePower: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.getPower) {
                console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">火力增强</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        },
        dead: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.beShotDead) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setState(Context.DeadState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.dead();
            }
        }
    }
});</span></pre>
</div>
<p>DeadState</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> DeadState =<span style="color: #000000;"> YYC.Class(State, {
    Public: {
        beNormal: function () {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">不能起死回生</span>
<span style="color: #000000;">        },
        beInvincible: function () {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">挂都挂了，还怎么无敌</span>
<span style="color: #000000;">        },
        bePower: function () {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">挂都挂了，还怎么火力增强</span>
<span style="color: #000000;">        },
        dead: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.beShotDead) {
                console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">死亡</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
        }
    }
});</span></pre>
</div>
<p>Context</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> Context =<span style="color: #000000;"> YYC.Class({
    Init: function (warrior) {
        </span><span style="color: #0000ff;">this</span>.warrior =<span style="color: #000000;"> warrior;
    },
    Private: {
        _state: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">
    },
    Public: {
        warrior: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">,

        setState: function (state) {
            </span><span style="color: #0000ff;">this</span>._state =<span style="color: #000000;"> state;
            </span><span style="color: #008000;">//</span><span style="color: #008000;">把当前的上下文通知到当前状态类对象中</span>
            <span style="color: #0000ff;">this</span>._state.setContext(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        },
        beNormal: function () {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.beNormal();
        },
        beInvincible: function () {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.beInvincible();
        },
        bePower: function () {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.bePower();
        },
        dead: function () {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._state.dead();
        }
    },
    Static: {
        NormalState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> NormalState(),
        InvincibleState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> InvincibleState(),
        PowerState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> PowerState(),
        DeadState: </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> DeadState()
    }
});</span></pre>
</div>
<p>Warrior</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> Warrior =<span style="color: #000000;"> YYC.Class({
    Init: function () {
        </span><span style="color: #0000ff;">this</span>._context = <span style="color: #0000ff;">new</span> Context(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">设置初始状态</span>
        <span style="color: #0000ff;">this</span><span style="color: #000000;">._context.setState(Context.NormalState);
    },
    Private: {
        _context: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">
    },
    Public: {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">*事件标志</span>
<span style="color: #000000;">
        getInvincible: </span><span style="color: #0000ff;">false</span><span style="color: #000000;">,
        getPower: </span><span style="color: #0000ff;">false</span><span style="color: #000000;">,
        timeOver: </span><span style="color: #0000ff;">false</span><span style="color: #000000;">,
        beShotDead: </span><span style="color: #0000ff;">false</span><span style="color: #000000;">,

        action: function () {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.beNormal();
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.beInvincible();
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.bePower();
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.dead();
        }
    }
});</span></pre>
</div>
<p>场景类Client</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">function _resetFlag(warrior) {
    warrior.getInvincible </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    warrior.getPower </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    warrior.imeOver </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    warrior.beShotDead </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
}
function _getInvincible(warrior) {
    _resetFlag(warrior);

    warrior.getInvincible </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}
function _getPower(warrior) {
    _resetFlag(warrior);

    warrior.getPower </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}
function _beShotDead(warrior) {
    _resetFlag(warrior);

    warrior.beShotDead </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}


function main() {
    </span><span style="color: #0000ff;">var</span> warrior = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Warrior();

    </span><span style="color: #008000;">//</span><span style="color: #008000;">获得无敌道具，进入无敌状态</span>
<span style="color: #000000;">    _getInvincible(warrior);

    warrior.action();

    </span><span style="color: #008000;">//</span><span style="color: #008000;">获得火力增强道具，进入火力增强状态</span>
<span style="color: #000000;">    _getPower(warrior);

    warrior.action();

    </span><span style="color: #008000;">//</span><span style="color: #008000;">被击中，进入死亡状态</span>
<span style="color: #000000;">    _beShotDead(warrior);

    warrior.action();
}</span></pre>
</div>
<h2><span style="font-size: 1.17em; line-height: 1.5;">运行结果</span></h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/12231521-63c8d60a7a9d42b4954f7dfa1194ff01.png" alt="" /></p>
<h2>示例分析</h2>
<h3>　　将触发状态的事件判断移到Warrior类中</h3>
<p>目前是在具体状态类中进行触发状态的事件判断，这样造成了重复判断。可以将判断提出来，放到Warrior类的action中进行判断：</p>
<p>Warrior</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        action: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.timeOver) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.beNormal();
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.getInvincible) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.beInvincible();
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.getPower) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.bePower();
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.beShotDead) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._context.dead();
            }
        }</span></pre>
</div>
<p><span>NormalState（其它三个具体状态类做相同的重构）</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> NormalState =<span style="color: #000000;"> YYC.Class(State, {
    Public: {
        beNormal: function () {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">本状态逻辑</span>
            console.log(<span style="color: #800000;">"</span><span style="color: #800000;">恢复正常</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        },
        beInvincible: function () {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">过度到无敌状态的逻辑</span>
            <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setState(Context.InvincibleState);
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.beInvincible();
        },
        bePower: function () {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">过度到火力增强状态的逻辑</span>
            <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setState(Context.PowerState);
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.bePower();
        },
        dead: function () {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">过度到死亡状态的逻辑</span>
            <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setState(Context.DeadState);
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.dead();
        }
    }
});</span></pre>
</div>
<h3>　　　　局限性</h3>
<p>如果不同状态转换为同一状态的触发事件不同，那么就不能把触发状态的事件移到Warrior类中，而需要在具体状态类中判断。</p>
<p>例如，现在从NORMAL状态转换到POWER状态的触发事件为&ldquo;获得火力增强道具&rdquo;，而从INVINCIBLE状态转换到POWER状态的触发事件为&ldquo;持续时间结束且获得火力增强道具&rdquo;：</p>
<p><img src="http://images.cnitblog.com/blog/419321/201310/13193149-ea13657ab3d5487d8f3b548cbef0f4c1.jpg" alt="" /></p>
<p>那么就不能在Warrior中进行统一的事件判断了，而应该在具体状态类NormalState、InvincibleState类中判断：</p>
<p>NormalState</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        bePower: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.getPower) {</span>
                <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setState(Context.PowerState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.bePower();
            }
        },</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">InvincibleState</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        bePower: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.P_context.warrior.timeOver &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.warrior.getPower) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.setState(Context.PowerState);
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_context.bePower();
            }
        },</span></pre>
</div>
<h3>　　　　结论</h3>
<p>不同状态转换为同一状态的触发事件相同，则可以将触发状态的事件判断放到调用Context的类中；否则将触发状态的事件判断放到具体状态类中。</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">参考资料</span></strong></p>
<h2>《设计模式之禅》</h2>
<p><a href="http://blog.csdn.net/ccf19881030/article/details/8257659">&lt;&lt;Head First设计模式&gt;&gt;之状态模式学习篇</a></p>]]></description></item><item><title>Javascript设计模式之我见：迭代器模式</title><link>http://www.cnblogs.com/chaogex/archive/2013/10/12/3342274.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sat, 12 Oct 2013 05:47:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/10/12/3342274.html</guid><description><![CDATA[<p><span style="font-size: 14px; line-height: 1.5;">大家好！本文介绍迭代器模式及其在Javascript中的应用。</span></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">模式介绍</span></strong></p>
<h1>定义</h1>
<p>提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象内部表示。</p>
<h1>类图及说明</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201310/12094238-df87998dd2394804ad48e235b3ee119e.jpg" alt="" /></p>
<p>&nbsp;</p>
<p>Iterator抽象迭代器</p>
<p>抽象迭代器负责定义访问和遍历元素的接口，而且基本上是有固定的3个方法：first()获得第一个元素，next()访问下一个元素，isDone()（或者为hasNext()）是否已经访问到底部</p>
<p>ConcreIterator具体迭代器</p>
<p>具体迭代器角色要实现迭代器接口，完成容器元素的遍历。</p>
<p>Aggregate抽象容器</p>
<p>容器角色负重提供创建具体迭代器角色的接口，必然提供一个类似createIterator()（或者为iterator()）这样的方法。</p>
<p>Concrete Aggregate具体容器</p>
<p>具体容器实现容器接口定义的方法，创建出容纳迭代器的对象。</p>
<h1>应用场景</h1>
<ul>
<li>
<p>访问一个聚合对象的内容而无需暴露它的内部表示。</p>
</li>
<li>
<p>支持对聚合对象的多种遍历。&nbsp;</p>
</li>
<li>
<p>为遍历不同的聚合结构提供一个统一的接口。</p>
</li>
</ul>
<h1>优点</h1>
<div><ol>
<li>支持以不同的方式遍历一个聚合，复杂的聚合可用多种方式进行遍历。</li>
<li>迭代器简化了聚合的接口。有了迭代器的遍历接口，聚合本身就不需要类似的遍历接口了，这样就简化了聚合的接口。</li>
<li>在同一个聚合上可以有多个遍历&nbsp;每个迭代器保持它自己的遍历状态。因此你可以同时进行多个遍历。</li>
</ol></div>
<h1>缺点&nbsp;</h1>
<ol>
<li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li>
<li>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如&nbsp;JDK&nbsp;内置迭代器&nbsp;Iterator&nbsp;就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator&nbsp;等来实现，而&nbsp;ListIterator&nbsp;迭代器无法用于操作&nbsp;Set&nbsp;类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。</li>
</ol>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">迭代器模式在Javascript中的应用</span></strong></p>
<h1>我的理解</h1>
<h2>抽象迭代器角色</h2>
<p>定义对数据结构的通用基本操作。如hasNext、next等。</p>
<h2><strong><span>具体迭代器角色</span></strong></h2>
<p>实现对某一类数据结构的基本操作。如ArrIterator实现对数组结构的基本操作，hashIterator实现对hash结构的基本操作</p>
<h2><strong><span>容器角色</span></strong></h2>
<p>实现数据结构的特定操作。</p>
<h1><strong><span>类图及说明</span></strong></h1>
<p>介绍两种形式的应用：</p>
<h2><strong><span>继承</span></strong></h2>
<p><strong><span><img src="http://images.cnitblog.com/blog/419321/201310/12124512-590ce51ef36a448482921529604c0a8a.jpg" alt="" /></span></strong></p>
<p>优点</p>
<ul>
<li>容器类可直接复用迭代器的操作，不用再提供方法iterator来获得迭代器实例了。</li>
</ul>
<p>缺点</p>
<ul>
<li>容器类继承了迭代器的所有操作，有些操作它可能不会用到。</li>
<li>限定了迭代器的扩展，在修改迭代器时可能会影响到容器类。</li>
</ul>
<p>适用场合</p>
<ul>
<li>迭代器比较简单</li>
<li>容器类需要使用所有的迭代器方法</li>
</ul>
<h2><strong><span>委托</span></strong></h2>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/419321/201310/12124521-83a75a25b58547c286572948db3614b8.jpg" alt="" /></p>
<p>优点</p>
<ul>
<li>容器类可以只使用迭代器的部分操作。</li>
<li>灵活，便于容器类与迭代器类扩展。</li>
</ul>
<p>缺点</p>
<ul>
<li>容器类中需要增加委托方法iterator。</li>
</ul>
<p>适用场合</p>
<ul>
<li>迭代器类和容器类需要扩展</li>
</ul>
<h1><span style="font-size: 2em; line-height: 1.5;">示例</span></h1>
<p>大神可以拿各种offer，屌丝表示很是好奇。一天屌丝偷偷搞到了大神读的书籍清单，于是迫不及待地打开，想看个究竟。</p>
<h2>类图</h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/12154344-e935a00032f5475589094df4c2201f93.jpg" alt="" /></p>
<h2>代码</h2>
<p>代码中使用的库：<a style="font-size: 14px; line-height: 1.5;" href="http://www.cnblogs.com/chaogex/archive/2013/06/07/3123999.html">YOOP</a></p>
<p>IBook</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> IBook = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">showInfo</span><span style="color: #800000;">"</span>);</pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">Book</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">    var</span> Book =<span style="color: #000000;"> YYC.Class({Interface: IBook}, {
        Init: function (name) {
            </span><span style="color: #0000ff;">this</span>._name =<span style="color: #000000;"> name;
        },
        Private: {
            _name: </span><span style="color: #800000;">""</span><span style="color: #000000;">
        },
        Public: {
            showInfo: function () {
                console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">._name);
            }
        }
    });</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">场景类</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">    function main(){
         </span><span style="color: #008000;">//</span><span style="color: #008000;">定义一个数组容器，存放所有的书对象</span>
        <span style="color: #0000ff;">var</span><span style="color: #000000;"> container, i, len;

        container </span>=<span style="color: #000000;"> [];
        i </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

        container.push(</span><span style="color: #0000ff;">new</span> Book(<span style="color: #800000;">"</span><span style="color: #800000;">设计模式之禅</span><span style="color: #800000;">"</span><span style="color: #000000;">));
        container.push(</span><span style="color: #0000ff;">new</span> Book(<span style="color: #800000;">"</span><span style="color: #800000;">Http权威指南</span><span style="color: #800000;">"</span><span style="color: #000000;">));
        container.push(</span><span style="color: #0000ff;">new</span> Book(<span style="color: #800000;">"</span><span style="color: #800000;">深入理解计算机操作系统</span><span style="color: #800000;">"</span><span style="color: #000000;">));

        </span><span style="color: #0000ff;">for</span>(i = <span style="color: #800080;">0</span>, len = container.length; i &lt; len; i++<span style="color: #000000;">){
                container[i].showInfo();
        }
    }<br /></span></pre>
</div>
<h2>&nbsp;<span style="font-size: 1.5em; line-height: 1.5;">运行结果</span></h2>
<p><img src="http://images.cnitblog.com/blog/419321/201310/12111712-58b861ee148c4985b23e6fb3f70c82c4.png" alt="" /></p>
<h2>示例分析</h2>
<p>场景类中实现了一个数组容器及其遍历。应该把容器的实现封装起来形成容器类，令场景类调用容器的接口方法。</p>
<p>另外，容器类中访问数组容器元素的逻辑具有通用性，可以提出来形成迭代器类。凡是需要访问数组容器元素的容器类，只要使用迭代器类就可以实现。</p>
<h1>使用迭代器模式</h1>
<p>现在分别用继承和委托的方式来实现。</p>
<h3><span style="font-size: 1.17em; line-height: 1.5;">继承</span></h3>
<p>可以将内部容器container放到Iterator类中。</p>
<h4><span style="font-size: 1.17em; line-height: 1.5;">类图</span></h4>
<p><img src="http://images.cnitblog.com/blog/419321/201310/12124628-bd799349226949c3afa59ca2ebe516c9.jpg" alt="" /></p>
<h4>代码</h4>
<p><span style="font-size: 14px; line-height: 1.5;">IIterator</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> IIterator = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">hasNext</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">next</span><span style="color: #800000;">"</span>);</pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">Iterator</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> Iterator =<span style="color: #000000;"> YYC.Class({Interface: IIterator}, {
    Init: function () {
    },
    Private: {
        _container: [],
        _cursor: </span><span style="color: #800080;">0</span><span style="color: #000000;">
    },
    Public: {
        hasNext: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._cursor === <span style="color: #0000ff;">this</span><span style="color: #000000;">._container.length) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        },
        next: function () {
            </span><span style="color: #0000ff;">var</span> result = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasNext()) {
                result </span>= <span style="color: #0000ff;">this</span>._container[<span style="color: #0000ff;">this</span><span style="color: #000000;">._cursor];
                </span><span style="color: #0000ff;">this</span>._cursor += <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                result </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }

            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
        }
    }
});</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">BookContainer</span></p>
<div class="cnblogs_code">
<pre>     <span style="color: #0000ff;">var</span> BookContainer =<span style="color: #000000;"> YYC.Class(Iterator, {
         Init: function(){},
         Public: {
             add: function(name){
                 </span><span style="color: #0000ff;">this</span>._container.push(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Book(name));
             },
             showInfo: function(){
                 </span><span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasNext()){
                     </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.next().showInfo();
                 }
             }
         }
     });</span></pre>
</div>
<p>IBook</p>
<div class="cnblogs_code">
<pre><span>var</span> IBook = YYC.Interface(<span>"</span><span>showInfo</span><span>"</span>);</pre>
</div>
<p><span>Book</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> Book =<span style="color: #000000;"> YYC.Class({Interface: IBook}, {
    Init: function (name) {
        </span><span style="color: #0000ff;">this</span>._name =<span style="color: #000000;"> name;
    },
    Private: {
        _name: </span><span style="color: #800000;">""</span><span style="color: #000000;">
    },
    Public: {
        showInfo: function () {
            console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">._name);
        }
    }
});</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">场景类Client</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">function main() {
    </span><span style="color: #0000ff;">var</span> container = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BookContainer();

    container.add(</span><span style="color: #800000;">"</span><span style="color: #800000;">设计模式之禅</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    container.add(</span><span style="color: #800000;">"</span><span style="color: #800000;">Http权威指南</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    container.add(</span><span style="color: #800000;">"</span><span style="color: #800000;">深入理解计算机操作系统</span><span style="color: #800000;">"</span><span style="color: #000000;">);

    container.showInfo();
}</span></pre>
</div>
<h3>委托</h3>
<p>Iterator中通过注入获得内部容器container。</p>
<h4><span>类图</span></h4>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/419321/201310/12124715-92514bb485104eefbfc4a81bb4e3b705.jpg" alt="" /></p>
<h4>代码</h4>
<p><span>IIterator</span></p>
<div class="cnblogs_code">
<pre><span>var</span> IIterator = YYC.Interface(<span>"</span><span>hasNext</span><span>"</span>, <span>"</span><span>next</span><span>"</span>);</pre>
</div>
<p><span>Iterator</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> Iterator =<span style="color: #000000;"> YYC.Class({Interface: IIterator}, {
    Init: function (container) {
        </span><span style="color: #0000ff;">this</span>._container =<span style="color: #000000;"> container;
    },
    Private: {
        _container: [],
        _cursor: </span><span style="color: #800080;">0</span><span style="color: #000000;">
    },
    Public: {
        hasNext: function () {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._cursor === <span style="color: #0000ff;">this</span><span style="color: #000000;">._container.length) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        },
        next: function () {
            </span><span style="color: #0000ff;">var</span> result = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.hasNext()) {
                result </span>= <span style="color: #0000ff;">this</span>._container[<span style="color: #0000ff;">this</span><span style="color: #000000;">._cursor];
                </span><span style="color: #0000ff;">this</span>._cursor += <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                result </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }

            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
        }
    }
});</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">IBookContainer</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> IBookContainer = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">add</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">iterator</span><span style="color: #800000;">"</span>);</pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">BookContainer</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> BookContainer =<span style="color: #000000;"> YYC.Class({ Interface: IBookContainer }, {
    Init: function () {
    },
    Private: {
        _container: []
    },
    Public: {
        add: function (name) {
            </span><span style="color: #0000ff;">this</span>._container.push(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Book(name));
        },
        iterator: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Iterator(<span style="color: #0000ff;">this</span><span style="color: #000000;">._container);
        }
    }
});</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">IBook</span></p>
<div class="cnblogs_code">
<pre>var IBook = YYC.Interface("showInfo");</pre>
</div>
<p>Book</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> Book =<span style="color: #000000;"> YYC.Class({Interface: IBook}, {
    Init: function (name) {
        </span><span style="color: #0000ff;">this</span>._name =<span style="color: #000000;"> name;
    },
    Private: {
        _name: </span><span style="color: #800000;">""</span><span style="color: #000000;">
    },
    Public: {
        showInfo: function () {
            console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">._name);
        }
    }
});</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">场景类Client</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">function main() {
    </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> container, iter;

    container </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> BookContainer();

    container.add(</span><span style="color: #800000;">"</span><span style="color: #800000;">设计模式之禅</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    container.add(</span><span style="color: #800000;">"</span><span style="color: #800000;">Http权威指南</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    container.add(</span><span style="color: #800000;">"</span><span style="color: #800000;">深入理解计算机操作系统</span><span style="color: #800000;">"</span><span style="color: #000000;">);


    iter </span>=<span style="color: #000000;"> container.iterator();

    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (iter.hasNext()) {
        iter.next().showInfo();
    }
}</span></pre>
</div>
<h4><span style="font-size: 1.17em; line-height: 1.5;">变形</span></h4>
<p><span style="font-size: 1.17em; line-height: 1.5;">　　上面将容器类<span>BookContainer</span>的showInfo方法放到场景类中实现。也可以将其放到<span>BookContainer</span>中，这样BookContainer就不需要iterator方法了。</span></p>
<p><span>IBookContainer</span></p>
<div class="cnblogs_code">
<pre><span>var</span> IBookContainer = YYC.Interface(<span>"</span><span>add</span><span>"</span>, <span>"</span><span>showInfo</span><span>"</span>);</pre>
</div>
<p><span style="font-size: 1.17em; line-height: 1.5;">BookContainer</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> BookContainer =<span style="color: #000000;"> YYC.Class({ Interface: IBookContainer }, {
    Init: function () {
        </span><span style="color: #0000ff;">this</span>._iter = <span style="color: #0000ff;">new</span> Iterator(<span style="color: #0000ff;">this</span><span style="color: #000000;">._container);
    },
    Private: {
        _container: [],
        _iter: </span><span style="color: #0000ff;">null</span><span style="color: #000000;">
    },
    Public: {
        add: function (name) {
            </span><span style="color: #0000ff;">this</span>._container.push(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Book(name));
        },
        showInfo: function () {
            </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">._iter.hasNext()) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._iter.next().showInfo();
            }
        }
    }
});</span></pre>
</div>
<p><span style="font-size: 1.17em; line-height: 1.5;">场景类</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">function main() {
    </span><span style="color: #0000ff;">var</span> container = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BookContainer();

    container.add(</span><span style="color: #800000;">"</span><span style="color: #800000;">设计模式之禅</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    container.add(</span><span style="color: #800000;">"</span><span style="color: #800000;">Http权威指南</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    container.add(</span><span style="color: #800000;">"</span><span style="color: #800000;">深入理解计算机操作系统</span><span style="color: #800000;">"</span><span style="color: #000000;">);

    container.showInfo();
}</span></pre>
</div>
<h3><span style="font-size: 1.17em; line-height: 1.5;">运行结果</span></h3>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/419321/201310/12120526-e7650e25d5f64cda8d05d0bdcba91105.png" alt="" /></p>
<h2>示例分析</h2>
<p>　　<strong>为什么add放到容器类BookContainer，而不是放到迭代器Iterator中呢？</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">add: function (name) {
    </span><span style="color: #0000ff;">this</span>._container.push(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Book(name));
},</span></pre>
</div>
<p>因为在add方法中需要创建Book实例，因此与容器元素Book强耦合。而Iterator中都是容器的基本操作，是不需要知道具体的容器元素的。所以add不能放到Iterator中。</p>
<p>又因为add属于容器操作，因此应该放到作为容器类的BookContainer中。</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">参考资料</span></strong></p>
<h2><span>《设计模式之禅》</span></h2>
<p><a href="http://wenku.baidu.com/view/1ad15f11f18583d0496459e3.html"><span id="doc-tittle-5">迭代器模式</span></a></p>]]></description></item><item><title>Javascript设计模式之我见：观察者模式</title><link>http://www.cnblogs.com/chaogex/archive/2013/09/28/3340725.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sat, 28 Sep 2013 06:11:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/09/28/3340725.html</guid><description><![CDATA[<p>大家好！本文介绍观察者模式及其在Javascript中的应用。</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">模式介绍</span></strong></p>
<h1>定义</h1>
<p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p>
<h1>类图及说明</h1>
<p><img src="http://images.cnitblog.com/blog/419321/201309/26113842-bdd89b488ddb4998b1967d3eefa8d35e.png" alt="" /></p>
<p>&nbsp;</p>
<p>Subject：主题\发布者</p>
<p>能够动态地增加、取消观察者。它负责管理观察者并通知观察者。</p>
<p>Observer：观察者\订阅者</p>
<p>观察者收到消息后，即进行update操作，对接收到的信息进行处理。</p>
<p>ConcreteSubject：具体的主题\发布者</p>
<p>定义主题自己的业务逻辑，同时定义对哪些事件进行通知。</p>
<p>ConcreteObserver：具体的观察者\订阅者</p>
<p>每个观察者在接受到消息后的处理反应时不同的，各个观察者有自己的处理逻辑。</p>
<h1>应用场景</h1>
<ul>
<li><span style="font-size: 15px; line-height: 1.5;">当一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变。</span></li>
<li>
<p><span style="line-height: 1.5;">当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之,&nbsp;你不希望这些对象是紧密耦合的。</span></p>
</li>
<li>
<p><span style="line-height: 1.5; font-size: 14px;">对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。&nbsp;</span></p>
</li>
</ul>
<h4><span style="font-size: 2em; line-height: 1.5;">优点</span></h4>
<ol>
<li>支持简单的广播通信，自动通知所有已经订阅过的对象。</li>
<li>页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性。</li>
<li>目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用。&nbsp;</li>
</ol>
<h1>缺点&nbsp;</h1>
<p>1、&nbsp;&nbsp;松偶合导致代码关系不明显，有时可能难以理解。</p>
<p>2、&nbsp;&nbsp;如果一个Subject被大量Observer订阅的话，在广播通知的时候可能会有效率问题。&nbsp;</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">观察者模式在Javascript中的应用</span></strong></p>
<h1>类图及说明</h1>
<p><img src="http://images.cnitblog.com/i/419321/201406/040856300995745.jpg" alt="" /></p>
<p>这里有两个变化：</p>
<ol>
<li>ConcreteSubject与Subject的继承关系改为委托关系。</li>
<li>删除了Observer基类，直接将观察者的update方法订阅到Subject的events数组中。</li>
</ol>
<h1>应用场景</h1>
<ul>
<li><span style="font-size: 15px;">一个对象变化时触发多个对象变化</span></li>
<li><span style="font-size: 15px;">一个对象调用其他对象的方法，而又不想与之耦合</span></li>
</ul>
<h1>示例</h1>
<p>现在是找工作的季节，大家都在忙着找工作。大神可以单枪匹马秒杀各种offer，高富帅也有各种关系帮忙找工作。</p>
<p>让我们来看下高富帅是如何找工作的。</p>
<h2>类图</h2>
<p>&nbsp;<img src="http://images.cnitblog.com/i/419321/201406/040914258952017.jpg" alt="" /></p>
<h2>代码</h2>
<p>GaoFuShuai</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">function GaoFuShuai() {
    </span><span style="color: #0000ff;">this</span>._wang = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Wang();
}

GaoFuShuai.prototype.findJob </span>=<span style="color: #000000;"> function () {
    console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">高富帅开始找工作了</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._wang.help();
};</span></pre>
</div>
<p>王哥</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">        function Wang() {
        }

        Wang.prototype.help </span>=<span style="color: #000000;"> function () {
            console.log(</span><span style="color: #800000;">"高富帅找工作啊，</span><span style="color: #800000;">王哥来助你</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        }</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">场景</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">function main() {
    </span><span style="color: #0000ff;">var</span> gaofushuai = <span style="color: #0000ff;">new</span><span style="color: #000000;"> GaoFuShuai();

    gaofushuai.findJob();
}</span></pre>
</div>
<h2>运行结果</h2>
<p><img src="http://images.cnitblog.com/i/419321/201406/040919394742784.png" alt="" /></p>
<h2>分析</h2>
<p>本设计有以下的缺点：</p>
<ol>
<li><span style="font-size: 14px; line-height: 1.5;">观察者可能不止一个，如果增加李哥、张哥等观察类，那就都要对应修改高富帅类，不符合开闭原则。</span></li>
<li><span style="font-size: 14px; line-height: 1.5;">观察者可能不仅仅要观察高富帅的找工作情况，还要观察高富帅的上学、娱乐等情况，这样会有严重的耦合问题。</span></li>
</ol>
<h1>使用观察者模式</h1>
<p>现在使用观察者模式来改进设计。</p>
<h2><span style="font-size: 1.17em; line-height: 1.5;">类图</span></h2>
<p><img src="http://images.cnitblog.com/i/419321/201406/040934235207569.jpg" alt="" /></p>
<h2>代码</h2>
<p>Subject</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('6b811347-f9a4-48fb-bb68-1eccebbc0696')"><img id="code_img_closed_6b811347-f9a4-48fb-bb68-1eccebbc0696" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_6b811347-f9a4-48fb-bb68-1eccebbc0696" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6b811347-f9a4-48fb-bb68-1eccebbc0696',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_6b811347-f9a4-48fb-bb68-1eccebbc0696" class="cnblogs_code_hide">
<pre><span style="color: #000000;">   (function () {
        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">Array.prototype.forEach) {
            Array.prototype.forEach </span>=<span style="color: #000000;"> function (fn, thisObj) {
                </span><span style="color: #0000ff;">var</span> scope = thisObj ||<span style="color: #000000;"> window;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #0000ff;">this</span>.length; i &lt; j; ++<span style="color: #000000;">i) {
                    fn.call(scope, </span><span style="color: #0000ff;">this</span>[i], i, <span style="color: #0000ff;">this</span><span style="color: #000000;">);
                }
            };
        }

        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">Array.prototype.filter) {
            Array.prototype.filter </span>=<span style="color: #000000;"> function (fn, thisObj) {
                </span><span style="color: #0000ff;">var</span> scope = thisObj ||<span style="color: #000000;"> window;
                </span><span style="color: #0000ff;">var</span> a =<span style="color: #000000;"> [];
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #0000ff;">this</span>.length; i &lt; j; ++<span style="color: #000000;">i) {
                    </span><span style="color: #0000ff;">if</span> (!fn.call(scope, <span style="color: #0000ff;">this</span>[i], i, <span style="color: #0000ff;">this</span><span style="color: #000000;">)) {
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    a.push(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">[i]);
                }
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> a;
            };
        }

        </span><span style="color: #0000ff;">var</span> Subject =<span style="color: #000000;"> function () {
            </span><span style="color: #0000ff;">this</span>._events =<span style="color: #000000;"> [];
        }

        Subject.prototype </span>=<span style="color: #000000;"> (function () {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">订阅方法</span>
<span style="color: #000000;">                subscribe: function (context, fn) {
                    </span><span style="color: #0000ff;">if</span> (arguments.length == <span style="color: #800080;">2</span><span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">this</span>._events.push({ context: arguments[<span style="color: #800080;">0</span>], fn: arguments[<span style="color: #800080;">1</span><span style="color: #000000;">] });
                    }
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        </span><span style="color: #0000ff;">this</span>._events.push(arguments[<span style="color: #800080;">0</span><span style="color: #000000;">]);
                    }
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">发布指定方法</span>
<span style="color: #000000;">                publish: function (context, fn, args) {
                    </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">2</span>);    <span style="color: #008000;">//</span><span style="color: #008000;">获得函数参数</span>
                    <span style="color: #0000ff;">var</span> _context = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">var</span> _fn = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._events.filter(function (el) {
                        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (el.context) {
                            _context </span>=<span style="color: #000000;"> el.context;
                            _fn </span>=<span style="color: #000000;"> el.fn;
                        }
                        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            _context </span>=<span style="color: #000000;"> context;
                            _fn </span>=<span style="color: #000000;"> el;
                        }

                        </span><span style="color: #0000ff;">if</span> (_fn ===<span style="color: #000000;"> fn) {
                            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> _fn;
                        }
                    }).forEach(function (el) {  </span><span style="color: #008000;">//</span><span style="color: #008000;">指定方法可能有多个</span>
                                el.apply(_context, args);       <span style="color: #008000;">//</span><span style="color: #008000;">执行每个指定的方法</span>
<span style="color: #000000;">                            });
                },
                unSubscribe: function (fn) {
                    </span><span style="color: #0000ff;">var</span> _fn = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">this</span>._events = <span style="color: #0000ff;">this</span><span style="color: #000000;">._events.filter(function (el) {
                        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (el.fn) {
                            _fn </span>=<span style="color: #000000;"> el.fn;
                        }
                        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            _fn </span>=<span style="color: #000000;"> el;
                        }

                        </span><span style="color: #0000ff;">if</span> (_fn !==<span style="color: #000000;"> fn) {
                            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> el;
                        }
                    });
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">全部发布</span>
<span style="color: #000000;">                publishAll: function (context, args) {
                    </span><span style="color: #0000ff;">var</span> args = Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span>);    <span style="color: #008000;">//</span><span style="color: #008000;">获得函数参数</span>
                    <span style="color: #0000ff;">var</span> _context = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">var</span> _fn = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._events.forEach(function (el) {
                        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (el.context) {
                            _context </span>=<span style="color: #000000;"> el.context;
                            _fn </span>=<span style="color: #000000;"> el.fn;
                        }
                        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            _context </span>=<span style="color: #000000;"> context;
                            _fn </span>=<span style="color: #000000;"> el;
                        }

                        _fn.apply(_context, args);       </span><span style="color: #008000;">//</span><span style="color: #008000;">执行每个指定的方法</span>
<span style="color: #000000;">                    });
                },
                dispose: function () {
                    </span><span style="color: #0000ff;">this</span>._events =<span style="color: #000000;"> [];
                }
            }
        })();

        window.Subject </span>=<span style="color: #000000;"> Subject;
    })();</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>GaoFuShuai</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> GaoFuShuai() {
}

GaoFuShuai.prototype.findJob </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    console.log(</span>"高富帅开始找工作了"<span style="color: #000000;">);
    window.subject.publishAll(null, </span>"帮忙找工作"<span style="color: #000000;">);
};
GaoFuShuai.prototype.haveFun </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    console.log(</span>"高富帅开始娱乐了"<span style="color: #000000;">);
    window.subject.publishAll(null, </span>"帮忙找乐子"<span style="color: #000000;">);
};</span></pre>
</div>
<p>王哥</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> Wang() {
}

Wang.prototype.help </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (actionStr) {
    console.log(</span>"王哥" +<span style="color: #000000;"> actionStr);
};</span></pre>
</div>
<p>李哥</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> Li() {
}

Li.prototype.help </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (actionStr) {
    console.log(</span>"李哥" +<span style="color: #000000;"> actionStr);
};</span></pre>
</div>
<p>场景</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> main() {
    </span><span style="color: #0000ff;">var</span> wang = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Wang(),
        li </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Li(),
        gaofushuai </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> GaoFuShuai();

    window.subject </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Subject();
    window.subject.subscribe(wang.help);
    window.subject.subscribe(li.help);

    gaofushuai.findJob();
    gaofushuai.haveFun();
}</span></pre>
</div>
<h2>运行结果</h2>
<p><img src="http://images.cnitblog.com/i/419321/201406/040940269589470.png" alt="" /></p>
<h2>分析</h2>
<p>这样就符合开闭原则了，被观察者与观察者也不再直接耦合了。如果想继续增加观察者，则只需对应修改main即可，被观察者GaoFuShuai类不用修改。</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">参考资料</span></strong></p>
<h2><span style="font-size: 16px;"><a id="ctl01_lnkTitle" href="http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html">深入理解JavaScript系列（32）：设计模式之观察者模式<br /></a></span><span style="font-size: 16px;">《设计模式之禅》</span></h2>]]></description></item><item><title>Javascript设计模式之我见：开篇</title><link>http://www.cnblogs.com/chaogex/archive/2013/09/26/3340425.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Thu, 26 Sep 2013 03:13:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/09/26/3340425.html</guid><description><![CDATA[<p>系列博文目录</p>
<p>&nbsp;</p>
<p>系列定位：向读者阐释在javascript中如何运用设计模式。因此，给出的示例要比较简单，不是我项目中实际使用的代码，而是我假设简化后的例子。</p>
<p>&nbsp;</p>
<p>系列特色：给出我对设计模式的理解，及其在javascript中的应用</p>
<p>&nbsp;</p>
<p>系列风格：语言幽默接地气。可参考《设计模式之禅》的语言风格。</p>
<p>&nbsp;</p>
<p>系列每篇博文详细阐释一个设计模式，写一篇发布一篇</p>
<p>格式可如下：</p>
<p>&nbsp;</p>
<p>通用模式说明</p>
<p>　　通用类图</p>
<p>　　角色</p>
<p>　　应用场景</p>
<p>　　优点</p>
<p>　　缺点</p>
<p>&nbsp;</p>
<p>Javascript中具体实现</p>
<p>　　类图</p>
<p>　　使用示例</p>
<p>　　我用到的场景（项目中用到的场景，简单说明下）</p>
<p>&nbsp;</p>
<p>　　与通用模式的比较</p>
<p>&nbsp;</p>
<p>总结</p>
<p>&nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>测试驱动开发：开发StringBuilder类</title><link>http://www.cnblogs.com/chaogex/archive/2013/09/24/3336895.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Tue, 24 Sep 2013 06:50:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/09/24/3336895.html</guid><description><![CDATA[<p>演示使用TDD开发StringBuilder类的过程</p>
<p>&nbsp;</p>
<p>尽量写详细点</p>]]></description></item><item><title>博文模板1</title><link>http://www.cnblogs.com/chaogex/archive/2013/09/17/3327093.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Tue, 17 Sep 2013 12:09:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/09/17/3327093.html</guid><description><![CDATA[<p><strong><span style="font-size: 18pt;">前言</span></strong></p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt;"><strong>说明</strong></span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt;">本文目的</span></strong></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt;">本文主要内容</span></strong></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt;">回顾上文更新后的领域模型</span></strong></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt; line-height: 1.5;">对领域模型进行思考</span></strong></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt;">开发策略</span></strong></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt;">正文</span></strong></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt; line-height: 1.5;">本文最终完整的领域模型</span></strong></p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt;"><strong>高层划分</strong></span></p>
<p><span style="color: #c0c0c0;">&nbsp;</span></p>
<p><strong><span style="font-size: 18pt;">本文源码下载</span></strong></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt;">演示地址</span></strong></p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt;"><strong>本文参考资料</strong></span></p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;"><strong><span style="font-size: 18pt;">欢迎浏览下一篇博文：</span></strong></span></p>
<p>&nbsp;</p>
<p><span style="color: #c0c0c0;">版本xx-xx</span></p>]]></description></item><item><title>创建Javascript的测试框架YTester（1）：创建Fake框架</title><link>http://www.cnblogs.com/chaogex/archive/2013/09/01/3294663.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sun, 01 Sep 2013 08:22:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/09/01/3294663.html</guid><description><![CDATA[<h1>介绍</h1>
<p>YTester包括以下部分：Fake框架、Stub框架、Mock框架。本文将创建Fake框架。</p>
<p>createFake</p>
<p>系列目录</p>
<ul>
<li><a href="http://www.cnblogs.com/chaogex/p/3294663.html%20">创建Javascript的测试框架YTester（1）：创建fake框架</a></li>
</ul>
<p>系列开发策略</p>
<p>&nbsp;</p>
<p>为什么要创建Mock框架，而不直接使用jasmine的spy</p>
<p>　　局限性</p>
<ul>
<li>解决jasmine.createSpy()会影响其他测试的问题</li>
<li>减少代码量（backup、restore等）</li>
</ul>
<p>示例</p>
<p>现在有A类和B类，在A的run方法中，需要调用B的buildNum方法，生成一个数字并将其赋给num属性。</p>
<p>&nbsp;</p>
<p>构造假数据</p>
<p>&nbsp;</p>
<p>使用createSpy</p>
<p>&nbsp;</p>
<p>　　期望的解决方案</p>
<p>&nbsp;将备份、恢复等活交给mock框架来做，</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>目的</p>
<ul>
<li>解决jasmine.createSpy()会影响其他测试的问题</li>
<li>减少代码量（backup、restore等）</li>
<li>接近mock风格，更加优雅</li>
</ul>
<h1 class="entry-title J_SinglePostTitle">&nbsp;</h1>
<h1>依赖库</h1>
<p>第三方库</p>
<p>jasmine</p>
<p>我的库</p>
<p><a href="http://www.cnblogs.com/chaogex/archive/2013/06/07/3123999.html">YOOP</a></p>
<p><span>工具库YTool<span style="color: #c0c0c0;">（命名空间：YYC.Tool）</span></span>中的extend、judge、namespace、object</p>
<p class="entry-title J_SinglePostTitle">&nbsp;</p>
<h1>用法</h1>
<p>stub 对象直接量</p>
<p>createObj</p>
<p>　　mock</p>
<p>　　　　fake</p>
<p>　　　　return</p>
<p>　　replace</p>
<p>&nbsp;</p>
<p>stub 类</p>
<p>createClass</p>
<p>&nbsp;</p>
<h1>代码</h1>
<p><span style="color: #888888;">测试代码</span></p>
<p>实现代码</p>
<p>代码分析</p>
<h1>下载</h1>
<p>demo下载</p>
<h1>参考资料</h1>
<p class="postTitle"><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/frostbelt/archive/2012/08/03/2622302.html">javascript单元测试</a></p>
<p class="entry-title J_SinglePostTitle"><a href="http://www.36ria.com/4457">Jasmine入门教程&mdash;web前端开发七武器（上）</a></p>
<p class="entry-title J_SinglePostTitle"><a href="http://www.36ria.com/4473">Jasmine入门教程&mdash;web前端开发七武器（下）</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-easymock.html">使用 EasyMock 更轻松地进行测试</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>目的</p>
<ul>
<li>解决jasmine.createSpy()会影响其他测试的问题</li>
<li>减少代码量（backup、restore等）</li>
<li>接近mock风格，更加优雅</li>
</ul>
<p>&nbsp;</p>
<p>后期扩展</p>
<ul>
<li>支持mock类实例（增加createMock）</li>
<li>构造假数据、假对象</li>
<li>方便插入和回收要测试的html</li>
<li>对属性进行mock</li>
<li>根据指定的参数，返回指定的结果</li>
<li>实现verify方法</li>
</ul>
<p>参照easymock，增加新功能</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>发布我的控件系列：弹出窗口控件YWindow v1.0</title><link>http://www.cnblogs.com/chaogex/archive/2013/08/06/3240506.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Tue, 06 Aug 2013 06:47:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/08/06/3240506.html</guid><description><![CDATA[<p>重新开发Window.js</p>
<p>&nbsp;</p>
<p>需求：</p>
<p>使用TDD开发<br />精简代码<br />可以更换css<br />去掉DOTA前缀（css），不使用任何前缀（js的命名空间中用YYC作为前缀，css中的类名不用前缀）</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>参考：</p>
<p>DOTA.window v0.1<br />作者：黄健<br />日期：2009.09.28<br />ＱＱ：573704282<br />Email: freewind22@163.com</p>]]></description></item><item><title>发布我的工具库YTool v0.1</title><link>http://www.cnblogs.com/chaogex/archive/2013/08/06/3240499.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Tue, 06 Aug 2013 06:45:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/08/06/3240499.html</guid><description><![CDATA[<p><span style="color: #888888;">将MyTool.tool和namespace合并为一个库，定义YYC命名空间。</span></p>
<p><br /><span style="color: #888888;">以后增加或修改MyTool时，先放到临时文件夹，然后定期更新各个子js（如extend.js、judge.js等），集成更新库。</span></p>
<p><span style="color: #888888;">&nbsp;</span></p>
<p><span style="color: #888888;">该文的目的</span></p>
<ul>
<li><span style="color: #888888;">介绍YTool包含的内容</span></li>
<li><span style="color: #888888;">整理工具箱，合并、修改、删除、重命名子js</span></li>



</ul>
<p><span style="color: #888888;">&nbsp;</span></p>
<p><span style="color: #888888;">该文会随着工具箱的更新而更新</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>//正式发布时需要进行的工作：</p>
<p>//验证YTool代码的每个方法均可用</p>
<p>//整理好文档，每个方法都要给出示例</p>
<p>&nbsp;</p>
<p>大家好！今天我正式发布我的工具库<span>YTool</span>&nbsp;0.1版本！<span style="color: #888888;">该库还不是很成熟，不过后续我会持续更新该库的版本的！</span></p>
<p><strong>来源</strong></p>
<p><span style="color: #888888;">YTool是我平时开发所积累的通用方法。</span></p>
<p>YTool库的大部分内容是我平时用js开发游戏、库、控件时，提取出来的通用方法；也有一些内容是从网上收集的或是对网上资料修改加工而成的。</p>
<p>&nbsp;</p>
<p>目的</p>
<p>我写这篇博文的目的是想与大家分享经验，共同进步，也为了帮助读者能更好的理解我的博客中发布的js游戏和库等内容。</p>
<p>&nbsp;</p>
<p>介绍</p>
<p>我给大家介绍下YTool库的内容。</p>
<p>&nbsp;</p>
<p>定义的命名空间</p>
<p>YTool定义了YYC和YYC.Tool命名空间</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>介绍两个</p>
<p>&nbsp;</p>
<p>YTool在YYC命名空间中实现了namespace、register方法，这两个方法都可以用来创建命名空间。</p>
<p>&nbsp;</p>
<p>介绍其他内容</p>
<p>在YYC.Tool命名空间中，实现了以下几类的通用方法：</p>
<p>ajax</p>
<p>异步</p>
<p>容器</p>
<p>　　集合</p>
<p>cookie</p>
<p>dom</p>
<p>　　复选框</p>
<p>　　iframe</p>
<p>　　页面</p>
<p>　　下拉框</p>
<p>　　选择器</p>
<p>事件</p>
<p>&nbsp;</p>
<p>//游戏和html5的操作不应该包含在YTool中！应该包含在游戏引擎中！</p>
<p><span style="color: #c0c0c0;">游戏</span></p>
<p><span style="color: #c0c0c0;">　　碰撞检测</span></p>
<p><span style="color: #c0c0c0;">html5</span></p>
<p><span style="color: #c0c0c0;">　　画布canvas</span></p>
<p>js的内建对象</p>
<p>　　array</p>
<p>　　date</p>
<p>　　function</p>
<p>　　string</p>
<p>数字计算</p>
<p>　　数字</p>
<p>　　随机数</p>
<p>代码复用</p>
<p>　　继承</p>
<p>优化</p>
<p>位置</p>
<p>安全</p>
<p>　　编码</p>
<p>　　转义</p>
<p>类型</p>
<p>　　判断类型</p>
<p>　　转换类型</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>源码下载</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>Javascript OOP框架YOOP重构实践（下）</title><link>http://www.cnblogs.com/chaogex/archive/2013/06/08/3126797.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sat, 08 Jun 2013 09:54:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/06/08/3126797.html</guid><description><![CDATA[<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">继续重构</span></strong></span></strong></p>
<h1><span style="color: #000000;">提取基类Structure</span></h1>
<h2><span style="color: #000000;">增加测试</span></h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('455dc95a-2e29-4aa5-a262-60974fd6a5aa')"><img id="code_img_closed_455dc95a-2e29-4aa5-a262-60974fd6a5aa" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_455dc95a-2e29-4aa5-a262-60974fd6a5aa" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('455dc95a-2e29-4aa5-a262-60974fd6a5aa',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_455dc95a-2e29-4aa5-a262-60974fd6a5aa" class="cnblogs_code_hide">
<pre>describe(<span style="color: #800000;">"</span><span style="color: #800000;">测试AClass</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
    it(</span><span style="color: #800000;">"</span><span style="color: #800000;">子类全部实现抽象父类的抽象成员时，不抛出异常</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
            Init: function (t) {
                </span><span style="color: #0000ff;">this</span>.a =<span style="color: #000000;"> t;
                </span><span style="color: #0000ff;">this</span>.b = <span style="color: #800080;">2</span><span style="color: #000000;">;
            },
            Public: {
                p: function () {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
                }
            },
            Private: {
                _m: </span><span style="color: #800080;">1</span><span style="color: #000000;">
            },
            Protected: {
                P_h: function () {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._m;
                },
                P_k: </span><span style="color: #800080;">3</span><span style="color: #000000;">
            },
            Abstract: {
                move: function () { },
                u: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
                t: function () { }
            }
        });
        </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
            Init: function () {
                </span><span style="color: #0000ff;">this</span>.b = <span style="color: #800080;">100</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span>(<span style="color: #800080;">200</span><span style="color: #000000;">);
            },
            Public: {
                move: function () {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_h();
                },
                t: function () { },
                u: </span><span style="color: #800080;">20</span><span style="color: #000000;">
            }
        });
        </span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.Class(B, {
            Public: {
                move: function () {
                    </span><span style="color: #0000ff;">var</span> baseResult = <span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();

                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> baseResult;
                },
                t: function () { }
            }
        });

        </span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
        </span><span style="color: #0000ff;">var</span> c = <span style="color: #0000ff;">new</span><span style="color: #000000;"> C();

        expect([b.a, b.b]).toEqual([</span><span style="color: #800080;">200</span>, <span style="color: #800080;">2</span><span style="color: #000000;">]);
        expect([b.p(), b.move(), b.u]).toEqual([</span><span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">20</span><span style="color: #000000;">]);
        expect(c.move()).toEqual(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
    });
});

describe(</span><span style="color: #800000;">"</span><span style="color: #800000;">测试Interface</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
    it(</span><span style="color: #800000;">"</span><span style="color: #800000;">子类没有全部实现了接口方法和属性，抛出异常</span><span style="color: #800000;">"</span><span style="color: #000000;">, function () {
        </span><span style="color: #0000ff;">var</span> Int = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">A</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">B</span><span style="color: #800000;">"</span><span style="color: #000000;">);

        expect(function () {
            YYC.AClass({ Interface: Int }, {
                Public: {
                    B: function () { }
                }
            });
        }).toThrow();

        </span><span style="color: #0000ff;">var</span> Int2 = YYC.Interface(Int, [<span style="color: #800000;">"</span><span style="color: #800000;">C</span><span style="color: #800000;">"</span>], [<span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span><span style="color: #000000;">]);

        expect(function () {
            YYC.AClass({ Interface: Int2 }, {
                Public: {
                    A: function () { },
                    B: function () { },
                    C: function () { }
                }
            });
        }).toThrow();
        expect(function () {
            YYC.AClass({ Interface: Int2 }, {
                Public: {
                    B: function () { },
                    C: function () { },
                    a: </span><span style="color: #800080;">1</span><span style="color: #000000;">
                }
            });
        }).toThrow();
    });
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>通过重构实践（一）的重构，我发现AClass和Class有很多相似之处，因此启发我采用oo思想来重构，提取出AClass和Class的基类Structure，将两者的共同或相似的代码放到Structure中，然后在Structure中运用模板模式，调用子类实现的方法或属性（如P_class、P_prepareCheck）。</p>
<p>另外进行上面的重构后，可以减少一些方法的形参个数，因为这些形参可以在方法内部通过this来获得了。</p>
<p>如_addStatic重构前：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> _addStatic(_class, prop) {
    </span><span style="color: #0000ff;">var</span> Static = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">var</span> k = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    Static </span>= prop.Static ? prop.Static : <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">静态属性/方法赋值</span>
    <span style="color: #0000ff;">for</span> (k <span style="color: #0000ff;">in</span><span style="color: #000000;"> Static) {
        _class[k] </span>=<span style="color: #000000;"> Static[k];
    }
};</span></pre>
</div>
<p>重构后（_addStatic移到Structure中，并改名为P_addStatic，表示为保护方法）：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">this</span>.P_addStatic = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    </span><span style="color: #0000ff;">var</span> Static = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
        k </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
        _class </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class,
        prop </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop;

    Static </span>= prop.Static ? prop.Static : <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">静态属性/方法赋值</span>
    <span style="color: #0000ff;">for</span> (k <span style="color: #0000ff;">in</span><span style="color: #000000;"> Static) {
        _class[k] </span>=<span style="color: #000000;"> Static[k];
    }
};</span></pre>
</div>
<p>然后又进行了一些小的重构（如删除密封方法的判断、检查；将AClass、Class中调用成员的职责提取为buildAClass、buildClass；重命名addPublic为prepareAndAddPublic等），重构后结构A2（包括Structure、AClass、Class）为：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('ca4ee7c9-6608-411e-abb3-633ee69b874d')"><img id="code_img_closed_ca4ee7c9-6608-411e-abb3-633ee69b874d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_ca4ee7c9-6608-411e-abb3-633ee69b874d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('ca4ee7c9-6608-411e-abb3-633ee69b874d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_ca4ee7c9-6608-411e-abb3-633ee69b874d" class="cnblogs_code_hide">
<pre>(<span style="color: #0000ff;">function</span><span style="color: #000000;"> () {

    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> Structure() {
        </span><span style="color: #0000ff;">this</span>.parentClass = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">this</span>.interface = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">this</span>.prop = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        </span><span style="color: #008000;">/*</span><span style="color: #008000;"> 深拷贝
    </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">this</span>.P_extendDeep = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (parent, child) {
            </span><span style="color: #0000ff;">var</span> i = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            len </span>= 0<span style="color: #000000;">,
                  toStr </span>=<span style="color: #000000;"> Object.prototype.toString,
                  sArr </span>= "[object Array]"<span style="color: #000000;">,
                  sOb </span>= "[object Object]"<span style="color: #000000;">,
                  type </span>= ""<span style="color: #000000;">,
           _child </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #008000;">//</span><span style="color: #008000;">数组的话，不获得Array原型上的成员。</span>
            <span style="color: #0000ff;">if</span> (toStr.call(parent) ===<span style="color: #000000;"> sArr) {
                _child </span>= child ||<span style="color: #000000;"> [];

                </span><span style="color: #0000ff;">for</span> (i = 0, len = parent.length; i &lt; len; i++<span style="color: #000000;">) {
                    type </span>=<span style="color: #000000;"> toStr.call(parent[i]);
                    </span><span style="color: #0000ff;">if</span> (type === sArr || type === sOb) {    <span style="color: #008000;">//</span><span style="color: #008000;">如果为数组或object对象</span>
                        _child[i] = type === sArr ?<span style="color: #000000;"> [] : {};
                        arguments.callee(parent[i], _child[i]);
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        _child[i] </span>=<span style="color: #000000;"> parent[i];
                    }
                }
            }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">对象的话，要获得原型链上的成员。因为考虑以下情景：</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">类A继承于类B，现在想要拷贝类A的实例a的成员（包括从类B继承来的成员），那么就需要获得原型链上的成员。</span>
            <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (toStr.call(parent) ===<span style="color: #000000;"> sOb) {
                _child </span>= child ||<span style="color: #000000;"> {};

                </span><span style="color: #0000ff;">for</span> (i <span style="color: #0000ff;">in</span><span style="color: #000000;"> parent) {
                    type </span>=<span style="color: #000000;"> toStr.call(parent[i]);
                    </span><span style="color: #0000ff;">if</span> (type === sArr || type ===<span style="color: #000000;"> sOb) {
                        _child[i] </span>= type === sArr ?<span style="color: #000000;"> [] : {};
                        arguments.callee(parent[i], _child[i]);
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        _child[i] </span>=<span style="color: #000000;"> parent[i];
                    }
                }
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                _child </span>=<span style="color: #000000;"> parent;
            }


            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> _child;
        };
        </span><span style="color: #008000;">//</span><span style="color: #008000;">检查子类的公有方法+虚方法+抽象方法是否包含父类的抽象方法/属性 或 接口方法/属性。</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">不用hasOwnProperty判断！否则就检查不到是否包含了父类的抽象方法/属性 或 接口方法/属性。</span>
        <span style="color: #0000ff;">this</span>.P_check = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (parentClass) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">var parentClass = this.parentClass,</span>
            <span style="color: #0000ff;">var</span> interface = <span style="color: #0000ff;">this</span><span style="color: #000000;">.interface,
                children </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.children;

            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass) {
                _checkAbstract(parentClass, children);
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (interface) {
                _checkInterface(interface, children);
            }
        };
        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _checkAbstract(parentClass, children) {
            </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

            </span><span style="color: #008000;">//</span><span style="color: #008000;">检查是否实现了抽象方法/属性</span>
            <span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> parentClass.prototype) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass.prototype.hasOwnProperty(name)) {
                    </span><span style="color: #0000ff;">if</span> (name === "constructor"<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #0000ff;">if</span> (name.contain("Abstract_"<span style="color: #000000;">)) {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象方法</span>
                        <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> parentClass.prototype[name] === "function"<span style="color: #000000;">) {
                            </span><span style="color: #0000ff;">if</span> (_noMethodForAbstract(children, name) &amp;&amp;<span style="color: #000000;"> _noMethodForAbstract(parentClass.prototype, name)) {
                                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Abstract method '" + name + "' must be overwrited!"<span style="color: #000000;">);
                            }
                        }
                            </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象属性</span>
                        <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            </span><span style="color: #0000ff;">if</span> (_noAttritubeForAbstract(children, name) &amp;&amp;<span style="color: #000000;"> _noAttritubeForAbstract(parentClass.prototype, name)) {
                                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Abstract attribute '" + name + "' must be overwrited!"<span style="color: #000000;">);
                            }
                        }
                    }
                }
            }
        };
        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _checkInterface(interface, children) {
            </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

            </span><span style="color: #008000;">//</span><span style="color: #008000;">检查是否实现了接口方法/属性</span>
            <span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> interface.prototype) {
                </span><span style="color: #0000ff;">if</span> (name === "constructor"<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">接口方法</span>
                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> interface.prototype[name] === "function"<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (_noMethodForInterface(children, name) &amp;&amp;<span style="color: #000000;"> _noMethodForInterface(parentClass.prototype, name)) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface method '" + name + "' must be overwrited!"<span style="color: #000000;">);
                    }
                }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">接口属性</span>
                <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">if</span> (_noAttritubeForInterface(children, name) &amp;&amp;<span style="color: #000000;"> _noAttritubeForInterface(parentClass.prototype, name)) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface attribute '" + name + "' must be overwrited!"<span style="color: #000000;">);
                    }
                }
            }
        };

        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _noMethodForAbstract(_class, name) {
            </span><span style="color: #0000ff;">return</span> _class[name.slice(9)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(9)] !== "function"<span style="color: #000000;">;
        };
        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _noAttritubeForAbstract(_class, name) {
            </span><span style="color: #0000ff;">return</span> _class[name.slice(9)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(9)] === "function"<span style="color: #000000;">;
        };
        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _noMethodForInterface(_class, name) {
            </span><span style="color: #0000ff;">return</span> _class[name.slice(10)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(10)] !== "function"<span style="color: #000000;">;
        };
        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _noAttritubeForInterface(_class, name) {
            </span><span style="color: #0000ff;">return</span> _class[name.slice(10)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(10)] === "function"<span style="color: #000000;">;
        };

        </span><span style="color: #008000;">//</span><span style="color: #008000;">检查抽象成员</span>
        <span style="color: #0000ff;">this</span>.P_addAbstract = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (abstract) {
            </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">,
                currentClass </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class;

            </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> abstract) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (abstract.hasOwnProperty(name)) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象方法前面加"Abstract_"前缀</span>
                    currentClass.prototype["Abstract_" + name] =<span style="color: #000000;"> abstract[name];
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">temp[name] = abstract[name];    //加入temp</span>
<span style="color: #000000;">                }
            }
        };

        </span><span style="color: #008000;">//</span><span style="color: #008000;">检查虚方法(不能为虚属性)</span>
        <span style="color: #0000ff;">this</span>.P_addVirtual = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (virtual) {
            </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">,
                currentClass </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class;

            </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> virtual) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (virtual.hasOwnProperty(name)) {
                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> virtual[name] !== "function"<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Virtual attribute is not allowed!"<span style="color: #000000;">);
                    }
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        currentClass.prototype[name] </span>=<span style="color: #000000;"> virtual[name];
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">temp[name] = virtual[name];    //加入this.temp</span>
<span style="color: #000000;">                    }
                }
            }
        };

        </span><span style="color: #008000;">//</span><span style="color: #008000;">//加入密封方法。</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">//没有实现检查子类是否重写了父类的密封方法，只是定义了一个规范。</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">this.P_addSealed = function (sealed, currentClass) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">    var name = "";</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">    for (name in sealed) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        if (sealed.hasOwnProperty(name)) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            currentClass.prototype[name] = sealed[name];</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            //temp[name] = sealed[name];    //加入this.temp</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">    }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">};</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">获得在原型prototype中不存在同名的str。</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">如果有同名，则加上前缀"_"</span>
        <span style="color: #0000ff;">this</span>.P_getNoRepeatStrInPrototype = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (prototype, str) {
            </span><span style="color: #0000ff;">var</span> new_str = ""<span style="color: #000000;">;

            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">prototype[str]) {
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> str;
            }
            new_str </span>= "_" +<span style="color: #000000;"> str;

            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> arguments.callee(prototype, new_str);
        };
        </span><span style="color: #0000ff;">this</span>.P_addStatic = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> Static = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                k </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                _class </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class,
                prop </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop;

            Static </span>= prop.Static ? prop.Static : <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #008000;">//</span><span style="color: #008000;">静态属性/方法赋值</span>
            <span style="color: #0000ff;">for</span> (k <span style="color: #0000ff;">in</span><span style="color: #000000;"> Static) {
                _class[k] </span>=<span style="color: #000000;"> Static[k];
            }
        };

        </span><span style="color: #0000ff;">this</span>.P_inherit = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> _class = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class,
                parentClass </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass;

            _class.prototype </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_extendDeep(parentClass.prototype);
            _class.prototype.constructor </span>=<span style="color: #000000;"> _class;

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果父类存在，则实例对象的baseClass指向父类的原型。</span>
            <span style="color: #008000;">//</span><span style="color: #008000;"> 这就提供了在实例对象中调用父类方法的途径。</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">baseClass的方法是指向this.parentClass的，不是指向F（子类）的！</span>
            _class.prototype[<span style="color: #0000ff;">this</span>.P_getNoRepeatStrInPrototype(parentClass.prototype, "baseClass")] =<span style="color: #000000;"> parentClass.prototype;
        };
        </span><span style="color: #0000ff;">this</span>.P_addInit = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">var self = this;</span>
            <span style="color: #0000ff;">var</span> _class = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class,
                parentClass </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass,
                prop </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop;

            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Init) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此类继承自父类this.parent并且父类原型中存在同名函数name</span>
                <span style="color: #0000ff;">if</span> (parentClass &amp;&amp;
        <span style="color: #0000ff;">typeof</span> prop.Init === "function" &amp;&amp;
        <span style="color: #0000ff;">typeof</span> _class.prototype.Init === "function"<span style="color: #000000;">) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">if (this.parentClass) {</span>
                    _class.prototype.Init = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (name) {
                        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                            </span><span style="color: #008000;">/*</span><span style="color: #008000;">
                            //此处不用创建闭包了！因为外面已经创建了闭包，name已经被保存了！
                            this.baseToParrent = function () {
                                //这个写法也可以！为什么不用apply修正this也行？？！
                                //this.parentClass.prototype[name](); 
        
                                //此处的arguments为baseToParrent方法传入的形参
                                //注意！要加上&ldquo;return&rdquo;，这样才能返回this.parentClass.prototype[name]的返回值
                                return this.parentClass.prototype[name].apply(this.parentClass.prototype, arguments);
                            };
                            </span><span style="color: #008000;">*/</span>
                            <span style="color: #008000;">//</span><span style="color: #008000;">指向子类，可以用于模版模式</span>
                            <span style="color: #0000ff;">this</span>.base =<span style="color: #000000;"> parentClass.prototype[name];

                            </span><span style="color: #008000;">//</span><span style="color: #008000;">执行fn并返回执行的结果</span>
                            <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为F.prototype[name]方法传入的形参。</span>
                            <span style="color: #0000ff;">return</span> prop[name].apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
                        };

                    }(</span>"Init"<span style="color: #000000;">);
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    _class.prototype.Init </span>=<span style="color: #000000;"> prop.Init;
                }
            }
        };

        </span><span style="color: #0000ff;">this</span>.P_addPrivate = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> name = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                _class </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class,
                private </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Private;

            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (private) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">私有属性/方法直接覆盖</span>
                <span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> private) {
                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (private.hasOwnProperty(name)) {
                        _class.prototype[name] </span>=<span style="color: #000000;"> private[name];
                    }
                }
            }
        };

        </span><span style="color: #0000ff;">this</span>.P_prepareAndAddPublic = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> name = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Public) {
                </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Public) {
                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Public.hasOwnProperty(name)) {
                        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.P_prepareCheck("Public", name) === "continue"<span style="color: #000000;">) {
                            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                        }
                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addPublic(name);
                        </span><span style="color: #0000ff;">this</span>.children[name] = <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Public[name];
                    }
                }
            }
        };

        </span><span style="color: #0000ff;">this</span>.P_addPublic = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (name) {
            </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.parentClass &amp;&amp;
                <span style="color: #0000ff;">typeof</span> <span style="color: #0000ff;">this</span>.prop.Public[name] === "function" &amp;&amp;
                <span style="color: #0000ff;">typeof</span> <span style="color: #0000ff;">this</span>.P_class.prototype[name] === "function"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">this</span>.P_class.prototype[name] = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (name) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #008000;">/*</span><span style="color: #008000;">
                        //此处不用创建闭包了！因为外面已经创建了闭包，name已经被保存了！
                        self.baseToParrent = function () {
                            //这个写法也可以！为什么不用apply修正this也行？？！
                            //this.parentClass.prototype[name](); 
    
                            //此处的arguments为baseToParrent方法传入的形参
                            //注意！要加上&ldquo;return&rdquo;，这样才能返回self.parentClass.prototype[name]的返回值
                            return self.parentClass.prototype[name].apply(self.parentClass.prototype, arguments);
                        };
                        </span><span style="color: #008000;">*/</span>
                        <span style="color: #008000;">//</span><span style="color: #008000;">指向子类，可以用于模版模式</span>
                        <span style="color: #0000ff;">this</span>.base =<span style="color: #000000;"> self.parentClass.prototype[name];

                        </span><span style="color: #008000;">//</span><span style="color: #008000;">执行fn并返回执行的结果</span>
                        <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为F.prototype[name]方法传入的形参。</span>
                        <span style="color: #0000ff;">return</span> self.prop.Public[name].apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
                    };

                }(name);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">this</span>.P_class.prototype[name] = <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Public[name];
            }
        };

        </span><span style="color: #0000ff;">this</span>.P_prepareAndAddProtected = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> name = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Protected) {
                </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Protected) {
                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Protected.hasOwnProperty(name)) {
                        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.P_prepareCheck("Protected", name) === "continue"<span style="color: #000000;">) {
                            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                        }
                        </span><span style="color: #0000ff;">this</span>.P_class.prototype[name] = <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Protected[name];
                        </span><span style="color: #0000ff;">this</span>.children[name] = <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Protected[name];
                    }
                }
            }
        };
    };


    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建抽象类</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">抽象类能够继承接口、抽象类以及实体类，但此处约定抽象类只能继承接口和抽象类，不能继承实体类！</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">（这样方便判断抽象类是否包含全部的父类（接口/抽象类）成员）</span>

    <span style="color: #0000ff;">function</span><span style="color: #000000;"> AClass() {
        </span><span style="color: #0000ff;">var</span> that = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

        </span><span style="color: #0000ff;">this</span>.children =<span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">this</span>.P_class =<span style="color: #000000;"> A;

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 本次调用所创建的类（构造函数）</span>
        <span style="color: #0000ff;">function</span><span style="color: #000000;"> A() {
        }

        </span><span style="color: #0000ff;">var</span> _getByParent = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (_parent, _prop) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">if (arguments.length === 1) {</span>
            <span style="color: #0000ff;">if</span> (_prop ===<span style="color: #000000;"> undefined) {
                that.prop </span>=<span style="color: #000000;"> _parent;
                that.parentClass </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                that.interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "object"<span style="color: #000000;">) {

                </span><span style="color: #0000ff;">if</span> (!_parent.Class &amp;&amp; !<span style="color: #000000;">_parent.Interface) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Please add AbstractClass or Interface!"<span style="color: #000000;">);
                }
                </span><span style="color: #0000ff;">if</span> (_getFunctionName(_parent.Class) === "F" || _getFunctionName(_parent.Interface) === "F"<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("AbstractClass here can't inherit this.parentClass which is created by Class function!"<span style="color: #000000;">);
                }

                that.parentClass </span>=<span style="color: #000000;"> _parent.Class;
                that.interface </span>=<span style="color: #000000;"> _parent.Interface;
                that.prop </span>=<span style="color: #000000;"> _prop;
            }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">_parent直接为xx，就表示父类为抽象类</span>
            <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "function"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (_getFunctionName(_parent) === "F"<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("AbstractClass here can't inherit this.parentClass which is created by Class function!"<span style="color: #000000;">);
                }

                that.parentClass </span>=<span style="color: #000000;"> _parent;
                that.interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                that.prop </span>=<span style="color: #000000;"> _prop;
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("arguments is not allowed!"<span style="color: #000000;">);
            }
        };
        </span><span style="color: #0000ff;">this</span>.P_prepareCheck = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (where, name) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">检查抽象成员，抽象成员放到Public或Protected中</span>
            <span style="color: #0000ff;">if</span> (name === "Abstract"<span style="color: #000000;">) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">this.P_addAbstract(this.prop[where][name], A, this.children);</span>
                <span style="color: #0000ff;">this</span>.P_addAbstract(<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop[where][name]);
                </span><span style="color: #0000ff;">return</span> "continue"<span style="color: #000000;">;
            }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">检查虚方法，虚方法放到Public或Protected中</span>
            <span style="color: #0000ff;">if</span> (name === "Virtual"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">this</span>.P_addVirtual(<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop[where][name]);
                </span><span style="color: #0000ff;">return</span> "continue"<span style="color: #000000;">;
            }
        };
        </span><span style="color: #0000ff;">this</span>.buildAClass = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (_parent, _prop) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">取出父类、接口</span>
<span style="color: #000000;">            _getByParent(_parent, _prop);

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此接口需要从其它接口扩展</span>
            <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass) {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_inherit();
            }

            </span><span style="color: #008000;">//</span><span style="color: #008000;">加入构造函数</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">抽象类本身因为不能实例化，所以不调用构造函数。</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">抽象类中的构造函数供子类构造函数中调用。</span>
            <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addInit();

            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addPrivate();

            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_prepareAndAddPublic();


            </span><span style="color: #008000;">//</span><span style="color: #008000;">保护成员</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">_prepareAndAddProtected();</span>
            <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_prepareAndAddProtected();

            </span><span style="color: #008000;">//</span><span style="color: #008000;">放到外面的抽象成员，默认为公有抽象成员</span>
            <span style="color: #0000ff;">this</span>.P_addAbstract(<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Abstract);

            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addStatic();

            </span><span style="color: #008000;">//</span><span style="color: #008000;">检查抽象类的公有方法+虚方法+抽象方法是否包含父类的接口方法/属性</span>
            <span style="color: #0000ff;">this</span>.P_check(<span style="color: #0000ff;">null</span><span style="color: #000000;">);

            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> A;
        };

    };


    AClass.prototype </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Structure();

    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建普通类</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">父类_parent可以为{Class: xx, Interface: xx}，或者直接为xx类</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> Class() {
        </span><span style="color: #0000ff;">var</span> that = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

        </span><span style="color: #0000ff;">this</span>.P_class =<span style="color: #000000;"> F;
        </span><span style="color: #0000ff;">this</span>.children =<span style="color: #000000;"> {};
        </span><span style="color: #008000;">//</span><span style="color: #008000;">当前是否处于创建类的阶段。</span>
        <span style="color: #0000ff;">this</span>.initializing = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">原型恢复标志，用于防止第一次创建实例时恢复原型</span>
        <span style="color: #0000ff;">this</span>.mark_resume = <span style="color: #0000ff;">false</span><span style="color: #000000;">;

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 本次调用所创建的类（构造函数）</span>
        <span style="color: #0000ff;">function</span><span style="color: #000000;"> F() {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">防止第一次创建实例时恢复原型</span>
            <span style="color: #0000ff;">if</span><span style="color: #000000;"> (that.mark_resume) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">还原原型</span>
<span style="color: #000000;">                that.P_extendDeep(F.backUp_prototype, F.prototype);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                that.mark_resume </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果当前处于实例化类的阶段，则调用Init原型函数</span>
            <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">that.initializing) {
                </span><span style="color: #0000ff;">this</span>.Init &amp;&amp; <span style="color: #0000ff;">this</span>.Init.apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
            }
            </span><span style="color: #008000;">/*</span><span style="color: #008000;">不能删除私有成员和保护成员！否则类的成员就不能调用到私有和保护的成员了（因为已经删除了）！
            对象的创建算法参考http://www.cnblogs.com/TomXu/archive/2012/02/06/2330609.html
        
        
        
        
            //删除私有成员和保护成员，这样外界就不能访问私有和保护成员了！
            for (name in this) {
            if (name.search(/(^_)|(^P_)/) !== -1) {
            delete F.prototype[name];
            //                                                    this[name] = null;
            }
              
            }
            </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        }

        </span><span style="color: #0000ff;">var</span> _getByParent = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (_parent, _prop) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">if (arguments.length === 1) {</span>
            <span style="color: #0000ff;">if</span> (_prop ===<span style="color: #000000;"> undefined) {
                that.prop </span>=<span style="color: #000000;"> _parent;
                that.parentClass </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                that.interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">{Class: xx, Interface: xx}</span>
            <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "object"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (!_parent.Class &amp;&amp; !<span style="color: #000000;">_parent.Interface) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Please add Class or Interface!"<span style="color: #000000;">);
                }

                that.parentClass </span>=<span style="color: #000000;"> _parent.Class;
                that.interface </span>=<span style="color: #000000;"> _parent.Interface;
                that.prop </span>=<span style="color: #000000;"> _prop;
            }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">直接为xx类</span>
            <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "function"<span style="color: #000000;">) {
                that.parentClass </span>=<span style="color: #000000;"> _parent;
                that.interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                that.prop </span>=<span style="color: #000000;"> _prop;
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("arguments is not allowed!"<span style="color: #000000;">);
            }
        };
        </span><span style="color: #008000;">//</span><span style="color: #008000;">this._addParentSealed = function () {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">    var name = null;</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">    for (name in this.parentClass.prototype) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        if (this.parentClass.prototype.hasOwnProperty(name)) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            //如果不是抽象方法/保护方法/私有方法/接口成员，则加入到this.temp中。</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            //用于添加父类的密封方法（因为子类并没有加入父类的密封方法）。</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            if (!name.match(/^Abstract_/) || !name.match(/^P_/) || !name.match(/^_/) || !name.match(/^Interface_/)) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                this.children[name] = this.parentClass.prototype[name];</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">    }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">};</span>
        <span style="color: #0000ff;">this</span>.P_prepareCheck = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (where, name) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">检查虚方法，虚方法放到Public或Protected中</span>
            <span style="color: #0000ff;">if</span> (name === "Virtual"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">this</span>.P_addVirtual(<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop[where][name]);
                </span><span style="color: #0000ff;">return</span> "continue"<span style="color: #000000;">;
            }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">//密封的方法（不允许子类重写）</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">if (name === "Sealed") {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">    this.P_addSealed(this.prop[where][name], A);</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">    return "continue";</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">}</span>

            <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        };

        </span><span style="color: #0000ff;">this</span>.buildClass = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (_parent, _prop) {
            _getByParent(_parent, _prop);

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此类需要从其它类扩展</span>
            <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass) {
                </span><span style="color: #0000ff;">this</span>.initializing = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_inherit();
                </span><span style="color: #0000ff;">this</span>.initializing = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }

            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addInit();

            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addPrivate();

            </span><span style="color: #008000;">//</span><span style="color: #008000;">保护成员</span>
            <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_prepareAndAddProtected();

            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Abstract) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Only abstractClass can have abstract methods!"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_prepareAndAddPublic();

            </span><span style="color: #008000;">//</span><span style="color: #008000;">检查公有成员和虚函数是否实现了抽象方法/属性 或 接口方法/属性</span>
            <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_check();

            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addStatic();

            </span><span style="color: #008000;">//</span><span style="color: #008000;">备份原型</span>
            F.backUp_prototype = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_extendDeep(F.prototype);

            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> F;
        };
    };

    Class.prototype </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Structure();

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
    下面的写法有问题！因为只有载入oopFrame.js时，创建了AClass的实例。
    调用YYC.AClass时，只是引用该实例的buildAClass，而不会再创建AClass实例。
    也就是说，所有YYC.AClass都共用一个AClass的实例！共用AClass实例的属性（如parent等）！

    YYC.AClass = new AClass().buildAClass;
    </span><span style="color: #008000;">*/</span><span style="color: #000000;">


    YYC.AClass </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (_parent, _prop) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> AClass().buildAClass(_parent, _prop);
    };
    YYC.Class </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (_parent, _prop) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Class().buildClass(_parent, _prop);
    };
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>重构Interface</h1>
<p>去掉i、args变量，提取出buildInterface方法，用oo思想重构Interface：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('78ff11db-0686-488b-ad0d-999fdd62e956')"><img id="code_img_closed_78ff11db-0686-488b-ad0d-999fdd62e956" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_78ff11db-0686-488b-ad0d-999fdd62e956" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('78ff11db-0686-488b-ad0d-999fdd62e956',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_78ff11db-0686-488b-ad0d-999fdd62e956" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> Interface() {
    </span><span style="color: #0000ff;">var</span> that = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">this</span>.parent = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">this</span>.method = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">this</span>.attribute = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> I() {
    }

    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _getByParent(_parent, _method, _attribute) {
        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "function"<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (_getFunctionName(_parent) !== "I"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface must inherit interface!"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                that.parent </span>=<span style="color: #000000;"> _parent;
                </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;Interface(Parent, "A", "B", "GetName");&rdquo;</span>
                <span style="color: #0000ff;">if</span> (_method &amp;&amp; !<span style="color: #000000;">_isArray(_method)) {
                    that.method </span>= Array.prototype.slice.call(arguments, 1<span style="color: #000000;">);
                    that.attribute </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;Interface(Parent, ["A", "B", "GetName"], ["a", "c"]);&rdquo;</span>
                <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    that.method </span>=<span style="color: #000000;"> _method;
                    that.attribute </span>=<span style="color: #000000;"> _attribute;
                }
            }
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            that.parent </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;Interface("A", "B", "GetName");&rdquo;</span>
            <span style="color: #0000ff;">if</span> (_method &amp;&amp; !<span style="color: #000000;">_isArray(_method)) {
                that.method </span>= Array.prototype.slice.call(arguments, 0<span style="color: #000000;">);
                that.attribute </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;Interface(["A", "B", "GetName"], ["a", "c"]);&rdquo;</span>
            <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                that.method </span>= arguments[0<span style="color: #000000;">];
                that.attribute </span>= arguments[1<span style="color: #000000;">];
            }
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _inherit() {
        I.prototype </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> that.parent();
        I.prototype.constructor </span>=<span style="color: #000000;"> I;
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _addMethod() {
        </span><span style="color: #0000ff;">var</span> i = 0<span style="color: #000000;">,
            len </span>= 0<span style="color: #000000;">;

        </span><span style="color: #0000ff;">for</span> (i = 0, len = that.method.length; i &lt; len; i++<span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">加上前缀&ldquo;Interface_&rdquo;</span>
            I.prototype["Interface_" + that.method[i]] = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("This method must be overwrited!"<span style="color: #000000;">);
            };
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _addAttribute() {
        </span><span style="color: #0000ff;">var</span> i = 0<span style="color: #000000;">,
            len </span>= 0<span style="color: #000000;">;

        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (that.attribute) {
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">_isArray(that.attribute)) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Attribute must be array!"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">for</span> (i = 0, len = that.method.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">加上前缀&ldquo;Interface_&rdquo;</span>
                    I.prototype["Interface_" + that.attribute[i]] = 0<span style="color: #000000;">;
                }
            }
        }
    };

    </span><span style="color: #0000ff;">this</span>.buildInterface = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (_parent, _method, _attribute) {
        _getByParent(_parent, _method, _attribute);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此接口需要从其它接口扩展</span>
        <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.parent) {
            _inherit();
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">方法</span>
<span style="color: #000000;">        _addMethod();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">属性</span>
<span style="color: #000000;">        _addAttribute();

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> I;
    };
};</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>增加测试</h1>
<p>增加测试"子类虚方法实现抽象父类的抽象方法时，不抛出异常"、"非抽象类定义抽象成员时抛出异常"：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('d4da9dc7-719d-42af-b2f8-cbeac0e86352')"><img id="code_img_closed_d4da9dc7-719d-42af-b2f8-cbeac0e86352" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_d4da9dc7-719d-42af-b2f8-cbeac0e86352" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d4da9dc7-719d-42af-b2f8-cbeac0e86352',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_d4da9dc7-719d-42af-b2f8-cbeac0e86352" class="cnblogs_code_hide">
<pre>it("子类虚方法实现抽象父类的抽象方法时，不抛出异常", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
        Abstract: {
            move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
        }
    });
    expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        YYC.Class(A, {
            Public: {
                Virtual: {
                    move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                }
            }
        });
    }).not.toThrow();
});
it(</span>"非抽象类定义抽象成员时抛出异常", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        YYC.Class({
            Protected: {
                Abstract: {
                    move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                }
            }
        });
    }).toThrow();
    expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        YYC.Class({
            Abstract: {
                move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
            }
        });
    }).toThrow();
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>重构children</h1>
<p>之前将temp改名为children，但是现在发现这个名字也不恰当，因此根据它的职责&ldquo;存储该类成员的名称，从而用于检查该类成员是否实现了接口或者父类的抽象成员。&rdquo;，将其改名为impletationMap。</p>
<p>将&ldquo;存储该类成员的名称&rdquo;的操作封装为函数P_addToImplementMap，放到Structure中：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">this</span>.P_addToImplementMap = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (name, func) {
    </span><span style="color: #0000ff;">this</span>.implementaionMap[name] =<span style="color: #000000;"> func;
};</span></pre>
</div>
<h1>然后又经过了下面的重构</h1>
<ul>
<li>将Structure -&gt; P_prepareAndAddProtected、P_prepareAndAddPublic、P_addVirtual中&ldquo;将实现方法加入到ImpletationMap中&rdquo;的职责提取出来形成P_prepareCheck方法，并将原方法改名为P_addPublicMember、P_addProtectedMember。</li>
<li>将Structure -&gt;P_addPrivate、P_addStatic改名为P_addPrivateMember、P_addStaticMember。</li>
<li>将buildClass、buildAClass中的加入外部的抽象成员职责提取为_addOuterAbstract方法。</li>
<li><span style="font-size: 14px; line-height: 1.5;">将Class -&gt; F中恢复F.prototype和初始化职责分别提取为_restorePrototype、_init方法。</span></li>
<li>将Structure的实例属性下移到子类中。</li>
</ul>
<h1><span style="color: #000000;">性能优化</span></h1>
<p>为了优化性能，减少占用的内存，考虑将Interface、Structure、AClass、Class的实例成员改写成原型成员。</p>
<p>重构Struture后，Structure的结构为：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> Structure() {
};
Structure.prototype </span>= (<span style="color: #0000ff;">function</span> () {}());</pre>
</div>
<p>&nbsp;</p>
<p>当我将AClass改写成原型形式后，发现测试不能通过，原来是如果写成原型形式，则AClass的实例就共享同一个内部函数A！这样会造成不同的类之间互相干扰！</p>
<p>因此，没有对Interface、AClass、Class进行该重构。</p>
<h1>改变原有的行为</h1>
<p>我需要增加&ldquo;支持继承多个接口&rdquo;，因此我先添加了测试用例，然后实现。另外我需要增加&ldquo;限制只能最多继承一个类&rdquo;，因此我也先添加测试用例，然后加入限制。</p>
<p>在改变代码原有行为时，可能需要改变或增加相应的测试用例。那么不用迟疑，立刻就去做。</p>
<h1>重构注释</h1>
<p>删除不必要的注释，添加重要的算法说明、重构说明等注释。</p>
<p>尽量少些注释，通过对类、函数、属性等的命名来体现职责和目的。</p>
<p>以下来自《代码整洁之道》，可作为参考：<br /><span style="font-size: 18px;">好注释：法律信息，提供信息的注释，对意图的解释，阐释，警示，TODO注释，放大，共用API中的javadoc</span><br /><span style="font-size: 18px;">坏注释：喃喃自语，多余的注释，误导性的注释，循规式的注释，日志式注释，废话注释，可怕的废话，能用函数或变量时就别用注释，位置标记，括号后面的注释，归属与署名，注释掉的代码，函数头，非共用API中的javadoc。</span></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">完成重构</span></strong></span></strong></p>
<p>最终的测试代码：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('3b8b6408-f709-4a1c-8789-f0d76132ff36')"><img id="code_img_closed_3b8b6408-f709-4a1c-8789-f0d76132ff36" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_3b8b6408-f709-4a1c-8789-f0d76132ff36" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3b8b6408-f709-4a1c-8789-f0d76132ff36',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_3b8b6408-f709-4a1c-8789-f0d76132ff36" class="cnblogs_code_hide">
<pre>describe("YOOP", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    it(</span>"不存在虚属性的概念（如果企图声明虚属性，会抛出异常）", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            YYC.Class({
                Virtual: {
                    a: </span>""<span style="color: #000000;">
                }
            });
        }).toThrow();
        expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            YYC.AClass({
                Virtual: {
                    a: </span>""<span style="color: #000000;">
                }
            });
        }).toThrow();
    });
    it(</span>"静态方法的this是指向类的", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({
            Static: {
                a: </span>100<span style="color: #000000;">,
                method: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    </span><span style="color: #0000ff;">this</span>.b = 300<span style="color: #000000;">;
                    </span><span style="color: #0000ff;">return</span> 200<span style="color: #000000;">;
                }
            }
        });
        </span><span style="color: #0000ff;">var</span> result =<span style="color: #000000;"> A.method();

        expect(result).toEqual(</span>200<span style="color: #000000;">);
        expect(A.b).toEqual(</span>300);    <span style="color: #008000;">//</span><span style="color: #008000;">300</span>
<span style="color: #000000;">    });

    describe(</span>"测试Class与AClass", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> testInheritFromOnlyOneClass(_class) {
            </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({});
            </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.AClass({});

            expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                YYC[_class](A, B, {});
            }).toThrow();
            expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                YYC[_class]({ Class: [A, B] }, {});
            }).toThrow();
        };

        describe(</span>"测试类Class", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            it(</span>"可以继承多个接口。如果不实现会抛出异常", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A = YYC.Interface("m1"<span style="color: #000000;">);
                </span><span style="color: #0000ff;">var</span> B = YYC.Interface("m2"<span style="color: #000000;">);

                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class({ Interface: A }, {
                        Public: {
                        }
                    });
                }).toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class({ Interface: [A] }, {
                        Public: {
                        }
                    });
                }).toThrow();

                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class({ Interface: [A, B] }, {
                        Public: {
                            m1: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class({ Interface: [A, B] }, {
                        Public: {
                            m2: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class({ Interface: [A, B] }, {
                        Public: {
                            m1: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { },
                            m2: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).not.toThrow();
            });

            it(</span>"只能继承一个类（Class或AClass），否则抛出异常", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                testInheritFromOnlyOneClass(</span>"Class"<span style="color: #000000;">);
            });
            it(</span>"创建实例时调用构造函数", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({
                    Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.a = 10<span style="color: #000000;">;
                    }
                });

                expect(</span><span style="color: #0000ff;">new</span> A().a).toEqual(10<span style="color: #000000;">);
            });

            describe(</span>"获得公有成员", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                it(</span>"如果父类不存在，能够正确获得公有方法", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    </span><span style="color: #0000ff;">var</span> Class =<span style="color: #000000;"> YYC.Class({
                        Public: {
                            a: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                                </span><span style="color: #0000ff;">this</span>.b = 1<span style="color: #000000;">;
                                </span><span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
                            }
                        }
                    });

                    </span><span style="color: #0000ff;">var</span> cla = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Class();
                    </span><span style="color: #0000ff;">var</span> result =<span style="color: #000000;"> cla.a();

                    expect(result).toEqual(</span>0<span style="color: #000000;">);
                    expect(cla.b).toEqual(</span>1<span style="color: #000000;">);
                });
            });
            it(</span>"不能定义抽象成员，否则抛出异常", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class({
                        Public: {
                            Abstract: {
                                move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                            }
                        }
                    })
                }).toThrow();
            });
            it(</span>"可以将虚方法定义在外面，表示公有虚方法", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({
                    Virtual: {
                        move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                    }
                });

                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> A().move()
                }).not.toThrow();
            });
            it(</span>"验证是否实现了接口成员，如果没有实现会抛出异常", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> I = YYC.Interface(["move"], ["a"<span style="color: #000000;">]);

                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class({ Interface: I }, {
                        Public: {
                            a: </span>0<span style="color: #000000;">
                        }
                    });
                }).toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class({ Interface: I }, {
                        Public: {
                            move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class({ Interface: I }, {
                        Public: {
                            a: </span>0<span style="color: #000000;">,
                            move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).not.toThrow();
            });
            it(</span>"验证是否实现了父类抽象成员，如果没有实现会抛出异常", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
                    Abstract: {
                        move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { },
                        a: </span>0<span style="color: #000000;">
                    }
                });

                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(A, {
                        Public: {
                            a: </span>0<span style="color: #000000;">
                        }
                    });
                }).toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(A, {
                        Public: {
                            move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(A, {
                        Public: {
                            a: </span>0<span style="color: #000000;">,
                            move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).not.toThrow();
            });
        });

        describe(</span>"测试抽象类AClass", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            it(</span>"可以继承多个接口（在抽象类中不用实现，可以交给子类Class实现）", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A = YYC.Interface("m1"<span style="color: #000000;">);
                </span><span style="color: #0000ff;">var</span> B = YYC.Interface(["m2"], ["a"<span style="color: #000000;">]);
                </span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.AClass({ Interface: [A, B] }, {});

                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(C, {
                        Public: {
                            m1: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(C, {
                        Public: {
                            m2: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(C, {
                        Public: {
                            m1: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { },
                            m2: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(C, {
                        Public: {
                            m1: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { },
                            m2: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { },
                            a: </span>1<span style="color: #000000;">
                        }
                    });
                }).not.toThrow();
            });
            it(</span>"只能继承一个类（Class或AClass），否则抛出异常", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                testInheritFromOnlyOneClass(</span>"AClass"<span style="color: #000000;">);
            });
            it(</span>"构造函数供子类调用", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
                    Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Error();
                    }
                });
                </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
                    Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.a = 10<span style="color: #000000;">;
                    }
                });
                </span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.Class(A, {
                    Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.a = 10<span style="color: #000000;">;
                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base();
                    }
                });

                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
                }).not.toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> C();
                }).toThrow();

            });
            it(</span>"抽象类如果继承实体类，会抛出异常", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({});
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.AClass(A, {});
                }).toThrow();
            });
            it(</span>"子类虚方法实现抽象父类的抽象方法时，不抛出异常", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
                    Abstract: {
                        move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                    }
                });
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(A, {
                        Public: {
                            Virtual: {
                                move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                            }
                        }
                    });
                }).not.toThrow();

                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(A, {
                        Public: {
                        }
                    });
                }).toThrow();
            });
            it(</span>"可以将虚方法定义在外面，表示公有虚方法", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
                    Virtual: {
                        move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                    }
                });
                </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {});

                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> B().move()
                }).not.toThrow();
            });
            it(</span>"可以将抽象成员定义在外面，表示公有抽象成员", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
                    Abstract: {
                        move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                    }
                });

                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(A, {
                        Public: {
                            move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).not.toThrow();
            });
            it(</span>"不验证是否实现父类的抽象成员（可以交给子类Class实现）", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
                    Abstract: {
                        move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { },
                        a: </span>0<span style="color: #000000;">
                    }
                });
                </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.AClass(A, {});
                </span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.AClass(B, {});

                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.AClass(A, {
                        Public: {
                            a: </span>0<span style="color: #000000;">
                        }
                    });
                }).not.toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.AClass(A, {
                        Public: {
                            move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).not.toThrow();


                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(B, {
                        Public: {}
                    });
                }).toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(B, {
                        Public: {
                            move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).toThrow();
                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(B, {
                        Public: {
                            move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { },
                            a: </span>1<span style="color: #000000;">
                        }
                    });
                }).not.toThrow();


                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(C, {
                        Public: {
                            move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                        }
                    });
                }).toThrow();
            });
            it(</span>"子类没有全部实现抽象父类的抽象成员时，抛出异常", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
                    Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (t) {
                        </span><span style="color: #0000ff;">this</span>.a =<span style="color: #000000;"> t;
                        </span><span style="color: #0000ff;">this</span>.b = 2<span style="color: #000000;">;
                    },
                    Public: {
                        p: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                            </span><span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
                        }
                    },
                    Private: {
                        _m: </span>1<span style="color: #000000;">
                    },
                    Protected: {
                        P_h: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._m;
                        },
                        P_k: </span>3<span style="color: #000000;">
                    },
                    Abstract: {
                        move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { },
                        u: </span>0<span style="color: #000000;">,
                        t: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                    }
                });

                expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    YYC.Class(A, {
                        Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                            </span><span style="color: #0000ff;">this</span>.b = 100<span style="color: #000000;">;
                            </span><span style="color: #0000ff;">this</span>.base(200<span style="color: #000000;">);
                        },
                        Public: {
                            u: </span>20<span style="color: #000000;">
                        }
                    });
                }).toThrow();
            });
            it(</span>"子类全部实现抽象父类的抽象成员时，不抛出异常", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
                    Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (t) {
                        </span><span style="color: #0000ff;">this</span>.a =<span style="color: #000000;"> t;
                        </span><span style="color: #0000ff;">this</span>.b = 2<span style="color: #000000;">;
                    },
                    Public: {
                        p: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                            </span><span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
                        }
                    },
                    Private: {
                        _m: </span>1<span style="color: #000000;">
                    },
                    Protected: {
                        P_h: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._m;
                        },
                        P_k: </span>3<span style="color: #000000;">
                    },
                    Abstract: {
                        move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { },
                        u: </span>0<span style="color: #000000;">,
                        t: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                    }
                });
                </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
                    Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.b = 100<span style="color: #000000;">;
                        </span><span style="color: #0000ff;">this</span>.base(200<span style="color: #000000;">);
                    },
                    Public: {
                        move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_h();
                        },
                        t: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { },
                        u: </span>20<span style="color: #000000;">
                    }
                });
                </span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.Class(B, {
                    Public: {
                        move: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                            </span><span style="color: #0000ff;">var</span> baseResult = <span style="color: #0000ff;">this</span><span style="color: #000000;">.base();

                            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> baseResult;
                        },
                        t: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
                    }
                });

                </span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
                </span><span style="color: #0000ff;">var</span> c = <span style="color: #0000ff;">new</span><span style="color: #000000;"> C();

                expect([b.a, b.b]).toEqual([</span>200, 2<span style="color: #000000;">]);
                expect([b.p(), b.move(), b.u]).toEqual([</span>0, 1, 20<span style="color: #000000;">]);
                expect(c.move()).toEqual(</span>1<span style="color: #000000;">);
            });
        });
    });


    describe(</span>"测试接口Interface", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        it(</span>"可以继承多个接口", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> A = YYC.Interface("m1"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">var</span> B = YYC.Interface("m2"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">var</span> C = YYC.Interface([A, B], "m3"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">var</span> D = YYC.Interface([A, B], ["m3"<span style="color: #000000;">]);
            </span><span style="color: #0000ff;">var</span> E = YYC.Interface([A, B], ["m3"], ["a"<span style="color: #000000;">]);
            </span><span style="color: #0000ff;">var</span> F = YYC.Interface(A, "m2"<span style="color: #000000;">);

            expect(C.prototype.Interface_m1).toBeExist();
            expect(C.prototype.Interface_m2).toBeExist();
            expect(C.prototype.Interface_m3).toBeExist();

            expect(D.prototype.Interface_m1).toBeExist();
            expect(D.prototype.Interface_m2).toBeExist();
            expect(D.prototype.Interface_m3).toBeExist();

            expect(E.prototype.Interface_m1).toBeExist();
            expect(E.prototype.Interface_m2).toBeExist();
            expect(E.prototype.Interface_m3).toBeExist();
            expect(E.prototype.Interface_a).toEqual(</span>0<span style="color: #000000;">);

            expect(F.prototype.Interface_m1).toBeExist();
            expect(F.prototype.Interface_m2).toBeExist();
        });
    });

    describe(</span>"集成测试", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        it(</span>"测试解决&ldquo;若父类的属性为引用类型（数组或对象）a，则如果子类的实例s1对a进行修改或者sub调用修改a的方法，则第二次创建实例s2的a为修改过后的a！&rdquo;的问题", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> Parent =<span style="color: #000000;"> YYC.AClass({
                Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    console.log(</span>"Parent Init!"<span style="color: #000000;">);
                },
                Public: {
                    a: [],
                }
            });
            </span><span style="color: #0000ff;">var</span> Sub =<span style="color: #000000;"> YYC.Class(Parent, {
                Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                },
                Public: {
                }
            });

            </span><span style="color: #0000ff;">var</span> t = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Sub();
            t.a.push(</span>"a"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">var</span> m = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Sub();

            expect(m.a).toEqual([]);
        });
        it(</span>"测试解决&ldquo;若父类Parent的属性为引用类型（数组或对象）a，有两个子类Sub1、Sub2。如果子类Sub1的实例s1对a进行修改或者sub调用修改a的方法，则子类Sub2的实例的a为修改过后的a！&rdquo;的问题", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> Parent =<span style="color: #000000;"> YYC.AClass({
                Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    console.log(</span>"Parent Init!"<span style="color: #000000;">);
                },
                Public: {
                    a: [],
                    add: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.a.push("a"<span style="color: #000000;">);
                    }
                }
            });
            </span><span style="color: #0000ff;">var</span> Sub1 =<span style="color: #000000;"> YYC.Class(Parent, {
                Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                },
                Public: {
                }
            });
            </span><span style="color: #0000ff;">var</span> Sub2 =<span style="color: #000000;"> YYC.Class(Parent, {
                Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                }
            });

            </span><span style="color: #0000ff;">var</span> t = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Sub1();
            t.a.push(</span>"a"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">var</span> k = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Sub2();

            expect(k.a).toEqual([]);

        });
        it(</span>"测试解决&ldquo;若A1为抽象类，A2（抽象类）继承于A1，B（类）继承于A2，A1、A2、B都有同名方法a，A2和B在a方法中都通过this.baseClass调用父类同名方法。则如果B的实例b调用a方法，则A2、B的a方法中的this.baseClass均指向A2（照理说A2的this.baseClass应该指向A1）！&rdquo;的问题", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> A1 =<span style="color: #000000;"> YYC.AClass({
                Public: {
                    arr: [],
                    a: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.arr.push(1<span style="color: #000000;">);
                    }
                }
            });
            </span><span style="color: #0000ff;">var</span> A2 =<span style="color: #000000;"> YYC.AClass(A1, {
                Public: {
                    a: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.arr.push(2<span style="color: #000000;">);
                        </span><span style="color: #0000ff;">this</span>.baseClass.a.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
                    }
                }
            });
            </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A2, {
                Public: {
                    a: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.arr.push(3<span style="color: #000000;">);
                        </span><span style="color: #0000ff;">this</span>._baseClass.a.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span><span style="color: #000000;">);

                        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.arr;
                    }
                }
            });
            </span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();

            expect(b.a()).toEqual([</span>3, 2, 1<span style="color: #000000;">]);
        });
    });
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<p>最终的YOOP代码：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('1b5c78b0-4800-4b52-8a54-4095ceae5340')"><img id="code_img_closed_1b5c78b0-4800-4b52-8a54-4095ceae5340" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1b5c78b0-4800-4b52-8a54-4095ceae5340" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1b5c78b0-4800-4b52-8a54-4095ceae5340',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1b5c78b0-4800-4b52-8a54-4095ceae5340" class="cnblogs_code_hide">
<pre><span style="color: #000000;">(function () {

    window.YYC </span>= window.YYC ||<span style="color: #000000;"> {};

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">************************************************* String对象扩展 ***********************************************************</span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">String.prototype.contain) {
        String.prototype.contain </span>=<span style="color: #000000;"> function (str) {
            </span><span style="color: #0000ff;">var</span> reg = <span style="color: #0000ff;">new</span> RegExp(str);  <span style="color: #008000;">//</span><span style="color: #008000;">str需要转义</span>
            <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.match(reg)) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">***************************************************************************************************************************</span><span style="color: #008000;">*/</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">获得在原型prototype中不存在同名的str。
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果有同名，则加上前缀"_"</span>
<span style="color: #000000;">    function getNoRepeatStrInPrototype(prototype, str) {
        </span><span style="color: #0000ff;">var</span> new_str = <span style="color: #800000;">""</span><span style="color: #000000;">;

        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">prototype[str]) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> str;
        }
        new_str </span>= <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> str;

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> arguments.callee(prototype, new_str);
    }


    function extendDeep(parent, child) {
        </span><span style="color: #0000ff;">var</span> i = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">,
            toStr </span>=<span style="color: #000000;"> Object.prototype.toString,
            sArr </span>= <span style="color: #800000;">"</span><span style="color: #800000;">[object Array]</span><span style="color: #800000;">"</span><span style="color: #000000;">,
            sOb </span>= <span style="color: #800000;">"</span><span style="color: #800000;">[object Object]</span><span style="color: #800000;">"</span><span style="color: #000000;">,
            type </span>= <span style="color: #800000;">""</span><span style="color: #000000;">,
            _child </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        </span><span style="color: #008000;">//</span><span style="color: #008000;">数组的话，不获得Array原型上的成员。</span>
        <span style="color: #0000ff;">if</span> (toStr.call(parent) ===<span style="color: #000000;"> sArr) {
            _child </span>= child ||<span style="color: #000000;"> [];

            </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = parent.length; i &lt; len; i++<span style="color: #000000;">) {
                type </span>=<span style="color: #000000;"> toStr.call(parent[i]);
                </span><span style="color: #0000ff;">if</span> (type === sArr || type === sOb) {    <span style="color: #008000;">//</span><span style="color: #008000;">如果为数组或object对象</span>
                    _child[i] = type === sArr ?<span style="color: #000000;"> [] : {};
                    arguments.callee(parent[i], _child[i]);
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    _child[i] </span>=<span style="color: #000000;"> parent[i];
                }
            }
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">对象的话，要获得原型链上的成员。因为考虑以下情景：
        </span><span style="color: #008000;">//</span><span style="color: #008000;">类A继承于类B，现在想要拷贝类A的实例a的成员（包括从类B继承来的成员），那么就需要获得原型链上的成员。</span>
        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (toStr.call(parent) ===<span style="color: #000000;"> sOb) {
            _child </span>= child ||<span style="color: #000000;"> {};

            </span><span style="color: #0000ff;">for</span> (i <span style="color: #0000ff;">in</span><span style="color: #000000;"> parent) {
                type </span>=<span style="color: #000000;"> toStr.call(parent[i]);
                </span><span style="color: #0000ff;">if</span> (type === sArr || type ===<span style="color: #000000;"> sOb) {
                    _child[i] </span>= type === sArr ?<span style="color: #000000;"> [] : {};
                    arguments.callee(parent[i], _child[i]);
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    _child[i] </span>=<span style="color: #000000;"> parent[i];
                }
            }
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            _child </span>=<span style="color: #000000;"> parent;
        }

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> _child;
    };
    function getFunctionName(fn) {
        </span><span style="color: #0000ff;">var</span> name = <span style="color: #800000;">""</span><span style="color: #000000;">;

        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">fn) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }

        name </span>= fn.toString().match(/^.*function\s*([^\(]*)/<span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> name === <span style="color: #0000ff;">null</span> ? name : name[<span style="color: #800080;">1</span><span style="color: #000000;">];
    };

    function isArray(val) {
        </span><span style="color: #0000ff;">return</span> Object.prototype.toString.call(val) === <span style="color: #800000;">"</span><span style="color: #800000;">[object Array]</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    };

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
     Structure写成原型形式，而Interface、AClass、Class不写成原型形式！（如写成:
     Interface.prototype = (function(){
     function I(){
     };

     return {
     ...
     };
     }());
     ）
     因为如果写成原型形式，则Interface/AClass/Class的实例就共享同一个I/A/F类！这样会造成不同的类之间互相干扰！
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">


    (function () {
        function Interface() {
            </span><span style="color: #0000ff;">var</span> that = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">this</span>.parent = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">this</span>.method = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">this</span>.attribute = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            function I() {
            }

            function _getByParent(_parent, _method, _attribute) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (_hasParent(_parent)) {
                    _checkInheritInterface(_parent);
                    that.parent </span>= isArray(_parent) ?<span style="color: #000000;"> _parent : [_parent];

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;Interface(Parent, "A", "B", "GetName");&rdquo;</span>
                    <span style="color: #0000ff;">if</span> (_method &amp;&amp; !<span style="color: #000000;">isArray(_method)) {
                        that.method </span>= Array.prototype.slice.call(arguments, <span style="color: #800080;">1</span><span style="color: #000000;">);
                        that.attribute </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;Interface(Parent, ["A", "B", "GetName"], ["a", "c"]);&rdquo;</span>
                    <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        that.method </span>=<span style="color: #000000;"> _method;
                        that.attribute </span>=<span style="color: #000000;"> _attribute;
                    }
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    that.parent </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;Interface("A", "B", "GetName");&rdquo;</span>
                    <span style="color: #0000ff;">if</span> (_parent &amp;&amp; !<span style="color: #000000;">isArray(_parent)) {
                        that.method </span>= Array.prototype.slice.call(arguments, <span style="color: #800080;">0</span><span style="color: #000000;">);
                        that.attribute </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;Interface(["A", "B", "GetName"], ["a", "c"]);&rdquo;</span>
                    <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        that.method </span>= arguments[<span style="color: #800080;">0</span><span style="color: #000000;">];
                        that.attribute </span>= arguments[<span style="color: #800080;">1</span><span style="color: #000000;">];
                    }
                }

                _checkMethod();
            };
            function _hasParent(_parent) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">typeof</span> _parent === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span> || (isArray(_parent) &amp;&amp; <span style="color: #0000ff;">typeof</span> _parent[<span style="color: #800080;">0</span>] === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            };
            function _checkInheritInterface(_parent) {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = _parent.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (getFunctionName(_parent[i]) !== <span style="color: #800000;">"</span><span style="color: #800000;">I</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">Interface must inherit interface!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                }
            };
            function _checkMethod() {
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">that.method) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">Interface must has methods</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            };
            function _inherit() {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = that.parent.length; i &lt; len; i++<span style="color: #000000;">) {
                    extendDeep(that.parent[i].prototype, I.prototype);
                }
                I.prototype.constructor </span>=<span style="color: #000000;"> I;
            };
            function _addMethod() {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = that.method.length; i &lt; len; i++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (that.method[i] ===<span style="color: #000000;"> undefined) {
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">加上前缀&ldquo;Interface_&rdquo;</span>
                    I.prototype[<span style="color: #800000;">"</span><span style="color: #800000;">Interface_</span><span style="color: #800000;">"</span> + that.method[i]] =<span style="color: #000000;"> function () {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">This method must be overwrited!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    };
                }
            };
            function _addAttribute() {
                </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                    len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (that.attribute) {
                    </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">isArray(that.attribute)) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">Attribute must be array!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = that.method.length; i &lt; len; i++<span style="color: #000000;">) {
                            </span><span style="color: #008000;">//</span><span style="color: #008000;">加上前缀&ldquo;Interface_&rdquo;</span>
                            I.prototype[<span style="color: #800000;">"</span><span style="color: #800000;">Interface_</span><span style="color: #800000;">"</span> + that.attribute[i]] = <span style="color: #800080;">0</span><span style="color: #000000;">;
                        }
                    }
                }
            };

            </span><span style="color: #0000ff;">this</span>.buildInterface =<span style="color: #000000;"> function (_parent, _method, _attribute) {
                _getByParent(_parent, _method, _attribute);
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.parent) {
                    _inherit();
                }
                _addMethod();
                _addAttribute();

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> I;
            };
        };

        YYC.Interface </span>=<span style="color: #000000;"> function (_parent, _method, _attribute) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Interface().buildInterface(_parent, _method, _attribute);
        };
    }());

    (function () {

        function Structure() {
        };
        Structure.prototype </span>=<span style="color: #000000;"> (function () {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {
                _addToImplementMap: function (name, func) {
                    </span><span style="color: #0000ff;">this</span>.implementaionMap[name] =<span style="color: #000000;"> func;
                },
                _prepareCheckFor: function (module) {
                    </span><span style="color: #0000ff;">var</span> name = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (module) {
                        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> module) {
                            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (module.hasOwnProperty(name)) {
                                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._prepareCheckForSpecial(name, module);
                                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._addToImplementMap(name, module[name]);
                            }
                        }
                    }
                },
                _prepareCheckForSpecial: function (name, module) {
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._addVirtualToImplementMap(name, module);
                },
                _addVirtualToImplementMap: function (name, module) {
                    </span><span style="color: #0000ff;">var</span> name2 = <span style="color: #800000;">""</span><span style="color: #000000;">;

                    </span><span style="color: #0000ff;">if</span> (name === <span style="color: #800000;">"</span><span style="color: #800000;">Virtual</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">for</span> (name2 <span style="color: #0000ff;">in</span><span style="color: #000000;"> module[name]) {
                            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (module[name].hasOwnProperty(name2)) {
                                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._addToImplementMap(name2, module[name][name2]);
                            }
                        }
                    }
                },
                P_checkImplementationOfAbstract: function () {
                    </span><span style="color: #0000ff;">var</span> name = <span style="color: #800000;">""</span><span style="color: #000000;">,
                        parentClass </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass;

                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass) {
                        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> parentClass.prototype) {
                            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass.prototype.hasOwnProperty(name)) {
                                </span><span style="color: #0000ff;">if</span> (name === <span style="color: #800000;">"</span><span style="color: #800000;">constructor</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                                    </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                                }
                                </span><span style="color: #0000ff;">if</span> (name.contain(<span style="color: #800000;">"</span><span style="color: #800000;">Abstract_</span><span style="color: #800000;">"</span><span style="color: #000000;">)) {
                                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> parentClass.prototype[name] === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._checkAbstractMethod(name);
                                    }
                                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._checkAbstractAttribute(name);
                                    }
                                }
                            }
                        }
                    }
                },
                _checkAbstractMethod: function (name) {
                    </span><span style="color: #0000ff;">var</span> parentClass = <span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass,
                        implementaionMap </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.implementaionMap;

                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._noMethodForAbstract(implementaionMap, name) &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">._noMethodForAbstract(parentClass.prototype, name)) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">Abstract method '</span><span style="color: #800000;">"</span> + name + <span style="color: #800000;">"</span><span style="color: #800000;">' must be overwrited!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                },
                _checkAbstractAttribute: function (name) {
                    </span><span style="color: #0000ff;">var</span> parentClass = <span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass,
                        implementaionMap </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.implementaionMap;

                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._noAttritubeForAbstract(implementaionMap, name) &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">._noAttritubeForAbstract(parentClass.prototype, name)) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">Abstract attribute '</span><span style="color: #800000;">"</span> + name + <span style="color: #800000;">"</span><span style="color: #800000;">' must be overwrited!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                },
                P_checkImplementationOfInterface: function (_interface) {
                    </span><span style="color: #0000ff;">var</span> name = <span style="color: #800000;">""</span><span style="color: #000000;">;

                    </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> _interface.prototype) {
                        </span><span style="color: #0000ff;">if</span> (!name.contain(<span style="color: #800000;">"</span><span style="color: #800000;">Interface_</span><span style="color: #800000;">"</span><span style="color: #000000;">)) {
                            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                        }
                        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _interface.prototype[name] === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._checkInterfaceMethod(name);
                        }
                        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._checkInterfaceAttribute(name);
                        }
                    }
                },
                _checkInterfaceMethod: function (name) {
                    </span><span style="color: #0000ff;">var</span> implementaionMap = <span style="color: #0000ff;">this</span><span style="color: #000000;">.implementaionMap,
                        parentClassPrototype </span>= <span style="color: #0000ff;">this</span>.parentClass ? <span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass.prototype : {};

                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._noMethodForInterface(implementaionMap, name) &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">._noMethodForInterface(parentClassPrototype, name)) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">Interface method '</span><span style="color: #800000;">"</span> + name + <span style="color: #800000;">"</span><span style="color: #800000;">' must be overwrited!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                },
                _checkInterfaceAttribute: function (name) {
                    </span><span style="color: #0000ff;">var</span> implementaionMap = <span style="color: #0000ff;">this</span><span style="color: #000000;">.implementaionMap,
                        parentClassPrototype </span>= <span style="color: #0000ff;">this</span>.parentClass ? <span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass.prototype : {};

                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>._noAttritubeForInterface(implementaionMap, name) &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">._noAttritubeForInterface(parentClassPrototype, name)) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">Interface attribute '</span><span style="color: #800000;">"</span> + name + <span style="color: #800000;">"</span><span style="color: #800000;">' must be overwrited!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                },
                _noMethodForAbstract: function (_class, name) {
                    </span><span style="color: #0000ff;">return</span> _class[name.slice(<span style="color: #800080;">9</span>)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(<span style="color: #800080;">9</span>)] !== <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                },
                _noAttritubeForAbstract: function (_class, name) {
                    </span><span style="color: #0000ff;">return</span> _class[name.slice(<span style="color: #800080;">9</span>)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(<span style="color: #800080;">9</span>)] === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                },
                _noMethodForInterface: function (_class, name) {
                    </span><span style="color: #0000ff;">return</span> _class[name.slice(<span style="color: #800080;">10</span>)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(<span style="color: #800080;">10</span>)] !== <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                },
                _noAttritubeForInterface: function (_class, name) {
                    </span><span style="color: #0000ff;">return</span> _class[name.slice(<span style="color: #800080;">10</span>)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(<span style="color: #800080;">10</span>)] === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                },
                P_addAbstract: function (</span><span style="color: #0000ff;">abstract</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">var</span> name = <span style="color: #800000;">""</span><span style="color: #000000;">,
                        _class </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class;

                    </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span> <span style="color: #0000ff;">abstract</span><span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">abstract</span><span style="color: #000000;">.hasOwnProperty(name)) {
                            </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象方法前面加"Abstract_"前缀</span>
                            _class.prototype[<span style="color: #800000;">"</span><span style="color: #800000;">Abstract_</span><span style="color: #800000;">"</span> + name] = <span style="color: #0000ff;">abstract</span><span style="color: #000000;">[name];
                        }
                    }
                },
                </span><span style="color: #008000;">//</span><span style="color: #008000;">加入虚方法(不能为虚属性)</span>
                P_addVirtualAndCheck: function (<span style="color: #0000ff;">virtual</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">var</span> name = <span style="color: #800000;">""</span><span style="color: #000000;">,
                        _class </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class;

                    </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span> <span style="color: #0000ff;">virtual</span><span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">virtual</span><span style="color: #000000;">.hasOwnProperty(name)) {
                            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> <span style="color: #0000ff;">virtual</span>[name] !== <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">Virtual attribute is not allowed!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                            }
                            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                                _class.prototype[name] </span>= <span style="color: #0000ff;">virtual</span><span style="color: #000000;">[name];
                            }
                        }
                    }
                },
                P_addStaticMember: function () {
                    </span><span style="color: #0000ff;">var</span> Static = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                        k </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                        _class </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class,
                        prop </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop;

                    Static </span>= prop.Static ? prop.Static : <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                    </span><span style="color: #0000ff;">for</span> (k <span style="color: #0000ff;">in</span><span style="color: #000000;"> Static) {
                        _class[k] </span>=<span style="color: #000000;"> Static[k];
                    }
                },
                P_inherit: function () {
                    </span><span style="color: #0000ff;">var</span> _class = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class,
                        parentClass </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass;

                    _class.prototype </span>=<span style="color: #000000;"> extendDeep(parentClass.prototype);
                    _class.prototype.constructor </span>=<span style="color: #000000;"> _class;

                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果父类存在，则实例对象的baseClass指向父类的原型。
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 这就提供了在实例对象中调用父类方法的途径。
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">baseClass的方法是指向this.parentClass.prototype的，不是指向（子类）的！</span>
                    _class.prototype[getNoRepeatStrInPrototype(parentClass.prototype, <span style="color: #800000;">"</span><span style="color: #800000;">baseClass</span><span style="color: #800000;">"</span>)] =<span style="color: #000000;"> parentClass.prototype;
                },
                P_addInit: function () {
                    </span><span style="color: #0000ff;">var</span> _class = <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class,
                        parentClass </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass,
                        prop </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop;

                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Init) {
                        </span><span style="color: #0000ff;">if</span> (parentClass &amp;&amp;
                            <span style="color: #0000ff;">typeof</span> prop.Init === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span> &amp;&amp;
                            <span style="color: #0000ff;">typeof</span> _class.prototype.Init === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                            _class.prototype.Init </span>=<span style="color: #000000;"> function (name) {
                                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> function () {
                                    </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span> =<span style="color: #000000;"> parentClass.prototype[name];

                                    </span><span style="color: #0000ff;">return</span> prop[name].apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
                                };
                            }(</span><span style="color: #800000;">"</span><span style="color: #800000;">Init</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                        }
                        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            _class.prototype.Init </span>=<span style="color: #000000;"> prop.Init;
                        }
                    }
                },
                P_addPrivateMember: function () {
                    </span><span style="color: #0000ff;">var</span> name = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                        _class </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class,
                        </span><span style="color: #0000ff;">private</span> = <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Private;

                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">private</span><span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span> <span style="color: #0000ff;">private</span><span style="color: #000000;">) {
                            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">private</span><span style="color: #000000;">.hasOwnProperty(name)) {
                                _class.prototype[name] </span>= <span style="color: #0000ff;">private</span><span style="color: #000000;">[name];
                            }
                        }
                    }
                },
                P_addPublicMember: function () {
                    </span><span style="color: #0000ff;">var</span> name = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Public) {
                        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Public) {
                            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Public.hasOwnProperty(name)) {
                                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.P_addSpecial(<span style="color: #800000;">"</span><span style="color: #800000;">Public</span><span style="color: #800000;">"</span>, name) === <span style="color: #800000;">"</span><span style="color: #800000;">continue</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                                    </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                                }
                                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">._addPublic(name);
                            }
                        }
                    }
                },
                _addPublic: function (name) {
                    </span><span style="color: #0000ff;">var</span> parentClass = <span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass,
                        prop </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop,
                        P_class </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_class;

                    </span><span style="color: #0000ff;">if</span> (parentClass &amp;&amp;
                        <span style="color: #0000ff;">typeof</span> prop.Public[name] === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span> &amp;&amp;
                        <span style="color: #0000ff;">typeof</span> P_class.prototype[name] === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                        P_class.prototype[name] </span>=<span style="color: #000000;"> function (name) {
                            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> function () {
                                </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span> =<span style="color: #000000;"> parentClass.prototype[name];

                                </span><span style="color: #0000ff;">return</span> prop.Public[name].apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
                            };
                        }(name);
                    }
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        P_class.prototype[name] </span>=<span style="color: #000000;"> prop.Public[name];
                    }
                },
                P_prepareCheck: function () {
                    </span><span style="color: #0000ff;">this</span>._prepareCheckFor(<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Public);
                    </span><span style="color: #0000ff;">this</span>._prepareCheckFor(<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Protected);
                },
                P_addProtectedMember: function () {
                    </span><span style="color: #0000ff;">var</span> name = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Protected) {
                        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Protected) {
                            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Protected.hasOwnProperty(name)) {
                                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.P_addSpecial(<span style="color: #800000;">"</span><span style="color: #800000;">Protected</span><span style="color: #800000;">"</span>, name) === <span style="color: #800000;">"</span><span style="color: #800000;">continue</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                                    </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                                }
                                </span><span style="color: #0000ff;">this</span>.P_class.prototype[name] = <span style="color: #0000ff;">this</span><span style="color: #000000;">.prop.Protected[name];
                            }
                        }
                    }
                }
            }
        }());

        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建抽象类
        </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象类能够继承接口、抽象类以及实体类，但此处约定抽象类只能继承接口和抽象类，不能继承实体类！
        </span><span style="color: #008000;">//</span><span style="color: #008000;">（这样方便判断抽象类是否包含全部的父类（接口/抽象类）成员）</span>
<span style="color: #000000;">
        function AClass() {
            </span><span style="color: #0000ff;">var</span> that = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">this</span>.P_class =<span style="color: #000000;"> A;
            </span><span style="color: #0000ff;">this</span>.implementaionMap =<span style="color: #000000;"> {};
            </span><span style="color: #0000ff;">this</span>.parentClass = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">interface</span> = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">this</span>.prop = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建的类（构造函数）</span>
<span style="color: #000000;">            function A() {
            };

            function __getByParent(args) {
                </span><span style="color: #0000ff;">var</span> _parent = args[<span style="color: #800080;">0</span><span style="color: #000000;">],
                    _prop </span>= args[<span style="color: #800080;">1</span><span style="color: #000000;">];

                __checkOnlyOneParentClass(args);

                </span><span style="color: #0000ff;">if</span> (_prop ===<span style="color: #000000;"> undefined) {
                    that.prop </span>=<span style="color: #000000;"> _parent;
                    that.parentClass </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    that.</span><span style="color: #0000ff;">interface</span> = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">{Class: xx, Interface: xx}</span>
                <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === <span style="color: #800000;">"</span><span style="color: #800000;">object</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (!_parent.Class &amp;&amp; !<span style="color: #000000;">_parent.Interface) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">Please add AbstractClass or Interface!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                    that.parentClass </span>=<span style="color: #000000;"> _parent.Class;
                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (isArray(_parent.Interface)) {
                        that.</span><span style="color: #0000ff;">interface</span> =<span style="color: #000000;"> _parent.Interface;
                    }
                    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent.Interface === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                        that.</span><span style="color: #0000ff;">interface</span> =<span style="color: #000000;"> [_parent.Interface];
                    }
                    that.prop </span>=<span style="color: #000000;"> _prop;
                }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">直接为xx抽象类</span>
                <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                    that.parentClass </span>=<span style="color: #000000;"> _parent;
                    that.</span><span style="color: #0000ff;">interface</span> = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    that.prop </span>=<span style="color: #000000;"> _prop;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">arguments is not allowed!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (__isInheritFromClass()) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">AbstractClass can't inherit class!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            };
            function __checkOnlyOneParentClass(args) {
                </span><span style="color: #0000ff;">if</span> (args.length &gt;= <span style="color: #800080;">3</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">AbstractClass can only inherit from one parentClass</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }

                </span><span style="color: #0000ff;">if</span> (args[<span style="color: #800080;">0</span><span style="color: #000000;">].Class) {
                    </span><span style="color: #0000ff;">if</span> (isArray(args[<span style="color: #800080;">0</span>].Class) &amp;&amp; args[<span style="color: #800080;">0</span>].Class.length &gt;= <span style="color: #800080;">2</span><span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">AbstractClass can only inherit from one parentClass</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                }
            };
            function __isInheritFromClass() {
                </span><span style="color: #0000ff;">return</span> getFunctionName(that.parentClass) === <span style="color: #800000;">"</span><span style="color: #800000;">F</span><span style="color: #800000;">"</span><span style="color: #000000;">;
            };
            </span><span style="color: #0000ff;">this</span>.P_inherit =<span style="color: #000000;"> function () {
                </span><span style="color: #0000ff;">var</span> parentClass = <span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass;

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass) {
                    A.prototype </span>=<span style="color: #000000;"> extendDeep(parentClass.prototype);
                    A.prototype.constructor </span>=<span style="color: #000000;"> A;

                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果父类存在，则实例对象的baseClass指向父类的原型。
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 这就提供了在实例对象中调用父类方法的途径。
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">baseClass的方法是指向this.parentClass.prototype的，不是指向（子类）的！</span>
                    A.prototype[getNoRepeatStrInPrototype(parentClass.prototype, <span style="color: #800000;">"</span><span style="color: #800000;">baseClass</span><span style="color: #800000;">"</span>)] =<span style="color: #000000;"> parentClass.prototype;
                }

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">interface</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                        len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = <span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">interface</span>.length; i &lt; len; i++<span style="color: #000000;">) {
                        extendDeep(</span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">interface</span><span style="color: #000000;">[i].prototype, A.prototype);
                    }
                }
            };
            </span><span style="color: #0000ff;">this</span>.P_addSpecial =<span style="color: #000000;"> function (moduleName, name) {
                </span><span style="color: #0000ff;">if</span> (name === <span style="color: #800000;">"</span><span style="color: #800000;">Abstract</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_addAbstract(<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop[moduleName][name]);
                    </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">continue</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">if</span> (name === <span style="color: #800000;">"</span><span style="color: #800000;">Virtual</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_addVirtualAndCheck(<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop[moduleName][name]);
                    </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">continue</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            };

            </span><span style="color: #0000ff;">this</span>.buildAClass =<span style="color: #000000;"> function (args) {
                __getByParent(args);

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_inherit();

                </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象类本身因为不能实例化，所以不在A中调用构造函数Init。
                </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象类中的构造函数供子类构造函数中调用。</span>
                <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addInit();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addPrivateMember();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addProtectedMember();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addPublicMember();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addStaticMember();
                __addOuterAbstract();
                __addOuterVirtual();

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_prepareCheck();

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> A;
            };

            </span><span style="color: #008000;">//</span><span style="color: #008000;">放到外面的抽象成员，默认为公有抽象成员</span>
<span style="color: #000000;">            function __addOuterAbstract() {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (that.prop.Abstract) {
                    that.P_addAbstract(that.prop.Abstract);
                }
            };
            function __addOuterVirtual() {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (that.prop.Virtual) {
                    that.P_addVirtualAndCheck(that.prop.Virtual);
                }
            };
        };

        AClass.prototype </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Structure();

        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建普通类
        </span><span style="color: #008000;">//</span><span style="color: #008000;">父类_parent可以为{Class: xx, Interface: xx}，或者直接为xx类</span>
<span style="color: #000000;">        function Class() {
            </span><span style="color: #0000ff;">var</span> that = <span style="color: #0000ff;">this</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">this</span>.implementaionMap =<span style="color: #000000;"> {};
            </span><span style="color: #0000ff;">this</span>.parentClass = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">interface</span> = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">this</span>.prop = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #0000ff;">this</span>.P_class =<span style="color: #000000;"> F;
            </span><span style="color: #008000;">//</span><span style="color: #008000;">当前是否处于创建类的阶段。</span>
            <span style="color: #0000ff;">this</span>.initializing = <span style="color: #0000ff;">false</span><span style="color: #000000;">;


            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建的类（构造函数）</span>
<span style="color: #000000;">            function F() {
                </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">,
                    args </span>=<span style="color: #000000;"> arguments;

                function _restorePrototype() {
                    extendDeep(F.prototype, self);
                };
                function _init() {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果当前处于实例化类的阶段，则调用构造函数Init</span>
                    <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">that.initializing) {
                        self.Init </span>&amp;&amp;<span style="color: #000000;"> self.Init.apply(self, args);
                    }
                };

                _restorePrototype();
                _init();

                </span><span style="color: #008000;">/*</span><span style="color: #008000;">不能删除私有成员和保护成员！否则类的成员就不能调用到私有和保护的成员了（因为已经删除了）！
                 对象的创建算法参考http://www.cnblogs.com/TomXu/archive/2012/02/06/2330609.html




                 //删除私有成员和保护成员，这样外界就不能访问私有和保护成员了！
                 for (name in this) {
                 if (name.search(/(^_)|(^P_)/) !== -1) {
                 delete F.prototype[name];
                 //                                                    this[name] = null;
                 }

                 }
                 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
            }

            function __getByParent(args) {
                </span><span style="color: #0000ff;">var</span> _parent = args[<span style="color: #800080;">0</span><span style="color: #000000;">],
                    _prop </span>= args[<span style="color: #800080;">1</span><span style="color: #000000;">];

                __checkOnlyOneParentClass(args);

                </span><span style="color: #0000ff;">if</span> (_prop ===<span style="color: #000000;"> undefined) {
                    that.prop </span>=<span style="color: #000000;"> _parent;
                    that.parentClass </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    that.</span><span style="color: #0000ff;">interface</span> = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">{Class: xx, Interface: xx}</span>
                <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === <span style="color: #800000;">"</span><span style="color: #800000;">object</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (!_parent.Class &amp;&amp; !<span style="color: #000000;">_parent.Interface) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">Please add Class or Interface!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                    that.parentClass </span>=<span style="color: #000000;"> _parent.Class;
                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (isArray(_parent.Interface)) {
                        that.</span><span style="color: #0000ff;">interface</span> =<span style="color: #000000;"> _parent.Interface;
                    }
                    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent.Interface === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                        that.</span><span style="color: #0000ff;">interface</span> =<span style="color: #000000;"> [_parent.Interface];
                    }
                    that.prop </span>=<span style="color: #000000;"> _prop;
                }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">直接为xx类</span>
                <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === <span style="color: #800000;">"</span><span style="color: #800000;">function</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                    that.parentClass </span>=<span style="color: #000000;"> _parent;
                    that.</span><span style="color: #0000ff;">interface</span> = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    that.prop </span>=<span style="color: #000000;"> _prop;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">arguments is not allowed!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            };
            function __checkOnlyOneParentClass(args) {
                </span><span style="color: #0000ff;">if</span> (args.length &gt;= <span style="color: #800080;">3</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">class can only inherit from one parentClass</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }

                </span><span style="color: #0000ff;">if</span> (args[<span style="color: #800080;">0</span><span style="color: #000000;">].Class) {
                    </span><span style="color: #0000ff;">if</span> (isArray(args[<span style="color: #800080;">0</span>].Class) &amp;&amp; args[<span style="color: #800080;">0</span>].Class.length &gt;= <span style="color: #800080;">2</span><span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">class can only inherit from one parentClass</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                    }
                }
            };
            </span><span style="color: #0000ff;">this</span>.P_addSpecial =<span style="color: #000000;"> function (moduleName, name) {
                </span><span style="color: #0000ff;">if</span> (name === <span style="color: #800000;">"</span><span style="color: #800000;">Abstract</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">class can't have abstract members</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
                </span><span style="color: #0000ff;">if</span> (name === <span style="color: #800000;">"</span><span style="color: #800000;">Virtual</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">this</span>.P_addVirtualAndCheck(<span style="color: #0000ff;">this</span><span style="color: #000000;">.prop[moduleName][name]);
                    </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">continue</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            };
            </span><span style="color: #0000ff;">this</span>.buildClass =<span style="color: #000000;"> function (args) {
                __getByParent(args);

                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.parentClass) {
                    </span><span style="color: #0000ff;">this</span>.initializing = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_inherit();
                    </span><span style="color: #0000ff;">this</span>.initializing = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addInit();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addPrivateMember();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addProtectedMember();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addPublicMember();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_addStaticMember();
                __addOuterAbstract();
                __addOuterVirtual();

                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_prepareCheck();
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.P_checkImplementationOfAbstract();
                __checkEachImplementationOfInterface();

                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> F;
            };
            function __checkEachImplementationOfInterface() {
                </span><span style="color: #0000ff;">if</span> (that.<span style="color: #0000ff;">interface</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">,
                        len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;

                    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>, len = that.<span style="color: #0000ff;">interface</span>.length; i &lt; len; i++<span style="color: #000000;">) {
                        that.P_checkImplementationOfInterface(that.</span><span style="color: #0000ff;">interface</span><span style="color: #000000;">[i]);
                    }
                }
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (__hasInterfaceInheritFromParentClass()) {
                    that.P_checkImplementationOfInterface(that.parentClass);
                }
            };
            function __hasInterfaceInheritFromParentClass() {
                </span><span style="color: #0000ff;">var</span> name = <span style="color: #800000;">""</span><span style="color: #000000;">;

                </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> F.prototype) {
                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (F.prototype.hasOwnProperty(name)) {
                        </span><span style="color: #0000ff;">if</span> (name.contain(<span style="color: #800000;">"</span><span style="color: #800000;">Interface_</span><span style="color: #800000;">"</span><span style="color: #000000;">)) {
                            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                        }
                    }
                }

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            };
            function __addOuterAbstract() {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (that.prop.Abstract) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(<span style="color: #800000;">"</span><span style="color: #800000;">class can't have abstract members!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            };
            function __addOuterVirtual() {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (that.prop.Virtual) {
                    that.P_addVirtualAndCheck(that.prop.Virtual);
                }
            };
        };

        Class.prototype </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Structure();

        </span><span style="color: #008000;">/*</span><span style="color: #008000;">
         下面的写法有问题！因为只有载入YOOP.js时，创建了AClass的实例。
         调用YYC.AClass时，只是引用该实例的buildAClass，而不会再创建AClass实例。
         也就是说，所有YYC.AClass都共用一个AClass的实例！共用AClass实例的属性（如parent等）！

         YYC.AClass = new AClass().buildAClass;
         </span><span style="color: #008000;">*/</span><span style="color: #000000;">


        YYC.AClass </span>=<span style="color: #000000;"> function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> AClass().buildAClass(arguments);
        };
        YYC.Class </span>=<span style="color: #000000;"> function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Class().buildClass(arguments);
        };
    }());
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">总结</span></strong></span></strong></p>
<p><span style="color: #000000;">我花了5天的时间来对YOOP进行重构，这样效率其实是比较低下的。我们应该采用TDD开发，在需要重构的时候立马重构。</span></p>
<p>因为随着人们对问题研究的深入，人们对问题的了解也越来越多，所以需要及时的反馈修正，对之前做的设计或代码进行修改，然后运行测试，保证测试的通过，然后再进行下一步的研究。这是一个迭代的过程，每次重构，都能反映自己的最新的理解。</p>
<p>为了保证代码质量，为了便于二次开发扩展，为了增强可读性，为了反映自己最新的理解，为了追求代码之美、设计之美，都需要我们在坚实的测试套件下，不断地重构改进。</p>
<p>需要注意的是，不仅是产品代码需要重构，测试代码也一样需要重构。</p>
<p>对于我们个人的修炼而言，应该时刻地重构；对于工程方面而言，有时为了赶进度，会对质量方面要求降低。但是作为程序员，应该对自己编写的代码负责，在赶进度的情况下，我们应该在项目结束或相对轻松的时间里，对代码进行重构，而且可以进行抽象、封装，提炼出自己的产品和文档。</p>
<p>只有通过不断地改进、总结，我们才能不断地进步。</p>]]></description></item><item><title>Javascript OOP框架YOOP重构实践（上）</title><link>http://www.cnblogs.com/chaogex/archive/2013/06/08/3125776.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sat, 08 Jun 2013 09:52:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/06/08/3125776.html</guid><description><![CDATA[<p>大家好！今天跟大家一起分享我的OOP框架YOOP重构实践，希望能与大家一起共同学习、共同进步。</p>
<p>本文展示了我对没有编写测试的YOOP原始版本的重构过程。通过该重构，力图将一个杂乱无章的遗留代码重构为有良好测试的、结构良好、可读性较强的高质量代码。</p>
<p>在本次重构中，我不但会对代码结构进行重构，还会改变部分行为（如将&ldquo;抽象类要检查是否实现了接口成员和父类的抽象方法&rdquo;修改为&ldquo;抽象类不检查是否实现了接口成员和父类的抽象方法&rdquo;；将&ldquo;抽象类、类只能继承1个接口&rdquo;修改为&ldquo;可以继承多个接口&rdquo;等等）。改变行为时，必须先添加或者修改测试，然后才能小步地改变行为。</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">原始版本</span></strong></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('3b39b8a8-bd00-4297-8fca-5bd444ac9637')"><img id="code_img_closed_3b39b8a8-bd00-4297-8fca-5bd444ac9637" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_3b39b8a8-bd00-4297-8fca-5bd444ac9637" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3b39b8a8-bd00-4297-8fca-5bd444ac9637',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_3b39b8a8-bd00-4297-8fca-5bd444ac9637" class="cnblogs_code_hide">
<pre>(<span style="color: #0000ff;">function</span><span style="color: #000000;"> () {

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">************************************************* String对象扩展 ***********************************************************
    
    扩展方法：
    contain
    containIgnoreCase
    trim

    </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">String.prototype.contain) {
        String.prototype.contain </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (str) {
            </span><span style="color: #008000;">/*</span><span style="color: #008000;"> 使用RegExp对象来构造动态匹配。
            注意！str是字符串，因此需要转义！

            由于JavaScript字符串中的&ldquo;\&rdquo;是一个转义字符，因此，使用显式构造函数创建RegExp实例对象时，应将原始正则表达式中的&ldquo;\&rdquo;用&ldquo;\\&rdquo;替换。例如，在代码1.2中的两条语句是等价的。

            代码1.2   转义字符中的&ldquo;\&rdquo;：1.2.htm

            &lt;script language="javascript"&gt;

            var re1 = new RegExp("\\d{5}");

            var re2 = /\d{5}/;

            alert("re1="+re1+"\nre2="+re2);

            &lt;/script&gt;

         

            由于正则表达式模式文本中的转义字符也是&ldquo;\&rdquo;，如果正则表达式中要匹配原义字符&ldquo;\&rdquo;，在正则表达式模式文本中要以&ldquo;\\&rdquo;来表示，当使用显式构造函数的方式创建RegExp实例对象的时候，就需要使用&ldquo;\\\\&rdquo;来表示原义字符&ldquo;\&rdquo;。

            var re = new RegExp(\\\\)。

            </span><span style="color: #008000;">*/</span>
            <span style="color: #0000ff;">var</span> reg = <span style="color: #0000ff;">new</span><span style="color: #000000;"> RegExp(str);
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.match(reg)) {  <span style="color: #008000;">//</span><span style="color: #008000;">用this指针指代本体</span>
                <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">***************************************************************************************************************************</span><span style="color: #008000;">*/</span>


    <span style="color: #008000;">//</span><span style="color: #008000;">当前是否处于创建类的阶段。</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">放在自执行函数中，initializing就是自执行函数的内部变量，自执行函数的上下文结束后，外部就不能访问initializing了。</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">不用var的话，就不是当前上下文的一个变量了，而是全局对象的一个属性。这样外部就能够访问了。</span>
    <span style="color: #0000ff;">var</span> initializing = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">    var count = 0;</span>


    <span style="color: #008000;">//</span><span style="color: #008000;">获得函数的参数数组</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> argumentNames(fn) {
        </span><span style="color: #0000ff;">var</span> names = fn.toString().match(/^[\s\(]*function[^(]*\(([^\)]*)\)/)[1].replace(/\s+/g, '').split(','<span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> names.length == 1 &amp;&amp; !names[0] ?<span style="color: #000000;"> [] : names;
    };

    </span><span style="color: #008000;">/*</span><span style="color: #008000;"> 深拷贝
    </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> extendDeep(parent, child) {
        </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> i,
                toStr </span>=<span style="color: #000000;"> Object.prototype.toString,
                sArr </span>= "[object Array]"<span style="color: #000000;">,
                sOb </span>= "[object Object]"<span style="color: #000000;">,
                type </span>= ""<span style="color: #000000;">,
        child </span>= child ||<span style="color: #000000;"> {};

        </span><span style="color: #0000ff;">for</span> (i <span style="color: #0000ff;">in</span><span style="color: #000000;"> parent) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">if (parent.hasOwnProperty &amp;&amp; parent.hasOwnProperty(i)) {</span>

            <span style="color: #008000;">//</span><span style="color: #008000;">                if (typeof parent[i] === 'object') {    //null === 'object'也为true！</span>
<span style="color: #000000;">
            type </span>=<span style="color: #000000;"> toStr.call(parent[i]);
            </span><span style="color: #0000ff;">if</span> (type === sArr || type === sOb) {    <span style="color: #008000;">//</span><span style="color: #008000;">如果为数组或object对象</span>
                child[i] = type === sArr ?<span style="color: #000000;"> [] : {};
                extendDeep(parent[i], child[i]);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                child[i] </span>=<span style="color: #000000;"> parent[i];
            }
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">}</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;"> child;
    };


    </span><span style="color: #008000;">//</span><span style="color: #008000;">获得函数名</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> getFunctionName(fn) {
        </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">fn) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }

        name </span>= fn.toString().match(/^.*function\s*([^\(]*)/<span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> name === <span style="color: #0000ff;">null</span> ? name : name[1<span style="color: #000000;">];
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;">判断是否为数组</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> isArray(val) {
        </span><span style="color: #0000ff;">return</span> Object.prototype.toString.call(val) === "[object Array]"<span style="color: #000000;">;
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查抽象类的公有方法+虚方法+抽象方法是否包含父类的抽象方法/属性 或 接口方法/属性。</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">不用hasOwnProperty判断！否则就检查不到是否包含了父类的抽象方法/属性 或 接口方法/属性。</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> check(parentClass, interface, children) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">        if (!parent || !interface || !children) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            throw new Error("check - arguments error!");</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        }</span>

        <span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">检查是否实现了抽象方法/属性</span>
            <span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> parentClass.prototype) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass.prototype.hasOwnProperty(name)) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">                console.log(name);</span>
                    <span style="color: #0000ff;">if</span> (name === "constructor"<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #0000ff;">if</span> (name.contain("Abstract_"<span style="color: #000000;">)) {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象方法</span>
                        <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> parentClass.prototype[name] === "function"<span style="color: #000000;">) {
                            </span><span style="color: #0000ff;">if</span> (children[name.slice(9)] === undefined || <span style="color: #0000ff;">typeof</span> children[name.slice(9)] !== "function"<span style="color: #000000;">) {
                                </span><span style="color: #008000;">//</span><span style="color: #008000;">                            var t = name.slice(9);</span>
                                <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Abstract method '" + name + "' must be overwrited!"<span style="color: #000000;">);
                            }
                        }
                            </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象属性</span>
                        <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            </span><span style="color: #0000ff;">if</span> (children[name.slice(9)] === undefined || <span style="color: #0000ff;">typeof</span> children[name.slice(9)] === "function"<span style="color: #000000;">) {
                                </span><span style="color: #008000;">//</span><span style="color: #008000;">                            var t = name.slice(9);</span>
                                <span style="color: #008000;">//</span><span style="color: #008000;">                            var p = children[name.slice(9)];</span>
                                <span style="color: #008000;">//</span><span style="color: #008000;">                            var q = typeof children[name.slice(9)];</span>
                                <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Abstract attribute '" + name + "' must be overwrited!"<span style="color: #000000;">);
                            }
                        }
                    }
                }
            }
        }

        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">interface) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;">检查是否实现了接口方法/属性</span>
        <span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> interface.prototype) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">                console.log(name);</span>
            <span style="color: #0000ff;">if</span> (name === "constructor"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">                if (interface.prototype.hasOwnProperty(name)) {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">接口方法</span>
            <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> interface.prototype[name] === "function"<span style="color: #000000;">) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">                    var t = name.slice(10);</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                    var m = children[name.slice(10)];</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                        console.log("t = " + t);</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                        console.log("m = " + m);</span>
                <span style="color: #0000ff;">if</span> (children[name.slice(10)] === undefined || <span style="color: #0000ff;">typeof</span> children[name.slice(10)] !== "function"<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface method '" + name + "' must be overwrited!"<span style="color: #000000;">);
                }
            }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">接口属性</span>
            <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">                    var t = name.slice(10);</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                    var m = children[name.slice(10)];</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                        console.log("t = " + t);</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                        console.log("m = " + m);</span>
                <span style="color: #0000ff;">if</span> (children[name.slice(10)] === undefined || <span style="color: #0000ff;">typeof</span> children[name.slice(10)] === "function"<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface attribute '" + name + "' must be overwrited!"<span style="color: #000000;">);
                }
            }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">                }</span>
<span style="color: #000000;">        }
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查抽象成员</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> addAbstract(abstract, currentClass, temp) {
        </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> abstract) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (abstract.hasOwnProperty(name)) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">                if (typeof abstract[name] !== "function") {</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                    throw new Error("Virtual attribute is not allowed!");</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                }</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                else {</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">抽象方法前面加"Abstract_"前缀</span>
                currentClass.prototype["Abstract_" + name] =<span style="color: #000000;"> abstract[name];
                </span><span style="color: #008000;">//</span><span style="color: #008000;">                currentClass.prototype[name] = abstract[name];</span>
<span style="color: #000000;">
                temp[name] </span>= abstract[name];    <span style="color: #008000;">//</span><span style="color: #008000;">加入temp</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                }</span>
<span style="color: #000000;">            }
        }
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查虚方法(不能为虚属性)</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> addVirtual(virtual, currentClass, temp) {
        </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> virtual) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (virtual.hasOwnProperty(name)) {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> virtual[name] !== "function"<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Virtual attribute is not allowed!"<span style="color: #000000;">);
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    currentClass.prototype[name] </span>=<span style="color: #000000;"> virtual[name];

                    temp[name] </span>= virtual[name];    <span style="color: #008000;">//</span><span style="color: #008000;">加入temp</span>
<span style="color: #000000;">                }
            }
        }
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;">加入密封方法。</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">没有实现检查子类是否重写了父类的密封方法，只是定义了一个规范。</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> addSealed(sealed, currentClass, temp) {
        </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> sealed) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (sealed.hasOwnProperty(name)) {
                currentClass.prototype[name] </span>=<span style="color: #000000;"> sealed[name];

                temp[name] </span>= sealed[name];    <span style="color: #008000;">//</span><span style="color: #008000;">加入temp</span>
<span style="color: #000000;">            }
        }
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;">获得在原型prototype中不存在同名的str。</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">如果有同名，则加上前缀"_"</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> getNoRepeatStrInPrototype(prototype, str) {
        </span><span style="color: #0000ff;">var</span> new_str = ""<span style="color: #000000;">;

        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">prototype[str]) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> str;
        }

        new_str </span>= "_" +<span style="color: #000000;"> str;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> getNoRepeatStrInPrototype(prototype, new_str);
    }




    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建接口</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">接口可以继承接口</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> MyInterface(_parent, _method, _attribute) {
        </span><span style="color: #0000ff;">var</span> i = 0, args = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        </span><span style="color: #0000ff;">var</span> parent = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            method </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            attribute </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "function"<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (getFunctionName(_parent) !== "I"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface must inherit interface!"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                parent </span>=<span style="color: #000000;"> _parent;

                </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;MyInterface(Parent, "A", "B", "GetName");&rdquo;</span>
                <span style="color: #0000ff;">if</span> (_method &amp;&amp; !<span style="color: #000000;">isArray(_method)) {
                    method </span>= Array.prototype.slice.call(arguments, 1<span style="color: #000000;">);
                    attribute </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;MyInterface(Parent, ["A", "B", "GetName"], ["a", "c"]);&rdquo;</span>
                <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    method </span>=<span style="color: #000000;"> _method;
                    attribute </span>=<span style="color: #000000;"> _attribute;
                }
            }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">            console.log(parent.toString());</span>
<span style="color: #000000;">        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            parent </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;MyInterface("A", "B", "GetName");&rdquo;</span>
            <span style="color: #0000ff;">if</span> (_method &amp;&amp; !<span style="color: #000000;">isArray(_method)) {
                method </span>=<span style="color: #000000;"> arguments
                attribute </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;MyInterface(["A", "B", "GetName"], ["a", "c"]);&rdquo;</span>
            <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                method </span>= arguments[0<span style="color: #000000;">];
                attribute </span>= arguments[1<span style="color: #000000;">];
            }
        }

        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> I() {
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此接口需要从其它接口扩展</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (parent) {
            I.prototype </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> parent();
            I.prototype.constructor </span>=<span style="color: #000000;"> I;
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;">        console.log("method = " + method);</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        console.log("attribute = " + attribute);</span>


        <span style="color: #008000;">//</span><span style="color: #008000;">        //形如&ldquo;MyInterface(["A", "B", "GetName"], ["a", "c"]);&rdquo;</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        if (isArray(method)) {</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">方法</span>
        <span style="color: #0000ff;">for</span> (i = 0; i &lt; method.length; i++<span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">加上前缀&ldquo;Interface_&rdquo;</span>
            I.prototype["Interface_" + method[i]] = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("This method must be overwrited!"<span style="color: #000000;">);
            };
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">属性</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (attribute) {
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">isArray(attribute)) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Attribute must be array!"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">for</span> (i = 0; i &lt; attribute.length; i++<span style="color: #000000;">) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">加上前缀&ldquo;Interface_&rdquo;</span>
                    I.prototype["Interface_" + attribute[i]] = 0<span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">        }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        //形如&ldquo;MyInterface("A", "B", "GetName");&rdquo;</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        else {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            args = Array.prototype.slice.call(arguments, 1);</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            //方法</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            for (i = 0; i &lt; args.length; i++) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                I.prototype[args[i]] = function () {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    throw new Error("This method must be overwrited!");</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                };</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        }</span>

        <span style="color: #0000ff;">return</span><span style="color: #000000;"> I;
    };



    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建抽象类</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">抽象类能够继承接口、抽象类以及实体类，但此处约定抽象类只能继承接口和抽象类，不能继承实体类！</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">（这样方便判断抽象类是否包含全部的父类（接口/抽象类）成员）</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> MyAbstract(_parent, _prop) {
        </span><span style="color: #0000ff;">var</span> Static = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">var</span> k = <span style="color: #0000ff;">null</span>, name = <span style="color: #0000ff;">null</span>, temp =<span style="color: #000000;"> {},
            virtual </span>=<span style="color: #000000;"> {};

        </span><span style="color: #008000;">//</span><span style="color: #008000;">        if (arguments.length &gt; 1) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            throw new Error("AbstractClass can't inherit other classes!");</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        }</span>

        <span style="color: #0000ff;">var</span> abstractClass = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            prop </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        </span><span style="color: #008000;">//</span><span style="color: #008000;">原型恢复标志，用于防止第一次创建实例时恢复原型</span>
        <span style="color: #0000ff;">var</span> mark_resume = <span style="color: #0000ff;">false</span><span style="color: #000000;">;


        </span><span style="color: #008000;">//</span><span style="color: #008000;">取出父类、接口</span>
        <span style="color: #0000ff;">if</span> (arguments.length === 1<span style="color: #000000;">) {
            prop </span>= arguments[0<span style="color: #000000;">];
            </span><span style="color: #008000;">//</span><span style="color: #008000;">            parent = null;</span>
            abstractClass = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">_parent为{Class: xx, Interface: xx}</span>
        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "object"<span style="color: #000000;">) {

            </span><span style="color: #0000ff;">if</span> (!_parent.Class &amp;&amp; !<span style="color: #000000;">_parent.Interface) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Please add AbstractClass or Interface!"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">if</span> (getFunctionName(_parent.Class) === "F" || getFunctionName(_parent.Interface) === "F"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("AbstractClass here can't inherit parentClass which is created by MyClass function!"<span style="color: #000000;">);
            }

            abstractClass </span>=<span style="color: #000000;"> _parent.Class;
            interface </span>=<span style="color: #000000;"> _parent.Interface;

            prop </span>=<span style="color: #000000;"> _prop;
        }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">_parent直接为xx，就表示父类为抽象类</span>
        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "function"<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (getFunctionName(_parent) === "F"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("AbstractClass here can't inherit parentClass which is created by MyClass function!"<span style="color: #000000;">);
            }

            abstractClass </span>=<span style="color: #000000;"> _parent;
            interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            prop </span>=<span style="color: #000000;"> _prop;
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("arguments is not allowed!"<span style="color: #000000;">);
        }


        Static </span>= prop.Static ? prop.Static : <span style="color: #0000ff;">null</span><span style="color: #000000;">;


        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 本次调用所创建的类（构造函数）</span>
        <span style="color: #0000ff;">function</span><span style="color: #000000;"> A() {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">            // 如果抽象父类存在，则实例对象的baseClass指向父类的原型</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            // 这就提供了在实例对象中调用父类方法的途径</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            if (abstractClass) {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                this.baseClass = abstractClass.prototype;</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            }</span>

            <span style="color: #008000;">//</span><span style="color: #008000;">//防止第一次创建实例时恢复原型</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">if (mark_resume) {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">    //还原原型</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">    extendDeep(A.prototype.backUp_prototype, A.prototype);</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">}</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">else {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">    mark_resume = true;</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">}</span>
<span style="color: #000000;">
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此接口需要从其它接口扩展</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (abstractClass) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">            //删除父类的私有成员，保留本类的私有成员</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            for (name in abstractClass.prototype) {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                if (abstractClass.prototype.hasOwnProperty(name)) {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                    //私有成员以&ldquo;_&rdquo;开头，可能有多个&ldquo;_&rdquo;（多层继承）</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                    if (!name.match(/^_+/)) {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                        //                                                delete parentClass.prototype[name];</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                        A.prototype[name] = abstractClass.prototype[name];</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                    }</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                }</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            }</span>

            <span style="color: #008000;">//</span><span style="color: #008000;">A.prototype = new abstractClass();</span>
            A.prototype =<span style="color: #000000;"> extendDeep(abstractClass.prototype);

            A.prototype.constructor </span>=<span style="color: #000000;"> A;

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果父类存在，则实例对象的baseClass指向父类的原型。</span>
            <span style="color: #008000;">//</span><span style="color: #008000;"> 这就提供了在实例对象中调用父类方法的途径。</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">baseClass的方法是指向abstractClass的，不是指向F（子类）的！</span>
<span style="color: #000000;">
            A.prototype[getNoRepeatStrInPrototype(abstractClass.prototype, </span>"baseClass")] =<span style="color: #000000;"> abstractClass.prototype;
            </span><span style="color: #008000;">//</span><span style="color: #008000;">A.prototype.baseClass = abstractClass.prototype;</span>
<span style="color: #000000;">        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;">加入构造函数</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">抽象类本身因为不能实例化，所以不调用构造函数。</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">抽象类中的构造函数供子类构造函数中调用。</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Init) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (abstractClass) {
                A.prototype.Init </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (name) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">此处不用创建闭包了！因为外面已经创建了闭包，name已经被保存了！</span>
                        <span style="color: #0000ff;">this</span>.base = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                            </span><span style="color: #008000;">//</span><span style="color: #008000;">这个写法也可以！为什么不用apply修正this也行？？！</span>
                            <span style="color: #008000;">//</span><span style="color: #008000;">parentClass.prototype[name](); </span>

                            <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为base方法传入的形参</span>
                            <span style="color: #008000;">//</span><span style="color: #008000;">注意！要加上&ldquo;return&rdquo;，这样才能返回parentClass.prototype[name]的返回值</span>
                            <span style="color: #0000ff;">return</span><span style="color: #000000;"> abstractClass.prototype[name].apply(abstractClass.prototype, arguments);
                        };
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">指向子类，可以用于模版模式</span>
                        <span style="color: #0000ff;">this</span>.baseToSubClass =<span style="color: #000000;"> abstractClass.prototype[name];

                        </span><span style="color: #008000;">//</span><span style="color: #008000;">执行fn并返回执行的结果</span>
                        <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为F.prototype[name]方法传入的形参。</span>
                        <span style="color: #0000ff;">return</span> prop[name].apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
                    };

                }(</span>"Init"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                A.prototype.Init </span>=<span style="color: #000000;"> prop.Init;
            }
        }

        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Private) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">私有属性/方法直接覆盖</span>
            <span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> prop.Private) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Private.hasOwnProperty(name)) {
                    A.prototype[name] </span>=<span style="color: #000000;"> prop.Private[name];
                }
            }
        }

        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Public) {
            </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> prop.Public) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Public.hasOwnProperty(name)) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查抽象成员，抽象成员放到Public或Protected中</span>
                    <span style="color: #0000ff;">if</span> (name === "Abstract"<span style="color: #000000;">) {
                        addAbstract(prop[</span>"Public"<span style="color: #000000;">][name], A, temp);
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查虚方法，虚方法放到Public或Protected中</span>
                    <span style="color: #0000ff;">if</span> (name === "Virtual"<span style="color: #000000;">) {
                        addVirtual(prop[</span>"Public"<span style="color: #000000;">][name], A, temp);
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">密封的方法（不允许子类重写）</span>
                    <span style="color: #0000ff;">if</span> (name === "Sealed"<span style="color: #000000;">) {
                        addSealed(prop[</span>"Public"<span style="color: #000000;">][name], A, temp);
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }

                    </span><span style="color: #0000ff;">if</span> (abstractClass &amp;&amp;
            <span style="color: #0000ff;">typeof</span> prop.Public[name] === "function" &amp;&amp;
            <span style="color: #0000ff;">typeof</span> A.prototype[name] === "function"<span style="color: #000000;">) {
                        A.prototype[name] </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (name) {
                            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                                </span><span style="color: #008000;">//</span><span style="color: #008000;">此处不用创建闭包了！因为外面已经创建了闭包，name已经被保存了！</span>
                                <span style="color: #0000ff;">this</span>.base = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                                    </span><span style="color: #008000;">//</span><span style="color: #008000;">这个写法也可以！为什么不用apply修正this也行？？！</span>
                                    <span style="color: #008000;">//</span><span style="color: #008000;">parentClass.prototype[name](); </span>

                                    <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为base方法传入的形参</span>
                                    <span style="color: #008000;">//</span><span style="color: #008000;">注意！要加上&ldquo;return&rdquo;，这样才能返回parentClass.prototype[name]的返回值</span>
                                    <span style="color: #0000ff;">return</span><span style="color: #000000;"> abstractClass.prototype[name].apply(abstractClass.prototype, arguments);
                                };
                                </span><span style="color: #008000;">//</span><span style="color: #008000;">指向子类，可以用于模版模式</span>
                                <span style="color: #0000ff;">this</span>.baseToSubClass =<span style="color: #000000;"> abstractClass.prototype[name];

                                </span><span style="color: #008000;">//</span><span style="color: #008000;">执行fn并返回执行的结果</span>
                                <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为F.prototype[name]方法传入的形参。</span>
                                <span style="color: #0000ff;">return</span> prop.Public[name].apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
                            };

                        }(name);
                    }
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        A.prototype[name] </span>=<span style="color: #000000;"> prop.Public[name];
                    }



                    temp[name] </span>= prop.Public[name];    <span style="color: #008000;">//</span><span style="color: #008000;">用于检查是否包含父类的抽象方法/属性 或 接口方法/属性</span>
<span style="color: #000000;">                }
            }
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">保护成员</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Protected) {
            </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> prop.Protected) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Protected.hasOwnProperty(name)) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查抽象成员，抽象成员放到Public或Protected中</span>
                    <span style="color: #0000ff;">if</span> (name === "Abstract"<span style="color: #000000;">) {
                        addAbstract(prop[</span>"Protected"<span style="color: #000000;">][name], A, temp);
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查虚方法，虚方法放到Public或Protected中</span>
                    <span style="color: #0000ff;">if</span> (name === "Virtual"<span style="color: #000000;">) {
                        addVirtual(prop[</span>"Protected"<span style="color: #000000;">][name], A, temp);
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">密封的方法（不允许子类重写）</span>
                    <span style="color: #0000ff;">if</span> (name === "Sealed"<span style="color: #000000;">) {
                        addSealed(prop[</span>"Protected"<span style="color: #000000;">][name], A, temp);
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    A.prototype[name] </span>=<span style="color: #000000;"> prop.Protected[name];

                }
            }
        }





        </span><span style="color: #008000;">//</span><span style="color: #008000;">        //虚方法(不能为虚属性)</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        if (prop.Virtual) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            for (name in prop.Virtual) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                if (prop.Virtual.hasOwnProperty(name)) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    if (typeof prop.Virtual[name] !== "function") {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                        throw new Error("Virtual attribute is not allowed!");</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    else {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                        //                        //虚方法前面加"Virtual_"前缀，在子类中要检查虚方法</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                        A.prototype[name] = prop.Virtual[name];</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">                        temp[name] = prop.Virtual[name];    //用于检查是否包含父类的抽象方法/属性 或 接口方法/属性</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        }</span>


        <span style="color: #008000;">//</span><span style="color: #008000;">抽象类可以没有抽象成员</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        if (!prop.Abstract) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            throw new Error("AbstractClass must have abstract methods!");</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        }</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">放到外面的抽象成员，默认为公有抽象成员</span>
        <span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> prop.Abstract) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Abstract.hasOwnProperty(name)) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">                console.log();</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">抽象方法前面加"Abstract_"前缀</span>
                A.prototype["Abstract_" + name] =<span style="color: #000000;"> prop.Abstract[name];

                temp[name] </span>= prop.Abstract[name];   <span style="color: #008000;">//</span><span style="color: #008000;">用于检查是否包含父类的抽象方法/属性 或 接口方法/属性</span>
<span style="color: #000000;">            }
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;">        //检查抽象类的公有方法+虚方法+抽象方法是否包含父类的抽象方法/属性 或 接口方法/属性</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">检查抽象类的公有方法+虚方法+抽象方法是否包含父类的接口方法/属性</span>
        check(<span style="color: #0000ff;">null</span><span style="color: #000000;">, interface, temp);

        </span><span style="color: #008000;">//</span><span style="color: #008000;">静态属性/方法赋值</span>
        <span style="color: #0000ff;">for</span> (k <span style="color: #0000ff;">in</span><span style="color: #000000;"> Static) {
            A[k] </span>=<span style="color: #000000;"> Static[k];
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;">//备份原型</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">A.prototype.backUp_prototype = extendDeep(A.prototype);</span>

        <span style="color: #0000ff;">return</span><span style="color: #000000;"> A;
    }



    </span><span style="color: #008000;">//</span><span style="color: #008000;">    //是否调用父类函数</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">    var base_flag = false;</span>

    <span style="color: #008000;">//</span><span style="color: #008000;">创建普通类</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">父类_parent可以为{Class: xx, Interface: xx}，或者直接为xx类</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> MyClass(_parent, _prop) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">        console.log("length = " + arguments.length);</span>
        <span style="color: #0000ff;">var</span> Static = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">                    Private = null,</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            Public = null,</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            Origin = null;</span>

        <span style="color: #0000ff;">var</span> k = <span style="color: #0000ff;">null</span>, name = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        </span><span style="color: #0000ff;">var</span> parentClass = <span style="color: #0000ff;">null</span>, interface = <span style="color: #0000ff;">null</span>, prop = <span style="color: #0000ff;">null</span>, temp =<span style="color: #000000;"> {};
        </span><span style="color: #008000;">//</span><span style="color: #008000;">        var temp = null;</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">        //原型备份容器，用于创建实例时，恢复最初的原型（每次创建实例时，原型都保持不变）。</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        var backUp_prototype = {};</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">原型恢复标志，用于防止第一次创建实例时恢复原型</span>
        <span style="color: #0000ff;">var</span> mark_resume = <span style="color: #0000ff;">false</span><span style="color: #000000;">;


        </span><span style="color: #008000;">//</span><span style="color: #008000;">取出父类、接口</span>
        <span style="color: #0000ff;">if</span> (arguments.length === 1<span style="color: #000000;">) {
            prop </span>= arguments[0<span style="color: #000000;">];
            parentClass </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">{Class: xx, Interface: xx}</span>
        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "object"<span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">            if (parent.Class)</span>
            <span style="color: #0000ff;">if</span> (!_parent.Class &amp;&amp; !<span style="color: #000000;">_parent.Interface) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Please add Class or Interface!"<span style="color: #000000;">);
            }

            parentClass </span>=<span style="color: #000000;"> _parent.Class;
            interface </span>=<span style="color: #000000;"> _parent.Interface;

            prop </span>=<span style="color: #000000;"> _prop;
        }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">直接为xx类</span>
        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "function"<span style="color: #000000;">) {
            parentClass </span>=<span style="color: #000000;"> _parent;
            interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #008000;">//</span><span style="color: #008000;">            parent = _parent;</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            interface = null;</span>
<span style="color: #000000;">
            prop </span>=<span style="color: #000000;"> _prop;
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("arguments is not allowed!"<span style="color: #000000;">);
        }



        </span><span style="color: #008000;">//</span><span style="color: #008000;">取出静态属性/方法、私有属性/方法、公有属性/方法</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        Private = prop.Private;</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">        Public = prop.Public;</span>
<span style="color: #000000;">
        Static </span>= prop.Static ? prop.Static : <span style="color: #0000ff;">null</span><span style="color: #000000;">;



        </span><span style="color: #008000;">//</span><span style="color: #008000;">        //保存原始的私有属性，用于创建实例时，重置私有属性</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        //        var Origin = {};</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        //        Origin = Private</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        Origin = operate.extendDeep(Private);</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        YYC.Tool.extend.extend(Origin, Private);</span>


        <span style="color: #008000;">//</span><span style="color: #008000;">        //访问公共属性/方法的入口，</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        MyClass.Public = Public;</span>


        <span style="color: #008000;">//</span><span style="color: #008000;"> 本次调用所创建的类（构造函数）</span>
        <span style="color: #0000ff;">function</span><span style="color: #000000;"> F() {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">            console.log(mark_resume);</span>



            <span style="color: #008000;">//</span><span style="color: #008000;">防止第一次创建实例时恢复原型</span>
            <span style="color: #0000ff;">if</span><span style="color: #000000;"> (mark_resume) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">var t = F.prototype.backUp_prototype;</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">var m = F.prototype;</span>

                <span style="color: #008000;">//</span><span style="color: #008000;">还原原型</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">extendDeep(F.prototype.backUp_prototype, F.prototype);</span>
<span style="color: #000000;">                extendDeep(F.backUp_prototype, F.prototype);


                </span><span style="color: #008000;">//</span><span style="color: #008000;">F.prototype.backUp_prototype = extendDeep(F.prototype);</span>
<span style="color: #000000;">            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                mark_resume </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果当前处于实例化类的阶段，则调用Init原型函数</span>
            <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">initializing) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">                console.log("F");</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                // 如果父类存在，则实例对象的baseClass指向父类的原型</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                // 这就提供了在实例对象中调用父类方法的途径</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                if (parentClass) {</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                    this.baseClass = parentClass.prototype;</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                    //                    console.log(this.baseClass);</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                }</span>
                <span style="color: #0000ff;">this</span>.Init &amp;&amp; <span style="color: #0000ff;">this</span>.Init.apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
            }

            </span><span style="color: #008000;">//</span><span style="color: #008000;">            this.Public = Public;</span>

            <span style="color: #008000;">//</span><span style="color: #008000;">            console.log("F");</span>


            <span style="color: #008000;">//</span><span style="color: #008000;">            if (this.)</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            console.log(this._m);</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            delete this._m;</span>

            <span style="color: #008000;">//</span><span style="color: #008000;">            delete F.prototype._m;</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            delete F.prototype._a;</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            this._m = null;</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            this._a = null;</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            delete F.prototype._a;</span>



            <span style="color: #008000;">/*</span><span style="color: #008000;">不能删除私有成员和保护成员！否则类的成员就不能调用到私有和保护的成员了（因为已经删除了）！
            对象的创建算法参考http://www.cnblogs.com/TomXu/archive/2012/02/06/2330609.html




            //删除私有成员和保护成员，这样外界就不能访问私有和保护成员了！
            for (name in this) {
            if (name.search(/(^_)|(^P_)/) !== -1) {
            delete F.prototype[name];
            //                                                    this[name] = null;
            }
              
            }
            </span><span style="color: #008000;">*/</span>



            <span style="color: #008000;">//</span><span style="color: #008000;">            console.log(count);</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            count++;</span>

            <span style="color: #008000;">//</span><span style="color: #008000;">不使用MyClass.self！因为该属性为静态属性，如果创建了该类后，又创建了类A，则MyClass.self会指向类A！</span>

            <span style="color: #008000;">//</span><span style="color: #008000;">            MyClass的静态属性self指向创建的类的实例，可以通过self来访问实例的属性和方法</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            MyClass.self = this;</span>





            <span style="color: #008000;">//</span><span style="color: #008000;">            Private.C();</span>

            <span style="color: #008000;">//</span><span style="color: #008000;">            for (name in Private) {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                Private[name].call(this);</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            }</span>
<span style="color: #000000;">



        }




        </span><span style="color: #008000;">//</span><span style="color: #008000;">        Private.C = Private.C.call(null, Public);</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">        Private.call(F, null);</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">                Private.M = (function (pub) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    return function () {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                        Private.M.call(null, arguments);</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                }(Public));</span>


        <span style="color: #008000;">//</span><span style="color: #008000;">        for (name in Private) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            Private[name] = function () {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                //            console.log("1111111");</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                return function () {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    //                console.log("222222222");</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    return Private[name].call(this, arguments);</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                }</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">            };</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        }</span>



        <span style="color: #008000;">//</span><span style="color: #008000;">        Private.C = function () {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            return function () {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                Private.C.call(F, arguments);</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        };</span>


        <span style="color: #008000;">//</span><span style="color: #008000;"> 如果此类需要从其它类扩展</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass) {

            initializing </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #008000;">//</span><span style="color: #008000;">F.prototype = new parentClass();</span>
            F.prototype =<span style="color: #000000;"> extendDeep(parentClass.prototype);


            F.prototype.constructor </span>=<span style="color: #000000;"> F;

            </span><span style="color: #008000;">//</span><span style="color: #008000;">            for (name in parentClass.prototype) {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                if (parentClass.prototype.hasOwnProperty(name)) {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                    //私有成员不继承</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                    if (!name.match(/^_/)) {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                        F.prototype[name] = parentClass.prototype[name];</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                    }</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                }</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            }</span>

            <span style="color: #008000;">//</span><span style="color: #008000;">            //删除父类的私有成员，保留本类的私有成员</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            for (name in parentClass.prototype) {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                if (parentClass.prototype.hasOwnProperty(name)) {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                    //私有成员以&ldquo;_&rdquo;开头，可能有多个&ldquo;_&rdquo;（多层继承）</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                    if (!name.match(/^_+/)) {</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                        //                                                delete parentClass.prototype[name];</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                        F.prototype[name] = parentClass.prototype[name];</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                    }</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">                }</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">            }</span>

            <span style="color: #008000;">//</span><span style="color: #008000;">            console.log(F.prototype.constructor);</span>


            <span style="color: #008000;">//</span><span style="color: #008000;"> 如果父类存在，则实例对象的baseClass指向父类的原型。</span>
            <span style="color: #008000;">//</span><span style="color: #008000;"> 这就提供了在实例对象中调用父类方法的途径。</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">baseClass的方法是指向parentClass的，不是指向F（子类）的！</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">F.prototype.baseClass = parentClass.prototype;</span>
<span style="color: #000000;">

            F.prototype[getNoRepeatStrInPrototype(parentClass.prototype, </span>"baseClass")] =<span style="color: #000000;"> parentClass.prototype;

            initializing </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }

        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Init) {



            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此类继承自父类parent并且父类原型中存在同名函数name</span>
            <span style="color: #0000ff;">if</span> (parentClass &amp;&amp;
    <span style="color: #0000ff;">typeof</span> prop.Init === "function" &amp;&amp;
    <span style="color: #0000ff;">typeof</span> F.prototype.Init === "function"<span style="color: #000000;">) {
                F.prototype.Init </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (name) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.base = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> parentClass.prototype[name].apply(parentClass.prototype, arguments);
                        };
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">指向子类，可以用于模版模式</span>
                        <span style="color: #0000ff;">this</span>.baseToSubClass =<span style="color: #000000;"> parentClass.prototype[name];
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">执行fn并返回执行的结果</span>
                        <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为F.prototype[name]方法传入的形参。</span>
                        <span style="color: #0000ff;">return</span> prop[name].apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
                    };

                }(</span>"Init"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                F.prototype.Init </span>=<span style="color: #000000;"> prop.Init;
            }
        }


        </span><span style="color: #008000;">//</span><span style="color: #008000;">        Private.call(this);</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">        if (parentClass &amp;&amp; parentClass.prototype["JudgeDoubleHit"]) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            console.log(parentClass.toString());</span>


        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass) {
            </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> parentClass.prototype) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass.prototype.hasOwnProperty(name)) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">如果不是抽象方法/保护方法/私有方法/接口成员，则加入到temp中。</span>
                    <span style="color: #008000;">//</span><span style="color: #008000;">用于添加父类的密封方法（因为子类并没有加入父类的密封方法）。</span>
                    <span style="color: #0000ff;">if</span> (!name.match(/^Abstract_/) || !name.match(/^P_/) || !name.match(/^_/) || !name.match(/^Interface_/<span style="color: #000000;">)) {
                        temp[name] </span>=<span style="color: #000000;"> parentClass.prototype[name];
                    }
                }
            }
        }





        </span><span style="color: #008000;">//</span><span style="color: #008000;">        }</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">        if (this.baseClass.Protected) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            if (this.baseClass.Protected.Sealed) {</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">                for (k in this.baseClass.Protected.Sealed) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    temp[k] = this.baseClass.Protected.Sealed[k];</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        }</span>


        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Private) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">私有属性/方法直接覆盖</span>
            <span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> prop.Private) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Private.hasOwnProperty(name)) {
                    F.prototype[name] </span>=<span style="color: #000000;"> prop.Private[name];
                }
            }
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;">        if (!prop.Public) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            throw new Error("Class must have public methods!");</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        else {</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">        }</span>


        <span style="color: #008000;">//</span><span style="color: #008000;">保护成员</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Protected) {
            </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> prop.Protected) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Protected.hasOwnProperty(name)) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查虚方法，虚方法放到Public或Protected中</span>
                    <span style="color: #0000ff;">if</span> (name === "Virtual"<span style="color: #000000;">) {
                        addVirtual(prop[</span>"Protected"<span style="color: #000000;">][name], F, temp);
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">密封的方法（不允许子类重写）</span>
                    <span style="color: #0000ff;">if</span> (name === "Sealed"<span style="color: #000000;">) {
                        addSealed(prop[</span>"Protected"<span style="color: #000000;">][name], F, temp);
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }

                    F.prototype[name] </span>=<span style="color: #000000;"> prop.Protected[name];

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">如果父类有保护抽象成员，此处检查子类的保护成员是否实现了父类的保护抽象成员</span>
                    temp[name] =<span style="color: #000000;"> prop.Protected[name];
                }
            }
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;">        //虚方法(不能为虚属性)</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        if (prop.Virtual) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            for (name in prop.Virtual) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                if (prop.Virtual.hasOwnProperty(name)) {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    if (typeof prop.Virtual[name] !== "function") {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                        throw new Error("Virtual attribute is not allowed!");</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    else {</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                        F.prototype[name] = prop.Virtual[name];</span>

        <span style="color: #008000;">//</span><span style="color: #008000;">                        temp[name] = prop.Virtual[name];    //加入temp</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                    }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">                }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">            }</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">        }</span>

        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Abstract) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Only abstractClass can have abstract methods!"<span style="color: #000000;">);
        }



        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Public) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 覆盖父类的同名公有方法</span>
            <span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> prop.Public) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">            console.log("for in name = " + name);</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">            //私有属性/方法不加入到原型中</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">            if (name === "Private") {</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">//                console.log("continue");</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">                continue;</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">            }</span>

                <span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Public.hasOwnProperty(name)) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查虚方法，虚方法放到Public或Protected中</span>
                    <span style="color: #0000ff;">if</span> (name === "Virtual"<span style="color: #000000;">) {
                        addVirtual(prop[</span>"Public"<span style="color: #000000;">][name], F, temp);
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">密封的方法（不允许子类重写）</span>
                    <span style="color: #0000ff;">if</span> (name === "Sealed"<span style="color: #000000;">) {
                        addSealed(prop[</span>"Public"<span style="color: #000000;">][name], F, temp);
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">                    console.log("Public");</span>
                    <span style="color: #008000;">//</span><span style="color: #008000;">                    console.log("name = " + name);</span>
                    <span style="color: #008000;">//</span><span style="color: #008000;">                    console.log("prop.Public[name] = " + prop.Public[name]);</span>
                    temp[name] = prop.Public[name];     <span style="color: #008000;">//</span><span style="color: #008000;">加入temp</span>

                    <span style="color: #008000;">//</span><span style="color: #008000;"> 如果此类继承自父类parent并且父类原型中存在同名函数name</span>
                    <span style="color: #0000ff;">if</span> (parentClass &amp;&amp;
            <span style="color: #0000ff;">typeof</span> prop.Public[name] === "function" &amp;&amp;
            <span style="color: #0000ff;">typeof</span> F.prototype[name] === "function"<span style="color: #000000;">) {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">                        console.log("parent!");</span>
<span style="color: #000000;">



                        F.prototype[name] </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (name) {
                            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                                </span><span style="color: #008000;">/*</span><span style="color: #008000;">此处如果写成&ldquo;this.base = parentClass.prototype[name];&rdquo;，则在使用this.base()调用父类同名方法时，
                                父类同名方法的this指针是指向F的！（即指向子类，而不是指向父类！）   为什么？？？？
                                如：
                                var Person = MyAbstract({
                                Init: function (name) {
                                this.name = name;
                                },
                                Public: {
                                m: 1,
                                getEmployeeID: function () {
                                console.log(this.m);
                                }
                                }
                                }
                                });


                                var Employee = MyClass({
                                Init: function (name) {
                                this.name = name;
                                },
                                Public: {
                                m: 100,
                                getEmployeeID: function () {
                                this.baseClass.getEmployeeID();
                                this.base();
                                }
                                }
                                });

                                var m = new Employee();
                                m.getEmployeeID();    //输出：1  100

                                分析：
                            
                                this.baseClass.getEmployeeID()的this指向Person，而this.base()的this指向Employee！

                                解决方案：

                                用apply修正this.base()中的this，使其指向父类。
                                </span><span style="color: #008000;">*/</span>


                                <span style="color: #008000;">//</span><span style="color: #008000;">                                if (!this.base) {</span>
                                <span style="color: #008000;">//</span><span style="color: #008000;">此处不用创建闭包了！因为外面已经创建了闭包，name已经被保存了！</span>
                                <span style="color: #0000ff;">this</span>.base = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                                    </span><span style="color: #008000;">//</span><span style="color: #008000;">这个写法也可以！为什么不用apply修正this也行？？！</span>
                                    <span style="color: #008000;">//</span><span style="color: #008000;">parentClass.prototype[name](); </span>

                                    <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为base方法传入的形参</span>
                                    <span style="color: #008000;">//</span><span style="color: #008000;">注意！要加上&ldquo;return&rdquo;，这样才能返回parentClass.prototype[name]的返回值</span>
                                    <span style="color: #0000ff;">return</span><span style="color: #000000;"> parentClass.prototype[name].apply(parentClass.prototype, arguments);

                                    </span><span style="color: #008000;">//</span><span style="color: #008000;">                                    this.baseClass.</span>
<span style="color: #000000;">                                };
                                </span><span style="color: #008000;">//</span><span style="color: #008000;">                                }</span>
                                <span style="color: #008000;">//</span><span style="color: #008000;">                                if (!this.baseToSubClass) {</span>
                                <span style="color: #008000;">//</span><span style="color: #008000;">指向子类，可以用于模版模式</span>
                                <span style="color: #0000ff;">this</span>.baseToSubClass =<span style="color: #000000;"> parentClass.prototype[name];
                                </span><span style="color: #008000;">//</span><span style="color: #008000;">                                }</span>

                                <span style="color: #008000;">//</span><span style="color: #008000;">                                this.base = function () {</span>
                                <span style="color: #008000;">//</span><span style="color: #008000;">                                    //                                    console.log(base_flag);</span>

                                <span style="color: #008000;">//</span><span style="color: #008000;">                                    Private = {</span>
                                <span style="color: #008000;">//</span><span style="color: #008000;">                                    };</span>
                                <span style="color: #008000;">//</span><span style="color: #008000;">//                                    base_flag = true;</span>
                                <span style="color: #008000;">//</span><span style="color: #008000;">                                    return parent.prototype[name];</span>
                                <span style="color: #008000;">//</span><span style="color: #008000;">                                };</span>
                                <span style="color: #008000;">//</span><span style="color: #008000;">                            console.log("arg = " + arg);</span>

                                <span style="color: #008000;">//</span><span style="color: #008000;">执行fn并返回执行的结果</span>
                                <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为F.prototype[name]方法传入的形参。</span>
                                <span style="color: #0000ff;">return</span> prop.Public[name].apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
                            };

                        }(name);

                    }
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">                    console.log();</span>
                        <span style="color: #008000;">//</span><span style="color: #008000;">公有属性</span>
                        <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> (prop.Public[name]) !== "function"<span style="color: #000000;">) {
                            F.prototype[name] </span>=<span style="color: #000000;"> prop.Public[name];
                        }
                            </span><span style="color: #008000;">//</span><span style="color: #008000;">公有方法</span>
                        <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            </span><span style="color: #008000;">/*</span><span style="color: #008000;"> 如果不传入Public[name]，而直接在自执行函数中调用Public[name]，如
                            F.prototype[name] = function () {
                            return function () {
                            prop.Public[name].apply(this, arguments);
                            };
                            } ();

                            或者写成：
                            F.prototype[name] = function () {
                            prop.Public[name].call(this, arguments);
                            };
                        
                        
                            这样的话，在创建实例时调用方法时，都会执行MyClass中的最后一个函数！见下例
                        
                            var Person = MyClass({
                            Init: function (name) {
                            this.name = name;
                            },
                            getName: function () {
                            console.log("getName");
                            },
                            getEmployeeID: function ($private) {
                            console.log("Person getEmployeeID");
                            }
                            });
                            var m = new Person("name");     
                            m.getName();    //第一种和第二种写法此处会输出："Person getEmployeeID"
                

                            这样执行的原因是：

                            （引用自&ldquo;深入理解JavaScript系列（16）：闭包（Closures）&rdquo;）
                            同一个父上下文中创建的闭包是共用一个[[Scope]]属性的。也就是说，
                            某个闭包对其中[[Scope]]的变量做修改会影响到其他闭包对其变量的读取。
                            这就是说：所有的内部函数都共享同一个父作用域。

                            也就是说，function里面的name都是共用父作用域中的name！所以此处F.prototype[name]被激活的时候，
                            name都为最后一个值即"getEmployeeID"。
                            所以F原型上的方法都指向"getEmployeeID"

                            解决方案：

                            创建一个闭包来保存name的值。
                            </span><span style="color: #008000;">*/</span><span style="color: #000000;">
                            F.prototype[name] </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (name) {
                                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                                    </span><span style="color: #0000ff;">return</span> prop.Public[name].apply(<span style="color: #0000ff;">this</span>, arguments);     <span style="color: #008000;">//</span><span style="color: #008000;">执行fn并返回执行的结果</span>
<span style="color: #000000;">                                };
                            }(name);

                        }
                    }
                }
            }
        }




        </span><span style="color: #008000;">//</span><span style="color: #008000;">检查公有成员和虚函数是否实现了抽象方法/属性 或 接口方法/属性</span>
<span style="color: #000000;">        check(parentClass, interface, temp);


        </span><span style="color: #008000;">//</span><span style="color: #008000;">静态属性/方法赋值</span>
        <span style="color: #0000ff;">for</span> (k <span style="color: #0000ff;">in</span><span style="color: #000000;"> Static) {
            F[k] </span>=<span style="color: #000000;"> Static[k];
        }



        </span><span style="color: #008000;">//</span><span style="color: #008000;">备份原型</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">F.prototype.backUp_prototype = extendDeep(F.prototype);</span>
        F.backUp_prototype =<span style="color: #000000;"> extendDeep(F.prototype);


        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> F;
    };

    YYC.Pattern.namespace(</span>"Frame").MyInterface =<span style="color: #000000;"> MyInterface;

    YYC.Pattern.namespace(</span>"Frame").MyAbstract =<span style="color: #000000;"> MyAbstract;

    YYC.Pattern.namespace(</span>"Frame").MyClass =<span style="color: #000000;"> MyClass;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>代码分析</h1>
<p>我并不打算对代码详细说明，因为该文的重点在于展示重构的过程。因此我介绍下原始版本实现OOP的核心内容，具体请参考代码。</p>
<p>MyInterface为接口，MyAbstract为抽象类，MyClass为类。</p>
<p>创建一个接口，可以这样写：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A = YYC.Frame.MyInterface("method1", "method2");</pre>
</div>
<p>调用&ldquo;YYC.Frame.MyInterface&rdquo;时，会调用MyInterface函数，该函数会把参数解析，把方法和属性加上前缀&ldquo;Interface_&rdquo;，加入到内部函数I.prototype中，然后返回内部函数I。</p>
<p>因此，A就具有了接口方法和接口属性，但是我们不会直接使用接口（如创建A的实例，访问接口方法），因为接口的方法和属性（统称为成员）并没有实现，需要在继承接口的类中实现。</p>
<p>然后创建一个抽象类：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('2a4acf03-346b-4edc-9e0e-ef102ebba09d')"><img id="code_img_closed_2a4acf03-346b-4edc-9e0e-ef102ebba09d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_2a4acf03-346b-4edc-9e0e-ef102ebba09d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2a4acf03-346b-4edc-9e0e-ef102ebba09d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_2a4acf03-346b-4edc-9e0e-ef102ebba09d" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Frame.MyAbstract({
    Protected: {    </span><span style="color: #008000;">//</span><span style="color: #008000;">保护成员</span>
        Abstract: { <span style="color: #008000;">//</span><span style="color: #008000;">保护抽象成员</span>
<span style="color: #000000;">        },
        Virtual: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">保护虚方法</span>
<span style="color: #000000;">        },
        P_proA: </span><span style="color: #0000ff;">true</span>,   <span style="color: #008000;">//</span><span style="color: #008000;">保护属性</span>
        P_proM: <span style="color: #0000ff;">function</span> () { }    <span style="color: #008000;">//</span><span style="color: #008000;">保护方法</span>
<span style="color: #000000;">    },
    Public: {   </span><span style="color: #008000;">//</span><span style="color: #008000;">公有成员</span>
        Abstract: { <span style="color: #008000;">//</span><span style="color: #008000;">公有抽象成员</span>
<span style="color: #000000;">        },
        Virtual: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">公有虚方法</span>
<span style="color: #000000;">        },
        pubM: </span><span style="color: #0000ff;">function</span> () { },  <span style="color: #008000;">//</span><span style="color: #008000;">公有方法</span>
        pubA: 0    <span style="color: #008000;">//</span><span style="color: #008000;">公有属性</span>
<span style="color: #000000;">    },
    Private: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">私有成员</span>
        _priA: "",   <span style="color: #008000;">//</span><span style="color: #008000;">私有属性</span>
        _priM: <span style="color: #0000ff;">function</span> () { } <span style="color: #008000;">//</span><span style="color: #008000;">私有方法</span>
<span style="color: #000000;">    },
    Abstract: { </span><span style="color: #008000;">//</span><span style="color: #008000;">公有抽象成员</span>
<span style="color: #000000;">    },
    Virtual: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">公有虚方法</span>
<span style="color: #000000;">    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<p>调用&ldquo;YYC.Frame.MyAbstract&rdquo;时，会调用MyAbstract函数，该函数会把参数解析，将公有成员、私有成员、保护成员都加入到内部函数A.prototype中（约定私有成员、保护成员的命名规则，约定使用框架者遵守访问权限）。</p>
<p>抽象成员（Abstract:{}中的成员）先加上前缀&ldquo;Abstract_&rdquo;，然后加入到A.prototype中（子类根据前缀来区分判断是否实现了父类的抽象成员）。</p>
<p>然后创建一个类，继承接口A和抽象类B：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('efae46ee-c9e3-4708-b99f-999c41491786')"><img id="code_img_closed_efae46ee-c9e3-4708-b99f-999c41491786" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_efae46ee-c9e3-4708-b99f-999c41491786" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('efae46ee-c9e3-4708-b99f-999c41491786',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_efae46ee-c9e3-4708-b99f-999c41491786" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.Frame.MyClass({Interface: A, Class: B},{
    Init: </span><span style="color: #0000ff;">function</span> () { <span style="color: #008000;">//</span><span style="color: #008000;">构造函数</span>
<span style="color: #000000;">    },
    Protected: {    </span><span style="color: #008000;">//</span><span style="color: #008000;">保护成员</span>
<span style="color: #000000;">    },
    Public: {   
        Virtual: { 
        },
        method1: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }, 
        method2: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
    },
    Private: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">私有成员</span>
        _priA: "",   <span style="color: #008000;">//</span><span style="color: #008000;">私有属性</span>
        _priM: <span style="color: #0000ff;">function</span> () { } <span style="color: #008000;">//</span><span style="color: #008000;">私有方法</span>
<span style="color: #000000;">    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<p>调用&ldquo;YYC.Frame.MyClass&rdquo;时，会调用MyClass函数，该函数会把参数解析，将公有成员、私有成员、保护成员都加入到内部函数F.prototype中。</p>
<p>构造函数Init在F的构造函数function F(){}中调用，从而在创建C的实例时，会调用构造函数Init。</p>
<p>此处继承了接口A和抽象类B，因此会先用<span style="color: #ff0000;">深拷贝</span>的方法来将A、B的成员加入到F.prototype中，然后判断是否实现A的接口成员（根据&ldquo;Interface_&rdquo;前缀来判断）、是否实现B的抽象成员（根据&ldquo;Abstract_&rdquo;前缀来判断），如果没有实现会抛出异常。</p>
<h1>为什么要用深拷贝来实现继承</h1>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">F.prototype = new <span style="background-color: #f5f5f5; font-family: Courier New;">parentClass</span>();</span>
F.prototype =<span style="color: #000000;"> extendDeep(<span style="background-color: #f5f5f5; font-family: Courier New;">parentClass</span>.prototype);
</span></pre>
</div>
<p>此处继承使用深拷贝来实现，原因是为了解决下面的问题：</p>
<ul>
<li>若父类Parent的属性为引用类型（数组或对象）a，有两个子类Sub1、Sub2。如果子类Sub1的实例s1对a进行修改或者sub调用修改a的方法，则子类Sub2的实例的a为修改过后的a！</li>
</ul>
<h2>问题描述<br /><br /></h2>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> Parent =<span style="color: #000000;"> YYC.Frame.MyClass({
    Private:{
        _a: []
    },
    Public: {
        add: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">this</span>._a.push("a"<span style="color: #000000;">);
        }
    }
});
</span><span style="color: #0000ff;">var</span> Sub1 =<span style="color: #000000;"> YYC.Frame.MyClass(Parent, {});
</span><span style="color: #0000ff;">var</span> Sub2 =<span style="color: #000000;"> YYC.Frame.MyClass(Parent, {});

</span><span style="color: #0000ff;">var</span> t = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Sub1();
t.add();
console.log(t.a);        </span><span style="color: #008000;">//</span><span style="color: #008000;">["a"]</span>
<span style="color: #0000ff;">var</span> k = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Sub2();
console.log(k.a);    </span><span style="color: #008000;">//</span><span style="color: #008000;">照理说应该为[]，但实际上却是["a"]！</span></pre>
</div>
<h2>原因分析</h2>
<p>上例中的&ldquo;t.add();&rdquo;修改的是实例t的_a属性，实例t的_a属性与Parent.prototype._a指向同一个数组。因此修改实例t的_a就相当于修改了Parent.prototype._a。</p>
<h2>解决方案</h2>
<p>修改类继承方式，改为通过深拷贝的方式拷贝父类原型的成员来实现继承：</p>
<div class="cnblogs_code">
<pre>F.prototype = extendDeep(parentClass.prototype);</pre>
</div>
<p>这样实例t的_a属性和Parent.protype._a就指向不同的数组了。</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">为什么要重构</span></strong></span></strong></p>
<p>原始版本对其它的库有依赖（如依赖于namespace.js），有太多没用或错误的注释，混在一起的职责，过于庞大的函数，函数名、属性名不能很好地体现职责，多层嵌套的条件式等等。另外，最大的问题是没有对应的测试套件。</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">开始重构</span></strong></span></strong></p>
<h1><span style="color: #000000;">编写测试</span></h1>
<p><span style="color: #000000;">回到本次重构中来，要进行重构，首先需要坚固的测试作保证。我使用<a href="http://www.36ria.com/4457">Jasmine</a>作为Javascript的测试工具。建议大家先可以看下<a href="http://www.cnblogs.com/frostbelt/archive/2012/08/03/2622302.html">javascript单元测试</a>，里面介绍了单元测试的工具，包括Jasmine。</span></p>
<p><span style="color: #000000;">先编写几个主要的测试，测试是否解决了我之前发现的几个问题。</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('198e63af-668a-4418-bfeb-d38a0c122fd4')"><img id="code_img_closed_198e63af-668a-4418-bfeb-d38a0c122fd4" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_198e63af-668a-4418-bfeb-d38a0c122fd4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('198e63af-668a-4418-bfeb-d38a0c122fd4',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_198e63af-668a-4418-bfeb-d38a0c122fd4" class="cnblogs_code_hide">
<pre>describe("oopFrame", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    describe(</span>"测试Class", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        describe(</span>"获得公有成员", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            it(</span>"如果父类不存在，能够正确获得公有方法", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> Class =<span style="color: #000000;"> YYC.Frame.MyClass({
                    Public: {
                        a: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                            </span><span style="color: #0000ff;">this</span>.b = 1<span style="color: #000000;">;
                            </span><span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
                        }
                    }
                });

                </span><span style="color: #0000ff;">var</span> cla = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Class();
                </span><span style="color: #0000ff;">var</span> result =<span style="color: #000000;"> cla.a();

                expect(result).toEqual(</span>0<span style="color: #000000;">);
                expect(cla.b).toEqual(</span>1<span style="color: #000000;">);
            });
        });
    });

    describe(</span>"集成测试", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        it(</span>"测试解决&ldquo;若父类的属性为引用类型（数组或对象）a，则如果子类的实例s1对a进行修改或者sub调用修改a的方法，则第二次创建实例s2的a为修改过后的a！&rdquo;的问题", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> Parent =<span style="color: #000000;"> YYC.Frame.MyAbstract({
                Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    console.log(</span>"Parent Init!"<span style="color: #000000;">);
                },
                Public: {
                    a: [],
                }
            });
            </span><span style="color: #0000ff;">var</span> Sub =<span style="color: #000000;"> YYC.Frame.MyClass(Parent, {
                Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                },
                Public: {
                }
            });

            </span><span style="color: #0000ff;">var</span> t = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Sub();
            t.a.push(</span>"a"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">var</span> m = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Sub();

            expect(m.a).toEqual([]);
        });
        it(</span>"测试解决&ldquo;若父类Parent的属性为引用类型（数组或对象）a，有两个子类Sub1、Sub2。如果子类Sub1的实例s1对a进行修改或者sub调用修改a的方法，则子类Sub2的实例的a为修改过后的a！&rdquo;的问题", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> Parent =<span style="color: #000000;"> YYC.Frame.MyAbstract({
                Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    console.log(</span>"Parent Init!"<span style="color: #000000;">);
                },
                Public: {
                    a: [],
                    add: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.a.push("a"<span style="color: #000000;">);
                    }
                }
            });
            </span><span style="color: #0000ff;">var</span> Sub1 =<span style="color: #000000;"> YYC.Frame.MyClass(Parent, {
                Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                },
                Public: {
                }
            });
            </span><span style="color: #0000ff;">var</span> Sub2 =<span style="color: #000000;"> YYC.Frame.MyClass(Parent, {
                Init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                }
            });

            </span><span style="color: #0000ff;">var</span> t = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Sub1();
            t.a.push(</span>"a"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">var</span> k = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Sub2();

            expect(k.a).toEqual([]);

        });
        it(</span>"测试解决&ldquo;若A1为抽象类，A2（抽象类）继承于A1，B（类）继承于A2，A1、A2、B都有同名方法a，A2和B在a方法中都通过this.baseClass调用父类同名方法。则如果B的实例b调用a方法，则A2、B的a方法中的this.baseClass均指向A2（照理说A2的this.baseClass应该指向A1）！&rdquo;的问题", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> A1 =<span style="color: #000000;"> YYC.Frame.MyAbstract({
                Public: {
                    arr: [],
                    a: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.arr.push(1<span style="color: #000000;">);
                    }
                }
            });
            </span><span style="color: #0000ff;">var</span> A2 =<span style="color: #000000;"> YYC.Frame.MyAbstract(A1, {
                Public: {
                    a: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.arr.push(2<span style="color: #000000;">);
                        </span><span style="color: #0000ff;">this</span>.baseClass.a.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
                    }
                }
            });
            </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Frame.MyClass(A2, {
                Public: {
                    a: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.arr.push(3<span style="color: #000000;">);
                        </span><span style="color: #0000ff;">this</span>._baseClass.a.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span><span style="color: #000000;">);

                        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.arr;
                    }
                }
            });
            </span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();

            expect(b.a()).toEqual([</span>3, 2, 1<span style="color: #000000;">]);
        });
    });
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<p>现在测试的覆盖面还不全，有些代码没有测试到。不过我们已经构建了主要的测试，剩下的测试可以在后续的重构中逐渐加入。</p>
<h2>测试页面</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('29ada139-9d71-4de4-be4c-854c90899ee0')"><img id="code_img_closed_29ada139-9d71-4de4-be4c-854c90899ee0" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_29ada139-9d71-4de4-be4c-854c90899ee0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('29ada139-9d71-4de4-be4c-854c90899ee0',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_29ada139-9d71-4de4-be4c-854c90899ee0" class="cnblogs_code_hide">
<pre><span style="background-color: #ffff00; color: #000000;">&lt;%</span><span style="background-color: #f5f5f5; color: #000000;">@ Page Language</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #800000;">"</span><span style="background-color: #f5f5f5; color: #800000;">C#</span><span style="background-color: #f5f5f5; color: #800000;">"</span><span style="background-color: #f5f5f5; color: #000000;"> Inherits</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #800000;">"</span><span style="background-color: #f5f5f5; color: #800000;">System.Web.Mvc.ViewPage&lt;dynamic&gt;</span><span style="background-color: #f5f5f5; color: #800000;">"</span> <span style="background-color: #ffff00; color: #000000;">%&gt;</span>
<span style="color: #0000ff;">&lt;!</span><span style="color: #ff00ff;">DOCTYPE HTML</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">html</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">head </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="Head1"</span><span style="color: #ff0000;"> runat</span><span style="color: #0000ff;">="server"</span><span style="color: #0000ff;">&gt;</span>
   <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>Jasmine Spec Runner<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">link </span><span style="color: #ff0000;">rel</span><span style="color: #0000ff;">="stylesheet"</span><span style="color: #ff0000;"> type</span><span style="color: #0000ff;">="text/css"</span><span style="color: #ff0000;"> href</span><span style="color: #0000ff;">="&lt;%=Url.Content("</span><span style="color: #ff0000;">~/Scripts/jasmine/lib/jasmine-1.3.1/jasmine.css") %</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">" /&gt;
        </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">script </span><span style="color: #ff0000;">src</span><span style="color: #0000ff;">="&lt;%=Url.Content("</span><span style="color: #ff0000;">~/Scripts/jasmine/lib/jasmine-1.3.1/jasmine.js") %</span><span style="color: #0000ff;">&gt;</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">&gt;&lt;/script&gt;
    &lt;script src=</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">&lt;%=</span><span style="background-color: #f5f5f5; color: #000000;">Url.Content(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">~/Scripts/jasmine/lib/jasmine-1.3.1/jasmine-html.js</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">) </span><span style="background-color: #f5f5f5; color: #000000;">%&gt;</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">&gt;&lt;/script&gt;
  &lt;!-- include source files here... --&gt;
    &lt;script src=</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">&lt;%=</span><span style="background-color: #f5f5f5; color: #000000;">Url.Content(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">~/Scripts/jquery-1.7.js</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">)</span><span style="background-color: #f5f5f5; color: #000000;">%&gt;</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">&gt;&lt;/script&gt;
    &lt;script src=</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">..</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">..</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">Scripts</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">myTool</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">pattern</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">createObject</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">namespace.js</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">&gt;&lt;/script&gt;
    &lt;script src=</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">&lt;%=</span><span style="background-color: #f5f5f5; color: #000000;">Url.Content(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">~/Scripts/myTool/frame/YOOP.js</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">)</span><span style="background-color: #f5f5f5; color: #000000;">%&gt;</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">&gt;&lt;/script&gt;
  &lt;!-- include spec files here... --&gt;
    &lt;script src=</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">&lt;%=</span><span style="background-color: #f5f5f5; color: #000000;">Url.Content(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">~/Scripts/jasmine/spec/helper/specHelper.js</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">)</span><span style="background-color: #f5f5f5; color: #000000;">%&gt;</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">&gt;&lt;/script&gt;
    &lt;script src=</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">..</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">..</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">Scripts</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">jasmine</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">spec</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">frameSpec</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">YOOPSpec.js</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;


  &lt;script type=</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">text</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">javascript"&gt;</span>
<span style="background-color: #f5f5f5; color: #000000;">      (</span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;"> () {
              </span><span style="background-color: #f5f5f5; color: #0000ff;">var</span><span style="background-color: #f5f5f5; color: #000000;"> jasmineEnv </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> jasmine.getEnv();
              jasmineEnv.updateInterval </span><span style="background-color: #f5f5f5; color: #000000;">=</span> <span style="background-color: #f5f5f5; color: #000000;">1000</span><span style="background-color: #f5f5f5; color: #000000;">;

              </span><span style="background-color: #f5f5f5; color: #0000ff;">var</span><span style="background-color: #f5f5f5; color: #000000;"> htmlReporter </span><span style="background-color: #f5f5f5; color: #000000;">=</span> <span style="background-color: #f5f5f5; color: #0000ff;">new</span><span style="background-color: #f5f5f5; color: #000000;"> jasmine.HtmlReporter();

              jasmineEnv.addReporter(htmlReporter);

              jasmineEnv.specFilter </span><span style="background-color: #f5f5f5; color: #000000;">=</span> <span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;"> (spec) {
                  </span><span style="background-color: #f5f5f5; color: #0000ff;">return</span><span style="background-color: #f5f5f5; color: #000000;"> htmlReporter.specFilter(spec);
              };
              </span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;"> execJasmine() {
                  jasmineEnv.execute();
              }


              </span><span style="background-color: #f5f5f5; color: #0000ff;">var</span><span style="background-color: #f5f5f5; color: #000000;"> currentWindowOnload </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> window.onload;



              </span><span style="background-color: #f5f5f5; color: #0000ff;">if</span><span style="background-color: #f5f5f5; color: #000000;"> (currentWindowOnload) {
                  currentWindowOnload();
              }
              execJasmine();
      })();
</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span>

<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">html</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<p>在测试页面中运行测试，通过全部测试。</p>
<h1>解除对其它库的依赖</h1>
<p>现在该框架通过了测试，能够正常工作。但是因为它采用命名空间模式，需要依赖于namespace.js库。</p>
<p>我想解除这个依赖，因此直接在框架中定义YYC命名空间，并且考虑到该框架的通用性较高，因此将其命名空间YYC.Frame更改为YYC。</p>
<p>修改框架为：</p>
<div class="cnblogs_code">
<pre>window.YYC = window.YYC ||<span style="color: #000000;"> {};
...
YYC.MyInterface </span>=<span style="color: #000000;"> MyInterface;
YYC.MyAbstract </span>=<span style="color: #000000;"> MyAbstract;
YYC.MyClass </span>= MyClass;</pre>
</div>
<p>测试页面中去掉对namespace.js的引用。</p>
<h1><span style="color: #000000;">修改类名</span>&nbsp;</h1>
<p>类名MyInterface、MyAbstract、MyClass太长了，而且个人气息太浓，因此将类名改为Interface、AClass、Class。</p>
<h1><span style="color: #000000;">重构this.base，this.baseToSubClass</span></h1>
<p><span style="color: #000000;">原始版本：</span></p>
<div class="cnblogs_code">
<pre>A.prototype[name] = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (name) {
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">此处不用创建闭包了！因为外面已经创建了闭包，name已经被保存了！</span>
        <span style="color: #0000ff;">this</span>.base = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">这个写法也可以！为什么不用apply修正this也行？？！</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">parentClass.prototype[name](); </span>

            <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为base方法传入的形参</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">注意！要加上&ldquo;return&rdquo;，这样才能返回parentClass.prototype[name]的返回值</span>
            <span style="color: #0000ff;">return</span><span style="color: #000000;"> abstractClass.prototype[name].apply(abstractClass.prototype, arguments);
        };
        </span><span style="color: #008000;">//</span><span style="color: #008000;">指向子类，可以用于模版模式</span>
        <span style="color: #0000ff;">this</span>.baseToSubClass =<span style="color: #000000;"> abstractClass.prototype[name];

        </span><span style="color: #008000;">//</span><span style="color: #008000;">执行fn并返回执行的结果</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为F.prototype[name]方法传入的形参。</span>
        <span style="color: #0000ff;">return</span> prop.Public[name].apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
    };

}(name);</span></pre>
</div>
<p><span style="color: #000000;">原版中，子类使用this.base调用父类同名函数（函数中this指向父类同名函数），子类使用this.baseToSubClass调用父类同名函数（函数中this指向子类同名函数）。</span></p>
<p><span style="color: #000000;">考虑到一般都是使用this.baseToSubClass，因此将this.base改名为this.baseToParent，this.baseToSubClass改名为this.base，并不再使用this.baseToParent。</span></p>
<p><span style="color: #000000;">重构版本：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
    //此处不用创建闭包了！因为外面已经创建了闭包，name已经被保存了！
    this.baseToParrent = function () {
        //这个写法也可以！为什么不用apply修正this也行？？！
        //parentClass.prototype[name](); 

        //此处的arguments为baseToParrent方法传入的形参
        //注意！要加上&ldquo;return&rdquo;，这样才能返回parentClass.prototype[name]的返回值
        return parentClass.prototype[name].apply(parentClass.prototype, arguments);
    };
    </span><span style="color: #008000;">*/</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">指向子类，可以用于模版模式</span>
    <span style="color: #0000ff;">this</span>.base =<span style="color: #000000;"> parentClass.prototype[name];

    </span><span style="color: #008000;">//</span><span style="color: #008000;">执行fn并返回执行的结果</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为F.prototype[name]方法传入的形参。</span>
    <span style="color: #0000ff;">return</span> prop[name].apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
};</span></pre>
</div>
<h1><span style="color: #000000;">重构结构</span></h1>
<p>分析代码结构，发现AClass与Class联系的比较紧密，而Interface则可以单独为一块，因此对代码进行分块：</p>
<div class="cnblogs_code">
<pre>(<span style="color: #0000ff;">function</span>(){    <span style="color: #008000;">//</span><span style="color: #008000;">A结构</span>
    (<span style="color: #0000ff;">function</span>(){    <span style="color: #008000;">//</span><span style="color: #008000;">A1结构</span>
        <span style="color: #0000ff;">function</span><span style="color: #000000;"> Interface(){
        };

        YYC.Interface </span>=<span style="color: #000000;"> Interface;
    }());

    (</span><span style="color: #0000ff;">function</span>(){    <span style="color: #008000;">//</span><span style="color: #008000;">A2结构</span>
        <span style="color: #0000ff;">function</span><span style="color: #000000;"> AClass(){
        };

        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> Class(){
        };

        YYC.AClass </span>=<span style="color: #000000;"> AClass;
        YYC.Class </span>=<span style="color: #000000;"> Class;
    }());
}());</span></pre>
</div>
<h1>提取工具函数</h1>
<p>在工具函数的名字中加入前缀&ldquo;_&rdquo;，表示为私有函数。</p>
<p>将Interface、AClass、Class共用的工具函数提出来，放到A中。然后将AClass、Class共用的工具函数提出来放到A2中：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('1d1485b8-b709-4473-8a9a-5b1f0df25749')"><img id="code_img_closed_1d1485b8-b709-4473-8a9a-5b1f0df25749" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1d1485b8-b709-4473-8a9a-5b1f0df25749" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1d1485b8-b709-4473-8a9a-5b1f0df25749',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1d1485b8-b709-4473-8a9a-5b1f0df25749" class="cnblogs_code_hide">
<pre>(<span style="color: #0000ff;">function</span>(){    <span style="color: #008000;">//</span><span style="color: #008000;">A结构</span>
    window.YYC = window.YYC ||<span style="color: #000000;"> {};

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">************************************************* String对象扩展 ***********************************************************
    
    扩展方法：
    contain
    containIgnoreCase
    trim

    </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">String.prototype.contain) {
        String.prototype.contain </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (str) {
            </span><span style="color: #0000ff;">var</span> reg = <span style="color: #0000ff;">new</span><span style="color: #000000;"> RegExp(str);
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.match(reg)) {  <span style="color: #008000;">//</span><span style="color: #008000;">用this指针指代本体</span>
                <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">***************************************************************************************************************************</span><span style="color: #008000;">*/</span>


    <span style="color: #008000;">//</span><span style="color: #008000;">//获得函数的参数数组</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">function argumentNames(fn) {</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">    var names = fn.toString().match(/^[\s\(]*function[^(]*\(([^\)]*)\)/)[1].replace(/\s+/g, '').split(',');</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">    return names.length == 1 &amp;&amp; !names[0] ? [] : names;</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">};</span>


    <span style="color: #008000;">//</span><span style="color: #008000;">获得函数名</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> _getFunctionName(fn) {
        </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">fn) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }

        name </span>= fn.toString().match(/^.*function\s*([^\(]*)/<span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> name === <span style="color: #0000ff;">null</span> ? name : name[1<span style="color: #000000;">];
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;">判断是否为数组</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> _isArray(val) {
        </span><span style="color: #0000ff;">return</span> Object.prototype.toString.call(val) === "[object Array]"<span style="color: #000000;">;
    };

    (</span><span style="color: #0000ff;">function</span>(){    <span style="color: #008000;">//</span><span style="color: #008000;">A1结构</span>
        <span style="color: #0000ff;">function</span><span style="color: #000000;"> Interface(){
        };
    }());

    (</span><span style="color: #0000ff;">function</span>(){    <span style="color: #008000;">//</span><span style="color: #008000;">A2结构</span>
        <span style="color: #008000;">/*</span><span style="color: #008000;"> 深拷贝
</span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">function</span><span style="color: #000000;"> _extendDeep(parent, child) {
            </span><span style="color: #0000ff;">var</span> i = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            len </span>= 0<span style="color: #000000;">,
                  toStr </span>=<span style="color: #000000;"> Object.prototype.toString,
                  sArr </span>= "[object Array]"<span style="color: #000000;">,
                  sOb </span>= "[object Object]"<span style="color: #000000;">,
                  type </span>= ""<span style="color: #000000;">,
           _child </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #008000;">//</span><span style="color: #008000;">数组的话，不获得Array原型上的成员。</span>
            <span style="color: #0000ff;">if</span> (toStr.call(parent) ===<span style="color: #000000;"> sArr) {
                _child </span>= child ||<span style="color: #000000;"> [];

                </span><span style="color: #0000ff;">for</span> (i = 0, len = parent.length; i &lt; len; i++<span style="color: #000000;">) {
                    type </span>=<span style="color: #000000;"> toStr.call(parent[i]);
                    </span><span style="color: #0000ff;">if</span> (type === sArr || type === sOb) {    <span style="color: #008000;">//</span><span style="color: #008000;">如果为数组或object对象</span>
                        _child[i] = type === sArr ?<span style="color: #000000;"> [] : {};
                        _extendDeep(parent[i], _child[i]);
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        _child[i] </span>=<span style="color: #000000;"> parent[i];
                    }
                }
            }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">对象的话，要获得原型链上的成员。因为考虑以下情景：</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">类A继承于类B，现在想要拷贝类A的实例a的成员（包括从类B继承来的成员），那么就需要获得原型链上的成员。</span>
            <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (toStr.call(parent) ===<span style="color: #000000;"> sOb) {
                _child </span>= child ||<span style="color: #000000;"> {};

                </span><span style="color: #0000ff;">for</span> (i <span style="color: #0000ff;">in</span><span style="color: #000000;"> parent) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">if (parent.hasOwnProperty &amp;&amp; parent.hasOwnProperty(i)) {</span>

                    <span style="color: #008000;">//</span><span style="color: #008000;">                if (typeof parent[i] === 'object') {    //null === 'object'也为true！</span>
<span style="color: #000000;">
                    type </span>=<span style="color: #000000;"> toStr.call(parent[i]);
                    </span><span style="color: #0000ff;">if</span> (type === sArr || type === sOb) {    <span style="color: #008000;">//</span><span style="color: #008000;">如果为数组或object对象</span>
                        _child[i] = type === sArr ?<span style="color: #000000;"> [] : {};
                        _extendDeep(parent[i], _child[i]);
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        _child[i] </span>=<span style="color: #000000;"> parent[i];
                    }
                }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">}</span>
<span style="color: #000000;">            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                _child </span>=<span style="color: #000000;"> parent;
            }


            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> _child;
        };
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获得在原型prototype中不存在同名的str。</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">如果有同名，则加上前缀"_"</span>
        <span style="color: #0000ff;">function</span><span style="color: #000000;"> _getNoRepeatStrInPrototype(prototype, str) {
            </span><span style="color: #0000ff;">var</span> new_str = ""<span style="color: #000000;">;

            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">prototype[str]) {
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> str;
            }
            new_str </span>= "_" +<span style="color: #000000;"> str;

            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> _getNoRepeatStrInPrototype(prototype, new_str);
        }

        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> AClass(){
        };

        </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> Class(){
        };

        YYC.AClass </span>=<span style="color: #000000;"> AClass;
        YYC.Class </span>=<span style="color: #000000;"> Class;
    }());
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>重构_check函数</h2>
<p>注意到_check函数太大，因此需要根据职责来提取出小函数。</p>
<p>_check有两个职责：</p>
<ol>
<li>检查是否实现了父类的抽象方法/属性。</li>
<li>检查是否实现了接口方法/属性。</li>
</ol>
<p>重构前：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('77221b2e-c902-42c1-838d-19d27c3154cf')"><img id="code_img_closed_77221b2e-c902-42c1-838d-19d27c3154cf" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_77221b2e-c902-42c1-838d-19d27c3154cf" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('77221b2e-c902-42c1-838d-19d27c3154cf',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_77221b2e-c902-42c1-838d-19d27c3154cf" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> _check(parentClass, interface, children) {
    </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">检查是否实现了抽象方法/属性</span>
        <span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> parentClass.prototype) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass.prototype.hasOwnProperty(name)) {
                </span><span style="color: #0000ff;">if</span> (name === "constructor"<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">if</span> (name.contain("Abstract_"<span style="color: #000000;">)) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象方法</span>
                    <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> parentClass.prototype[name] === "function"<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">if</span> (children[name.slice(9)] === undefined || <span style="color: #0000ff;">typeof</span> children[name.slice(9)] !== "function"<span style="color: #000000;">) {
                            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Abstract method '" + name + "' must be overwrited!"<span style="color: #000000;">);
                        }
                    }
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象属性</span>
                    <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        </span><span style="color: #0000ff;">if</span> (children[name.slice(9)] === undefined || <span style="color: #0000ff;">typeof</span> children[name.slice(9)] === "function"<span style="color: #000000;">) {
                            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Abstract attribute '" + name + "' must be overwrited!"<span style="color: #000000;">);
                        }
                    }
                }
            }
        }
    }
    </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">interface) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查是否实现了接口方法/属性</span>
    <span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> interface.prototype) {
        </span><span style="color: #0000ff;">if</span> (name === "constructor"<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">接口方法</span>
        <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> interface.prototype[name] === "function"<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (children[name.slice(10)] === undefined || <span style="color: #0000ff;">typeof</span> children[name.slice(10)] !== "function"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface method '" + name + "' must be overwrited!"<span style="color: #000000;">);
            }
        }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">接口属性</span>
        <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span> (children[name.slice(10)] === undefined || <span style="color: #0000ff;">typeof</span> children[name.slice(10)] === "function"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface attribute '" + name + "' must be overwrited!"<span style="color: #000000;">);
            }
        }
    }
};</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<p>重构后：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('f29e59bb-540c-4795-892b-f132e222ede7')"><img id="code_img_closed_f29e59bb-540c-4795-892b-f132e222ede7" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_f29e59bb-540c-4795-892b-f132e222ede7" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f29e59bb-540c-4795-892b-f132e222ede7',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_f29e59bb-540c-4795-892b-f132e222ede7" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">检查子类的公有方法+虚方法+抽象方法是否包含父类的抽象方法/属性 或 接口方法/属性。</span><span style="color: #008000;">
//</span><span style="color: #008000;">不用hasOwnProperty判断！否则就检查不到是否包含了父类的抽象方法/属性 或 接口方法/属性。</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> _check(parentClass, interface, children) {
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass) {
        _checkAbstract(parentClass, children);
    }
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (interface) {
        _checkInterface(interface, children);
    }
};
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _checkAbstract(parentClass, children) {
    </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

    </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> parentClass.prototype) {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass.prototype.hasOwnProperty(name)) {
            </span><span style="color: #0000ff;">if</span> (name === "constructor"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (name.contain("Abstract_"<span style="color: #000000;">)) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象方法</span>
                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> parentClass.prototype[name] === "function"<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (children[name.slice(9)] === undefined || <span style="color: #0000ff;">typeof</span> children[name.slice(9)] !== "function"<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Abstract method '" + name + "' must be overwrited!"<span style="color: #000000;">);
                    }
                }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象属性</span>
                <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">if</span> (children[name.slice(9)] === undefined || <span style="color: #0000ff;">typeof</span> children[name.slice(9)] === "function"<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Abstract attribute '" + name + "' must be overwrited!"<span style="color: #000000;">);
                    }
                }
            }
        }
    }
};
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _checkInterface(interface, children) {
    </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

    </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> interface.prototype) {
        </span><span style="color: #0000ff;">if</span> (name === "constructor"<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">接口方法</span>
        <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> interface.prototype[name] === "function"<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (children[name.slice(10)] === undefined || <span style="color: #0000ff;">typeof</span> children[name.slice(10)] !== "function"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface method '" + name + "' must be overwrited!"<span style="color: #000000;">);
            }
        }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">接口属性</span>
        <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span> (children[name.slice(10)] === undefined || <span style="color: #0000ff;">typeof</span> children[name.slice(10)] === "function"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface attribute '" + name + "' must be overwrited!"<span style="color: #000000;">);
            }
        }

    }
};</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<p>_checkAbstract、_checkInterface中的&ldquo;if (children[name.slice(9)] === undefined || typeof children[name.slice(9)] !== "function") {&rdquo;等条件语句很难理解，因此将其封装成函数：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('12b42df8-afc7-432c-a816-f7567f74a935')"><img id="code_img_closed_12b42df8-afc7-432c-a816-f7567f74a935" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_12b42df8-afc7-432c-a816-f7567f74a935" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('12b42df8-afc7-432c-a816-f7567f74a935',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_12b42df8-afc7-432c-a816-f7567f74a935" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> _checkAbstract(parentClass, children) {
    </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

    </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> parentClass.prototype) {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass.prototype.hasOwnProperty(name)) {
            </span><span style="color: #0000ff;">if</span> (name === "constructor"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (name.contain("Abstract_"<span style="color: #000000;">)) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象方法</span>
                <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> parentClass.prototype[name] === "function"<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (_noMethodForAbstract(children, name) &amp;&amp;<span style="color: #000000;"> _noMethodForAbstract(parentClass.prototype, name)) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Abstract method '" + name + "' must be overwrited!"<span style="color: #000000;">);
                    }
                }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象属性</span>
                <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">if</span> (_noAttritubeForAbstract(children, name) &amp;&amp;<span style="color: #000000;"> _noAttritubeForAbstract(parentClass.prototype, name)) {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Abstract attribute '" + name + "' must be overwrited!"<span style="color: #000000;">);
                    }
                }
            }
        }
    }
};
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _checkInterface(interface, children) {
    </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

    </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> interface.prototype) {
        </span><span style="color: #0000ff;">if</span> (name === "constructor"<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">接口方法</span>
        <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> interface.prototype[name] === "function"<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (_noMethodForInterface(children, name) &amp;&amp;<span style="color: #000000;"> _noMethodForInterface(parentClass.prototype, name)) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface method '" + name + "' must be overwrited!"<span style="color: #000000;">);
            }
        }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">接口属性</span>
        <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span> (_noAttritubeForInterface(children, name) &amp;&amp;<span style="color: #000000;"> _noAttritubeForInterface(parentClass.prototype, name)) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface attribute '" + name + "' must be overwrited!"<span style="color: #000000;">);
            }
        }
    }
};
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _noMethodForAbstract(_class, name) {
    </span><span style="color: #0000ff;">return</span> _class[name.slice(9)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(9)] !== "function"<span style="color: #000000;">;
};
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _noAttritubeForAbstract(_class, name) {
    </span><span style="color: #0000ff;">return</span> _class[name.slice(9)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(9)] === "function"<span style="color: #000000;">;
};
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _noMethodForInterface(_class, name) {
    </span><span style="color: #0000ff;">return</span> _class[name.slice(10)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(10)] !== "function"<span style="color: #000000;">;
};
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _noAttritubeForInterface(_class, name) {
    </span><span style="color: #0000ff;">return</span> _class[name.slice(10)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(10)] === "function"<span style="color: #000000;">;
};</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>重构Interface</h1>
<p>现在让我们看下function Interface(){}中的代码：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('7915ba4b-20a7-4b69-a0b3-28cbca2a0a80')"><img id="code_img_closed_7915ba4b-20a7-4b69-a0b3-28cbca2a0a80" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_7915ba4b-20a7-4b69-a0b3-28cbca2a0a80" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('7915ba4b-20a7-4b69-a0b3-28cbca2a0a80',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_7915ba4b-20a7-4b69-a0b3-28cbca2a0a80" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">创建接口</span><span style="color: #008000;">
//</span><span style="color: #008000;">接口可以继承接口</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> Interface(_parent, _method, _attribute) {
    </span><span style="color: #0000ff;">var</span> i = 0, args = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">var</span> parent = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
        method </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
        attribute </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "function"<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">if</span> (_getFunctionName(_parent) !== "I"<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface must inherit interface!"<span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            parent </span>=<span style="color: #000000;"> _parent;

            </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;MyInterface(Parent, "A", "B", "GetName");&rdquo;</span>
            <span style="color: #0000ff;">if</span> (_method &amp;&amp; !<span style="color: #000000;">_isArray(_method)) {
                method </span>= Array.prototype.slice.call(arguments, 1<span style="color: #000000;">);
                attribute </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;MyInterface(Parent, ["A", "B", "GetName"], ["a", "c"]);&rdquo;</span>
            <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                method </span>=<span style="color: #000000;"> _method;
                attribute </span>=<span style="color: #000000;"> _attribute;
            }
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">            console.log(parent.toString());</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        parent </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;MyInterface("A", "B", "GetName");&rdquo;</span>
        <span style="color: #0000ff;">if</span> (_method &amp;&amp; !<span style="color: #000000;">_isArray(_method)) {
            method </span>=<span style="color: #000000;"> arguments
            attribute </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;MyInterface(["A", "B", "GetName"], ["a", "c"]);&rdquo;</span>
        <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            method </span>= arguments[0<span style="color: #000000;">];
            attribute </span>= arguments[1<span style="color: #000000;">];
        }
    }

    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> I() {
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此接口需要从其它接口扩展</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;"> (parent) {
        I.prototype </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> parent();
        I.prototype.constructor </span>=<span style="color: #000000;"> I;
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;">        console.log("method = " + method);</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">        console.log("attribute = " + attribute);</span>


    <span style="color: #008000;">//</span><span style="color: #008000;">        //形如&ldquo;MyInterface(["A", "B", "GetName"], ["a", "c"]);&rdquo;</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">        if (isArray(method)) {</span>

    <span style="color: #008000;">//</span><span style="color: #008000;">方法</span>
    <span style="color: #0000ff;">for</span> (i = 0; i &lt; method.length; i++<span style="color: #000000;">) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">加上前缀&ldquo;Interface_&rdquo;</span>
        I.prototype["Interface_" + method[i]] = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("This method must be overwrited!"<span style="color: #000000;">);
        };
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">属性</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;"> (attribute) {
        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">isArray(attribute)) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Attribute must be array!"<span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (i = 0; i &lt; attribute.length; i++<span style="color: #000000;">) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">加上前缀&ldquo;Interface_&rdquo;</span>
                I.prototype["Interface_" + attribute[i]] = 0<span style="color: #000000;">;
            }
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">        }</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">        //形如&ldquo;MyInterface("A", "B", "GetName");&rdquo;</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">        else {</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">            args = Array.prototype.slice.call(arguments, 1);</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">            //方法</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">            for (i = 0; i &lt; args.length; i++) {</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">                I.prototype[args[i]] = function () {</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">                    throw new Error("This method must be overwrited!");</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">                };</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">            }</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">        }</span>

    <span style="color: #0000ff;">return</span><span style="color: #000000;"> I;
};</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<p>该函数包含了太多的职责，应该把每一个职责提取为一个内部函数，然后再在Interface中调用这些内部函数:</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('41d924a9-9af8-45eb-bb80-d66576a87179')"><img id="code_img_closed_41d924a9-9af8-45eb-bb80-d66576a87179" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_41d924a9-9af8-45eb-bb80-d66576a87179" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('41d924a9-9af8-45eb-bb80-d66576a87179',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_41d924a9-9af8-45eb-bb80-d66576a87179" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">创建接口</span><span style="color: #008000;">
//</span><span style="color: #008000;">接口可以继承接口</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> Interface(_parent, _method, _attribute) {
    </span><span style="color: #0000ff;">var</span> i = 0, args = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">var</span> parent = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
        method </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
        attribute </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _getByParent() {
        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "function"<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (_getFunctionName(_parent) !== "I"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface must inherit interface!"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                parent </span>=<span style="color: #000000;"> _parent;
                </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;Interface(Parent, "A", "B", "GetName");&rdquo;</span>
                <span style="color: #0000ff;">if</span> (_method &amp;&amp; !<span style="color: #000000;">_isArray(_method)) {
                    method </span>= Array.prototype.slice.call(arguments, 1<span style="color: #000000;">);
                    attribute </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;Interface(Parent, ["A", "B", "GetName"], ["a", "c"]);&rdquo;</span>
                <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    method </span>=<span style="color: #000000;"> _method;
                    attribute </span>=<span style="color: #000000;"> _attribute;
                }
            }
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            parent </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;Interface("A", "B", "GetName");&rdquo;</span>
            <span style="color: #0000ff;">if</span> (_method &amp;&amp; !<span style="color: #000000;">_isArray(_method)) {
                method </span>=<span style="color: #000000;"> arguments
                attribute </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">形如&ldquo;Interface(["A", "B", "GetName"], ["a", "c"]);&rdquo;</span>
            <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                method </span>= arguments[0<span style="color: #000000;">];
                attribute </span>= arguments[1<span style="color: #000000;">];
            }
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _inherit() {
        I.prototype </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> parent();
        I.prototype.constructor </span>=<span style="color: #000000;"> I;
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _addMethod() {
        </span><span style="color: #0000ff;">for</span> (i = 0; i &lt; method.length; i++<span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">加上前缀&ldquo;Interface_&rdquo;</span>
            I.prototype["Interface_" + method[i]] = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("This method must be overwrited!"<span style="color: #000000;">);
            };
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _addAttribute() {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (attribute) {
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">_isArray(attribute)) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Attribute must be array!"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">for</span> (i = 0; i &lt; attribute.length; i++<span style="color: #000000;">) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">加上前缀&ldquo;Interface_&rdquo;</span>
                    I.prototype["Interface_" + attribute[i]] = 0<span style="color: #000000;">;
                }
            }
        }
    };

    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> I() {
    }

    _getByParent();
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此接口需要从其它接口扩展</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;"> (parent) {
        _inherit();
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">方法</span>
<span style="color: #000000;">    _addMethod();
    </span><span style="color: #008000;">//</span><span style="color: #008000;">属性</span>
<span style="color: #000000;">    _addAttribute();

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> I;
};</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>重构AClass、Class</h1>
<p>AClass、Class中有一些重复的代码，将这些重复的代码提取为函数，放到结构A2中，供AClass、Class调用：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('028f91e0-5187-4cf1-99f3-b4587da88884')"><img id="code_img_closed_028f91e0-5187-4cf1-99f3-b4587da88884" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_028f91e0-5187-4cf1-99f3-b4587da88884" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('028f91e0-5187-4cf1-99f3-b4587da88884',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_028f91e0-5187-4cf1-99f3-b4587da88884" class="cnblogs_code_hide">
<pre>(<span style="color: #0000ff;">function</span>(){    <span style="color: #008000;">//</span><span style="color: #008000;">A2结构</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">检查抽象成员</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> _addAbstract(abstract, currentClass, temp) {
        </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> abstract) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (abstract.hasOwnProperty(name)) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象方法前面加"Abstract_"前缀</span>
                currentClass.prototype["Abstract_" + name] =<span style="color: #000000;"> abstract[name];
                temp[name] </span>= abstract[name];    <span style="color: #008000;">//</span><span style="color: #008000;">加入temp</span>
<span style="color: #000000;">            }
        }
    };
    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查虚方法(不能为虚属性)</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> _addVirtual(virtual, currentClass, temp) {
        </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> virtual) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (virtual.hasOwnProperty(name)) {
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> virtual[name] !== "function"<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Virtual attribute is not allowed!"<span style="color: #000000;">);
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    currentClass.prototype[name] </span>=<span style="color: #000000;"> virtual[name];
                    temp[name] </span>= virtual[name];    <span style="color: #008000;">//</span><span style="color: #008000;">加入temp</span>
<span style="color: #000000;">                }
            }
        }
    };
    </span><span style="color: #008000;">//</span><span style="color: #008000;">加入密封方法。</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">没有实现检查子类是否重写了父类的密封方法，只是定义了一个规范。</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> _addSealed(sealed, currentClass, temp) {
        </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> sealed) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (sealed.hasOwnProperty(name)) {
                currentClass.prototype[name] </span>=<span style="color: #000000;"> sealed[name];
                temp[name] </span>= sealed[name];    <span style="color: #008000;">//</span><span style="color: #008000;">加入temp</span>
<span style="color: #000000;">            }
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _addStatic(_class, prop) {
        </span><span style="color: #0000ff;">var</span> Static = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">var</span> k = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        Static </span>= prop.Static ? prop.Static : <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">静态属性/方法赋值</span>
        <span style="color: #0000ff;">for</span> (k <span style="color: #0000ff;">in</span><span style="color: #000000;"> Static) {
            _class[k] </span>=<span style="color: #000000;"> Static[k];
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _inherit(_class, parentClass) {
        _class.prototype </span>=<span style="color: #000000;"> _extendDeep(parentClass.prototype);
        _class.prototype.constructor </span>=<span style="color: #000000;"> _class;

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果父类存在，则实例对象的baseClass指向父类的原型。</span>
        <span style="color: #008000;">//</span><span style="color: #008000;"> 这就提供了在实例对象中调用父类方法的途径。</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">baseClass的方法是指向parentClass的，不是指向F（子类）的！</span>
        _class.prototype[_getNoRepeatStrInPrototype(parentClass.prototype, "baseClass")] =<span style="color: #000000;"> parentClass.prototype;
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _addInit(_class, parentClass, prop) {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Init) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此类继承自父类parent并且父类原型中存在同名函数name</span>
            <span style="color: #0000ff;">if</span> (parentClass &amp;&amp;
    <span style="color: #0000ff;">typeof</span> prop.Init === "function" &amp;&amp;
    <span style="color: #0000ff;">typeof</span> _class.prototype.Init === "function"<span style="color: #000000;">) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">if (parentClass) {</span>
                _class.prototype.Init = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (name) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #008000;">/*</span><span style="color: #008000;">
                        //此处不用创建闭包了！因为外面已经创建了闭包，name已经被保存了！
                        this.baseToParrent = function () {
                            //这个写法也可以！为什么不用apply修正this也行？？！
                            //parentClass.prototype[name](); 
    
                            //此处的arguments为baseToParrent方法传入的形参
                            //注意！要加上&ldquo;return&rdquo;，这样才能返回parentClass.prototype[name]的返回值
                            return parentClass.prototype[name].apply(parentClass.prototype, arguments);
                        };
                        </span><span style="color: #008000;">*/</span>
                        <span style="color: #008000;">//</span><span style="color: #008000;">指向子类，可以用于模版模式</span>
                        <span style="color: #0000ff;">this</span>.base =<span style="color: #000000;"> parentClass.prototype[name];

                        </span><span style="color: #008000;">//</span><span style="color: #008000;">执行fn并返回执行的结果</span>
                        <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为F.prototype[name]方法传入的形参。</span>
                        <span style="color: #0000ff;">return</span> prop[name].apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
                    };

                }(</span>"Init"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                _class.prototype.Init </span>=<span style="color: #000000;"> prop.Init;
            }
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _addPrivate(_class, private) {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (private) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">私有属性/方法直接覆盖</span>
            <span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> private) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (private.hasOwnProperty(name)) {
                    _class.prototype[name] </span>=<span style="color: #000000;"> private[name];
                }
            }
        }
    };
    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查抽象类的公有方法+虚方法+抽象方法是否包含父类的抽象方法/属性 或 接口方法/属性。</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">不用hasOwnProperty判断！否则就检查不到是否包含了父类的抽象方法/属性 或 接口方法/属性。</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> _check(parentClass, interface, children) {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass) {
            _checkAbstract(parentClass, children);
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (interface) {
            _checkInterface(interface, children);
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _checkAbstract(parentClass, children) {
        </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> parentClass.prototype) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass.prototype.hasOwnProperty(name)) {
                </span><span style="color: #0000ff;">if</span> (name === "constructor"<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">if</span> (name.contain("Abstract_"<span style="color: #000000;">)) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象方法</span>
                    <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> parentClass.prototype[name] === "function"<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">if</span> (_noMethodForAbstract(children, name) &amp;&amp;<span style="color: #000000;"> _noMethodForAbstract(parentClass.prototype, name)) {
                            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Abstract method '" + name + "' must be overwrited!"<span style="color: #000000;">);
                        }
                    }
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">抽象属性</span>
                    <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        </span><span style="color: #0000ff;">if</span> (_noAttritubeForAbstract(children, name) &amp;&amp;<span style="color: #000000;"> _noAttritubeForAbstract(parentClass.prototype, name)) {
                            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Abstract attribute '" + name + "' must be overwrited!"<span style="color: #000000;">);
                        }
                    }
                }
            }
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _checkInterface(interface, children) {
        </span><span style="color: #0000ff;">var</span> name = ""<span style="color: #000000;">;

        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> interface.prototype) {
            </span><span style="color: #0000ff;">if</span> (name === "constructor"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">接口方法</span>
            <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> interface.prototype[name] === "function"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (_noMethodForInterface(children, name) &amp;&amp;<span style="color: #000000;"> _noMethodForInterface(parentClass.prototype, name)) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface method '" + name + "' must be overwrited!"<span style="color: #000000;">);
                }
            }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">接口属性</span>
            <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (_noAttritubeForInterface(children, name) &amp;&amp;<span style="color: #000000;"> _noAttritubeForInterface(parentClass.prototype, name)) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Interface attribute '" + name + "' must be overwrited!"<span style="color: #000000;">);
                }
            }
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _noMethodForAbstract(_class, name) {
        </span><span style="color: #0000ff;">return</span> _class[name.slice(9)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(9)] !== "function"<span style="color: #000000;">;
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _noAttritubeForAbstract(_class, name) {
        </span><span style="color: #0000ff;">return</span> _class[name.slice(9)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(9)] === "function"<span style="color: #000000;">;
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _noMethodForInterface(_class, name) {
        </span><span style="color: #0000ff;">return</span> _class[name.slice(10)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(10)] !== "function"<span style="color: #000000;">;
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _noAttritubeForInterface(_class, name) {
        </span><span style="color: #0000ff;">return</span> _class[name.slice(10)] === undefined || <span style="color: #0000ff;">typeof</span> _class[name.slice(10)] === "function"<span style="color: #000000;">;
    };

    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> AClass(){
    };

    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> Class(){
    };

    YYC.AClass </span>=<span style="color: #000000;"> AClass;
    YYC.Class </span>=<span style="color: #000000;"> Class;
}());</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<p>将AClass中的每一个职责提取为一个内部函数，然后再在AClass中调用这些内部函数：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5b7a38b0-3fdb-46e9-b185-46e96290142b')"><img id="code_img_closed_5b7a38b0-3fdb-46e9-b185-46e96290142b" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_5b7a38b0-3fdb-46e9-b185-46e96290142b" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5b7a38b0-3fdb-46e9-b185-46e96290142b',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_5b7a38b0-3fdb-46e9-b185-46e96290142b" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">创建抽象类</span><span style="color: #008000;">
//</span><span style="color: #008000;">抽象类能够继承接口、抽象类以及实体类，但此处约定抽象类只能继承接口和抽象类，不能继承实体类！</span><span style="color: #008000;">
//</span><span style="color: #008000;">（这样方便判断抽象类是否包含全部的父类（接口/抽象类）成员）</span>

<span style="color: #0000ff;">function</span><span style="color: #000000;"> AClass(_parent, _prop) {

    </span><span style="color: #0000ff;">var</span> name = <span style="color: #0000ff;">null</span>, temp =<span style="color: #000000;"> {};
    </span><span style="color: #0000ff;">var</span> parentClass = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
        prop </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">//原型恢复标志，用于防止第一次创建实例时恢复原型</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">var mark_resume = false;</span>

    <span style="color: #0000ff;">function</span><span style="color: #000000;"> _getByParent() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">if (arguments.length === 1) {</span>
        <span style="color: #0000ff;">if</span> (_prop ===<span style="color: #000000;"> undefined) {
            prop </span>=<span style="color: #000000;"> _parent;
            parentClass </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "object"<span style="color: #000000;">) {

            </span><span style="color: #0000ff;">if</span> (!_parent.Class &amp;&amp; !<span style="color: #000000;">_parent.Interface) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Please add AbstractClass or Interface!"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">if</span> (_getFunctionName(_parent.Class) === "F" || _getFunctionName(_parent.Interface) === "F"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("AbstractClass here can't inherit parentClass which is created by Class function!"<span style="color: #000000;">);
            }

            parentClass </span>=<span style="color: #000000;"> _parent.Class;
            interface </span>=<span style="color: #000000;"> _parent.Interface;

            prop </span>=<span style="color: #000000;"> _prop;
        }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">_parent直接为xx，就表示父类为抽象类</span>
        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "function"<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (_getFunctionName(_parent) === "F"<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("AbstractClass here can't inherit parentClass which is created by Class function!"<span style="color: #000000;">);
            }

            parentClass </span>=<span style="color: #000000;"> _parent;
            interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            prop </span>=<span style="color: #000000;"> _prop;
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("arguments is not allowed!"<span style="color: #000000;">);
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _prepareAndAddPublic() {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Public) {
            </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> prop.Public) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Public.hasOwnProperty(name)) {
                    </span><span style="color: #0000ff;">if</span> (_prepareCheck("Public") === "continue"<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    _addPublic();
                }
            }
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _addPublic() {
        </span><span style="color: #0000ff;">if</span> (parentClass &amp;&amp;
            <span style="color: #0000ff;">typeof</span> prop.Public[name] === "function" &amp;&amp;
            <span style="color: #0000ff;">typeof</span> A.prototype[name] === "function"<span style="color: #000000;">) {
            A.prototype[name] </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (name) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
                    //此处不用创建闭包了！因为外面已经创建了闭包，name已经被保存了！
                    this.baseToParrent = function () {
                        //这个写法也可以！为什么不用apply修正this也行？？！
                        //parentClass.prototype[name](); 

                        //此处的arguments为baseToParrent方法传入的形参
                        //注意！要加上&ldquo;return&rdquo;，这样才能返回parentClass.prototype[name]的返回值
                        return parentClass.prototype[name].apply(parentClass.prototype, arguments);
                    };
                    </span><span style="color: #008000;">*/</span>
                    <span style="color: #008000;">//</span><span style="color: #008000;">指向子类，可以用于模版模式</span>
                    <span style="color: #0000ff;">this</span>.base =<span style="color: #000000;"> parentClass.prototype[name];

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">执行fn并返回执行的结果</span>
                    <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为F.prototype[name]方法传入的形参。</span>
                    <span style="color: #0000ff;">return</span> prop.Public[name].apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
                };

            }(name);
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            A.prototype[name] </span>=<span style="color: #000000;"> prop.Public[name];
        }
    }
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _prepareAndAddProtected() {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Protected) {
            </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> prop.Protected) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Protected.hasOwnProperty(name)) {
                    </span><span style="color: #0000ff;">if</span> (_prepareCheck("Protected") === "continue"<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    A.prototype[name] </span>=<span style="color: #000000;"> prop.Protected[name];

                }
            }
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _prepareCheck(where) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">检查抽象成员，抽象成员放到Public或Protected中</span>
        <span style="color: #0000ff;">if</span> (name === "Abstract"<span style="color: #000000;">) {
            _addAbstract(prop[where][name], A, temp);
            </span><span style="color: #0000ff;">return</span> "continue"<span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">检查虚方法，虚方法放到Public或Protected中</span>
        <span style="color: #0000ff;">if</span> (name === "Virtual"<span style="color: #000000;">) {
            _addVirtual(prop[where][name], A, temp);
            </span><span style="color: #0000ff;">return</span> "continue"<span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">密封的方法（不允许子类重写）</span>
        <span style="color: #0000ff;">if</span> (name === "Sealed"<span style="color: #000000;">) {
            _addSealed(prop[where][name], A, temp);
            </span><span style="color: #0000ff;">return</span> "continue"<span style="color: #000000;">;
        }

        temp[name] </span>= prop[where][name];    <span style="color: #008000;">//</span><span style="color: #008000;">用于检查是否包含父类的抽象方法/属性 或 接口方法/属性</span>
        <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    };

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 本次调用所创建的类（构造函数）</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> A() {
    }


    </span><span style="color: #008000;">//</span><span style="color: #008000;">取出父类、接口</span>
<span style="color: #000000;">    _getByParent();

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此接口需要从其它接口扩展</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass) {
        _inherit(A, parentClass);
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;">加入构造函数</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">抽象类本身因为不能实例化，所以不调用构造函数。</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">抽象类中的构造函数供子类构造函数中调用。</span>
<span style="color: #000000;">    _addInit(A, parentClass, prop);

    _addPrivate(A, prop.Private);

    _prepareAndAddPublic();


    </span><span style="color: #008000;">//</span><span style="color: #008000;">保护成员</span>
<span style="color: #000000;">    _prepareAndAddProtected();

    </span><span style="color: #008000;">//</span><span style="color: #008000;">放到外面的抽象成员，默认为公有抽象成员</span>
<span style="color: #000000;">    _addAbstract(prop.Abstract, A, temp);

    _addStatic(A, prop);

    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查抽象类的公有方法+虚方法+抽象方法是否包含父类的接口方法/属性</span>
    _check(<span style="color: #0000ff;">null</span><span style="color: #000000;">, interface, temp);

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> A;
};</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<p>同理Class重构为：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('7793e4c1-9a60-4c6c-b8d2-c4e9a99fa361')"><img id="code_img_closed_7793e4c1-9a60-4c6c-b8d2-c4e9a99fa361" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_7793e4c1-9a60-4c6c-b8d2-c4e9a99fa361" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('7793e4c1-9a60-4c6c-b8d2-c4e9a99fa361',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_7793e4c1-9a60-4c6c-b8d2-c4e9a99fa361" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">创建普通类</span><span style="color: #008000;">
//</span><span style="color: #008000;">父类_parent可以为{Class: xx, Interface: xx}，或者直接为xx类</span>

<span style="color: #0000ff;">function</span><span style="color: #000000;"> Class(_parent, _prop) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">当前是否处于创建类的阶段。</span>
    <span style="color: #0000ff;">var</span> initializing = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">var</span> name = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">var</span> parentClass = <span style="color: #0000ff;">null</span>, interface = <span style="color: #0000ff;">null</span>, prop = <span style="color: #0000ff;">null</span>, temp =<span style="color: #000000;"> {};
    </span><span style="color: #008000;">//</span><span style="color: #008000;">原型恢复标志，用于防止第一次创建实例时恢复原型</span>
    <span style="color: #0000ff;">var</span> mark_resume = <span style="color: #0000ff;">false</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _getByParent() {
        </span><span style="color: #0000ff;">if</span> (_prop ===<span style="color: #000000;"> undefined) {
            prop </span>=<span style="color: #000000;"> _parent;
            parentClass </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">{Class: xx, Interface: xx}</span>
        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "object"<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (!_parent.Class &amp;&amp; !<span style="color: #000000;">_parent.Interface) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Please add Class or Interface!"<span style="color: #000000;">);
            }

            parentClass </span>=<span style="color: #000000;"> _parent.Class;
            interface </span>=<span style="color: #000000;"> _parent.Interface;
            prop </span>=<span style="color: #000000;"> _prop;
        }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">直接为xx类</span>
        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> _parent === "function"<span style="color: #000000;">) {
            parentClass </span>=<span style="color: #000000;"> _parent;
            interface </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            prop </span>=<span style="color: #000000;"> _prop;
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("arguments is not allowed!"<span style="color: #000000;">);
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _addParentSealed() {
        </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> parentClass.prototype) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass.prototype.hasOwnProperty(name)) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">如果不是抽象方法/保护方法/私有方法/接口成员，则加入到temp中。</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">用于添加父类的密封方法（因为子类并没有加入父类的密封方法）。</span>
                <span style="color: #0000ff;">if</span> (!name.match(/^Abstract_/) || !name.match(/^P_/) || !name.match(/^_/) || !name.match(/^Interface_/<span style="color: #000000;">)) {
                    temp[name] </span>=<span style="color: #000000;"> parentClass.prototype[name];
                }
            }
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _prepareAndAddPublic() {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Public) {
            </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> prop.Public) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Public.hasOwnProperty(name)) {
                    </span><span style="color: #0000ff;">if</span> (_prepareCheck("Public") === "continue"<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    _addPublic();
                }
            }
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _addPublic() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此类继承自父类parent并且父类原型中存在同名函数name</span>
        <span style="color: #0000ff;">if</span> (parentClass &amp;&amp;
<span style="color: #0000ff;">typeof</span> prop.Public[name] === "function" &amp;&amp;
<span style="color: #0000ff;">typeof</span> F.prototype[name] === "function"<span style="color: #000000;">) {
            F.prototype[name] </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (name) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">指向子类，可以用于模版模式</span>
                    <span style="color: #0000ff;">this</span>.base =<span style="color: #000000;"> parentClass.prototype[name];
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">执行fn并返回执行的结果</span>
                    <span style="color: #008000;">//</span><span style="color: #008000;">此处的arguments为F.prototype[name]方法传入的形参。</span>
                    <span style="color: #0000ff;">return</span> prop.Public[name].apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
                };
            }(name);

        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            F.prototype[name] </span>=<span style="color: #000000;"> prop.Public[name];
        }
    }
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _prepareAndAddProtected() {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Protected) {
            </span><span style="color: #0000ff;">for</span> (name <span style="color: #0000ff;">in</span><span style="color: #000000;"> prop.Protected) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Protected.hasOwnProperty(name)) {
                    </span><span style="color: #0000ff;">if</span> (_prepareCheck("Protected") === "continue"<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    F.prototype[name] </span>=<span style="color: #000000;"> prop.Protected[name];

                }
            }
        }
    };
    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> _prepareCheck(where) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">检查虚方法，虚方法放到Public或Protected中</span>
        <span style="color: #0000ff;">if</span> (name === "Virtual"<span style="color: #000000;">) {
            _addVirtual(prop[where][name], A, temp);
            </span><span style="color: #0000ff;">return</span> "continue"<span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">密封的方法（不允许子类重写）</span>
        <span style="color: #0000ff;">if</span> (name === "Sealed"<span style="color: #000000;">) {
            _addSealed(prop[where][name], A, temp);
            </span><span style="color: #0000ff;">return</span> "continue"<span style="color: #000000;">;
        }

        temp[name] </span>= prop[where][name];    <span style="color: #008000;">//</span><span style="color: #008000;">用于检查是否包含父类的抽象方法/属性 或 接口方法/属性</span>
        <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    };

    _getByParent();

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 本次调用所创建的类（构造函数）</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> F() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">防止第一次创建实例时恢复原型</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (mark_resume) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">还原原型</span>
<span style="color: #000000;">            _extendDeep(F.backUp_prototype, F.prototype);
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            mark_resume </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果当前处于实例化类的阶段，则调用Init原型函数</span>
        <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">initializing) {
            </span><span style="color: #0000ff;">this</span>.Init &amp;&amp; <span style="color: #0000ff;">this</span>.Init.apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
        }
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">不能删除私有成员和保护成员！否则类的成员就不能调用到私有和保护的成员了（因为已经删除了）！
        对象的创建算法参考http://www.cnblogs.com/TomXu/archive/2012/02/06/2330609.html




        //删除私有成员和保护成员，这样外界就不能访问私有和保护成员了！
        for (name in this) {
        if (name.search(/(^_)|(^P_)/) !== -1) {
        delete F.prototype[name];
        //                                                    this[name] = null;
        }
          
        }
        </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此类需要从其它类扩展</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass) {
        initializing </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        _inherit(F, parentClass);
        initializing </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }

    _addInit(F, parentClass, prop);

    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (parentClass) {
        _addParentSealed();
    }

    _addPrivate(F, prop.Private);

    </span><span style="color: #008000;">//</span><span style="color: #008000;">保护成员</span>
<span style="color: #000000;">    _prepareAndAddProtected();

    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.Abstract) {
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error("Only abstractClass can have abstract methods!"<span style="color: #000000;">);
    }

    _prepareAndAddPublic();

    </span><span style="color: #008000;">//</span><span style="color: #008000;">检查公有成员和虚函数是否实现了抽象方法/属性 或 接口方法/属性</span>
<span style="color: #000000;">    _check(parentClass, interface, temp);

    _addStatic(F, prop);


    </span><span style="color: #008000;">//</span><span style="color: #008000;">备份原型</span>
    F.backUp_prototype =<span style="color: #000000;"> _extendDeep(F.prototype);

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> F;
};</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>重命名temp</h2>
<p>AClass和Class中的局部属性temp的职责是存储该类成员的名称，从而用于检查该类成员是否实现了接口或者父类的抽象成员。</p>
<p>因此，将temp改名为children，这样能反映职责。</p>]]></description></item><item><title>发布我的Javascript OOP框架YOOP</title><link>http://www.cnblogs.com/chaogex/archive/2013/06/07/3123999.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Fri, 07 Jun 2013 08:18:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2013/06/07/3123999.html</guid><description><![CDATA[<p>大家好！今天我正式发布我的OOP框架<span style="color: #000000; font-size: 18px;">YOOP</span>！该框架将帮助开发者更好地进行面向对象编程。</p>
<p>当前版本号：v1.1</p>
<p><span style="font-size: 18pt;"><a style="font-size: 20px; line-height: 1.5;" href="https://github.com/yyc-git/YOOP" target="_blank">GitHub下载地址</a></span></p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">介绍</span></strong></p>
<p>该框架包含接口、抽象类、类。</p>
<p>接口Interface可以继承多个接口，可以定义方法、属性。</p>
<p>抽象类AClass可以继承多个接口、一个抽象类，可以定义构造函数、公有成员、私有成员、保护成员、静态成员、虚成员、抽象成员。</p>
<p>类Class可以继承多个接口、一个抽象类或类，可以定义构造函数、公有成员、私有成员、保护成员、静态成员、虚成员。&nbsp;</p>
<h1><span style="background-color: #ffffff; color: #000000;">子类调用父类成员</span></h1>
<p>在子类中，可以使用this.base()来调用父类同名方法。也可以使用this.baseClass来访问父类的原型。</p>
<h1><span style="background-color: #ffffff; color: #000000;">主要的语法规则</span></h1>
<h2>类Class：</h2>
<ol>
<li>创建实例时调用构造函数。</li>
<li>验证是否实现了接口的方法、属性，如果没有实现会抛出异常。</li>
<li>验证是否实现了父类的抽象成员，如果没有实现会抛出异常。</li>
<li>只能继承一个类（AClass或Class），否则抛出异常.</li>
<li>不能定义抽象成员，否则抛出异常。</li>
</ol>
<h2>抽象类AClass：</h2>
<ol>
<li>可以声明构造函数，供子类Class调用。</li>
<li>抽象类如果继承类Class，会抛出异常。</li>
<li>不用实现接口，可以交给子类Class实现。</li>
<li>不用实现父类抽象成员，可以交给子类Class实现。</li>
<li>只能继承一个抽象类AClass，否则抛出异常。</li>
</ol>
<h2>接口Interface：</h2>
<ol>
<li>接口只能继承接口，否则抛出异常。&nbsp;</li>
</ol>
<h1>使用YOOP</h1>
<p>YOOP支持AMD、CMD、CommonJS规范，可在Sea.js、node.js中使用：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> yoop = require(<span style="color: #800000;">"</span><span style="color: #800000;">./YOOP.js</span><span style="color: #800000;">"</span><span style="color: #000000;">);

yoop.Class({});</span></pre>
</div>
<p>也可以<span style="font-size: 14px; line-height: 1.5;">通过script标签在页面上直接引用</span></p>
<p><span style="font-size: 14px; line-height: 1.5;">页面上引用script：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">script </span><span style="color: #ff0000;">src</span><span style="color: #0000ff;">="./YOOP.js"</span><span style="color: #0000ff;">&gt;&lt;/</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>然后通过命名空间YYC来使用：</p>
<div class="cnblogs_code">
<pre>YYC.Class({});</pre>
</div>
<p style="width: 100%; background-color: #c0c0c0;"><span style="font-family: 幼圆;"><strong><span style="color: #ffffff; font-size: 18pt;">用法</span></strong></span></p>
<h1>接口</h1>
<h2>定义接口</h2>
<p>只有方法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">method1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">method2</span><span style="color: #800000;">"</span>);</pre>
</div>
<p>只有属性：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface([], [<span style="color: #800000;">"</span><span style="color: #800000;">attribute1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">attribute2</span><span style="color: #800000;">"</span>]);</pre>
</div>
<p>既有方法又有属性：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface([<span style="color: #800000;">"</span><span style="color: #800000;">method1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">method2</span><span style="color: #800000;">"</span>], [<span style="color: #800000;">"</span><span style="color: #800000;">attribute1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">attribute2</span><span style="color: #800000;">"</span>]);</pre>
</div>
<h2>继承接口</h2>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface([<span style="color: #800000;">"</span><span style="color: #800000;">method1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">method2</span><span style="color: #800000;">"</span>],[<span style="color: #800000;">"</span><span style="color: #800000;">attribute1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">attribute2</span><span style="color: #800000;">"</span><span style="color: #000000;">]);
</span><span style="color: #0000ff;">var</span> B = YYC.Interface(A, <span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> C = YYC.Interface([A], [<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span>], [<span style="color: #800000;">"</span><span style="color: #800000;">a1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">a2</span><span style="color: #800000;">"</span><span style="color: #000000;">]);
</span><span style="color: #0000ff;">var</span> D = YYC.Interface([A, B], [<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span>], [<span style="color: #800000;">"</span><span style="color: #800000;">a1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">a2</span><span style="color: #800000;">"</span>]);</pre>
</div>
<h1>抽象类</h1>
<h2>定义抽象类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('74d2895c-4a23-4e35-9396-13051e6c6202')"><img id="code_img_closed_74d2895c-4a23-4e35-9396-13051e6c6202" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_74d2895c-4a23-4e35-9396-13051e6c6202" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('74d2895c-4a23-4e35-9396-13051e6c6202',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_74d2895c-4a23-4e35-9396-13051e6c6202" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
    Init: </span><span style="color: #0000ff;">function</span> () { <span style="color: #008000;">//</span><span style="color: #008000;">构造函数</span>
<span style="color: #000000;">    },
    Protected: {    </span><span style="color: #008000;">//</span><span style="color: #008000;">保护成员</span>
        Abstract: { <span style="color: #008000;">//</span><span style="color: #008000;">保护抽象成员</span>
<span style="color: #000000;">        },
        Virtual: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">保护虚方法</span>
<span style="color: #000000;">        },
        P_proA: </span><span style="color: #0000ff;">true</span>,   <span style="color: #008000;">//</span><span style="color: #008000;">保护属性</span>
       P_proM: <span style="color: #0000ff;">function</span> () { }    <span style="color: #008000;">//</span><span style="color: #008000;">保护方法</span>
<span style="color: #000000;">    },
    Public: {   </span><span style="color: #008000;">//</span><span style="color: #008000;">公有成员</span>
        Abstract: { <span style="color: #008000;">//</span><span style="color: #008000;">公有抽象成员</span>
<span style="color: #000000;">        },
        Virtual: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">公有虚方法</span>
<span style="color: #000000;">        },
        pubM: </span><span style="color: #0000ff;">function</span> () { },  <span style="color: #008000;">//</span><span style="color: #008000;">公有方法</span>
      pubA: 0    <span style="color: #008000;">//</span><span style="color: #008000;">公有属性</span>
<span style="color: #000000;">    },
    Private: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">私有成员</span>
        _priA: "",   <span style="color: #008000;">//</span><span style="color: #008000;">私有属性</span>
        _priM: <span style="color: #0000ff;">function</span> () { } <span style="color: #008000;">//</span><span style="color: #008000;">私有方法</span>
<span style="color: #000000;">    },
    Abstract: { </span><span style="color: #008000;">//</span><span style="color: #008000;">公有抽象成员</span>
<span style="color: #000000;">    },
    Virtual: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">公有虚方法</span>
<span style="color: #000000;">    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承抽象类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('86502fa7-140a-46a9-9ca3-cc15a69312c9')"><img id="code_img_closed_86502fa7-140a-46a9-9ca3-cc15a69312c9" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_86502fa7-140a-46a9-9ca3-cc15a69312c9" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('86502fa7-140a-46a9-9ca3-cc15a69312c9',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_86502fa7-140a-46a9-9ca3-cc15a69312c9" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({});
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.AClass(A, {});
</span><span style="color: #0000ff;">var</span> C = YYC.AClass({Class: A}, {}); </pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承接口</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('9e2698d9-dc7f-4d21-ac3c-9365f4b1430c')"><img id="code_img_closed_9e2698d9-dc7f-4d21-ac3c-9365f4b1430c" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9e2698d9-dc7f-4d21-ac3c-9365f4b1430c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9e2698d9-dc7f-4d21-ac3c-9365f4b1430c',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9e2698d9-dc7f-4d21-ac3c-9365f4b1430c" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> B = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.AClass({ Interface: A }, {
    Public: {
        m1: function () { }
    }
});
</span><span style="color: #0000ff;">var</span> D =<span style="color: #000000;"> YYC.AClass({ Interface: [A, B] }, {
    Public: {
        m1: function () { },
        m2: function () { }
    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承接口和抽象类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('4a15c29d-3313-4198-a7e9-79a429b0deb0')"><img id="code_img_closed_4a15c29d-3313-4198-a7e9-79a429b0deb0" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_4a15c29d-3313-4198-a7e9-79a429b0deb0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4a15c29d-3313-4198-a7e9-79a429b0deb0',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_4a15c29d-3313-4198-a7e9-79a429b0deb0" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> B = YYC.Interface([<span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span>], [<span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span><span style="color: #000000;">]);
</span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.AClass({});
</span><span style="color: #0000ff;">var</span> D =<span style="color: #000000;"> YYC.AClass({ Interface: [A, B], Class: C }, {
    Public: {
        m1: function () { },
        a: </span><span style="color: #800080;">0</span><span style="color: #000000;">
    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>类</h1>
<h2>定义类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('9e441a77-56a3-4ab3-84c3-75f649488695')"><img id="code_img_closed_9e441a77-56a3-4ab3-84c3-75f649488695" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9e441a77-56a3-4ab3-84c3-75f649488695" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9e441a77-56a3-4ab3-84c3-75f649488695',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9e441a77-56a3-4ab3-84c3-75f649488695" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({
                Init: function () { </span><span style="color: #008000;">//</span><span style="color: #008000;">构造函数</span>
<span style="color: #000000;">                },
                Protected: {    </span><span style="color: #008000;">//</span><span style="color: #008000;">保护成员</span>
                    Virtual: {  <span style="color: #008000;">//</span><span style="color: #008000;">保护虚方法</span>
<span style="color: #000000;">                    },
                    P_proA: </span><span style="color: #0000ff;">true</span>,   <span style="color: #008000;">//</span><span style="color: #008000;">保护属性</span>
                    P_proM: function () { }    <span style="color: #008000;">//</span><span style="color: #008000;">保护方法</span>
<span style="color: #000000;">                },
                Public: {   </span><span style="color: #008000;">//</span><span style="color: #008000;">公有成员</span>
                    Virtual: {  <span style="color: #008000;">//</span><span style="color: #008000;">公有虚方法</span>
<span style="color: #000000;">                    },
                    pubM: function () { },  </span><span style="color: #008000;">//</span><span style="color: #008000;">公有方法</span>
                    pubA: <span style="color: #800080;">0</span>    <span style="color: #008000;">//</span><span style="color: #008000;">公有属性</span>
<span style="color: #000000;">                },
                Private: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">私有成员</span>
                    _priA: <span style="color: #800000;">""</span>,   <span style="color: #008000;">//</span><span style="color: #008000;">私有属性</span>
                    _priM: function () { } <span style="color: #008000;">//</span><span style="color: #008000;">私有方法</span>
<span style="color: #000000;">                },
                Virtual: {  </span><span style="color: #008000;">//</span><span style="color: #008000;">公有虚方法</span>
<span style="color: #000000;">                }
            });</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承抽象类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('9384a505-35bc-44d2-aa46-b5e0deed39f9')"><img id="code_img_closed_9384a505-35bc-44d2-aa46-b5e0deed39f9" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9384a505-35bc-44d2-aa46-b5e0deed39f9" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9384a505-35bc-44d2-aa46-b5e0deed39f9',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9384a505-35bc-44d2-aa46-b5e0deed39f9" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({});
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.AClass(A, {});
</span><span style="color: #0000ff;">var</span> C = YYC.AClass({ Class: A }, {});</pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('976ac329-56ac-4f09-811f-66706040d12f')"><img id="code_img_closed_976ac329-56ac-4f09-811f-66706040d12f" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_976ac329-56ac-4f09-811f-66706040d12f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('976ac329-56ac-4f09-811f-66706040d12f',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_976ac329-56ac-4f09-811f-66706040d12f" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({});
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {});
</span><span style="color: #0000ff;">var</span> C = YYC.Class({ Class: A }, {});</pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承接口</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('30e4055d-da03-44ae-85cc-0501a94069a4')"><img id="code_img_closed_30e4055d-da03-44ae-85cc-0501a94069a4" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_30e4055d-da03-44ae-85cc-0501a94069a4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('30e4055d-da03-44ae-85cc-0501a94069a4',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_30e4055d-da03-44ae-85cc-0501a94069a4" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> B = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.Class({ Interface: A }, {
    Public: {
        m1: function () { }
    }
});
</span><span style="color: #0000ff;">var</span> D =<span style="color: #000000;"> YYC.Class({ Interface: [A, B] }, {
    Public: {
        m1: function () { },
        m2: function () { }
    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h2>继承接口和抽象类/类</h2>
<div class="cnblogs_code" onclick="cnblogs_code_show('8dc18103-1f27-4cb1-8bab-d06523bedfcc')"><img id="code_img_closed_8dc18103-1f27-4cb1-8bab-d06523bedfcc" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_8dc18103-1f27-4cb1-8bab-d06523bedfcc" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8dc18103-1f27-4cb1-8bab-d06523bedfcc',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_8dc18103-1f27-4cb1-8bab-d06523bedfcc" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> B = YYC.Interface([<span style="color: #800000;">"</span><span style="color: #800000;">m2</span><span style="color: #800000;">"</span>], [<span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span><span style="color: #000000;">]);
</span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.AClass({});
</span><span style="color: #0000ff;">var</span> D =<span style="color: #000000;"> YYC.Class({});
</span><span style="color: #0000ff;">var</span> E =<span style="color: #000000;"> YYC.AClass({ Interface: [A, B], Class: C }, {
    Public: {
        m1: function () { },
        a: </span><span style="color: #800080;">0</span><span style="color: #000000;">
    }
});
</span><span style="color: #0000ff;">var</span> F =<span style="color: #000000;"> YYC.AClass({ Interface: [A, B], Class: D }, {
    Public: {
        m1: function () { },
        a: </span><span style="color: #800080;">0</span><span style="color: #000000;">
    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>构造函数</h1>
<div class="cnblogs_code" onclick="cnblogs_code_show('1f31e68a-88be-4e95-85a9-35fcd59c1d1c')"><img id="code_img_closed_1f31e68a-88be-4e95-85a9-35fcd59c1d1c" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1f31e68a-88be-4e95-85a9-35fcd59c1d1c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1f31e68a-88be-4e95-85a9-35fcd59c1d1c',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1f31e68a-88be-4e95-85a9-35fcd59c1d1c" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({
　　Init: function(t){
　　　　</span><span style="color: #0000ff;">this</span>.value =<span style="color: #000000;"> t;
　　}
});
</span><span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span> A(<span style="color: #800080;">100</span><span style="color: #000000;">);
console.log(a.value);　　</span><span style="color: #008000;">//</span><span style="color: #008000;">100</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>静态成员</h1>
<p>使用&ldquo;类.静态成员&rdquo;的形式来调用静态成员。这里静态成员实质是类（function，function也是对象）的成员。</p>
<p>注意！静态方法中的this指向类，不是指向类的实例！</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5b868112-991a-4f5f-8bce-cabd0c7c48aa')"><img id="code_img_closed_5b868112-991a-4f5f-8bce-cabd0c7c48aa" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_5b868112-991a-4f5f-8bce-cabd0c7c48aa" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5b868112-991a-4f5f-8bce-cabd0c7c48aa',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_5b868112-991a-4f5f-8bce-cabd0c7c48aa" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({
    Static: {
        a: </span>100<span style="color: #000000;">,
        method1: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">return</span> 200<span style="color: #000000;">;
        },
        method2: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
             </span><span style="color: #0000ff;">this</span>.k = 300<span style="color: #000000;">;
        }
    }
});

A.method2();

console.log(A.a);   </span><span style="color: #008000;">//</span><span style="color: #008000;">100</span>
console.log(A.method1());    <span style="color: #008000;">//</span><span style="color: #008000;">200</span>
console.log(A.k);   <span style="color: #008000;">//</span><span style="color: #008000;">300</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>类的成员互相调用</h1>
<p>使用this来调用。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('2fa57eb4-faee-463b-b0f3-ed5329d090c0')"><img id="code_img_closed_2fa57eb4-faee-463b-b0f3-ed5329d090c0" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_2fa57eb4-faee-463b-b0f3-ed5329d090c0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2fa57eb4-faee-463b-b0f3-ed5329d090c0',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_2fa57eb4-faee-463b-b0f3-ed5329d090c0" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({
    Private: {
        _a: </span><span style="color: #800080;">100</span><span style="color: #000000;">
    },
    Public: {
        method: function (t) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._a;
        }
    }
});
</span><span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> A();
console.log(a.method);  </span><span style="color: #008000;">//</span><span style="color: #008000;">100</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>子类调用父类</h1>
<p>使用this.base()可调用父类同名函数。</p>
<p>使用this.baseClass.xx.call(this, xx)可调用父类的成员。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('1f442ed7-4339-49f7-abb1-7f1f1563cca6')"><img id="code_img_closed_1f442ed7-4339-49f7-abb1-7f1f1563cca6" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1f442ed7-4339-49f7-abb1-7f1f1563cca6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1f442ed7-4339-49f7-abb1-7f1f1563cca6',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1f442ed7-4339-49f7-abb1-7f1f1563cca6" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
                    Init: function () {
                        </span><span style="color: #0000ff;">this</span>.p = <span style="color: #800080;">100</span><span style="color: #000000;">;
                    },
                    Public: {
                        method1: function () {
                            </span><span style="color: #0000ff;">this</span>.m = <span style="color: #800080;">300</span><span style="color: #000000;">;
                        },
                        method2: function () {
                            </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">100</span><span style="color: #000000;">;
                        }
                    }
                });
                </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
                    Init: function () {
                        </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
                    },
                    Private: {
                        _a: </span><span style="color: #800080;">100</span><span style="color: #000000;">
                    },
                    Public: {
                        method1: function (t) {
                            </span><span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
                            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.baseClass.method2.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span>) + <span style="color: #0000ff;">this</span><span style="color: #000000;">._a;
                        }
                    }
                });
                </span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
                console.log(b.method1());  </span><span style="color: #008000;">//</span><span style="color: #008000;">200</span>
                console.log(b.p);  <span style="color: #008000;">//</span><span style="color: #008000;">100</span>
                console.log(b.m);  <span style="color: #008000;">//</span><span style="color: #008000;">300</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>父类调用子类</h1>
<div class="cnblogs_code" onclick="cnblogs_code_show('e3a2be67-7d0e-4470-83c8-ba38c13853f4')"><img id="code_img_closed_e3a2be67-7d0e-4470-83c8-ba38c13853f4" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_e3a2be67-7d0e-4470-83c8-ba38c13853f4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e3a2be67-7d0e-4470-83c8-ba38c13853f4',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_e3a2be67-7d0e-4470-83c8-ba38c13853f4" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
    Public: {
        method: function () {
            console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.value);
        }
    }
});
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
    Public: {
        value: </span><span style="color: #800080;">100</span><span style="color: #000000;">
    }
});
</span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
b.method(); </span><span style="color: #008000;">//</span><span style="color: #008000;">100</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code </span></div>
<h1>覆写父类方法，实现接口成员、抽象成员</h1>
<div class="cnblogs_code" onclick="cnblogs_code_show('97fdfde9-9bae-4c6a-9edf-8f0c0e468bbd')"><img id="code_img_closed_97fdfde9-9bae-4c6a-9edf-8f0c0e468bbd" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_97fdfde9-9bae-4c6a-9edf-8f0c0e468bbd" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('97fdfde9-9bae-4c6a-9edf-8f0c0e468bbd',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_97fdfde9-9bae-4c6a-9edf-8f0c0e468bbd" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">var</span> A = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">m1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.AClass({ Interface: A }, {
    Protected: {
        Abstract: {
            P_method: function () { }
        }
    },
    Public: {
        method: function () { }
    }
});
</span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.Class(B, {
    Protected: {
        P_method: function () {
            console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">实现抽象方法</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        }
    },
    Public: {
        method: function () {
            console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">覆盖父类同名方法</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        },
        m1: function () {
            console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">实现接口</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        }
    }
});</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<div onclick="cnblogs_code_show('97fdfde9-9bae-4c6a-9edf-8f0c0e468bbd')">
<h1>其它API</h1>
<h2>stubParentMethod、stubParentMethodByAClass</h2>
<p>让父类（Class/AClass）指定方法不执行。</p>
<p>测试用例如下：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('15b404e0-607c-479a-ac33-644b97af531f')"><img id="code_img_closed_15b404e0-607c-479a-ac33-644b97af531f" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_15b404e0-607c-479a-ac33-644b97af531f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('15b404e0-607c-479a-ac33-644b97af531f',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_15b404e0-607c-479a-ac33-644b97af531f" class="cnblogs_code_hide">
<pre>describe("stubParentMethod", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        </span><span style="color: #0000ff;">var</span> sandbox = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">var</span> A = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            B </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            C </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            a </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            b </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            c </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        beforeEach(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            A </span>=<span style="color: #000000;"> YYC.Class({
                Public: {
                    done: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(""<span style="color: #000000;">);
                    }
                }
            });
            B </span>=<span style="color: #000000;"> YYC.Class(A, {
                Public: {
                    done: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span>.baseClass.done.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
                    }
                }
            });
            C </span>=<span style="color: #000000;"> YYC.Class(B, {
                Public: {
                    a: </span>0<span style="color: #000000;">,

                    done: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base();

                        </span><span style="color: #0000ff;">this</span>.a = 100<span style="color: #000000;">;
                    }
                }
            });
            a </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> A();
            b </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
            c </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> C();

            sandbox </span>=<span style="color: #000000;"> sinon.sandbox.create();
        });
        afterEach(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            sandbox.restore();
        });

        it(</span>"让父类指定方法不执行，用于Class的测试方法中调用了父类方法的情况", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                b.done();
            }).toThrow();
            expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                c.done();
            }).toThrow();

            b.stubParentMethod(sandbox, </span>"done"<span style="color: #000000;">);
            c.stubParentMethod(sandbox, </span>"done"<span style="color: #000000;">);

            expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                b.done();
            }).not.toThrow();
            expect(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                c.done();
            }).not.toThrow();
        });
        it(</span>"可将父类指定方法替换为假方法", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            c.stubParentMethod(sandbox, </span>"done", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span>.val = 1<span style="color: #000000;">;
            });

            c.done();

            expect(c.val).toEqual(</span>1<span style="color: #000000;">);
        });
        it(</span>"可按照sinon-&gt;stub API测试父类指定方法的调用情况", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            c.stubParentMethod(sandbox, </span>"done"<span style="color: #000000;">);

            c.done();

            expect(c.lastBaseClassForTest.done.calledOnce).toBeTruthy();
        });
    });

    describe(</span>"stubParentMethodByAClass", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        </span><span style="color: #0000ff;">var</span> sandbox = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">var</span> A = <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            B </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
            t </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        beforeEach(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            A </span>=<span style="color: #000000;"> YYC.AClass({
                Public: {
                    a: </span>0<span style="color: #000000;">,
                    done: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error(""<span style="color: #000000;">);
                    }
                }
            });
            B </span>=<span style="color: #000000;"> YYC.AClass(A, {
                Public: {
                    done: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.base();
                    }
                }
            });

            </span><span style="color: #008000;">//</span><span style="color: #008000;">想要测试B的done方法，必须先建一个空子类继承B，然后测试空子类的done方法</span>
            <span style="color: #0000ff;">function</span><span style="color: #000000;"> getInstance() {
                </span><span style="color: #0000ff;">var</span> T =<span style="color: #000000;"> YYC.Class(B, {
                });

                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> T();
            }

            t </span>=<span style="color: #000000;"> getInstance();

            sandbox </span>=<span style="color: #000000;"> sinon.sandbox.create();
        });
        afterEach(</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            sandbox.restore();
        });

        it(</span>"让父类指定方法不执行，用于AClass的测试方法中调用了父类方法的情况", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            expect(t.done).toThrow();

            t.stubParentMethodByAClass(sandbox, </span>"done"<span style="color: #000000;">);

            expect(t.done).not.toThrow();
        });
        it(</span>"可将父类指定方法替换为假方法", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            t.stubParentMethodByAClass(sandbox, </span>"done", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">this</span>.val = 1<span style="color: #000000;">;
            });

            t.done();

            expect(t.val).toEqual(</span>1<span style="color: #000000;">);
        });
        it(</span>"可按照sinon-&gt;stub API测试父类指定方法的调用情况", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            t.stubParentMethodByAClass(sandbox, </span>"done"<span style="color: #000000;">);

            t.done();

            expect(t.lastBaseClassForTest.done.calledOnce).toBeTruthy();
        });
    });</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h2>isInstanceOf</h2>
<p>判断是否为类的实例。</p>
<p>测试用例如下：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('b1730895-ca72-43f4-80d7-919d8312d0c8')"><img id="code_img_closed_b1730895-ca72-43f4-80d7-919d8312d0c8" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_b1730895-ca72-43f4-80d7-919d8312d0c8" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b1730895-ca72-43f4-80d7-919d8312d0c8',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_b1730895-ca72-43f4-80d7-919d8312d0c8" class="cnblogs_code_hide">
<pre>     describe("isInstanceOf", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
        it(</span>"直接判断是否为Class的实例", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({});

            expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> A().isInstanceOf(A)).toBeTruthy();
        });
        describe(</span>"测试继承抽象类时的情况", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            it(</span>"测试1", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({});
                </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {});

                expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> B().isInstanceOf(B)).toBeTruthy();
                expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> B().isInstanceOf(A)).toBeTruthy();
            });
            it(</span>"测试2", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({});
                </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.AClass(A, {});
                </span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.Class(B, {});
                </span><span style="color: #0000ff;">var</span> D =<span style="color: #000000;"> YYC.Class(A, {});

                expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> C().isInstanceOf(B)).toBeTruthy();
                expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> C().isInstanceOf(A)).toBeTruthy();
                expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> D().isInstanceOf(A)).toBeTruthy();
                expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> D().isInstanceOf(B)).toBeFalsy();
            });
        });

        describe(</span>"测试继承接口时的情况", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            it(</span>"测试1", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A = YYC.Interface("a"<span style="color: #000000;">);
                </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class({Interface: A}, {
                    Public: {
                        a: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        }
                    }
                });

                expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> B().isInstanceOf(B)).toBeTruthy();
                expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> B().isInstanceOf(A)).toBeTruthy();
            });
            it(</span>"测试2", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                </span><span style="color: #0000ff;">var</span> A = YYC.Interface("a"<span style="color: #000000;">);
                </span><span style="color: #0000ff;">var</span> B = YYC.Interface("b"<span style="color: #000000;">);
                </span><span style="color: #0000ff;">var</span> C = YYC.Interface([A, B], "c"<span style="color: #000000;">);
                </span><span style="color: #0000ff;">var</span> D =<span style="color: #000000;"> YYC.Class({Interface: C}, {
                    Public: {
                        a: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        },
                        b: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        },
                        c: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                        }
                    }
                });

                expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> D().isInstanceOf(C)).toBeTruthy();
                expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> D().isInstanceOf(B)).toBeTruthy();
                expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> D().isInstanceOf(A)).toBeTruthy();
            });
        });

        it(</span>"综合测试", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
            </span><span style="color: #0000ff;">var</span> A = YYC.Interface("a1"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">var</span> B = YYC.Interface(A, "a2"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">var</span> C =<span style="color: #000000;"> YYC.AClass({Interface: B}, {
                Public: {
                    a1: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    },
                    a2: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    }
                }
            });
            </span><span style="color: #0000ff;">var</span> D =<span style="color: #000000;"> YYC.AClass(C, {
                Public: {
                    a1: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    },
                    a2: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
                    }
                }
            });
            </span><span style="color: #0000ff;">var</span> E =<span style="color: #000000;"> YYC.Class(C, {
            });
            </span><span style="color: #0000ff;">var</span> F =<span style="color: #000000;"> YYC.Class(E, {
            });
            </span><span style="color: #0000ff;">var</span> G =<span style="color: #000000;"> YYC.Class({Interface: B, Class: D}, {
            });

            expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> E().isInstanceOf(C)).toBeTruthy();
            expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> E().isInstanceOf(B)).toBeTruthy();
            expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> E().isInstanceOf(A)).toBeTruthy();

            expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> F().isInstanceOf(E)).toBeTruthy();
            expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> F().isInstanceOf(C)).toBeTruthy();
            expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> F().isInstanceOf(B)).toBeTruthy();
            expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> F().isInstanceOf(A)).toBeTruthy();

            expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> G().isInstanceOf(B)).toBeTruthy();
            expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> G().isInstanceOf(D)).toBeTruthy();

            expect(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> G().isInstanceOf(E)).toBeFalsy();
        });
    }); </span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h2>YOOP.version</h2>
<p>返回当前版本号。</p>
<p>测试用例如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">    it("获得当前版本号", function () {
       expect(YYC.YOOP.version).toBeString();
    });</span></pre>
</div>
</div>
<p style="width: 100%; background-color: #c0c0c0;"><span style="font-family: 幼圆;"><strong><span style="color: #ffffff; font-size: 18pt;">约定</span></strong></span></p>
<p>在该框架的实现中，类的实例可以访问类的公有成员、保护成员、私有成员，所有成员都是添加到类的原型中（如果是继承，则将父类的成员添和子类的成员都添加到子类的原型中），框架只是从语义上区分了成员的访问权限，在机制上没有对成员的访问权限设任何限制！</p>
<p>因此，用户需要采用<span style="color: #ff0000;">命名约定</span>的方式来区分不同的成员，需要自觉遵守访问权限规则（如类的实例只能访问公有成员；不能访问其它类的私有成员；子类可以访问父类的保护成员等等）。</p>
<h1>私有成员和保护成员的建议命名约定</h1>
<p>基类的私有成员以&ldquo;_&rdquo;开头，保护成员以&ldquo;P_&rdquo;开头。</p>
<p>在继承树中，第一层类私有成员以&ldquo;_&rdquo;开头，第二层类私有成员以&ldquo;__&rdquo;开头，以此类推，从而<span style="line-height: 1.5;">区分不同层级中同名的私有成员。</span></p>
<p><span style="color: #ff0000;">所有层级中的保护成员前缀都为&ldquo;P_&rdquo;（原因见后面&ldquo;</span><span style="color: #ff0000;">为什么每层子类的保护成员前缀都一样</span><span style="color: #ff0000;">&rdquo;的讨论）。</span></p>
<p>用户也可以将第一层子类的私有成员前缀设为&ldquo;_1_&rdquo;，第二层子类的私有成员设为&ldquo;_2_&rdquo;。。。。。。</p>
<p>前缀设置规则用户可自订，只要在继承中使<span style="color: #ff0000;">不同层级的类的私有成员不重名</span>即可。</p>
<p>见下面的实例代码：</p>
<p>不继承接口</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A = YYC.AClass({    <span style="color: #008000;">//</span><span style="color: #008000;">私有成员以&ldquo;_&rdquo;开头，保护成员以&ldquo;P_&rdquo;开头</span>
<span style="color: #000000;">    Private: {
        _value: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        _method: function () {
        }
    },
    Protected: {
        P_value: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

        Virtual: {
            P_method: function () {
            }
        }
    }
});
</span><span style="color: #0000ff;">var</span> B = YYC.Class(A, {  <span style="color: #008000;">//</span><span style="color: #008000;">私有成员以&ldquo;__&rdquo;开头，保护成员以&ldquo;P_&rdquo;开头</span>
<span style="color: #000000;">    Private: {
        __value: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        __method: function () {
        }
    },
    Protected: {
        P_method: function () {
        }
    }
});</span></pre>
</div>
<p>继承接口</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> I = YYC.Interface(<span style="color: #800000;">"</span><span style="color: #800000;">method</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> A = YYC.AClass({ Interface: I }, {   <span style="color: #008000;">//</span><span style="color: #008000;">私有成员以&ldquo;_&rdquo;开头，保护成员以&ldquo;P_&rdquo;</span>
<span style="color: #000000;">    Private: {
        _value: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        _method: function () {
        }
    },
    Protected: {
        P_value: </span><span style="color: #800080;">0</span><span style="color: #000000;">,

        Virtual: {
            P_method: function () {
            }
        }
    }
});
</span><span style="color: #0000ff;">var</span> B = YYC.Class(A, {  <span style="color: #008000;">//</span><span style="color: #008000;">私有成员以&ldquo;__&rdquo;开头，保护成员以&ldquo;P_&rdquo;</span>
<span style="color: #000000;">    Private: {
        __value: </span><span style="color: #800080;">0</span><span style="color: #000000;">,
        __method: function () {
        }
    },
    Protected: {
        P_method: function () {
        }
    },
    Public: {
        method: function () {
        }
    }
});</span></pre>
</div>
<h2>为什么每层子类的私有前缀最好不一样？</h2>
<p>如果子类与父类有同名的私有成员时，当子类调用父类成员时，可能会出现父类成员调用子类的私有成员。</p>
<p>见下面的示例代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
    Private: {
        _val: </span><span style="color: #800080;">100</span><span style="color: #000000;">
    },
    Public: {
        getVal: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">._val;
        }
    }
});

</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
    Private: {
        _val: </span><span style="color: #800080;">200</span><span style="color: #000000;">
    },
    Public: {
        getVal: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
        }
    }
});

expect(</span><span style="color: #0000ff;">new</span> B().getVal()).toEqual(<span style="color: #800080;">100</span>);　　<span style="color: #008000;">//</span><span style="color: #008000;">失败！期望返回A-&gt;_val（100），实际返回的是B-&gt;_val（200）</span></pre>
</div>
<h2>为什么每层子类的保护成员前缀都一样？</h2>
<p>如果父类与子类的保护成员同名，则父类的该保护成员一般都是设计为虚成员，专门供子类覆写的。因此当子类调用父类成员时，本来就期望父类成员调用子类覆写的保护成员。</p>
<p>见下面的示例代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
    Protected: {
        Virtual: {
            P_val: </span><span style="color: #800080;">100</span><span style="color: #000000;">
        }
    },
    Public: {
        getVal: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.P_val;
        }
    }
});

</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
    Protected: {
        P_val: </span><span style="color: #800080;">200</span><span style="color: #000000;">
    },
    Public: {
        getVal: function () {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.<span style="color: #0000ff;">base</span><span style="color: #000000;">();
        }
    }
});

expect(</span><span style="color: #0000ff;">new</span> B().getVal()).toEqual(<span style="color: #800080;">200</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">由于B覆写了A的虚属性P_val，因此B-&gt;getVal应该返回B覆写后的P_val（200）</span></pre>
</div>
<h1>baseClass</h1>
<p>为了防止子类的prototype.baseClass覆盖父类prototype.baseClass，在子类继承父类时，用户需要先判断父类prototype.baseClass是否存在。如果存在，则加上前缀&ldquo;_&rdquo;，如&ldquo;_baseClass&rdquo;。如果加上前缀后依然存在，则再加上前缀&ldquo;_&rdquo;，如&ldquo;__baseClass&rdquo;。以此类推。</p>
<p>如：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('cd98ce59-5a2e-4bc6-a6d7-f592a6c41ecb')"><img id="code_img_closed_cd98ce59-5a2e-4bc6-a6d7-f592a6c41ecb" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_cd98ce59-5a2e-4bc6-a6d7-f592a6c41ecb" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('cd98ce59-5a2e-4bc6-a6d7-f592a6c41ecb',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_cd98ce59-5a2e-4bc6-a6d7-f592a6c41ecb" class="cnblogs_code_hide">
<pre>                <span style="color: #0000ff;">var</span> A1 =<span style="color: #000000;"> YYC.AClass({
                    Public: {
                        arr: [],
                        a: function () {
                            </span><span style="color: #0000ff;">this</span>.arr.push(<span style="color: #800080;">1</span><span style="color: #000000;">);
                        }
                    }
                });
                </span><span style="color: #0000ff;">var</span> A2 =<span style="color: #000000;"> YYC.AClass(A1, {
                    Public: {
                        a: function () {
                            </span><span style="color: #0000ff;">this</span>.arr.push(<span style="color: #800080;">2</span><span style="color: #000000;">);
                            </span><span style="color: #0000ff;">this</span>.baseClass.a.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">调用A1.a</span>
<span style="color: #000000;">                        }
                    }
                });
                </span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A2, {
                    Public: {
                        a: function () {
                            </span><span style="color: #0000ff;">this</span>.arr.push(<span style="color: #800080;">3</span><span style="color: #000000;">);
                            </span><span style="color: #0000ff;">this</span>._baseClass.a.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span>); <span style="color: #008000;">//</span><span style="color: #008000;">调用A2.a</span>
                            <span style="color: #0000ff;">this</span>.baseClass.a.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">调用A1.a</span>

                            <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.arr;
                        }
                    }
                });
                </span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();

                expect(b.a()).toEqual([</span><span style="color: #800080;">3</span>, <span style="color: #800080;">2</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>]);</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p style="width: 100%; background-color: #c0c0c0;"><span style="font-family: 幼圆;"><strong><span style="color: #ffffff; font-size: 18pt;">注意事项</span></strong></span></p>
<p><strong><span style="font-size: 18px;">子类使用this.baseClass调用父类成员时，要将父类成员的this指向子类。</span></strong></p>
<p>错误的写法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
    Public: {
        method: function () {
            </span><span style="color: #0000ff;">this</span>.p = <span style="color: #800080;">100</span><span style="color: #000000;">;
        }
    }
});
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
    Public: {
        method: function () {
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.baseClass.method();
        }
    }
});
</span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
b.method();
console.log(b.p);   </span><span style="color: #008000;">//</span><span style="color: #008000;">此处为undefined，而不是100！</span></pre>
</div>
<p>正确的写法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.AClass({
    Public: {
        method: function () {
            </span><span style="color: #0000ff;">this</span>.p = <span style="color: #800080;">100</span><span style="color: #000000;">;
        }
    }
});
</span><span style="color: #0000ff;">var</span> B =<span style="color: #000000;"> YYC.Class(A, {
    Public: {
        method: function () {
            </span><span style="color: #0000ff;">this</span>.baseClass.method.call(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
        }
    }
});
</span><span style="color: #0000ff;">var</span> b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
b.method();
console.log(b.p);   </span><span style="color: #008000;">//</span><span style="color: #008000;">100</span></pre>
</div>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">已解决的问题</span></strong></p>
<p>YOOP框架目前已解决了下面的问题：</p>
<p>1、同一个类的实例之间不应该共享属性。</p>
<p><strong>问题描述</strong></p>
<p>参考下面的代码：</p>
<div class="cnblogs_code">
<pre>            <span style="color: #0000ff;">var</span> A =<span style="color: #000000;"> YYC.Class({
                Init: function () {
                },
                Public: {
                    a:[]
                }
            });

            </span><span style="color: #0000ff;">var</span> t = <span style="color: #0000ff;">new</span><span style="color: #000000;"> A();
            t.a.push(</span><span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">var</span> m = <span style="color: #0000ff;">new</span><span style="color: #000000;"> A();

            expect(t.a).toEqual([</span><span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span><span style="color: #000000;">]);
            expect(m.a).toEqual([]);    </span><span style="color: #008000;">//</span><span style="color: #008000;">失败！实际为["a"]！</span></pre>
</div>
<p><strong><span style="font-size: 1em; line-height: 1.5;">原因分析</span></strong></p>
<p>因为YOOP将类的成员都加入到类的原型对象中，而类实例的成员都是链接自类的原型对象，所以同一个类的实例之间成员共享。</p>
<p><strong>解决方案</strong></p>
<p>在Class的构造函数中深拷贝<span style="color: #ff0000;">原型的属性</span>到实例中，不拷贝原型的方法，从而同一个类的实例之间共享同一原型对象的方法，但它们的属性相互独立。</p>
<p>2、继承于同一父类的子类实例之间不应该共享属性。</p>
<p><strong>问题描述</strong></p>
<p>参考下面的代码</p>
<div class="cnblogs_code">
<pre>            <span style="color: #0000ff;">var</span> Parent =<span style="color: #000000;"> YYC.AClass({
                Init: function () {
                    console.log(</span><span style="color: #800000;">"</span><span style="color: #800000;">Parent Init!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                },
                Public: {
                    a: []
                }
            });
            </span><span style="color: #0000ff;">var</span> Sub1 =<span style="color: #000000;"> YYC.Class(Parent, {
                Init: function () {
                },
                Public: {
                }
            });
            </span><span style="color: #0000ff;">var</span> Sub2 =<span style="color: #000000;"> YYC.Class(Parent, {
                Init: function () {
                }
            });

            </span><span style="color: #0000ff;">var</span> t = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Sub1();
            t.a.push(</span><span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">var</span> k = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Sub2();

            expect(t.a).toEqual([</span><span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span><span style="color: #000000;">]);
            expect(k.a).toEqual([]);    </span><span style="color: #008000;">//</span><span style="color: #008000;">失败！实际为["a"]！</span></pre>
</div>
<p><strong><span style="font-size: 1em; line-height: 1.5;">原因分析</span></strong></p>
<p>目前是通过原型继承的方式来实现继承的。这样子类之间的成员都链接自父类的原型对象，从而会造成同一父类的子类实例之间成员共享。</p>
<p><strong>解决方案</strong></p>
<p>修改类继承方式，通过&ldquo;深拷贝父类原型所有成员到子类中&rdquo;的方式实现继承，从而同一父类的子类实例之间的成员相互独立。</p>
<p style="width: 100%; background-color: #c0c0c0;">&nbsp;<span style="font-family: 幼圆;"><strong><span style="color: #ffffff; font-size: 18pt;">缺点</span></strong></span></p>
<p><strong><span style="font-size: 18px;">只是从语义上约定了访问权限，而没有从机制上限制访问权限。</span></strong></p>
<p>如可以根据命名约定区分类的公有成员、保护成员、私有成员，但是类的实例却可以访问类的所有成员。</p>
<p style="width: 100%; background-color: #c0c0c0;"><strong><span style="font-family: 幼圆; color: #ffffff; font-size: 18pt;">版本历史</span></strong></p>
<p><strong>2013-06-07 发布YOOP v1.0&nbsp;</strong></p>
<p><strong>2014-08-26 发布YOOP v1.1&nbsp;</strong></p>
<p>1、类实例增加isInstanceOf方法，用于判断是否为类的实例，适用于接口继承、类继承等情况</p>
<p>2、protected方法也可以使用this.base来访问父类同名方法了</p>
<p>3、解决了&ldquo;若一个方法中调用其它方法，则它们的this.base会互相干扰&rdquo;的问题</p>
<p>4、增加stubParentMethod和stubParentMethodByAClass方法，该方法让父类（Class/AClass）指定方法不执行，用于Class的测试方法中调用了父类方法的情况（如调用了this.base()或this.baseClass.xxx）</p>
<p><span style="font-size: 14px; line-height: 1.5;">5、现在支持AMD、CMD、CommonJS规范了</span></p>
<p>6、增加YYC.YOOP.version属性，用于获得当前版本号&nbsp;</p>
<p>7、Class的构造函数F中现在只拷贝原型的属性到实例中，从而同一个类的实例之间共享同一原型对象的方法，但属性相互独立。</p>]]></description></item><item><title>发布我制作的jQuery贪吃蛇游戏</title><link>http://www.cnblogs.com/chaogex/archive/2012/10/10/2717669.html</link><dc:creator>yyc元超</dc:creator><author>yyc元超</author><pubDate>Tue, 09 Oct 2012 17:11:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2012/10/10/2717669.html</guid><description><![CDATA[<p>　　首先感谢<span style="color: #ff0000;"><strong>CNwander、Richard Willis</strong></span>，我参考了两位的代码。</p>
<p><strong>　　</strong>然后介绍我的这款小游戏吧~</p>
<p>　　这款游戏需要<span style="color: #ff0000;">jquery库支持，一共有5关，难度会逐步提升，而且可以吃道具。另外有点意思的是障碍物可以移动。</span></p>
<p>　　大家可以随便玩玩，有兴趣的可以看看我的代码，欢迎大家跟我交流哈！祝大家游戏愉快！</p>
<p>　　附上操作指南：<span style="color: #ff0000;">按方向键可控制蛇的移动方向。长按方向键可使蛇加速移动，按反方向键可使蛇恢复正常速度。按P键可暂停游戏。按N键可开始新游戏。</span></p>
<p><span style="color: #ff0000;">　　<span style="color: #000000;">测试环境：ie7、ie8、ie9、ff、chrome</span></span></p>
<p><span style="color: #ff0000;">　　<a href="https://github.com/yyc-git/Snake" target="_blank"><span style="color: #000000;"><strong>GitHub地址</strong></span></a></span></p>
<p><span style="color: #ff0000;"><span style="color: #000000;"><strong>　　<a href="https://yyc-git.github.io/snake/Index.html" target="_blank">演示地址</a></strong></span></span></p>
<p><span style="color: #000000;">　　游戏截图：</span></p>
<p><img src="http://pic002.cnblogs.com/images/2012/419321/2012101011131167.jpg" alt="" width="904" height="514" /></p>
<p>&nbsp;</p>]]></description></item><item><title>ajax 延迟显示加载中提示</title><link>http://www.cnblogs.com/chaogex/archive/2012/06/16/2551782.html</link><dc:creator>码农终结者</dc:creator><author>码农终结者</author><pubDate>Sat, 16 Jun 2012 04:32:00 GMT</pubDate><guid>http://www.cnblogs.com/chaogex/archive/2012/06/16/2551782.html</guid><description><![CDATA[<p><span style="font-size: 14px; line-height: 1.5;">　　近期做项目时用到了jquery的ajax，我希望实现&ldquo;加载时提示用户&rdquo;的功能，于是先习惯性的度娘谷哥了下，发现按照网上朋友所说的做，每次加载都会提示，不符合我的需求。</span>于是我改进了下<span style="font-size: 14px; line-height: 1.5;">，现在如果deferTime内加载成功，则不提示用户，否则就显示加载中图片。</span></p>
<p><span style="font-size: 14px; line-height: 1.5;">ajaxHelper</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> ajaxHelper =<span style="color: #000000;"> (function () {
    function _judgeAndShowLoadingImg(timeCount, timer, loading, whole, imgPath) {
        </span><span style="color: #0000ff;">var</span> imgSrc = <span style="color: #800000;">"</span><span style="color: #800000;">&lt;img src='</span><span style="color: #800000;">"</span> + imgPath + <span style="color: #800000;">"</span><span style="color: #800000;">' border='0'/&gt;</span><span style="color: #800000;">"</span>;   <span style="color: #008000;">//</span><span style="color: #008000;">加载中图片</span>

        <span style="color: #0000ff;">if</span> (timeCount !== <span style="color: #800080;">0</span>) {    <span style="color: #008000;">//</span><span style="color: #008000;">如果已经加载成功或加载失败，则清除重复执行并返回</span>
<span style="color: #000000;">            clearInterval(timer);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            $(whole).hide();
            $(loading).html(imgSrc).show();
            clearInterval(timer);
        }
    }

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {

        </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
         * 设定ajax全局事件，显示加载中、加载失败

         示例：
         &lt;div id="loading" style="border:1px solid red;display:none;"&gt;
         &lt;/div&gt;
         &lt;div id="whole" &gt;
         &lt;/div&gt;
         * @param loading   显示信息的层的ID
         * @param whole     正文所在层的ID
         * @param deferTime 延迟时间（秒）。如果延迟时间内加载成功，则不显示加载中图片，否则显示
         * @param imgPath   加载中图片的路径。如"/Content/Image/Shared/Loading/ico_loading3.gif"
         * @returns
         </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        showWholeLoading: function (loading, whole, deferTime, imgPath) {
            </span><span style="color: #0000ff;">var</span> _timeCount = <span style="color: #800080;">0</span><span style="color: #000000;">,
                _timer </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            $(loading).ajaxStart(function () {
                _timeCount </span>= <span style="color: #800080;">0</span>;  <span style="color: #008000;">//</span><span style="color: #008000;">归位</span>
                _timer =<span style="color: #000000;"> setInterval(function () {
                    _judgeAndShowLoadingImg(_timeCount, _timer, loading, whole, imgPath);
                }, deferTime </span>* <span style="color: #800080;">1000</span><span style="color: #000000;">);
            }).ajaxSuccess(function () {
                    _timeCount</span>++;    <span style="color: #008000;">//</span><span style="color: #008000;">计数加1，用来判断是否加载成功</span>
                    $(<span style="color: #0000ff;">this</span><span style="color: #000000;">).hide();
                    $(whole).show();
                }).ajaxError(function (e, xhr, settings, exception) {
                    _timeCount </span>+= <span style="color: #800080;">2</span>;    <span style="color: #008000;">//</span><span style="color: #008000;">计数加2，用来判断是否加载失败</span>
                    $(<span style="color: #0000ff;">this</span>).html(<span style="color: #800000;">"</span><span style="color: #800000;">加载失败：</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> exception).show();
                    $(whole).hide();
                });
        },
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
         * 设置单次ajax的事件，显示加载中、加载失败

         示例：
         &lt;div id="loading" style="border:1px solid red;display:none;"&gt;
         &lt;/div&gt;
         &lt;div id="whole" &gt;
         &lt;/div&gt;
         * @param loading   显示信息的层的ID
         * @param whole     正文所在层的ID
         * @param deferTime 延迟时间（秒）。如果延迟时间内加载成功，则不显示加载中图片，否则显示
         * @param imgPath   加载中图片的路径。如"/Content/Image/Shared/Loading/ico_loading3.gif"
         * @param setting   ajax的参数。包括url、data、type、dataType、success
         * @returns
         </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        showSingleLoading: function (loading, whole, deferTime, imgPath, setting) {
            </span><span style="color: #0000ff;">var</span> _timeCount = <span style="color: #800080;">0</span><span style="color: #000000;">,
                _timer </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">,
                self </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">;

            $.ajax({
                url: setting.url,
                data: setting.data,
                type: setting.type </span>|| <span style="color: #800000;">"</span><span style="color: #800000;">GET</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                dataType: setting.dataType,

                beforeSend: function () {
                    _timeCount </span>= <span style="color: #800080;">0</span>;  <span style="color: #008000;">//</span><span style="color: #008000;">归位</span>
                    _timer =<span style="color: #000000;"> setInterval(function () {
                        _judgeAndShowLoadingImg(_timeCount, _timer, loading, whole, imgPath);
                    }, deferTime </span>* <span style="color: #800080;">1000</span><span style="color: #000000;">);
                },
                error: function (jqXHR, textStatus, exception) {
                    _timeCount </span>+= <span style="color: #800080;">2</span>;    <span style="color: #008000;">//</span><span style="color: #008000;">计数加2，用来判断是否加载失败</span>
                    $(loading).html(<span style="color: #800000;">"</span><span style="color: #800000;">加载失败：</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> exception).show();
                    $(whole).hide();
                },
                success: function (data) {
                    _timeCount</span>++;    <span style="color: #008000;">//</span><span style="color: #008000;">计数加1，用来判断是否加载成功</span>
<span style="color: #000000;">                    $(loading).hide();
                    $(whole).show();

                    setting.success(data)
                }
            });
        }
    }
}());</span></pre>
</div>
<p>　　欢迎各位大神指教，转载请注明出处~</p>]]></description></item></channel></rss>
